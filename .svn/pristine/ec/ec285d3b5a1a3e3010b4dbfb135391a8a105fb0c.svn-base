// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------

//! 
//! \file structuring_element.test
//!
//! Tests for class StructuringElement
//!

#include <iostream>

#include <imageplus/core.hpp>
#include <imageplus/math/morphology/structuring_element.hpp>

BOOST_AUTO_TEST_SUITE ( StructuringElementSuite );

using namespace imageplus;
using namespace imageplus::math::morphology;

BOOST_AUTO_TEST_CASE( SEGeneral)
{
    // Test default constructor
    StructuringElement<2> se;

    BOOST_CHECK_EQUAL(se.iterations(),  1UL);
    BOOST_CHECK_EQUAL(se.connectivity(),8UL);
    BOOST_CHECK_EQUAL(se.simple(),true);
    BOOST_CHECK_EQUAL(se.num_active_elements(),9UL);

    uint64 k = 0;
    for (uint64 j=0; j < 3; ++j)
    for (uint64 i=0; i < 3; ++i)
    {
        Coord<int64,2> cc(i,j);
        Coord<int64,2> dif = cc - se.origin();

        BOOST_CHECK_EQUAL(dif, se.element_coord(k));
        k++;
        
    }

    StructuringElement<2> se_simple34(3,4);

    BOOST_CHECK_EQUAL(se_simple34.iterations(),  1UL);
    BOOST_CHECK_EQUAL(se_simple34.connectivity(),4UL);
    BOOST_CHECK_EQUAL(se_simple34.simple(),true);
    BOOST_CHECK_EQUAL(se_simple34.num_active_elements(),5UL);

    k = 0;
    for (int64 j=0; j < 3; ++j)
    for (int64 i=0; i < 3; ++i)
    {
        if (i == 1 || j == 1)
        {
            Coord<int64,2> cc(i,j);
            Coord<int64,2> dif = cc - se_simple34.origin();

            BOOST_CHECK_EQUAL(dif, se_simple34.element_coord(k));
            k++;
        }
    }

    StructuringElement<2> se_simple58(5,8);

    BOOST_CHECK_EQUAL(se_simple58.iterations(),  2UL);
    BOOST_CHECK_EQUAL(se_simple58.connectivity(),8UL);
    BOOST_CHECK_EQUAL(se_simple58.simple(),true);

    // NOTE: #include <.h this case, the element is 3x3, iterated two times.
    // For this case, most operations will use fast implementations
    // not using directly the structuring element (see erosion.cpp)
    BOOST_CHECK_EQUAL(se_simple58.num_active_elements(),9UL);

    k = 0;
    for (uint64 j=0; j < 3; ++j)
    for (uint64 i=0; i < 3; ++i)
    {
        Coord<int64,2> cc(i,j);
        Coord<int64,2> dif = cc - se_simple58.origin();

        BOOST_CHECK_EQUAL(dif, se_simple58.element_coord(k));
        k++;
        
    }

    // Define an arbitrary SE using a multiarray
    MultiArray<bool,2> se_ma(3,3);
    se_ma = true;

    uint64 size_x = se_ma.dims(0);
    uint64 size_y = se_ma.dims(1);

    // SE center in (1,1). Connectivity is not used in this case        
    StructuringElement<2> se_arb(se_ma, Coord<int64,2>(1,1));

    BOOST_CHECK_EQUAL(se_arb.iterations(),  1UL);
    BOOST_CHECK_EQUAL(se_arb.connectivity(),0UL);
    BOOST_CHECK_EQUAL(se_arb.simple(),false);
    BOOST_CHECK_EQUAL(se_arb.num_active_elements(),9UL);

    k = 0;
    for (uint64 j=0; j < size_y; ++j)
    for (uint64 i=0; i < size_x; ++i)
    {
        Coord<int64,2> cc(i,j);
        Coord<int64,2> dif = cc - se_arb.origin();

        BOOST_CHECK_EQUAL(dif, se_arb.element_coord(k));
        k++;
        
    }
}

BOOST_AUTO_TEST_SUITE_END ();
