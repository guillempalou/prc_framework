// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------

/*!
 * \example import_export.test
 */

#include <imageplus/core/import_export.hpp>
#include <imageplus/core/imavol_logical.hpp>

BOOST_AUTO_TEST_SUITE ( ImportExportSuite );

using namespace imageplus;

typedef boost::mpl::list< uint8, uint16, uint32, uint64,
                           int8,  int16,  int32,  int64,
                                                float64 > ImageTypes;

BOOST_AUTO_TEST_CASE_TEMPLATE( test_import_export_gray, T, ImageTypes )
{
    /*
     * The input data: an ImageGray (4x3) with 3 lines of different Colors
     */
    ImageGray<T> gry (4,3);

    typedef typename ImageGray<T>::Color Color; 
    Color c1, c2, c3;
    
    c1[0] = 127;
    c2[0] =  64;
    c3[0] =   0;

    for(std::size_t ii=0; ii < gry.size_x(); ++ii )
    {
        gry(Coord<int64,2>(ii,0)) = c1;
        gry(Coord<int64,2>(ii,1)) = c2;
        gry(Coord<int64,2>(ii,2)) = c3;
    }
    
    /*
     * Creating the buffer to store the data (using a MutiArray just for convenience)
     */
    MultiArray<T,2> ma_gry(4,3);
    ma_gry      = 0;
    
    /*
     * Exporting Data data
     */
    export_to( gry, ma_gry.data(), ma_gry.num_elements()*sizeof(T), GRAY );
    
    /*
     * Importing and checking export/import
     */
    ImageGray<T> gry_out(4,3);
    
    import_from( gry_out, ma_gry.data(), ma_gry.num_elements()*sizeof(T), GRAY );
    BOOST_CHECK( gry_out == gry );
    
    /*
     * Cheching the buffers content
     */
    for(std::size_t ii=0; ii < 4; ++ii )
    {
        BOOST_CHECK( ma_gry(Coord<int64,2>(ii, 0)) == 127 ); //c1
        BOOST_CHECK( ma_gry(Coord<int64,2>(ii, 1)) ==  64 ); //c2
        BOOST_CHECK( ma_gry(Coord<int64,2>(ii, 2)) ==   0 ); //c3
    }
}

BOOST_AUTO_TEST_CASE_TEMPLATE( test_import_export_rgb, T, ImageTypes )
{
    /*
     * The input data: an ImageRGB (4x3) with 3 lines of different Colors
     */
    ImageRGB<T> rgb (4,3);
    
    typedef typename ImageRGB <T>::Color Color;
    
    Color  c1, c2, c3;
    
    c1[0] = 127;    c2[0] =   0;    c3[0] =  64;
    c1[1] =  64;    c2[1] = 127;    c3[1] =   0;
    c1[2] =   0;    c2[2] =  64;    c3[2] = 127;
    
    for(std::size_t ii=0; ii < rgb.size_x(); ++ii )
    {
        rgb(Coord<int64,2>(ii,0)) = c1;
        rgb(Coord<int64,2>(ii,1)) = c2;
        rgb(Coord<int64,2>(ii,2)) = c3;
    }
    
    /*
     * Init the buffers (using MutiArray for convenience)
     */
    MultiArray<T,2> ma_rgb_rgb (4*3,3);
    MultiArray<T,2> ma_rgb_bgr (4*3,3);
    MultiArray<T,2> ma_rgb_rgba(4*4,3); // for the RGBA mode be need 4 elements per pixel
    
    ma_rgb_rgb  = 0;
    ma_rgb_bgr  = 0;
    ma_rgb_rgba = 0;
    
    /*
     * Exporting Data data
     */
    export_to( rgb, ma_rgb_rgb .data(), ma_rgb_rgb .num_elements()*sizeof(T), RGB  );
    export_to( rgb, ma_rgb_bgr .data(), ma_rgb_bgr .num_elements()*sizeof(T), BGR  );
    export_to( rgb, ma_rgb_rgba.data(), ma_rgb_rgba.num_elements()*sizeof(T), RGBA );
    
    /*
     * Importing and checking export/import
     */
    ImageRGB<T>  rgb_out(4,3);
    
    import_from( rgb_out, ma_rgb_rgb .data(), ma_rgb_rgb .num_elements()*sizeof(T), RGB  );
    BOOST_CHECK( rgb_out == rgb ); rgb_out = 0;
    
    import_from( rgb_out, ma_rgb_bgr .data(), ma_rgb_bgr .num_elements()*sizeof(T), BGR  );
    BOOST_CHECK( rgb_out == rgb ); rgb_out = 0;
    
    import_from( rgb_out, ma_rgb_rgba.data(), ma_rgb_rgba.num_elements()*sizeof(T), RGBA );
    BOOST_CHECK( rgb_out == rgb ); rgb_out = 0;
    
    /*
     * Cheching the buffers
     */
    for(std::size_t ii=0; ii < 4; ii+=3 )
    {
        BOOST_CHECK( ma_rgb_rgb(Coord<int64,2>(ii,   0)) == 127 ); //c1-RGB
        BOOST_CHECK( ma_rgb_rgb(Coord<int64,2>(ii+1, 0)) ==  64 );
        BOOST_CHECK( ma_rgb_rgb(Coord<int64,2>(ii+2, 0)) ==   0 );
        
        BOOST_CHECK( ma_rgb_rgb(Coord<int64,2>(ii,   1)) ==   0 ); //c2-RGB
        BOOST_CHECK( ma_rgb_rgb(Coord<int64,2>(ii+1, 1)) == 127 );
        BOOST_CHECK( ma_rgb_rgb(Coord<int64,2>(ii+2, 1)) ==  64 );

        BOOST_CHECK( ma_rgb_rgb(Coord<int64,2>(ii,   2)) ==  64 ); //c3-RGB
        BOOST_CHECK( ma_rgb_rgb(Coord<int64,2>(ii+1, 2)) ==   0 );
        BOOST_CHECK( ma_rgb_rgb(Coord<int64,2>(ii+2, 2)) == 127 );
    }
    
    for(std::size_t ii=0; ii < 4; ii+=3 )
    {
        BOOST_CHECK( ma_rgb_bgr(Coord<int64,2>(ii,   0)) ==   0 ); //c1-BGR
        BOOST_CHECK( ma_rgb_bgr(Coord<int64,2>(ii+1, 0)) ==  64 );
        BOOST_CHECK( ma_rgb_bgr(Coord<int64,2>(ii+2, 0)) == 127 );
        
        BOOST_CHECK( ma_rgb_bgr(Coord<int64,2>(ii,   1)) ==  64 ); //c2-BGR
        BOOST_CHECK( ma_rgb_bgr(Coord<int64,2>(ii+1, 1)) == 127 );
        BOOST_CHECK( ma_rgb_bgr(Coord<int64,2>(ii+2, 1)) ==   0 );

        BOOST_CHECK( ma_rgb_bgr(Coord<int64,2>(ii,   2)) == 127 ); //c3-BGR
        BOOST_CHECK( ma_rgb_bgr(Coord<int64,2>(ii+1, 2)) ==   0 );
        BOOST_CHECK( ma_rgb_bgr(Coord<int64,2>(ii+2, 2)) ==  64 );
    }
    
    for(std::size_t ii=0; ii < 4; ii+=4 )
    {
        BOOST_CHECK( ma_rgb_rgba(Coord<int64,2>(ii,   0)) == 127 ); //c1-RGBA
        BOOST_CHECK( ma_rgb_rgba(Coord<int64,2>(ii+1, 0)) ==  64 );
        BOOST_CHECK( ma_rgb_rgba(Coord<int64,2>(ii+2, 0)) ==   0 );
        BOOST_CHECK( ma_rgb_rgba(Coord<int64,2>(ii+3, 0)) ==   1 );
        
        BOOST_CHECK( ma_rgb_rgba(Coord<int64,2>(ii,   1)) ==   0 ); //c2-RGBA
        BOOST_CHECK( ma_rgb_rgba(Coord<int64,2>(ii+1, 1)) == 127 );
        BOOST_CHECK( ma_rgb_rgba(Coord<int64,2>(ii+2, 1)) ==  64 );
        BOOST_CHECK( ma_rgb_rgba(Coord<int64,2>(ii+3, 1)) ==   1 );

        BOOST_CHECK( ma_rgb_rgba(Coord<int64,2>(ii,   2)) ==  64 ); //c3-RGBA
        BOOST_CHECK( ma_rgb_rgba(Coord<int64,2>(ii+1, 2)) ==   0 );
        BOOST_CHECK( ma_rgb_rgba(Coord<int64,2>(ii+2, 2)) == 127 );
        BOOST_CHECK( ma_rgb_rgba(Coord<int64,2>(ii+3, 2)) ==   1 );
    }
}

BOOST_AUTO_TEST_CASE_TEMPLATE( test_import_export_yuv422, T, ImageTypes )
{
    /*
     * The input data: an ImageYUV422 (8x6) with 3 lines of different Colors
     */
    ImageYUV422<T> ima (8,6);
    
    typedef typename ImageYUV422<T>::Color Color;
    
    Color  c1, c2, c3;
    
    c1[0] = 127;    c2[0] =   0;    c3[0] =  64;
    c1[1] =  64;    c2[1] = 127;    c3[1] =   0;
    c1[2] =   0;    c2[2] =  64;    c3[2] = 127;
    
    for(std::size_t ii=0, jj=0; ii < ima(1).dims(0); ++ii, jj+=2 )
    {
        ima(0)[jj]  [0]   = c1[0];
        ima(0)[jj+1][0]   = c1[0];
        ima(0)[jj]  [0+1] = c1[0];
        ima(0)[jj+1][0+1] = c1[0];
        ima(1)[ii]  [0]   = c1[1];
        ima(2)[ii]  [0]   = c1[2];

        ima(0)[jj]  [1]   = c2[0];
        ima(0)[jj+1][1]   = c2[0];
        ima(0)[jj]  [1+1] = c2[0];
        ima(0)[jj+1][1+1] = c2[0];
        ima(1)[ii]  [1]   = c2[1];
        ima(2)[ii]  [1]   = c2[2];

        ima(0)[jj]  [2]   = c3[0];
        ima(0)[jj+1][2]   = c3[0];
        ima(0)[jj]  [2+1] = c3[0];
        ima(0)[jj+1][2+1] = c3[0];
        ima(1)[ii]  [2]   = c3[1];
        ima(2)[ii]  [2]   = c3[2];
    }
    
    /*
     * Init the buffers (using MutiArray for convenience)
     */
    MultiArray<T,2> ma_yuyv (8*2,6);
    MultiArray<T,2> ma_uyvy (8*2,6);
    
    ma_yuyv = 0;
    ma_uyvy = 0;
    
    /*
     * Exporting Data data
     */
    export_to( ima, ma_yuyv.data(), ma_yuyv.num_elements()*sizeof(T), YUYV );
    export_to( ima, ma_uyvy.data(), ma_uyvy.num_elements()*sizeof(T), UYVY );
    
    /*
     * Importing and checking export/import
     */
    ImageYUV422<T> ima_out(8,6);
    
    import_from( ima_out, ma_yuyv.data(), ma_yuyv.num_elements()*sizeof(T), YUYV );
    BOOST_CHECK( ima_out == ima ); ima_out = 0;
    
    import_from( ima_out, ma_uyvy.data(), ma_uyvy.num_elements()*sizeof(T), UYVY  );
    BOOST_CHECK( ima_out == ima ); ima_out = 0;
    
    /*
     * Cheching the buffers
     */
    for(std::size_t ii=0; ii < 16; ii+=4 )
    {
        BOOST_CHECK( ma_yuyv[ii]  [0] == c1[0] ); //c1-YUYV
        BOOST_CHECK( ma_yuyv[ii+1][0] == c1[1] );
        BOOST_CHECK( ma_yuyv[ii+2][0] == c1[0] );
        BOOST_CHECK( ma_yuyv[ii+3][0] == c1[2] );
        
        BOOST_CHECK( ma_yuyv[ii]  [1] == c2[0] ); //c2-YUYV
        BOOST_CHECK( ma_yuyv[ii+1][1] == c2[1] );
        BOOST_CHECK( ma_yuyv[ii+2][1] == c2[0] );
        BOOST_CHECK( ma_yuyv[ii+3][1] == c2[2] );

        BOOST_CHECK( ma_yuyv[ii]  [2] == c3[0] ); //c3-YUYV
        BOOST_CHECK( ma_yuyv[ii+1][2] == c3[1] );
        BOOST_CHECK( ma_yuyv[ii+2][2] == c3[0] );
        BOOST_CHECK( ma_yuyv[ii+3][2] == c3[2] );
    }
    
    for(std::size_t ii=0; ii < 16; ii+=4 )
    {
        BOOST_CHECK( ma_uyvy[ii]  [0] == c1[1] ); //c1-UYVY
        BOOST_CHECK( ma_uyvy[ii+1][0] == c1[0] );
        BOOST_CHECK( ma_uyvy[ii+2][0] == c1[2] );
        BOOST_CHECK( ma_uyvy[ii+3][0] == c1[0] );
        
        BOOST_CHECK( ma_uyvy[ii]  [1] == c2[1] ); //c2-UYVY
        BOOST_CHECK( ma_uyvy[ii+1][1] == c2[0] );
        BOOST_CHECK( ma_uyvy[ii+2][1] == c2[2] );
        BOOST_CHECK( ma_uyvy[ii+3][1] == c2[0] );

        BOOST_CHECK( ma_uyvy[ii]  [2] == c3[1] ); //c3-UYVY
        BOOST_CHECK( ma_uyvy[ii+1][2] == c3[0] );
        BOOST_CHECK( ma_uyvy[ii+2][2] == c3[2] );
        BOOST_CHECK( ma_uyvy[ii+3][2] == c3[0] );
    }
}

BOOST_AUTO_TEST_SUITE_END ();
