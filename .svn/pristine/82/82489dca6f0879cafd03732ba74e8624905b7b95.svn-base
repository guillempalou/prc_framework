// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------


//!
//! \file capturev4l2.cpp
//!
//! \author Adolfo LÃ³pez <alopez@upc.edu>
//!
//! \date 14-7-2008
//!
//! Implementation for CaptureV4L2 class
//!

#ifdef USE_VIDEO4LINUX

#include <errno.h>
#include <fcntl.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <unistd.h>

#include <boost/shared_array.hpp>
#include <boost/tuple/tuple.hpp>

#include <imageplus/io/capturev4l2.hpp>

using namespace imageplus;
using namespace imageplus::io;

CaptureV4L2::CaptureV4L2(const std::string &device,
                         int64 width,
                         int64 height,
                         int64 fps,
                         int32 format) throw (ImagePlusError)
        : _device(device), _fd(-1)
{
    int32 ret; //return handler
    if (format<0) 
    {
    	TRACE("Using default format: " << V4L2_PIX_FMT_YUYV);
    	_format_in=V4L2_PIX_FMT_YUYV;
    }
    else _format_in=format; //V4L2_PIX_FMT_YUYV
    _width=width;
    _height=height;
    _fps=fps;

    struct stat st;

    if ( stat(_device.c_str(), &st ) != 0 )
    {
        throw ImagePlusError("Couldn't read file-attributes of '" + _device + "': " + strerror( errno ));
    }

    if ( !S_ISCHR(st.st_mode) )
    {
        throw ImagePlusError("'" + _device + "' is not a device" );
    }

    _fd = open( _device.c_str(), O_RDWR, 0 );
    if ( _fd == -1 )
    {
        throw ImagePlusError("Could not open device '" + _device + "': " + strerror( errno ) );
    }

    _grabmethod=1; //1 is mmap; by default:::0 read

    try
    {

        //struct video_capability cap;
        struct v4l2_capability cap;
        memset(&cap, 0, sizeof(struct v4l2_capability));


        if (ioctl(_fd, VIDIOC_QUERYCAP, &cap) < 0)
        {
            throw ImagePlusError("Error requesting video capabilities of v4l2 device '" + _device + "': " + strerror( errno ) );
        }

        if ((cap.capabilities & V4L2_CAP_VIDEO_CAPTURE) == 0)
        {
            throw ImagePlusError("Error opening device " + _device +": video capture not supported.");

        }
        if (_grabmethod)
        {
            if (!(cap.capabilities & V4L2_CAP_STREAMING))
            {
                throw ImagePlusError(_device +" does not support streaming i/o");
            }
        }
        else
        {
            if (!(cap.capabilities & V4L2_CAP_READWRITE))
            {
                throw ImagePlusError(_device + "does not support read i/o");
            }
        }
		
		//Request and modify video controls
		struct v4l2_queryctrl queryctrl;
		struct v4l2_control control;
		
		memset (&queryctrl, 0, sizeof (queryctrl));
		queryctrl.id = V4L2_CID_BRIGHTNESS;
		
		if (-1 == ioctl (_fd, VIDIOC_QUERYCTRL, &queryctrl)) 
		{
		        if (errno != EINVAL) 
		        {
		                perror ("VIDIOC_QUERYCTRL");
		                exit (EXIT_FAILURE);
		        } 
		        else 
		        {
		                throw ImagePlusError ("V4L2_CID_BRIGHTNESS is not supported\n");
		        }
		} 
		else if (queryctrl.flags & V4L2_CTRL_FLAG_DISABLED) 
		{
		        throw ImagePlusError ("V4L2_CID_BRIGHTNESS is not supported\n");
		} 
		else 
		{
		        memset (&control, 0, sizeof (control));
		        control.id = V4L2_CID_BRIGHTNESS;
		        control.value = queryctrl.default_value;
		
		        if (-1 == ioctl (_fd, VIDIOC_S_CTRL, &control)) 
		        {
		                perror ("VIDIOC_S_CTRL");
		                exit (EXIT_FAILURE);
		        }
		}
		
		memset (&control, 0, sizeof (control));
		control.id = V4L2_CID_CONTRAST;
		
		if (0 == ioctl (_fd, VIDIOC_G_CTRL, &control)) 
		{
		        //control.value += 1;
		
		        /* The driver may clamp the value or return ERANGE, ignored here */
		
		        if (-1 == ioctl (_fd, VIDIOC_S_CTRL, &control)
		            && errno != ERANGE) 
		        {
		                perror ("VIDIOC_S_CTRL");
		                exit (EXIT_FAILURE);
		        }
		/* Ignore if V4L2_CID_CONTRAST is unsupported */
		} 
		else if (errno != EINVAL) 
		{
		        perror ("VIDIOC_G_CTRL");
		        exit (EXIT_FAILURE);
		}
		//AUTO-WHITE BALANCE
		memset (&control, 0, sizeof (control));
		control.id=V4L2_CID_AUTO_WHITE_BALANCE;
		control.value=false;
		
		if (ioctl (_fd, VIDIOC_S_CTRL, &control)==-1) TRACE("Auto White Balance not supported");
		

		#ifndef NDEBUG //QuickCam pro 9000 test
		//List private controls
		for (uint64 k=0; k<30; k++)
		{
			memset (&queryctrl, 0, sizeof (queryctrl));
			queryctrl.id = V4L2_CID_PRIVATE_BASE+k;
			if (-1 == ioctl (_fd, VIDIOC_QUERYCTRL, &queryctrl)) 
			{
			        if (errno != EINVAL) 
			        {
			                perror ("VIDIOC_QUERYCTRL");
			                exit (EXIT_FAILURE);
			        } 
			        else 
			        {
			                continue;
			        }
			} 
			else
			{
				std::cout << "The "<< k << "-th control requested is " << queryctrl.name << " with value ";
				memset (&control, 0, sizeof (control));
				control.id = V4L2_CID_PRIVATE_BASE+k; //QuickCam Pro 9000
				if (ioctl (_fd, VIDIOC_G_CTRL, &control)==-1) throw ImagePlusError("Error Requesting Control Value");
				std::cout << control.value << std::endl;
				
			}
			std::cout << control.id << std::endl;

		}
		
		#endif
		//QuickCam Pro 9000 Hacks
		//BackLight Compensation
		memset (&control, 0, sizeof (control));
		control.id = V4L2_CID_PRIVATE_BASE+0; //Backlight Compensation-QuickCam Pro 9000
		control.value=0;
		if (ioctl (_fd, VIDIOC_S_CTRL, &control)==-1) throw ImagePlusError("Error in Backlight Compensation");
		
		//Auto Exposure
		memset (&control, 0, sizeof (control));
		control.id = V4L2_CID_PRIVATE_BASE+10; //Auto Exposure -QuickCam Pro 9000
		control.value=8; //off
		if (ioctl (_fd, VIDIOC_S_CTRL, &control)==-1) throw ImagePlusError("Error in Auto Exposure");
		//Auto White Balance Temperature
		memset (&control, 0, sizeof (control));
		control.id = V4L2_CID_PRIVATE_BASE+12; //Auto White Balance Temperature -QuickCam Pro 9000
		control.value=0;
		if (ioctl (_fd, VIDIOC_S_CTRL, &control)==-1)
		{
			//TODO: AGIL: check if WB is supported or not
			//throw ImagePlusError("Error in Auto WB Temperature");
			TRACE("Auto White Balance not supported");
		}
		
		//End control set
		
        int32 device_formats[16] = { 0 }; // Assume no device supports more than 16 formats
        int32 requested_format_found = 0, fallback_format = -1;
        size_t array_size=sizeof(device_formats)/sizeof(device_formats[0]);

// TODO: AGIL: Removed for Debian compatibility
#if 0
        if (enum_frame_formats(device_formats, array_size))
        {
            throw ImagePlusError("Unable to enumerate frame formats");
        }
#endif
        for (uint32 i = 0; i < array_size && device_formats[i]; i++)
        {
            if (device_formats[i] == _format_in)
            {
                requested_format_found = 1;
                break;
            }
            if (device_formats[i] == V4L2_PIX_FMT_MJPEG || device_formats[i] == V4L2_PIX_FMT_YUYV)
                fallback_format = i;
        }
        if (requested_format_found)
        {
            // The requested format is supported
            TRACE("Frame format supported ");
        }
        else if (fallback_format >= 0)
        {
            // The requested format is not supported but there's a fallback format
            TRACE("  Frame format is no supported but there's a fallback format");
            _format_in = device_formats[0];
        }
        else
        {
        	//TODO: AGIL: Removed to avoid errors with analogue cameras
            // The requested format is not supported and no fallback format is available
            //throw ImagePlusError("ERROR: Requested frame format is not available and no fallback format was found "); //
        }
        
        // TODO: AGIL select channel/index from constructor
        int32 index = 1;
                
        if (-1 == ioctl (_fd, VIDIOC_S_INPUT, &index)) {
                perror ("VIDIOC_S_INPUT");
                exit (EXIT_FAILURE);
        }

        // Set pixel format and frame size
        memset(&_fmt, 0, sizeof(struct v4l2_format));
        _fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
        _fmt.fmt.pix.width = _width;
        _fmt.fmt.pix.height = _height;
        _fmt.fmt.pix.pixelformat = _format_in; //integer: MJPEG or YUV
        _fmt.fmt.pix.field = V4L2_FIELD_ANY;

        if (ioctl(_fd, VIDIOC_S_FMT, &_fmt)<0)
        {
            throw ImagePlusError("Error setting format information in device " + _device);
        }
        if ((_fmt.fmt.pix.width != _width) || (_fmt.fmt.pix.height != _height))
        {
            //std::cout << " Frame size: requested size is not supported by device " << _device << std::endl;
            _width = _fmt.fmt.pix.width;
            _height = _fmt.fmt.pix.height;
        }

        /* set framerate */
        struct v4l2_streamparm* setfps;
        setfps=(struct v4l2_streamparm *) calloc(1, sizeof(struct v4l2_streamparm));
        memset(setfps, 0, sizeof(struct v4l2_streamparm));
        setfps->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
        setfps->parm.capture.timeperframe.numerator=1;
        setfps->parm.capture.timeperframe.denominator=_fps; //need for class info on window and frame_rate
        ret = ioctl(_fd, VIDIOC_S_PARM, setfps);
        if (ret == -1)
        {
        	// TODO: AGIL: We need to fix this for debian
            //throw ImagePlusError("Unable to set frame rate");
        }
        ret = ioctl(_fd, VIDIOC_G_PARM, setfps);
        if (ret == 0)
        {
        	std::cout << "Frame rate: " << setfps->parm.capture.timeperframe.denominator << "fps (requested frame rate fps " << _fps << " is not supported by device)" << std::endl;
        	
            if (setfps->parm.capture.timeperframe.numerator != 1 ||
                    setfps->parm.capture.timeperframe.denominator != _fps)
            {
            	std::cout << "Frame rate: " << setfps->parm.capture.timeperframe.denominator << "fps (requested frame rate fps " << _fps << " is not supported by device)" << std::endl;
                TRACE("Frame rate: " << setfps->parm.capture.timeperframe.denominator << "fps (requested frame rate fps " << _fps << " is not supported by device)" << std::endl);
            }

        }
        else
        {
            throw ImagePlusError("Unable to read out current frame rate");
        }
        /* request buffers */
        memset(&_rb, 0, sizeof(struct v4l2_requestbuffers));
        _rb.count = NB_BUFFER;
        _rb.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
        _rb.memory = V4L2_MEMORY_MMAP;

        ret = ioctl(_fd, VIDIOC_REQBUFS, &_rb);
        if (ret < 0)
        {
            throw ImagePlusError("Unable to allocate buffers");
        }
        /* map the buffers */
        for (uint16 i = 0; i < NB_BUFFER; i++)
        {
            memset(&_buf, 0, sizeof(struct v4l2_buffer));
            _buf.index = i;
            _buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
            _buf.memory = V4L2_MEMORY_MMAP;
            ret = ioctl(_fd, VIDIOC_QUERYBUF, &_buf);
            if (ret < 0)
            {
                throw ImagePlusError("Unable to query buffer");
            }

            TRACE("length: " << _buf.length << " offset: " <<  _buf.m.offset << std::endl);

			//TODO: AGIL: Which flas we should use for nmap...? 
			//            It differs from analog cameras to webcams?
			
            /* start anywhere */
            /*_mem[i] = mmap(0  ,
                           _buf.length, PROT_READ, MAP_SHARED, _fd,
                           _buf.m.offset);*/
            
            _mem[i] = (unsigned char *)mmap( 0 , (size_t)_buf.length,
                                                   PROT_READ | PROT_WRITE ,
                                                   MAP_SHARED , _fd , _buf.m.offset );
            
            if (_mem[i] == MAP_FAILED)
            {
                throw ImagePlusError("Unable to map buffer");
            }

        }
        /* Queue the buffers. */
        for (uint16 i = 0; i < NB_BUFFER; ++i)
        {
            memset(&_buf, 0, sizeof(struct v4l2_buffer));
            _buf.index = i;
            _buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
            _buf.memory = V4L2_MEMORY_MMAP;
            ret = ioctl(_fd, VIDIOC_QBUF, &_buf);
            if (ret < 0)
            {
                throw ImagePlusError("Unable to queue buffer");
            }
        }
        
        

    }
    catch ( ImagePlusError &e )
    {
        for (uint16 i=0; i<NB_BUFFER; ++i)
        {
            if (_mem[i]!=MAP_FAILED)
                munmap(_mem[i], _buf.length);
        }
        if ( _fd != -1 ) close( _fd );
        throw e;
    }

}

CaptureV4L2::~CaptureV4L2(void)
{
    // close map (_mem)
    for (uint16 i=0; i<NB_BUFFER; ++i)
    {
        if (_mem[i]!=MAP_FAILED)
            munmap(_mem[i], _buf.length);
    }

//    if( _map != MAP_FAILED )
//        munmap( _map, _buf.length );

    // close open file
    if ( _fd != -1 ) close( _fd );

}

void CaptureV4L2::start() throw (ImagePlusError)
{
    int32 type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
    int32 ret;

    ret = ioctl(_fd, VIDIOC_STREAMON, &type);
    if (ret < 0)
    {
        throw ImagePlusError("Unable to start capture");
    }
}

void CaptureV4L2::stop() throw (ImagePlusError)
{
    int32 type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
    int32 ret;

    ret = ioctl(_fd, VIDIOC_STREAMOFF, &type);
    if (ret < 0)
    {
        throw ImagePlusError("Unable to stop capture");
    }
}



//void CaptureV4L2::set_sensivity( uint16 brightness,
//                                uint16 hue,
//                                uint16 colour,
//                                uint16 contrast ) throw (ImagePlusError)
//{
//    _pic.brightness = brightness;
//    _pic.hue = hue;
//    _pic.colour = colour;
//    _pic.contrast = contrast;
//
////    if ( xioctl( VIDIOCSPICT, &_pic ) != 0)
////    {
////        throw ImagePlusError("Error changing sensivity of video-device.");
////    }
//}


template<typename T>
void CaptureV4L2::operator>>( ImageRGB<T>& ima ) throw (ImagePlusError)
{
	//TODO: what if T != uint8??
    uint8 *src = NULL;
    int ret;
    
    ASSERT(ima.size_x() == _width && ima.size_y() == _height, "Captured image has different size than your image");

    //start capture is mandatory
    memset(&_buf, 0, sizeof(struct v4l2_buffer));
    
    _buf.type   = V4L2_BUF_TYPE_VIDEO_CAPTURE;
    _buf.memory = V4L2_MEMORY_MMAP;
    
    ret = ioctl(_fd, VIDIOC_DQBUF, &_buf);
    if (ret < 0)
    {
        throw ImagePlusError("Unable to dequeue buffer");
    }

    /* Capture a single raw frame */
    src=static_cast<uint8*>(_mem[_buf.index]);
    T* r = ima(RED_CHANNEL  ).data();
	T* g = ima(GREEN_CHANNEL).data();
	T* b = ima(BLUE_CHANNEL ).data();
	uint32 size=_width*_height;
	
    if (_buf.bytesused > 0)
    {
        switch (_format_in)
        {
            case V4L2_PIX_FMT_RGB32:
            	for (uint32 i=0; i<size; i++)
                {
            		src++;
                	*r++ = static_cast<T>(*src++);
                	*g++ = static_cast<T>(*src++);
                	*b++ = static_cast<T>(*src++);
                }
                
                break;

            case V4L2_PIX_FMT_MJPEG:

                break;
            case V4L2_PIX_FMT_YUYV:
            	//Quick conversion to rgb, avoid construction of a YUV image
            	//ImageRGB<uint8> imag(_width, _height);
                int16 tmp;
                float64 y0, y1, u, v;
                for (uint32 i=0; i<size; i++, src=src+4)
                {
                    y0=static_cast<float64>(*src);
                    u=static_cast<float64>(*(src+1));
                    y1=static_cast<float64>(*(src+2));
                    v=static_cast<float64>(*(src+3));

                    if ((tmp=static_cast<int16>(y0 + (v - 128.0) * 1.4   + 0.5))>255) tmp=255;
                    else if (tmp<0) tmp=0;
                    ima(0).data()[i] =  static_cast<T>(tmp);
                    if ((tmp=static_cast<int16>(y0 - (u - 128.0) * 0.34 + (v - 128.0)*0.71 + 0.5))>255) tmp=255;
                    else if (tmp<0) tmp=0;
                    ima(1).data()[i] =  static_cast<T>(tmp);
                    if ((tmp=static_cast<int16>(y0 + (u - 128.0) * 1.78   + 0.5))>255) tmp=255;
                    else if (tmp<0) tmp=0;
                    ima(2).data()[i] =   static_cast<T>(tmp);

                    ++i;

                    if ((tmp=static_cast<int16>(y1 + (v - 128.0) * 1.4   + 0.5))>255) tmp=255;
                    else if (tmp<0) tmp=0;
                    ima(0).data()[i] =   static_cast<T>(tmp);
                    if ((tmp=static_cast<int16>(y1 - (u - 128.0) * 0.34 + (v - 128.0)*0.71 + 0.5))>255) tmp=255;
                    else if (tmp<0) tmp=0;
                    ima(1).data()[i] =  static_cast<T>(tmp);
                    if ((tmp=static_cast<int16>(y1 + (u - 128.0) * 1.78   + 0.5))>255) tmp=255;
                    else if (tmp<0) tmp=0;
                    ima(2).data()[i] =   static_cast<T>(tmp);

                }
                //ima = convert<T>(imag);
                break;
            default:

                break;
        }

    }
    ret = ioctl(_fd, VIDIOC_QBUF, &_buf);
    if (ret < 0)
    {
        throw ImagePlusError("Unable to requeue buffer");
    }
}

// TODO: AGIL: Removed for Debian compatibility 
#if 0

int32 CaptureV4L2::enum_frame_formats(int32 *supported_formats, uint32 max_formats)
{
    int ret;
    struct v4l2_fmtdesc fmt;

    memset(&fmt, 0, sizeof(fmt));
    fmt.index = 0;
    fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
    while ((ret = ioctl(_fd, VIDIOC_ENUM_FMT, &fmt)) == 0)
    {
        if (supported_formats == NULL)
        {
            printf("{ pixelformat = '%c%c%c%c', description = '%s' }\n",
                   fmt.pixelformat & 0xFF, (fmt.pixelformat >> 8) & 0xFF,
                   (fmt.pixelformat >> 16) & 0xFF, (fmt.pixelformat >> 24) & 0xFF,
                   fmt.description);
            ret = enum_frame_sizes(fmt.pixelformat);
            if (ret != 0)
                TRACE ("  Unable to enumerate frame sizes.\n");
        }
        else if (fmt.index < max_formats)
        {
            supported_formats[fmt.index] = fmt.pixelformat;
        }

        fmt.index++;
    }
    if (errno != EINVAL)
    {
        return errno;
    }

    return 0;
}

int32 CaptureV4L2::enum_frame_intervals( __u32 pixfmt, __u32 width, __u32 height)
{
    int32 ret;
    struct v4l2_frmivalenum fival;

    memset(&fival, 0, sizeof(fival));
    fival.index = 0;
    fival.pixel_format = pixfmt;
    fival.width = width;
    fival.height = height;
    printf("\tTime interval between frame: ");
    while ((ret = ioctl(_fd, VIDIOC_ENUM_FRAMEINTERVALS, &fival)) == 0)
    {
        if (fival.type == V4L2_FRMIVAL_TYPE_DISCRETE)
        {
            printf("%u/%u, ",
                   fival.discrete.numerator, fival.discrete.denominator);
        }
        else if (fival.type == V4L2_FRMIVAL_TYPE_CONTINUOUS)
        {
            printf("{min { %u/%u } .. max { %u/%u } }, ",
                   fival.stepwise.min.numerator, fival.stepwise.min.numerator,
                   fival.stepwise.max.denominator, fival.stepwise.max.denominator);
            break;
        }
        else if (fival.type == V4L2_FRMIVAL_TYPE_STEPWISE)
        {
            printf("{min { %u/%u } .. max { %u/%u } / "
                   "stepsize { %u/%u } }, ",
                   fival.stepwise.min.numerator, fival.stepwise.min.denominator,
                   fival.stepwise.max.numerator, fival.stepwise.max.denominator,
                   fival.stepwise.step.numerator, fival.stepwise.step.denominator);
            break;
        }
        fival.index++;
    }
    printf("\n");
    if (ret != 0 && errno != EINVAL)
    {
        return errno;
    }

    return 0;
}
int32 CaptureV4L2::enum_frame_sizes(__u32 pixfmt)
{
    int32 ret;
    struct v4l2_frmsizeenum fsize;

    memset(&fsize, 0, sizeof(fsize));
    fsize.index = 0;
    fsize.pixel_format = pixfmt;
    while ((ret = ioctl(_fd, VIDIOC_ENUM_FRAMESIZES, &fsize)) == 0)
    {
        if (fsize.type == V4L2_FRMSIZE_TYPE_DISCRETE)
        {
            printf("{ discrete: width = %u, height = %u }\n",
                   fsize.discrete.width, fsize.discrete.height);
            ret = enum_frame_intervals(pixfmt,
                                       fsize.discrete.width, fsize.discrete.height);
            if (ret != 0)
                printf("  Unable to enumerate frame sizes.\n");
        }
        else if (fsize.type == V4L2_FRMSIZE_TYPE_CONTINUOUS)
        {
            printf("{ continuous: min { width = %u, height = %u } .. "
                   "max { width = %u, height = %u } }\n",
                   fsize.stepwise.min_width, fsize.stepwise.min_height,
                   fsize.stepwise.max_width, fsize.stepwise.max_height);
            printf("  Refusing to enumerate frame intervals.\n");
            break;
        }
        else if (fsize.type == V4L2_FRMSIZE_TYPE_STEPWISE)
        {
            printf("{ stepwise: min { width = %u, height = %u } .. "
                   "max { width = %u, height = %u } / "
                   "stepsize { width = %u, height = %u } }\n",
                   fsize.stepwise.min_width, fsize.stepwise.min_height,
                   fsize.stepwise.max_width, fsize.stepwise.max_height,
                   fsize.stepwise.step_width, fsize.stepwise.step_height);
            printf("  Refusing to enumerate frame intervals.\n");
            break;
        }
        fsize.index++;
    }
    if (ret != 0 && errno != EINVAL)
    {
        perror("ERROR enumerating frame sizes");
        return errno;
    }

    return 0;
}

#endif // Disabled for Debian compatibility

// instantations
template void imageplus::io::CaptureV4L2::operator>><uint8>(ImageRGB<uint8>&);

#endif
