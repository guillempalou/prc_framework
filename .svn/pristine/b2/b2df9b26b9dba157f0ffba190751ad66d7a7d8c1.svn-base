/*
 * minimizers.hpp
 *
 *  Created on: Oct 31, 2011
 *      Author: guillem
 */

#ifndef MINIMIZERS_HPP_
#define MINIMIZERS_HPP_

#include <imageplus/math/optimization/minimizer.hpp>

namespace imageplus {
	namespace math 		{
		namespace optimization {

		//! Classic Steepest Descent Algorithm
		//! \author Guillem Palou <guillem.palou@upc.edu>
		//! \date 10-04-2012
	class SteepestDescentMinimizer : public Minimizer {

		//! Variable Type
		typedef numeric::ScalarFunction::VariableType VariableType;

		//! Gradient Type
		typedef numeric::ScalarFunction::GradientType GradientType;

	public:

		//! Default constructor
		//!
		//! \param[in] f: convex and differentiable function to be minimized
		SteepestDescentMinimizer(numeric::ScalarFunction& f) : Minimizer(f) {
			_tolerance = 1e-6;
			_step = 1;
			_max_iterations = 1000;
		}

		//! Sets the maximum number of iterations
		//!
		//! \param[in] max_iterator : maximum number of iterations
		void max_iterations(uint32 max_iterations) {_max_iterations = max_iterations;}

		//! Sets the tolerance of the algorithm
		//! The algorithm will stop if the decrease of the minimum solution is below tolerance
		//!
		//! \param[in] tolerance : the tolerance (should be > 0)
		void tolerance(float64 tolerance) {_tolerance = tolerance;}

		//! Sets the step size
		//!
		//! \param[in] step : step size of the gradient
		void step(float64 step) {_step = step;}

		//! Minimizes the function using the steepest gradient algorithm:
		//! x_{n+1} = x_n + step * \nabla x_n
		//!
		//! \param[in] initial_point : point to begin with
		void minimize(const VariableType& initial_point) {

			VariableType ant_x 	= initial_point;
			VariableType x 		= initial_point;

			uint32 iterations = 0;

			float64 error = 0;
			do {

				const GradientType& g = this->_f.gradient(x);

				// Update the vector X along the gradient
				x -= _step*g;

				// Calculate the difference
				VariableType y = x-ant_x;
				error = y.norm();

				ant_x = x;

			} while (iterations++ < _max_iterations && std::fabs(error) > _tolerance); // check finish criterion

			this->_minimum_point = x;
		}
	private:

		//! tolerance
		float64 _tolerance;

		//! step size
		float64 _step;

		//! maximum number of iterations
		uint32 _max_iterations;

	};


		}
	}
}



#endif /* MINIMIZERS_HPP_ */
