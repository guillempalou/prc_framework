// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------

//!
//!  \file multiarray_math.cpp
//!
//!  Methods to compare multiarrays
//!

#include <imageplus/core/multiarray_math.hpp>
#include <math.h>
#include <time.h>

#include <boost/random.hpp>

// for uint64 std::abs(int64)
#include <imageplus/math.hpp>

namespace imageplus
{
    //!
    //! \brief Functor to compute absolute value.
    //!
    //! \author Ramon Morros <ramon.morros@upc.edu>
    //!
    //! \date 30-03-2008
    //!
    template< typename T >
    struct _abs : public std::unary_function< T, T > 
    {
            //!
            //! \brief Compute absolute value.
            //!
            //! \author Ramon Morros <ramon.morros@upc.edu>
            //!
            //! \date 30-03-2008
            //!
            //! \param [in] x : A number
            //!
            //! \return Absolute value of x
            //!
            T operator()( const T &x ) const { return std::abs( x ); }
    };

    //!
    //! \brief Functor to compute square of a number.
    //!
    //! \author Ramon Morros <ramon.morros@upc.edu>
    //!
    //! \date 30-03-2008
    //!
    template< typename T >
    struct _sqr: public std::unary_function< T, T > 
    {
            //!
            //! \brief Compute square.
            //!
            //! \author Ramon Morros <ramon.morros@upc.edu>
            //!
            //! \date 30-03-2008
            //!
            //! \param [in] x : A number
            //!
            //! \return Square of x
            //!
            T operator()( const T &x ) const { return x * x; }
    };


    //!
    //! \brief Functor to compute square root of a number.
    //!
    //! \author Ramon Morros <ramon.morros@upc.edu>
    //!
    //! \date 30-03-2008
    //!
    template< typename T >
    struct _sqrt: public std::unary_function< float64, T > 
    {
            //!
            //! \brief Compute square root.
            //!
            //! \author Ramon Morros <ramon.morros@upc.edu>
            //!
            //! \date 30-03-2008
            //!
            //! \param [in] x : A number
            //!
            //! \return Square root of x
            //!
            float64 operator()(const T& x ) const { return std::sqrt(static_cast<float64>(x)); }
    };

}


using namespace imageplus;


template<typename T, std::size_t D>
MultiArray<T,D> imageplus::abs( const MultiArray<T,D>& input1 )
{
    // Create sum as a copy of input1
    MultiArray<T,D> res(input1.dims());

    // Use the STL algorithm 'transform' with the function object '_abs()'
    std::transform (input1.data(),
                    input1.data() + input1.num_elements(),
                    res.data(),
                    imageplus::_abs<T>());

    return res;
}

template<typename T, std::size_t D>
MultiArray<T,D> imageplus::sqr( const MultiArray<T,D>& input1)
{
    // Create sum as a copy of input1
    MultiArray<T,D> prod(input1.dims());

    // Use the STL algorithm 'transform' with the function object '_sqr()'
    std::transform (input1.data(),
                    input1.data() + input1.num_elements(),
                    prod.data(),
                    imageplus::_sqr<T>());

    return prod;
}


template<typename T, std::size_t D>
MultiArray<float64,D> imageplus::sqrt( const MultiArray<T,D>& input1 )
{
    // Create sum as a copy of input1
    MultiArray<float64,D> res(input1.dims());

    // Use the STL algorithm 'transform' with the function object '_sqrt()'
    std::transform (input1.data(),
                    input1.data() + input1.num_elements(),
                    res.data(),
                    imageplus::_sqrt<float64>());

    return res;
}


template<typename T, std::size_t D>
void imageplus::random (MultiArray<T,D>& in, T maxval)
{
    // Define a random number generator and initialize it with a non-reproducible seed.
    // (The seed is unsigned, otherwise the wrong overload may be selected
    // when using mt19937 as the base_generator_type.)
    boost::mt19937 generator(static_cast<unsigned int>(time(0)));
        
    boost::variate_generator< boost::mt19937&, boost::uniform_int<T> > rnd_gen(generator, boost::uniform_int<T>(0, maxval));
    std::generate (in.data(), in.data()+in.num_elements(), rnd_gen);
}

template<std::size_t D>
void imageplus::random (MultiArray<float64,D>& in, float64 maxval)
{
    // Define a random number generator and initialize it with a non-reproducible seed.
    // (The seed is unsigned, otherwise the wrong overload may be selected
    // when using mt19937 as the base_generator_type.)
    boost::mt19937 generator(static_cast<unsigned int>(time(0)));
        
    boost::variate_generator< boost::mt19937&, boost::uniform_real<> > rnd_gen(generator, boost::uniform_real<>(0, maxval));
    std::generate (in.data(), in.data()+in.num_elements(), rnd_gen);
}



// Instantiations
namespace imageplus
{
    template struct _abs<int64>;
    template struct _abs<float64>;

    template struct _sqr<uint8>;
    template struct _sqr<int64>;
    template struct _sqr<float64>;

    template struct _sqrt<uint8>;
    template struct _sqrt<int64>;
    template struct _sqrt<float64>;
}

namespace imageplus
{
    template MultiArray<int64,1>   abs (const MultiArray<int64,1>& );
    template MultiArray<float64,1> abs (const MultiArray<float64,1>& );

    template MultiArray<int64,2>   abs (const MultiArray<int64,2>& );
    template MultiArray<float64,2> abs (const MultiArray<float64,2>& );

    template MultiArray<int64,3>   abs (const MultiArray<int64,3>& );
    template MultiArray<float64,3> abs (const MultiArray<float64,3>& );


    template MultiArray<uint8,1>   sqr (const MultiArray<uint8,1>& );
    template MultiArray<int64,1>   sqr (const MultiArray<int64,1>& );
    template MultiArray<float64,1> sqr (const MultiArray<float64,1>& );

    template MultiArray<uint8,2>   sqr (const MultiArray<uint8,2>& );
    template MultiArray<int64,2>   sqr (const MultiArray<int64,2>& );
    template MultiArray<float64,2> sqr (const MultiArray<float64,2>& );

    template MultiArray<uint8,3>   sqr (const MultiArray<uint8,3>& );
    template MultiArray<int64,3>   sqr (const MultiArray<int64,3>& );
    template MultiArray<float64,3> sqr (const MultiArray<float64,3>& );


    template MultiArray<float64,1> sqrt(const MultiArray<uint8,1>& );
    template MultiArray<float64,1> sqrt(const MultiArray<int64,1>& );
    template MultiArray<float64,1> sqrt(const MultiArray<float64,1>& );

    template MultiArray<float64,2> sqrt(const MultiArray<uint8,2>& );
    template MultiArray<float64,2> sqrt(const MultiArray<int64,2>& );
    template MultiArray<float64,2> sqrt(const MultiArray<float64,2>& );

    template MultiArray<float64,3> sqrt(const MultiArray<uint8,3>& );
    template MultiArray<float64,3> sqrt(const MultiArray<int64,3>& );
    template MultiArray<float64,3> sqrt(const MultiArray<float64,3>& );


    template void random (MultiArray<uint8,1>&,   uint8 );
    template void random (MultiArray<uint8,2>&,   uint8 );
    template void random (MultiArray<uint8,3>&,   uint8 );

    template void random (MultiArray<uint32,1>&,  uint32);
    template void random (MultiArray<uint32,2>&,  uint32);
    template void random (MultiArray<uint32,3>&,  uint32);
    
    template void random (MultiArray<uint64,1>&,  uint64);
    template void random (MultiArray<uint64,2>&,  uint64);
    template void random (MultiArray<uint64,3>&,  uint64);

    template void random (MultiArray<int64,1>&,   int64 );
    template void random (MultiArray<int64,2>&,   int64 );
    template void random (MultiArray<int64,3>&,   int64 );
    
    template void random (MultiArray<float64,1>&, float64 );
    template void random (MultiArray<float64,2>&, float64 );
    template void random (MultiArray<float64,3>&, float64 );
}
