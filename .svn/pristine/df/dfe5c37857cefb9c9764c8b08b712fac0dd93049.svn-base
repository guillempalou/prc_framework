// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------

//!
//!  \file foreground2d/inc/image_access.hpp
//!
//!  Access to pixels and 2D multiarray elements
//!

#ifndef IMAGEPLUS_CORE_IMAGE_ACCESS_HPP
#define IMAGEPLUS_CORE_IMAGE_ACCESS_HPP

#include <imageplus/core/imavol.hpp>
#include <imageplus/core/multiarray.hpp>
#include <imageplus/core/config.hpp>

namespace imageplus
{
    //! Definition of the direction encoding for pixel neighbors
    static int64 offsts8[2][9] = {{0, 1,  1,  0, -1, -1, -1 ,0, 1},
                                  {0, 0, -1, -1, -1,  0,  1, 1, 1}};

    //!
    //! \brief Get the address of the neighbour of a given element.
    //!
    //! Note: the directions are encoded this way for square grids:\n
    //!                                                            \n
    //!                      a4   a3  a2                           \n
    //!                      a5   a0  a1                           \n
    //!                      a6   a7  a8                           \n
    //!
    //! \tparam T : The type of the data                         
    //!
    //! \param[in] ima  : multiarray where the element resides
    //! \param[in] data : Pointer to the element
    //! \param[in] dir  : Direction of the neighbor (8 connectivity)
    //!
    //! \return Memory address of the neighbor
    //!
    //! \author Josep Ramon Morros <ramon.morros@upc.edu>
    //!
    //! \date 14-2-2008
    //!
    template<typename T>
    IMAGEPLUS_INLINE T* neigh8 (const MultiArray<T,2>& ima, T* data, uint64 dir)
    {
        return (data + offsts8[0][dir] + ima.dims(0) * offsts8[1][dir]);
    }

    //!
    //! \brief Get the address of the neighbour of a given pixel.
    //!
    //! Note: the directions are encoded this way for square grids:\n
    //!                                                            \n
    //!                      a4   a3  a2                           \n
    //!                      a5   a0  a1                           \n
    //!                      a6   a7  a8                           \n
    //!
    //! \tparam T : The type of the data                         
    //!
    //! \param[in] ima  : Image<T,1> (ImageGray, ImagePartition, ...) where the element resides
    //! \param[in] data : Pointer to the pixel
    //! \param[in] dir  : Direction of the neighbor (8 connectivity)
    //!
    //! \return Memory address of the neighbor
    //!
    //! \author Josep Ramon Morros <ramon.morros@upc.edu>
    //!
    //! \date 14-2-2008
    //!
    template<typename T>
    IMAGEPLUS_INLINE T* neigh8 (const Image<T,1>& ima, T* data, uint64 dir)
    {
        return (data + offsts8[0][dir] + ima.size_x() * offsts8[1][dir]);
    }

    //!
    //! \brief Get the x coordinate of a given element given its memory position inside the image
    //!
    //! \tparam T : The type of the data                         
    //!
    //! \author Josep Ramon Morros <ramon.morros@upc.edu>
    //!
    //! \date 14-2-2008
    //!
    //! \param[in] ima  : multiarray where the element resides
    //! \param[in] data : Pointer to the element
    //!
    //! \return X coordinate of the pixel
    //!
    template<typename T>
    IMAGEPLUS_INLINE int64 wherex (const MultiArray<T,2>& ima, const T* data)
    {
        return ((data - ima.data()) % ima.dims(0));
    }

    //!
    //! \brief Get the y coordinate of a given element given its memory position inside the image
    //!
    //! \tparam T : The type of the data                         \n
    //!
    //! \param[in] ima  : multiarray where the element resides
    //! \param[in] data : Pointer to the element
    //!
    //! \return Y coordinate of the pixel
    //!
    //! \author Josep Ramon Morros <ramon.morros@upc.edu>
    //!
    //! \date 14-2-2008
    //!
    template<typename T>
    IMAGEPLUS_INLINE int64 wherey (const MultiArray<T,2>& ima, const T* data)
    {
        return ((data - ima.data()) / ima.dims(0));
    }

    //!
    //! \brief Get the y coordinate of a given pixel given its memory position inside the image
    //!
    //! \tparam T : The type of the data                         \n
    //!
    //! \param[in] ima  : Image<T,1> (ImageGray, ImagePartition, ...) where the element resides
    //! \param[in] data : Pointer to the pixel
    //!
    //! \return Y coordinate of the pixel
    //!
    //! \author Josep Ramon Morros <ramon.morros@upc.edu>
    //!
    //! \date 14-2-2008
    //!
    template<typename T>
    IMAGEPLUS_INLINE int64 wherey (const Image<T,1>& ima, const T* data)
    {
        return ((data - ima(0).data()) / ima.size_x());
    }

    //!
    //! \brief Get the x coordinate of a given pixel given its memory position inside the image
    //!
    //! \tparam T : The type of the data                         \n
    //!
    //! \param[in] ima  : Image<T,1> (ImageGray, ImagePartition, ...) where the element resides
    //! \param[in] data : Pointer to the pixel
    //!
    //! \return X coordinate of the pixel
    //!
    //! \author Josep Ramon Morros <ramon.morros@upc.edu>
    //!
    //! \date 14-2-2008
    //!
    template<typename T>
    IMAGEPLUS_INLINE int64 wherex (const Image<T,1>& ima, const T* data)
    {
        return ((data - ima(0).data()) % ima.size_x());
    }


    //!
    //! \brief Get the coordinate of a given pixel given its memory position inside the image
    //!
    //! \tparam T : The type of the data                         \n
    //!
    //! \param[in] ima  : Image<T,1> (ImageGray, ImagePartition, ...) where the element resides
    //! \param[in] data : Pointer to the pixel
    //!
    //! \return Coordinate of the pixel
    //!
    //! \author Josep Ramon Morros <ramon.morros@upc.edu>
    //!
    //! \date 14-2-2008
    //!
    template<typename T>
    IMAGEPLUS_INLINE Coord2D<> whereis (const Image<T,1>& ima, const T* data)
    {
        Coord2D<> co;
        co.x() = (data - ima(0).data()) % ima.size_x();
        co.y() = (data - ima(0).data()) / ima.size_x();
        return co;
    }

}
#endif

