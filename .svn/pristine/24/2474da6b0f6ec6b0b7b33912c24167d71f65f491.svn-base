// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------


//!
//! \file capturev4l2.hpp
//!
//! \author Adolfo López <alopez@upc.edu>
//!
//! \date 14-7-2008
//!
//! Interface for CaptureV4L2 class
//!

#ifdef USE_VIDEO4LINUX

#ifndef IMAGEPLUS_IO_CAPTUREV4L2_HPP
#define IMAGEPLUS_IO_CAPTUREV4L2_HPP

#include <string>

#include <boost/smart_ptr.hpp>

//#include <linux/videodev.h>
#include <linux/videodev2.h>
#include <stdlib.h>




#include <imageplus/core.hpp>


namespace imageplus
{

    namespace io
    {

		//! Number of buffers that can be mapped
        const uint16 NB_BUFFER=8;
        //!
        //! \brief class to capture frames from a video4linux2 device
        //!
        //! \author Adolfo López Méndez <alopez@upc.edu>
        //!
        //! \date 14-7-2008
        //!
        //! This class follows the same rules as the ReadSequence class but captures frames
        //! from a video4linux2 device (such as webcams). Obviously this class only works
        //! in a linux compiled ImagePlus library
        //!
        //!
        //! To start capturing frames use:
        //! \code
        //!   CaptureV4L2 cap("/dev/video0", 640, 480, 25, V4L2_PIX_FMT_YUYV);
        //!   ImageRGB<uint8> rgb;
        //!	  cap.start()	
        //!   cap >> rgb;
        //!   cap.stop();
        //! \endcode
        //!
        class CaptureV4L2
        {

            public:

                //!
                //! \brief Constructor
                //!
                //! \param[in]       device : Device for the webca (default is "/dev/video0")
                //! \param[in]        width : Requested width of the capture window (-1 for maximum width supported by the device)
                //! \param[in]       height : Requested height of the capture window (-1 for maximum height supported by the device)
                //! \param[in]          fps : Frame rate (default is 25)
                //! \param[in] 		 format : Pixel Format (default is V4L2_PIX_FMT_YUYV)
                //!
                CaptureV4L2(const std::string& device = "/dev/video0",
                            int64 width = -1,
                            int64 height = -1,
                            int64 fps = 25,
                            int32 format = V4L2_PIX_FMT_YUYV
                           ) throw (ImagePlusError);

                //!
                //! \brief Destructor
                //!
                ~CaptureV4L2(void);

                
                //!
                //! \brief Start Capture
                //!
                void start() throw (ImagePlusError);

                //!
                //! \brief Stop Capture
                //!
                void stop() throw (ImagePlusError);

                
                //!
                //! \brief Grab RGB image from sequence
                //!
                //! \param[out] image : RGB image where the data is going to be stored
                //!
                //! Before grabbing, streaming must be triggered with start() method
                //! 
                template<typename T>
                void operator>>( ImageRGB<T>& image ) throw (ImagePlusError);

                //!
                //! \brief Access X size of frames
                //!
                //! \return sizeX of the frames
                //!
                inline uint64 size_x() const
                {
                    return _width;
                }

                //!
                //! \brief Access Y size of frames
                //!
                //! \return sizeY of the frames
                //!
                inline uint64 size_y() const
                {
                    return _height;
                }



//                void set_sensivity( uint16 brightness,
//                                    uint16 hue,
//                                    uint16 colour,
//                                    uint16 contrast ) throw (ImagePlusError);

            private:

                
// TODO: AGIL: Removed for Debian compatibility
#if 0


                //!
                //! \brief Enumerate supported formats
                //!
                //! \param[out] *supported_formats : vector where the supported formats are going to be written
                //! \param[in]  max_formats        : maximum number of requested formats
                //! TODO: adapt the input arguments with an imageplus container
                int32 enum_frame_formats(int32 *supported_formats, uint32 max_formats);
                
                //!
                //! \brief Enumerate frame intervals
                //!
                //! \param[in] pixfmt : V4L2 pixel format
                //! \param[in]  width  : frame width
                //! \param[in]  height  : frame height
               
                int32 enum_frame_intervals( __u32 pixfmt, __u32 width, __u32 height);
                
                //!
                //! \brief Enumerate frame sizes
                //!
                //! \param[in] pixfmt : V4L2 pixel format
                
                int32 enum_frame_sizes(__u32 pixfmt);
#endif
                

                //! stores the device name (usually "/dev/video0")
                std::string _device;

                //! stores the file descriptor of the open device
                int _fd;
                
				//! stores the grabbing method 0: read, 1: mmap (default)
				// TODO: create a method to read/write these member
                int32 _grabmethod;
                
				//! frame width
                uint32 _width;

				//! frame height
                uint32 _height;

				//! frame rate
                int64 _fps;

				//! V4L2 pixel format
                int32 _format_in;

				//! memory mapping addresses for input operations
                void *_mem[NB_BUFFER]; 

				//! V4L2 format structure
                struct v4l2_format _fmt;

				//! V4L2 buffer management structure
                struct v4l2_requestbuffers _rb;

				//! V4L2 data buffer
                struct v4l2_buffer _buf;

        };

    } // namespace io

} //namespace imageplus

#endif

#endif
