/*
 * propagation_score.hpp
 *
 *  Created on: Jan 9, 2013
 *      Author: gpalou
 */

#ifndef PROPAGATION_SCORE_HPP_
#define PROPAGATION_SCORE_HPP_

#include <imageplus/math/math_types.hpp>
#include <vector>

namespace imageplus {
	namespace segmentation {

	template<class PartitionModel>
	float64 covering_score(PartitionModel& partition, PartitionModel& groundtruth) {

		uint64 num_reg_1 = partition.max_label()+1;
		uint64 num_reg_2 = groundtruth.max_label()+1;

		std::vector<uint64> region_areas_1(num_reg_1,0);
		std::vector<uint64> region_areas_2(num_reg_2,0);
		std::vector<uint64> region_index(num_reg_1);

		math::Matrix intersect_matrix = math::Matrix::Zero(num_reg_1, num_reg_2);

		typename PartitionModel::iterator p = partition.begin();
		typename PartitionModel::iterator end = partition.end();
		for (; p != end; ++p) {
			typename PartitionModel::coord_type pos = p.pos();
			intersect_matrix(partition(pos)(0),groundtruth(pos)(0)) +=1;
		}

		uint64 image_area=0;
		for(std::size_t jj = 0; jj < num_reg_2; jj++)
		{
			for(std::size_t ii = 0; ii < num_reg_1; ii++)
			{
				image_area += intersect_matrix(ii,jj);
				region_areas_1[ii] = region_areas_1[ii] +  intersect_matrix(ii,jj);
				region_areas_2[jj] = region_areas_2[jj] +  intersect_matrix(ii,jj);
			}
		}

		// Matrix containing the Jaccard indices of each pair of regions
		math::Matrix jaccard_matrix(num_reg_1, num_reg_2);
		for(std::size_t jj = 0; jj < num_reg_2; jj++)
		{
			for(std::size_t ii = 0; ii < num_reg_1; ii++)
			{
				jaccard_matrix(ii,jj) = ((float64)intersect_matrix(ii,jj))/((float64)(region_areas_1[ii]+region_areas_2[jj]-intersect_matrix(ii,jj)));
			}
		}

		//! assign to each region the groundtruth region with maximum intersection
		for (std::size_t ii = 0; ii < num_reg_1; ii++) {
			uint64 max_inter = 0;

			for (std::size_t kk = 1; kk < num_reg_2; kk++) {
				if (intersect_matrix(ii,kk) > intersect_matrix(ii,max_inter)) {
					max_inter = kk;
				}
			}

			region_index[ii] = max_inter;
		}

		float64 propagation_score = 0.;
		for(uint64 ii=0; ii<num_reg_1; ii++)
		{
			float64 score=0;
			for(uint64 jj=0; jj<num_reg_2; ++jj)
			{
				if(region_index[ii] == jj)
				{
					score += jaccard_matrix(ii,jj);
				}
			}
			propagation_score += score;
		}

		return propagation_score/=num_reg_2;
	}

	}
}

#endif /* PROPAGATION_SCORE_HPP_ */
