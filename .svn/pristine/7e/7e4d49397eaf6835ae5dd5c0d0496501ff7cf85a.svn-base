// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------

//! 
//! \file partition_contour.test
//!
//! Tests for basic functions working with Partition with contours
//!
#include <imageplus/core.hpp>

BOOST_AUTO_TEST_SUITE ( Partition_Contour_Suite );

using namespace imageplus;
using namespace std;


BOOST_AUTO_TEST_CASE( partition_contour_neighbor_iterators )
{  
    ImagePartition<> temp_part(3,3);
    temp_part[0][0] = 1;     temp_part[1][0] = 1;     temp_part[2][0] = 2;
    temp_part[0][1] = 1;     temp_part[1][1] = 2;     temp_part[2][1] = 2;
    temp_part[0][2] = 3;     temp_part[1][2] = 4;     temp_part[2][2] = 5;

    typedef Partition<RegionContour<Coord2D<int64> > > partition_type;
    partition_type my_partition(temp_part);

    partition_type::RegionType& my_reg = my_partition[2];
    partition_type::RegionType::neighbor_iterator neigh_it = my_reg.neighbors_begin();
    
    std::set<uint32> neighb;
    std::set<uint32>::iterator set_it;
    neighb.insert(1);
    neighb.insert(4);
    neighb.insert(5);
    
    BOOST_CHECK(*neigh_it == NULL);
    ++neigh_it;
    set_it = neighb.find((*neigh_it)->label());
    BOOST_CHECK(set_it != neighb.end());
    ++neigh_it;
    set_it = neighb.find((*neigh_it)->label());
    BOOST_CHECK(set_it != neighb.end());
    ++neigh_it;
    set_it = neighb.find((*neigh_it)->label());
    BOOST_CHECK(set_it != neighb.end());
    ++neigh_it;
    BOOST_CHECK(neigh_it == my_reg.neighbors_end());

    neigh_it = my_reg.neighbors_find(partition_type::RegionPointer(&my_partition[3]));
    BOOST_CHECK(neigh_it==my_reg.neighbors_end());
    
    neigh_it = my_reg.neighbors_find(partition_type::RegionPointer());
    BOOST_CHECK(neigh_it!=my_reg.neighbors_end());
      
    neigh_it = my_reg.neighbors_find(partition_type::RegionPointer(&my_partition[1]));
    BOOST_CHECK(neigh_it!=my_reg.neighbors_end());
    
    neigh_it = my_reg.neighbors_find(partition_type::RegionPointer(&my_partition[4]));
    BOOST_CHECK(neigh_it!=my_reg.neighbors_end());

    neigh_it = my_reg.neighbors_find(partition_type::RegionPointer(&my_partition[5]));
    BOOST_CHECK(neigh_it!=my_reg.neighbors_end());    
    
    partition_type::RegionType& my_reg2 = my_partition[1];
    
    std::set<uint32> neighb2;
    neighb2.insert(2);
    neighb2.insert(3);
    
    neigh_it = my_reg2.neighbors_begin();
    BOOST_CHECK(*neigh_it == NULL);
      
    BOOST_CHECK_EQUAL(neigh_it.link_data()->neighbor_coords().size(), (std::size_t)1);
    BOOST_CHECK_EQUAL((*(neigh_it.link_data()->neighbor_coords().begin())).size(), (std::size_t)4);
    
    ++neigh_it;
    set_it = neighb2.find((*neigh_it)->label());
    BOOST_CHECK(set_it != neighb2.end());
    if((*neigh_it)->label()==2)
    {
        BOOST_CHECK_EQUAL(neigh_it.link_data()->neighbor_coords().size(), (std::size_t)1);
        BOOST_CHECK_EQUAL((*(neigh_it.link_data()->neighbor_coords().begin())).size(), (std::size_t)3);
    }
    else
    {
        BOOST_CHECK_EQUAL(neigh_it.link_data()->neighbor_coords().size(), (std::size_t)1);
        
        // Check that the neighboring coord is (1,4)
        BOOST_CHECK_EQUAL((*(*(neigh_it.link_data()->neighbor_coords().begin())).begin())[0], 1);
        BOOST_CHECK_EQUAL((*(*(neigh_it.link_data()->neighbor_coords().begin())).begin())[1], 4);
    }
    
    ++neigh_it;
    set_it = neighb2.find((*neigh_it)->label());
    BOOST_CHECK(set_it != neighb2.end());
    if((*neigh_it)->label()==2)
    {
            BOOST_CHECK_EQUAL(neigh_it.link_data()->neighbor_coords().size(), (std::size_t)1);
            BOOST_CHECK_EQUAL((*(neigh_it.link_data()->neighbor_coords().begin())).size(), (std::size_t)3);
    }
    else
    {
        BOOST_CHECK_EQUAL(neigh_it.link_data()->neighbor_coords().size(), (std::size_t)1);
        
        // Check that the neighboring coord is (1,4)
        BOOST_CHECK_EQUAL((*(*(neigh_it.link_data()->neighbor_coords().begin())).begin())[0], 1);
        BOOST_CHECK_EQUAL((*(*(neigh_it.link_data()->neighbor_coords().begin())).begin())[1], 4);
    }

    ++neigh_it;
    BOOST_CHECK(neigh_it == my_reg2.neighbors_end());
}

BOOST_AUTO_TEST_CASE( partition_contour_neighbor_iterators_with_fusion )
{  
    ImagePartition<> temp_part(3,3);
    temp_part[0][0] = 1;     temp_part[1][0] = 1;     temp_part[2][0] = 2;
    temp_part[0][1] = 1;     temp_part[1][1] = 2;     temp_part[2][1] = 2;
    temp_part[0][2] = 3;     temp_part[1][2] = 4;     temp_part[2][2] = 5;

    typedef Partition<RegionContour<Coord2D<int64> > > partition_type;
    partition_type my_partition(temp_part);
    
    merge_regions(1,2,9,my_partition);
    
    partition_type::RegionType& my_reg = my_partition[9];
    partition_type::RegionType::neighbor_iterator neigh_it = my_reg.neighbors_begin();
     
    std::set<uint32> neighb;
    std::set<uint32>::iterator set_it;
    neighb.insert(3);
    neighb.insert(4);
    neighb.insert(5);
    
    BOOST_CHECK(*neigh_it == NULL);
//    BOOST_CHECK_EQUAL(neigh_it.link_data()->neighbor_coords().size(), (std::size_t)1);
//    BOOST_CHECK_EQUAL((*(neigh_it.link_data()->neighbor_coords().begin())).size(), (std::size_t)7);
    ++neigh_it;
    set_it = neighb.find((*neigh_it)->label());
    BOOST_CHECK(set_it != neighb.end());
    BOOST_CHECK_EQUAL(neigh_it.link_data()->neighbor_coords().size(), (std::size_t)1);
    BOOST_CHECK_EQUAL((*(neigh_it.link_data()->neighbor_coords().begin())).size(), (std::size_t)1);
    ++neigh_it;
    set_it = neighb.find((*neigh_it)->label());
    BOOST_CHECK(set_it != neighb.end());
    BOOST_CHECK_EQUAL(neigh_it.link_data()->neighbor_coords().size(), (std::size_t)1);
    BOOST_CHECK_EQUAL((*(neigh_it.link_data()->neighbor_coords().begin())).size(), (std::size_t)1);
    ++neigh_it;
    set_it = neighb.find((*neigh_it)->label());
    BOOST_CHECK(set_it != neighb.end());
    BOOST_CHECK_EQUAL(neigh_it.link_data()->neighbor_coords().size(), (std::size_t)1);
    BOOST_CHECK_EQUAL((*(neigh_it.link_data()->neighbor_coords().begin())).size(), (std::size_t)1);
    ++neigh_it;
    BOOST_CHECK(neigh_it == my_reg.neighbors_end());
    
    partition_type::RegionType& my_reg2 = my_partition[4];
    neigh_it = my_reg2.neighbors_begin();
    
    neighb.clear();
    neighb.insert(3);
    neighb.insert(9);
    neighb.insert(5);
     
    BOOST_CHECK(*neigh_it == NULL);
    BOOST_CHECK_EQUAL(neigh_it.link_data()->neighbor_coords().size(), (std::size_t)1);
    ++neigh_it;
    set_it = neighb.find((*neigh_it)->label());
    BOOST_CHECK(set_it != neighb.end());
    BOOST_CHECK_EQUAL(neigh_it.link_data()->neighbor_coords().size(), (std::size_t)1);
    ++neigh_it;
    set_it = neighb.find((*neigh_it)->label());
    BOOST_CHECK(set_it != neighb.end());
    BOOST_CHECK_EQUAL(neigh_it.link_data()->neighbor_coords().size(), (std::size_t)1);
    ++neigh_it;
    set_it = neighb.find((*neigh_it)->label());
    BOOST_CHECK(set_it != neighb.end());
    BOOST_CHECK_EQUAL(neigh_it.link_data()->neighbor_coords().size(), (std::size_t)1);
    ++neigh_it;
    BOOST_CHECK(neigh_it == my_reg2.neighbors_end());
    

    merge_regions(4,3,10,my_partition);
    
    partition_type::RegionType& my_reg3 = my_partition[10];
    neigh_it = my_reg3.neighbors_begin();
    
    neighb.clear();
    neighb.insert(9);
    neighb.insert(5);
     
    BOOST_CHECK(*neigh_it == NULL);
    BOOST_CHECK_EQUAL(neigh_it.link_data()->neighbor_coords().size(), (std::size_t)1);
    BOOST_CHECK_EQUAL((*(neigh_it.link_data()->neighbor_coords().begin())).size(), (std::size_t)3);
        
    ++neigh_it;
    set_it = neighb.find((*neigh_it)->label());
    BOOST_CHECK(set_it != neighb.end());
    if((*neigh_it)->label()==9)
    	BOOST_CHECK_EQUAL((*neigh_it.link_data()->neighbor_coords().begin()).size(), (std::size_t)2);
    else
    	BOOST_CHECK_EQUAL((*neigh_it.link_data()->neighbor_coords().begin()).size(), (std::size_t)1);
    ++neigh_it;
    set_it = neighb.find((*neigh_it)->label());
    BOOST_CHECK(set_it != neighb.end());
    if((*neigh_it)->label()==9)
        BOOST_CHECK_EQUAL((*neigh_it.link_data()->neighbor_coords().begin()).size(), (std::size_t)2);
    else
        BOOST_CHECK_EQUAL((*neigh_it.link_data()->neighbor_coords().begin()).size(), (std::size_t)1);
    ++neigh_it;
    BOOST_CHECK(neigh_it == my_reg3.neighbors_end());
}

BOOST_AUTO_TEST_CASE( partition_contour_neighbor_iterators_multiple_links )
{  
    ImagePartition<> temp_part(3,3);
    temp_part[0][0] = 1;     temp_part[1][0] = 1;     temp_part[2][0] = 3;
    temp_part[0][1] = 1;     temp_part[1][1] = 2;     temp_part[2][1] = 3;
    temp_part[0][2] = 3;     temp_part[1][2] = 3;     temp_part[2][2] = 3;

    typedef Partition<RegionContour<Coord2D<int64> > > partition_type;
    partition_type my_partition(temp_part);

    partition_type::RegionType& my_reg = my_partition[3];
    partition_type::RegionType::neighbor_iterator neigh_it = my_reg.neighbors_begin();
    
    std::set<uint32> neighb;
    std::set<uint32>::iterator set_it;
    neighb.insert(1);
    neighb.insert(2);
    
    BOOST_CHECK(*neigh_it == NULL);
    ++neigh_it;
    set_it = neighb.find((*neigh_it)->label());
    BOOST_CHECK(set_it != neighb.end());
    ++neigh_it;
    set_it = neighb.find((*neigh_it)->label());
    BOOST_CHECK(set_it != neighb.end());
    ++neigh_it;
    BOOST_CHECK(neigh_it == my_reg.neighbors_end());
    
    partition_type::RegionType& my_reg2 = my_partition[1];
    
    std::set<uint32> neighb2;
    neighb2.insert(2);
    neighb2.insert(3);
    
    neigh_it = my_reg2.neighbors_begin();
    BOOST_CHECK(*neigh_it == NULL);
      
    BOOST_CHECK_EQUAL(neigh_it.link_data()->neighbor_coords().size(), (std::size_t)1);
    BOOST_CHECK_EQUAL((*(neigh_it.link_data()->neighbor_coords().begin())).size(), (std::size_t)4);
    
    ++neigh_it;
    set_it = neighb2.find((*neigh_it)->label());
    BOOST_CHECK(set_it != neighb2.end());
    ++neigh_it;
    set_it = neighb2.find((*neigh_it)->label());
    BOOST_CHECK(set_it != neighb2.end());

    if((*neigh_it)->label()==2)
    {
        BOOST_CHECK_EQUAL(neigh_it.link_data()->neighbor_coords().size(), (std::size_t)1);
        BOOST_CHECK_EQUAL((*(neigh_it.link_data()->neighbor_coords().begin())).size(), (std::size_t)2);
    }
    else
   {
    	// Check tat we have two disconnected contours between region 1 and 3
        BOOST_CHECK_EQUAL(neigh_it.link_data()->neighbor_coords().size(), (std::size_t)2);
        BOOST_CHECK_EQUAL((*(neigh_it.link_data()->neighbor_coords().begin())).size(), (std::size_t)1);
        BOOST_CHECK_EQUAL((*(++neigh_it.link_data()->neighbor_coords().begin())).size(), (std::size_t)1);
    }
}

BOOST_AUTO_TEST_CASE( partition_contour_iterators )
{  
    ImagePartition<> temp_part(3,3);
    temp_part[0][0] = 1;     temp_part[1][0] = 1;     temp_part[2][0] = 2;
    temp_part[0][1] = 1;     temp_part[1][1] = 2;     temp_part[2][1] = 2;
    temp_part[0][2] = 3;     temp_part[1][2] = 4;     temp_part[2][2] = 5;
    
    typedef Partition<RegionContour<Coord2D<int64> > > partition_type;
    partition_type my_partition(temp_part);
    merge_regions(1,2,6,my_partition);
    merge_regions(4,5,7,my_partition);
    merge_regions(3,6,8,my_partition);
 
    // Before pruning
    // All regions
    partition_type::global_iterator it = my_partition.begin();
    BOOST_CHECK_EQUAL((*it).label(), (uint32)1); ++it;
    BOOST_CHECK_EQUAL((*it).label(), (uint32)2); ++it;
    BOOST_CHECK_EQUAL((*it).label(), (uint32)3); ++it;
    BOOST_CHECK_EQUAL((*it).label(), (uint32)4); ++it;
    BOOST_CHECK_EQUAL((*it).label(), (uint32)5); ++it;
    BOOST_CHECK_EQUAL((*it).label(), (uint32)6); ++it;
    BOOST_CHECK_EQUAL((*it).label(), (uint32)7); ++it;
    BOOST_CHECK_EQUAL((*it).label(), (uint32)8); 
    BOOST_CHECK((*it).parent()==NULL);
    ++it;
    BOOST_CHECK(it==my_partition.end());

    
    // Leaf regions
    partition_type::leaves_iterator leaf_it = my_partition.begin();
    BOOST_CHECK_EQUAL((*leaf_it).label(), (uint32)1); ++leaf_it;
    BOOST_CHECK_EQUAL((*leaf_it).label(), (uint32)2); ++leaf_it;
    BOOST_CHECK_EQUAL((*leaf_it).label(), (uint32)3); ++leaf_it;
    BOOST_CHECK_EQUAL((*leaf_it).label(), (uint32)4); ++leaf_it;
    BOOST_CHECK_EQUAL((*leaf_it).label(), (uint32)5); ++leaf_it;
    BOOST_CHECK(leaf_it==my_partition.end());
    
    // Non-leaf regions
    partition_type::non_leaves_iterator non_leaf_it = my_partition.begin();
    BOOST_CHECK_EQUAL((*non_leaf_it).label(), (uint32)6); ++non_leaf_it;
    BOOST_CHECK_EQUAL((*non_leaf_it).label(), (uint32)7); ++non_leaf_it;
    BOOST_CHECK_EQUAL((*non_leaf_it).label(), (uint32)8); ++non_leaf_it;
    BOOST_CHECK(non_leaf_it==my_partition.end());
  
    // Root regions
    partition_type::roots_iterator root_it = my_partition.begin();
    BOOST_CHECK_EQUAL((*root_it).label(), (uint32)7); ++root_it;
    BOOST_CHECK_EQUAL((*root_it).label(), (uint32)8); ++root_it;
    BOOST_CHECK(root_it==my_partition.end());

    // Non-root regions
    partition_type::non_roots_iterator non_root_it = my_partition.begin();
    BOOST_CHECK_EQUAL((*non_root_it).label(), (uint32)1); ++non_root_it;
    BOOST_CHECK_EQUAL((*non_root_it).label(), (uint32)2); ++non_root_it;
    BOOST_CHECK_EQUAL((*non_root_it).label(), (uint32)3); ++non_root_it;
    BOOST_CHECK_EQUAL((*non_root_it).label(), (uint32)4); ++non_root_it;
    BOOST_CHECK_EQUAL((*non_root_it).label(), (uint32)5); ++non_root_it;
    BOOST_CHECK_EQUAL((*non_root_it).label(), (uint32)6); ++non_root_it;
    BOOST_CHECK(non_root_it==my_partition.end());    
    
    prune(8,my_partition);
    
    // After pruning
    // All regions
    it = my_partition.begin();
    BOOST_CHECK_EQUAL((*it).label(), (uint32)4); ++it;
    BOOST_CHECK_EQUAL((*it).label(), (uint32)5); ++it;
    BOOST_CHECK_EQUAL((*it).label(), (uint32)7); ++it;
    BOOST_CHECK_EQUAL((*it).label(), (uint32)8); ++it;
    BOOST_CHECK(it==my_partition.end());

    
    // Leaf regions
    leaf_it = my_partition.begin();
    BOOST_CHECK_EQUAL((*leaf_it).label(), (uint32)4); ++leaf_it;
    BOOST_CHECK_EQUAL((*leaf_it).label(), (uint32)5); ++leaf_it;
    BOOST_CHECK_EQUAL((*leaf_it).label(), (uint32)8); ++leaf_it;
    BOOST_CHECK(leaf_it==my_partition.end());
    
  
    // Root regions
    root_it = my_partition.begin();
    BOOST_CHECK_EQUAL((*root_it).label(), (uint32)7); ++root_it;
    BOOST_CHECK_EQUAL((*root_it).label(), (uint32)8); ++root_it;
    BOOST_CHECK(root_it==my_partition.end());
    
    merge_regions(7,8,9,my_partition);
    
    // After adding a merging
    // All regions
    it = my_partition.begin();
    BOOST_CHECK_EQUAL((*it).label(), (uint32)4); ++it;
    BOOST_CHECK_EQUAL((*it).label(), (uint32)5); ++it;
    BOOST_CHECK_EQUAL((*it).label(), (uint32)7); ++it;
    BOOST_CHECK_EQUAL((*it).label(), (uint32)8); ++it;
    BOOST_CHECK_EQUAL((*it).label(), (uint32)9); ++it;
    BOOST_CHECK(it==my_partition.end());

    
    // Leaf regions
    leaf_it = my_partition.begin();
    BOOST_CHECK_EQUAL((*leaf_it).label(), (uint32)4); ++leaf_it;
    BOOST_CHECK_EQUAL((*leaf_it).label(), (uint32)5); ++leaf_it;
    BOOST_CHECK_EQUAL((*leaf_it).label(), (uint32)8); ++leaf_it;
    BOOST_CHECK(leaf_it==my_partition.end());
    
  
    // Root regions
    root_it = my_partition.begin();
    BOOST_CHECK_EQUAL((*root_it).label(), (uint32)9); ++root_it;
    BOOST_CHECK(root_it==my_partition.end());
    
    
}



BOOST_AUTO_TEST_CASE( partition_contour_const_iterators )
{  
    ImagePartition<> temp_part(3,3);
    temp_part[0][0] = 1;     temp_part[1][0] = 1;     temp_part[2][0] = 2;
    temp_part[0][1] = 1;     temp_part[1][1] = 2;     temp_part[2][1] = 2;
    temp_part[0][2] = 3;     temp_part[1][2] = 4;     temp_part[2][2] = 5;

    typedef Partition<RegionContour<Coord2D<int64> > > partition_type;
    partition_type my_partition(temp_part);
    merge_regions(1,2,6,my_partition);
    merge_regions(4,5,7,my_partition);
    merge_regions(3,6,8,my_partition);
    
    const partition_type& my_const_partition = my_partition;
 
    // Before pruning
    // All regions
    partition_type::const_global_iterator it = my_const_partition.begin();
    BOOST_CHECK_EQUAL((*it).label(), (uint32)1); ++it;
    BOOST_CHECK_EQUAL((*it).label(), (uint32)2); ++it;
    BOOST_CHECK_EQUAL((*it).label(), (uint32)3); ++it;
    BOOST_CHECK_EQUAL((*it).label(), (uint32)4); ++it;
    BOOST_CHECK_EQUAL((*it).label(), (uint32)5); ++it;
    BOOST_CHECK_EQUAL((*it).label(), (uint32)6); ++it;
    BOOST_CHECK_EQUAL((*it).label(), (uint32)7); ++it;
    BOOST_CHECK_EQUAL((*it).label(), (uint32)8);
    // If we uncomment this line, it should not compile because the iterator is const
    // (*it).father(NULL);
    ++it;
    BOOST_CHECK(it==my_const_partition.end());

    
    // Leaf regions
    partition_type::const_leaves_iterator leaf_it = my_const_partition.begin();
    BOOST_CHECK_EQUAL((*leaf_it).label(), (uint32)1); ++leaf_it;
    BOOST_CHECK_EQUAL((*leaf_it).label(), (uint32)2); ++leaf_it;
    BOOST_CHECK_EQUAL((*leaf_it).label(), (uint32)3); ++leaf_it;
    BOOST_CHECK_EQUAL((*leaf_it).label(), (uint32)4); ++leaf_it;
    BOOST_CHECK_EQUAL((*leaf_it).label(), (uint32)5); ++leaf_it;
    BOOST_CHECK(leaf_it==my_const_partition.end());
    
    // Non-leaf regions
    partition_type::const_non_leaves_iterator non_leaf_it = my_const_partition.begin();
    BOOST_CHECK_EQUAL((*non_leaf_it).label(), (uint32)6); ++non_leaf_it;
    BOOST_CHECK_EQUAL((*non_leaf_it).label(), (uint32)7); ++non_leaf_it;
    BOOST_CHECK_EQUAL((*non_leaf_it).label(), (uint32)8); ++non_leaf_it;
    BOOST_CHECK(non_leaf_it==my_const_partition.end());
  
    // Root regions
    partition_type::const_roots_iterator root_it = my_const_partition.begin();
    BOOST_CHECK_EQUAL((*root_it).label(), (uint32)7); ++root_it;
    BOOST_CHECK_EQUAL((*root_it).label(), (uint32)8); ++root_it;
    BOOST_CHECK(root_it==my_const_partition.end());

    // Non-root regions
    partition_type::const_non_roots_iterator non_root_it = my_const_partition.begin();
    BOOST_CHECK_EQUAL((*non_root_it).label(), (uint32)1); ++non_root_it;
    BOOST_CHECK_EQUAL((*non_root_it).label(), (uint32)2); ++non_root_it;
    BOOST_CHECK_EQUAL((*non_root_it).label(), (uint32)3); ++non_root_it;
    BOOST_CHECK_EQUAL((*non_root_it).label(), (uint32)4); ++non_root_it;
    BOOST_CHECK_EQUAL((*non_root_it).label(), (uint32)5); ++non_root_it;
    BOOST_CHECK_EQUAL((*non_root_it).label(), (uint32)6); ++non_root_it;
    BOOST_CHECK(non_root_it==my_const_partition.end());    
    
    prune(8,my_partition);
    
    // After pruning
    // All regions
    it = my_const_partition.begin();
    BOOST_CHECK_EQUAL((*it).label(), (uint32)4); ++it;
    BOOST_CHECK_EQUAL((*it).label(), (uint32)5); ++it;
    BOOST_CHECK_EQUAL((*it).label(), (uint32)7); ++it;
    BOOST_CHECK_EQUAL((*it).label(), (uint32)8); ++it;
    BOOST_CHECK(it==my_const_partition.end());

    
    // Leaf regions
    leaf_it = my_const_partition.begin();
    BOOST_CHECK_EQUAL((*leaf_it).label(), (uint32)4); ++leaf_it;
    BOOST_CHECK_EQUAL((*leaf_it).label(), (uint32)5); ++leaf_it;
    BOOST_CHECK_EQUAL((*leaf_it).label(), (uint32)8); ++leaf_it;
    BOOST_CHECK(leaf_it==my_const_partition.end());
    
  
    // Root regions
    root_it = my_const_partition.begin();
    BOOST_CHECK_EQUAL((*root_it).label(), (uint32)7); ++root_it;
    BOOST_CHECK_EQUAL((*root_it).label(), (uint32)8); ++root_it;
    BOOST_CHECK(root_it==my_const_partition.end());
    
    merge_regions(7,8,9,my_partition);
    
    // After adding a merging
    // All regions
    it = my_const_partition.begin();
    BOOST_CHECK_EQUAL((*it).label(), (uint32)4); ++it;
    BOOST_CHECK_EQUAL((*it).label(), (uint32)5); ++it;
    BOOST_CHECK_EQUAL((*it).label(), (uint32)7); ++it;
    BOOST_CHECK_EQUAL((*it).label(), (uint32)8); ++it;
    BOOST_CHECK_EQUAL((*it).label(), (uint32)9); ++it;
    BOOST_CHECK(it==my_const_partition.end());

    
    // Leaf regions
    leaf_it = my_const_partition.begin();
    BOOST_CHECK_EQUAL((*leaf_it).label(), (uint32)4); ++leaf_it;
    BOOST_CHECK_EQUAL((*leaf_it).label(), (uint32)5); ++leaf_it;
    BOOST_CHECK_EQUAL((*leaf_it).label(), (uint32)8); ++leaf_it;
    BOOST_CHECK(leaf_it==my_const_partition.end());
    
  
    // Root regions
    root_it = my_const_partition.begin();
    BOOST_CHECK_EQUAL((*root_it).label(), (uint32)9); ++root_it;
    BOOST_CHECK(root_it==my_const_partition.end());
}

BOOST_AUTO_TEST_CASE(partition_contour_position_iterator_test)
{
	typedef ImageRGB<uint8> InputType;
	typedef RegionContour<Coord2D<int64> > RegionType;
	typedef Partition<RegionType> partition_type;
	
	vector<set<pair<uint32,uint32> > > regs(20); // vector with all the coordinates
	
	ImagePartition<> my_part(10,10);
	for (uint32 l = 0; l < 10; l++)
		for (uint32 i = 0; i <= l; i++)
			for (uint32 k = 0; k <= l; k++)
				my_part[i][k]++;

	partition_type my_bpt(my_part);

	for (uint32 i = 0; i < 10; i++) {
		for (uint32 k = 0; k < 10; k++) {
			pair<uint32,uint32> c(i,k);
			regs[my_part[i][k]].insert(c); 
			regs[19].insert(c);
			switch(my_part[i][k]) {
			case 1:
			case 2:
				regs[11].insert(c);
				regs[16].insert(c);
				break;
			case 3:
			case 4:
				regs[12].insert(c);
				regs[16].insert(c);
				break;
			case 5:
			case 6:
				regs[13].insert(c);
				regs[17].insert(c);
				regs[18].insert(c);
				break;
			case 7:
			case 8:
				regs[14].insert(c);
				regs[17].insert(c);
				regs[18].insert(c);
				break;
			case 9:
			case 10:
				regs[15].insert(c);
				regs[18].insert(c);
				break;
			}
		}
	}

	merge_regions(1,2,11,my_bpt);
	merge_regions(3,4,12,my_bpt);
	merge_regions(5,6,13,my_bpt);
	merge_regions(7,8,14,my_bpt);
	merge_regions(9,10,15,my_bpt);

	merge_regions(11,12,16,my_bpt);
	merge_regions(13,14,17,my_bpt);
	merge_regions(15,17,18,my_bpt);
	merge_regions(16,18,19,my_bpt);

	for (uint32 r = 1; r < 20; r++) { // check all the regions
		uint32 sz = 0;
		for (RegionType::position_iterator it = my_bpt[r].begin(); it != my_bpt[r].end(); ++it,sz++) {
			bool b = false;
			if (regs[r].find(pair<uint32,uint32>((*it)[0],(*it)[1])) != regs[r].end()) b = true;
			BOOST_CHECK( b == true);
		}
		BOOST_CHECK(sz == regs[r].size());
	}
}


BOOST_AUTO_TEST_CASE( partition_contour_copy_constructor )
{
    ImagePartition<> temp_part(2,2);
    
    temp_part[0][0] = 3;
    temp_part[1][0] = 8;
    temp_part[0][1] = 8;
    temp_part[1][1] = 9;

    Partition<RegionContour<Coord2D<int64> > > my_partition(temp_part);

    merge_regions(8,9,26,my_partition);

    Partition<RegionContour<Coord2D<int64> > > my_partition2(my_partition);

    BOOST_CHECK(my_partition==my_partition2);
    
    BOOST_CHECK(&(my_partition[3])!=&(my_partition2[3]));
    BOOST_CHECK(&(my_partition[8])!=&(my_partition2[8]));
    BOOST_CHECK(&(my_partition[9])!=&(my_partition2[9]));
    BOOST_CHECK(&(my_partition[26])!=&(my_partition2[26]));

    BOOST_CHECK(my_partition2[26].parts()[0] == &(my_partition2[8]));
    BOOST_CHECK(my_partition2[26].parts()[1] == &(my_partition2[9]));
    BOOST_CHECK(my_partition2[8].parent() == &(my_partition2[26]));
    BOOST_CHECK(my_partition2[9].parent() == &(my_partition2[26]));
    
    RegionContour<Coord2D<int64> >::neighbor_iterator neigh_it = my_partition2[3].neighbors_begin();
    BOOST_CHECK((*neigh_it)==0);
    ++neigh_it;
    BOOST_CHECK(*neigh_it==&(my_partition2[26]));
    ++neigh_it;
    BOOST_CHECK(neigh_it==my_partition2[3].neighbors_end());
    
    neigh_it = my_partition2[26].neighbors_begin();
    BOOST_CHECK((*neigh_it)==0);
    ++neigh_it;
    if(neigh_it.link_data()->neighbor1()==&(my_partition2[3]))
    {
        BOOST_CHECK(neigh_it.link_data()->neighbor2()==&(my_partition2[26]));
    }
    else if(neigh_it.link_data()->neighbor1()==&(my_partition2[26]))
    {
        BOOST_CHECK(neigh_it.link_data()->neighbor2()==&(my_partition2[3]));
    }
    else
    {
        BOOST_CHECK(false);
    }
    BOOST_CHECK(*neigh_it==&(my_partition2[3]));
    ++neigh_it;
    BOOST_CHECK(neigh_it==my_partition2[26].neighbors_end());
}



BOOST_AUTO_TEST_CASE( partition_contour_prune )
{  
    ImagePartition<> temp_part(3,3);
    temp_part[0][0] = 1;     temp_part[1][0] = 1;     temp_part[2][0] = 2;
    temp_part[0][1] = 1;     temp_part[1][1] = 2;     temp_part[2][1] = 2;
    temp_part[0][2] = 3;     temp_part[1][2] = 4;     temp_part[2][2] = 5;

    Partition<RegionContour<Coord2D<int64> > > my_partition(temp_part);
    merge_regions(1,2,6,my_partition);
    merge_regions(4,5,7,my_partition);
    merge_regions(3,6,8,my_partition);
    merge_regions(7,8,9,my_partition);
    
    BOOST_CHECK_EQUAL( my_partition.num_regions(), (std::size_t)9 );
    
    prune(8,my_partition);
    
    BOOST_CHECK_EQUAL( my_partition.num_regions(), (std::size_t)5 );

    BOOST_CHECK_EQUAL( my_partition[8].parts().size(), (std::size_t)0 );

    BOOST_CHECK_EQUAL( my_partition[9].size(), (std::size_t)9 );
    BOOST_CHECK_EQUAL( my_partition[8].size(), (std::size_t)7 );
    BOOST_CHECK_EQUAL( my_partition[7].size(), (std::size_t)0 ); // It does not contain the coordinates
    BOOST_CHECK_EQUAL( my_partition[4].size(), (std::size_t)1 );
    BOOST_CHECK_EQUAL( my_partition[5].size(), (std::size_t)1 );
    
    BOOST_CHECK_EQUAL( my_partition[9].label(), (uint32)9 );
    BOOST_CHECK_EQUAL( my_partition[8].label(), (uint32)8 );
    BOOST_CHECK_EQUAL( my_partition[7].label(), (uint32)7 );
    BOOST_CHECK_EQUAL( my_partition[4].label(), (uint32)4 );
    BOOST_CHECK_EQUAL( my_partition[5].label(), (uint32)5 );

    // Not included, they cause leaks
    //    BOOST_CHECK_THROW( my_partition[1], ImagePlusError);
    //    BOOST_CHECK_THROW( my_partition[2], ImagePlusError);
    //    BOOST_CHECK_THROW( my_partition[3], ImagePlusError);
    //    BOOST_CHECK_THROW( my_partition[6], ImagePlusError);
    
    BOOST_CHECK_EQUAL( my_partition.leaves_partition()(0)[0][0], (uint32)8);
    BOOST_CHECK_EQUAL( my_partition.leaves_partition()(0)[0][1], (uint32)8); 
    BOOST_CHECK_EQUAL( my_partition.leaves_partition()(0)[0][2], (uint32)8); 
    BOOST_CHECK_EQUAL( my_partition.leaves_partition()(0)[1][0], (uint32)8); 
    BOOST_CHECK_EQUAL( my_partition.leaves_partition()(0)[1][1], (uint32)8); 
    BOOST_CHECK_EQUAL( my_partition.leaves_partition()(0)[1][2], (uint32)4); 
    BOOST_CHECK_EQUAL( my_partition.leaves_partition()(0)[2][0], (uint32)8); 
    BOOST_CHECK_EQUAL( my_partition.leaves_partition()(0)[2][1], (uint32)8); 
    BOOST_CHECK_EQUAL( my_partition.leaves_partition()(0)[2][2], (uint32)5); 
}


BOOST_AUTO_TEST_SUITE_END ();


