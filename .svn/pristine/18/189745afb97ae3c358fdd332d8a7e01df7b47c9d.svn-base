/*
 * full_search.hpp
 *
 *  Created on: Apr 13, 2012
 *      Author: gpalou
 */

#ifndef FULL_SEARCH_HPP_
#define FULL_SEARCH_HPP_

#include <imageplus/math/optimization/minimizer.hpp>

namespace imageplus {
	namespace math 		{
		namespace optimization {

		//! Recursive Full search algorithm
		//! \author Guillem Palou <guillem.palou@upc.edu>
		//! \date 10-04-2012
	class FullSearchMinimizer : public Minimizer {

		//! Variable Type
		typedef numeric::ScalarFunction::VariableType VariableType;

		//! Gradient Type
		typedef numeric::ScalarFunction::GradientType GradientType;

	public:

		//! Default constructor
		//!
		//! \param[in] f: convex and differentiable function to be minimized
		FullSearchMinimizer(numeric::ScalarFunction& f) : Minimizer(f) {
			_tolerance = 1e-6;
			_max_levels = 1000;
			_divisions = 2;
		}

		//! Sets the maximum number of iterations
		//!
		//! \param[in] max_iterator : maximum number of iterations
		void max_levels(uint32 max_levels) {_max_levels = max_levels;}

		//! Sets the tolerance of the algorithm
		//! The algorithm will stop if the decrease of the minimum solution is below tolerance
		//!
		//! \param[in] tolerance : the tolerance (should be > 0)
		void tolerance(float64 tolerance) {_tolerance = tolerance;}

		//! Sets the divisions at each dimension
		//! The algorithm works minimum with 3 divisions
		//! \param[in] divisions : number of divisions for each dimension. Be careful, the complexity of the algorithm is ($divisions^{dimensions}$)
		void divisions(float64 divisions) {_divisions = std::min(3.0,divisions);}

		//! Minimizes the function using a recursive full search algorithm arround a point
		//!
		//! \param[in] initial_point : point to begin with
		virtual void minimize(const VariableType& initial_point) {
			Vector box(_f.dimensions());

			box.fill(1);

			Vector lower_point = initial_point - box;
			Vector upper_point = initial_point + box;

			minimize(lower_point, upper_point);
		}

		//! Minimizes the function using a recursive full search algorithm
		//!
		//! \param[in] initial_point : point to begin with
		void minimize(const VariableType& lower_point, const VariableType& upper_point) {
			uint64 D = _f.dimensions();

			_lower_point = lower_point;
			_upper_point = upper_point;

			_current_point = lower_point;
			_current_location.resize(D);

			float64 ant_value = _minimum_value;

			uint64 current_level = 0;

			float64 global_minimum_value = 1e200;
			Vector global_minimum;

			while (current_level < _max_levels) {
				_division_size = (_upper_point - _lower_point) * (1.0/_divisions);

				_minimum_value = 1e200;

				full_search(0);

				if (global_minimum_value > _minimum_value) {
					global_minimum_value = _minimum_value;
					global_minimum = _minimum_point;
				}
				// Check convergence
				if (std::abs((_minimum_value - ant_value)) < _tolerance) break;

				ant_value = _minimum_value;

				// Get the new lower_point
				Vector support = _lower_point;
				for (uint64 i = 0; i < D; i++) {
					float64 new_loc_d = std::max(0.0, _minimum_location[i]-1.0);
					_lower_point(i) = support(i) + new_loc_d * _division_size(i);
				}

				//Get the new upper_point
				for (uint64 i = 0; i < D; i++) {
					float64 new_loc_d = std::min(_divisions, _minimum_location[i]+1.0);
					_upper_point(i) = support(i) + new_loc_d * _division_size(i);
				}

				current_level++;
			}
			_minimum_point = global_minimum;
			_minimum_value = global_minimum_value;
		}

	private:

		void full_search(uint64 d) {
			uint64 D = _f.dimensions();

			if (d == D) {

				float64 v = _f.value(_current_point);

				if (v < _minimum_value) {
					_minimum_value = v;
					_minimum_point = _current_point;
					_minimum_location = _current_location;
				}

			} else {

				for (float64 i = 0; i <= _divisions; i++) {
					_current_point(d) = _lower_point(d) + i * _division_size(d);
					_current_location[d] = i;
					full_search(d+1);
				}

			}
		}

	private:

		//! Current point
		VariableType _current_point;

		//! Current location
		std::vector<float64> _current_location;

		//!location of the minimum, in terms of divisions
		std::vector<float64> _minimum_location;

		//! size of the division at each dimension
		Vector _division_size;

		//! lower point where the search begins
		VariableType _lower_point;

		//! upper point where the search ends
		VariableType _upper_point;

		//! tolerance
		float64 _tolerance;

		//! step size
		float64 _divisions;

		//! maximum number of iterations
		uint32 _max_levels;

	};


		}
	}
}

#endif /* FULL_SEARCH_HPP_ */
