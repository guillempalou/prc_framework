// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------

//!
//!  \file normalization.cpp
//!
//!

#include <imageplus/math/numeric/normalization.hpp>
#include <imageplus/math/statistics/multiarray_statistics.hpp>

using namespace imageplus;
using namespace imageplus::math::numeric;

template<typename T1, typename T2>
MultiArray<T1,2> imageplus::math::numeric::mean_var_normalization(const MultiArray<T2,2>& in, NormalizationType dir)  throw (ImagePlusNotImplemented)
{
    MultiArray<T1,2> out(in.dims(0), in.dims(1));
    MultiArray<T1,1> d;

    switch (dir)
    {
        case COLUMNWISE_NORMALIZATION:
        {
            d = MultiArray<T1,1>(in.dims(1));

            for ( size_type ii= 0; ii < in.dims(0); ii++)
            {
                for (size_type jj= 0; jj < in.dims(1); jj++) 
                {
                    d[jj] = in[ii][jj];
                }
        
                float64 mean_vect     = math::statistics::mean(d);
                float64 sqr_var_vect  = std::sqrt( math::statistics::variance(d));

                for (size_type jj= 0; jj < d.dims(0); jj++)
                {
                    d[jj] = (d[jj] - mean_vect) / sqr_var_vect;
                    out[ii][jj] = d[jj];                        
                } 
            } 
        }
        break;

        case ROWWISE_NORMALIZATION:
        {
            d = MultiArray<T1,1>(in.dims(0));

            for ( size_type jj= 0; jj < in.dims(1); jj++)
            {
                for (size_type ii= 0; ii < in.dims(0); ii++) 
                {
                    d[ii] = in[ii][jj];
                }
        
                float64 mean_vect     = math::statistics::mean(d);
                float64 sqr_var_vect  = std::sqrt(math::statistics::variance(d));
        
                for (size_type ii= 0; ii < d.dims(0); ii++)
                {
                    d[ii] = (d[ii] - mean_vect) / sqr_var_vect;
                    out[ii][jj] = d[ii];                        
                } 
            }
        }
        break;

        default:
            throw ImagePlusNotImplemented("mean_var_normalization : Normalization method not implemented");
            break;
    }

    return out;
    
} 

template<typename T1, typename T2>
MultiArray<T1,2> imageplus::math::numeric::mean_normalization (const MultiArray<T2,2>& in, NormalizationType dir) throw (ImagePlusNotImplemented)
{
    MultiArray<T1,2> out(in.dims(0), in.dims(1));
    MultiArray<T1,1> d;
    
    switch (dir)
    {
        case COLUMNWISE_NORMALIZATION:
        {
            d = MultiArray<T1,1>(in.dims(1));

            for (size_type ii= 0; ii < in.dims(0); ii++) 
            {
                for ( size_type jj= 0; jj < in.dims(1); jj++)
                {
                    d[jj] = in[ii][jj];
                }

                float64 mean_vect = math::statistics::mean(d);
                
                for (size_type jj= 0; jj < d.dims(0); jj++)
                {
                    out[ii][jj] = d[jj] - mean_vect;                        
                } 
            }
        }
        break;

        case ROWWISE_NORMALIZATION:
        {
            d = MultiArray<T1,1>(in.dims(0));

            for ( size_type jj= 0; jj < in.dims(1); jj++)
            {
                for (size_type ii= 0; ii < in.dims(0); ii++) 
                {
                    d[ii] = in[ii][jj];
                }

                float64 mean_vect = math::statistics::mean(d);
        
                for (size_type ii= 0; ii < d.dims(0); ii++)
                {
                    out[ii][jj] = d[ii] - mean_vect;                        
                } 
            }
        }
        break;
        
        default:
            throw ImagePlusNotImplemented("mean_normalization : Normalization method not implemented");
            break;            
    }
    
    return out; 
} 



template<typename T1, typename T2>
MultiArray<T1,2> imageplus::math::numeric::mean_norm_normalization(const MultiArray<T2,2>& xmat, NormalizationType dir) throw (ImagePlusNotImplemented)
{
    MultiArray<T1,2> fxmat(xmat.dims(0), xmat.dims(1));
    
    switch (dir)
    {
        case COLUMNWISE_NORMALIZATION:
        {
            size_type size_y = xmat.dims(1);

            for ( size_type ii = 0; ii < xmat.dims(0); ii++)
            {
                float64 sx  = 0.0;
                float64 sx2 = 0.0;

                for (size_type jj = 0; jj < size_y; jj++) 
                {
                    sx  += static_cast<float64> (xmat[ii][jj]);
                    sx2 += static_cast<float64> (xmat[ii][jj]) * xmat[ii][jj];
                }

                float64 mean = sx / size_y;

                float64 sk1  = std::sqrt( sx2 - (sx * sx / size_y) );
    
                for(size_type jj=0; jj < size_y; jj++)
                {
                    fxmat[ii][jj] = (xmat[ii][jj]-mean) / sk1;
                }
            }
        }
        break;

        case ROWWISE_NORMALIZATION:
        {
            size_type size_x = xmat.dims(0);

            for ( size_type jj = 0; jj < xmat.dims(1); jj++)
            {
                float64 sx  = 0.0;
                float64 sx2 = 0.0;

                for (size_type ii = 0; ii < size_x; ii++) 
                {
                    sx  += static_cast<float64> (xmat[ii][jj]);
                    sx2 += static_cast<float64> (xmat[ii][jj]) * xmat[ii][jj];
                }

                float64 mean = sx / size_x;

                float64 sk1  = std::sqrt( sx2 - (sx * sx / size_x) );
    
                for(size_type ii=0; ii < size_x; ii++)
                {
                    fxmat[ii][jj] = (xmat[ii][jj]-mean) / sk1;
                }
            }
        }
        break;

        default:
            throw ImagePlusNotImplemented("mean_norm_normalization : Normalization method not implemented");
            break;            
    }

    return (fxmat);
}

template<typename T1, typename T2>
MultiArray<T1,2> imageplus::math::numeric::norm_normalization(const MultiArray<T2,2>& xmat, NormalizationType dir) throw (ImagePlusNotImplemented)
{
    MultiArray<T1,2> fxmat(xmat.dims(0), xmat.dims(1));
    
    switch (dir)
    {
        case COLUMNWISE_NORMALIZATION:
        {
            size_type size_y = xmat.dims(1);

            for ( size_type ii = 0; ii < xmat.dims(0); ii++)
            {
                float64 sx  = 0.0;
                float64 sx2 = 0.0;

                for (size_type jj = 0; jj < size_y; jj++) 
                {
                    sx  += static_cast<float64> (xmat[ii][jj]);
                    sx2 += static_cast<float64> (xmat[ii][jj]) * xmat[ii][jj];
                }

                float64 sk1  = std::sqrt( sx2 - (sx * sx / size_y) );
    
                for(size_type jj=0; jj < size_y; jj++)
                {
                    fxmat[ii][jj] = (xmat[ii][jj]) / sk1;
                }
            }
        }
        break;

        case ROWWISE_NORMALIZATION:
        {
            size_type size_x = xmat.dims(0);

            for ( size_type jj = 0; jj < xmat.dims(1); jj++)
            {
                float64 sx  = 0.0;
                float64 sx2 = 0.0;

                for (size_type ii = 0; ii < size_x; ii++) 
                {
                    sx  += static_cast<float64> (xmat[ii][jj]);
                    sx2 += static_cast<float64> (xmat[ii][jj]) * xmat[ii][jj];
                }

                float64 sk1  = std::sqrt( sx2 - (sx * sx / size_x) );
    
                for(size_type ii=0; ii < size_x; ii++)
                {
                    fxmat[ii][jj] = (xmat[ii][jj]) / sk1;
                }
            }
        }
        break;

        default:
            throw ImagePlusNotImplemented("mean_norm_normalization : Normalization method not implemented");
            break;            
    }

    return (fxmat);
}


template<typename T1, typename T2>
MultiArray<T1,1> imageplus::math::numeric::mean_norm_normalization(const MultiArray<T2,1>& xmat)
{
    float64 sx,sx2,mean,k1,sk1;
    uint64 size = xmat.dims(0);
    MultiArray<T1,1> fxmat(xmat.dims(0));

    sx = 0.;
    sx2= 0.;
    
    for(size_type j=0; j<size; j++) 
    {
        sx  += static_cast<float64> (xmat[j]);
        sx2 += static_cast<float64> (xmat[j] * xmat[j]);
    }
    mean = sx / size;

    k1 = std::abs(sx2 - (sx * sx / size));
    sk1= std::sqrt(k1);

    for(size_type j=0; j<size; j++)
    {
        fxmat[j] = static_cast<float64>((xmat[j]-mean) / sk1);
    }
    return (fxmat);
}



template MultiArray<float64,2> imageplus::math::numeric::mean_var_normalization<float64>(const MultiArray<int64,2>& in, NormalizationType dir);
template MultiArray<float64,2> imageplus::math::numeric::mean_var_normalization<float64>(const MultiArray<float64,2>& in, NormalizationType dir);
template MultiArray<float64,2> imageplus::math::numeric::mean_var_normalization<float64>(const MultiArray<uint8,2>& in, NormalizationType dir);

template MultiArray<float64,2> imageplus::math::numeric::mean_normalization<float64>(const MultiArray<int64,2>& in, NormalizationType dir);
template MultiArray<float64,2> imageplus::math::numeric::mean_normalization<float64>(const MultiArray<float64,2>& in, NormalizationType dir);
template MultiArray<float64,2> imageplus::math::numeric::mean_normalization<float64>(const MultiArray<uint8,2>& in, NormalizationType dir);

template MultiArray<float64,2> imageplus::math::numeric::mean_norm_normalization<float64>(const MultiArray<int64,2>& xmat, NormalizationType dir);
template MultiArray<float64,2> imageplus::math::numeric::mean_norm_normalization<float64>(const MultiArray<float64,2>& xmat, NormalizationType dir);
template MultiArray<float64,2> imageplus::math::numeric::mean_norm_normalization<float64>(const MultiArray<uint8,2>& xmat, NormalizationType dir);

template MultiArray<float64,1> imageplus::math::numeric::mean_norm_normalization<float64>(const MultiArray<int64,1>& xmat);
template MultiArray<float64,1> imageplus::math::numeric::mean_norm_normalization<float64>(const MultiArray<float64,1>& xmat);
template MultiArray<float64,1> imageplus::math::numeric::mean_norm_normalization<float64>(const MultiArray<uint8,1>& xmat);

template MultiArray<float64,2> imageplus::math::numeric::norm_normalization<float64>(const MultiArray<int64,2>& xmat, NormalizationType dir);
template MultiArray<float64,2> imageplus::math::numeric::norm_normalization<float64>(const MultiArray<float64,2>& xmat, NormalizationType dir);
template MultiArray<float64,2> imageplus::math::numeric::norm_normalization<float64>(const MultiArray<uint8,2>& xmat, NormalizationType dir);
