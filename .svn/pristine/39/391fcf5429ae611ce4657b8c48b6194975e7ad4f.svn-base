// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------

/*!
 * \test interpolation.test
 */

#include <imageplus/math/numeric/interpolation.hpp>
#include <imageplus/math/statistics/random_generators.hpp>

BOOST_AUTO_TEST_SUITE ( interpolation_suite );

using namespace std;
using namespace imageplus;
using namespace imageplus::math::numeric;
using namespace imageplus::math::statistics;

typedef boost::mpl::list< uint8, uint16, uint32, uint64,
                           int8,  int16,  int32,  int64,
                                                float64 > ImageDataTypes;

BOOST_AUTO_TEST_CASE_TEMPLATE( test_resize, T, ImageDataTypes )
{
    /*
     * Useful typedefs, the real data "Color" (normally integer) and the "interpolated Color" (float)
     */
    typedef typename ImaVol<T      ,1,2>::Color Color;
    typedef typename ImaVol<float64,1,2>::Color ColorInterp;
    
    /*
     * Creating the test data: an ImaVol with of 4x4 with values from 0 to 3 diagonally increasing
     * and decresing.
     */
    ImaVol<T,1,2> iv(4,4);
    ImaVol<T,1,2> out;
    
    Color c0 =  T(0);
    Color c1 =  T(1);
    Color c2 =  T(2);
    Color c3 =  T(3);
    
    iv(Coord2D<>(0,0)) = c0; iv(Coord2D<>(1,0)) = c1; iv(Coord2D<>(2,0)) = c2; iv(Coord2D<>(3,0)) = c3;
    iv(Coord2D<>(0,1)) = c1; iv(Coord2D<>(1,1)) = c2; iv(Coord2D<>(2,1)) = c3; iv(Coord2D<>(3,1)) = c2;
    iv(Coord2D<>(0,2)) = c2; iv(Coord2D<>(1,2)) = c3; iv(Coord2D<>(2,2)) = c2; iv(Coord2D<>(3,2)) = c1;
    iv(Coord2D<>(0,3)) = c3; iv(Coord2D<>(1,3)) = c2; iv(Coord2D<>(2,3)) = c1; iv(Coord2D<>(3,3)) = c0;
    
//    std::cout << "iv = " << std::endl;
//    std::cout <<  iv     << std::endl;
    
    boost::array<std::size_t,2> size;

    /*
     * Resizing to just 1 "pixel"
     */
    size.assign(1);
    out = resize( iv, size );
    
    BOOST_CHECK( out.size(0) == 1 );
    BOOST_CHECK( out.size(1) == 1 );
    
    BOOST_CHECK( out(Coord2D<>(0,0))[0] >= T(1.84) && 
                 out(Coord2D<>(0,0))[0] <= T(1.85) );
    
    /*
     * Resizing to just 1 row
     */
    size[0] = 4;
    size[1] = 1;
    out = resize( iv, size );
    
    BOOST_CHECK( out.size(0) == 4 );
    BOOST_CHECK( out.size(1) == 1 );
    
    BOOST_CHECK( out(Coord2D<>(0,0))    == T(1.5) );
    BOOST_CHECK( out(Coord2D<>(1,0))[0] >= T(2.08) &&
                 out(Coord2D<>(1,0))[0] <= T(2.09) );
    BOOST_CHECK( out(Coord2D<>(2,0))[0] >= T(2.08) &&
                 out(Coord2D<>(2,0))[0] <= T(2.09) );
    BOOST_CHECK( out(Coord2D<>(3,0))    == T(1.5) );

    /*
     * Halving the signal
     */
    size.assign(2);
    out = resize( iv, size );
    
    BOOST_CHECK( out.size(0) == iv.size(0)/2 );
    BOOST_CHECK( out.size(1) == iv.size(1)/2 );
    
    BOOST_CHECK( out(Coord2D<>(0,0))[0] >= T(1.38) &&
                 out(Coord2D<>(0,0))[0] <= T(1.39) );
    BOOST_CHECK( out(Coord2D<>(1,0))[0] >= T(2.26) &&
                 out(Coord2D<>(1,0))[0] <= T(2.27) );
    BOOST_CHECK( out(Coord2D<>(0,1))[0] >= T(2.26) &&
                 out(Coord2D<>(0,1))[0] <= T(2.27) );
    BOOST_CHECK( out(Coord2D<>(1,1))[0] >= T(1.38) &&
                 out(Coord2D<>(1,1))[0] <= T(1.39) );

    /*
     * Resize to the same size
     */
    size.assign(4);
    out = resize( iv, size );

    BOOST_CHECK( out == iv ); // resize does notihng
    
    /*
     * Resizing to 6x6 
     */
    size.assign(6);
    out = resize( iv, size );
    
    BOOST_CHECK( out.size(0) == 6 );
    BOOST_CHECK( out.size(1) == 6 );

    BOOST_CHECK( out(Coord2D<>(0,0))    == T(0.0) );
    BOOST_CHECK( out(Coord2D<>(1,1))    == T(1.0) );
    BOOST_CHECK( out(Coord2D<>(2,2))[0] >= T(2.27) &&
                 out(Coord2D<>(2,2))[0] <= T(2.28) );
    BOOST_CHECK( out(Coord2D<>(3,3))[0] >= T(2.27) &&
                 out(Coord2D<>(3,3))[0] <= T(2.28) );
    BOOST_CHECK( out(Coord2D<>(4,4))[0] >= T(1.00) && // using >= && <= because BOOST_CHECK_CLOSE doesn't work for non float types 
                 out(Coord2D<>(4,4))[0] <= T(1.01) );
    BOOST_CHECK( out(Coord2D<>(5,5))    == T(0.0) );
    
    BOOST_CHECK( out(Coord2D<>(0,5))    == T(3.00) );
    BOOST_CHECK( out(Coord2D<>(1,4))    == T(2.50) );
    BOOST_CHECK( out(Coord2D<>(2,3))[0] >= T(2.72) &&
                 out(Coord2D<>(2,3))[0] <= T(2.73) );
    BOOST_CHECK( out(Coord2D<>(3,2))[0] >= T(2.72) &&
                 out(Coord2D<>(3,2))[0] <= T(2.73) );
    BOOST_CHECK( out(Coord2D<>(4,1))    == T(2.50) );
    BOOST_CHECK( out(Coord2D<>(5,0))    == T(3.00) );

    /*
     * Doubling the size
     */
    size.assign(8);
    out = resize( iv, size );
    
    BOOST_CHECK( out.size(0) == iv.size(0)*2 );
    BOOST_CHECK( out.size(1) == iv.size(0)*2 );

    BOOST_CHECK( out(Coord2D<>(0,0)) == T(0.000) );
    BOOST_CHECK( out(Coord2D<>(1,1)) == T(0.500) );
    BOOST_CHECK( out(Coord2D<>(2,2)) == T(1.500) );
    BOOST_CHECK( out(Coord2D<>(3,3)) == T(2.375) );
    BOOST_CHECK( out(Coord2D<>(4,4)) == T(2.375) );
    BOOST_CHECK( out(Coord2D<>(5,5)) == T(1.500) );
    BOOST_CHECK( out(Coord2D<>(6,6)) == T(0.500) );
    BOOST_CHECK( out(Coord2D<>(7,7)) == T(0.000) );
    
    BOOST_CHECK( out(Coord2D<>(0,7)) == T(3.000) );
    BOOST_CHECK( out(Coord2D<>(1,6)) == T(2.625) );
    BOOST_CHECK( out(Coord2D<>(2,5)) == T(2.625) );
    BOOST_CHECK( out(Coord2D<>(3,4)) == T(2.625) );
    BOOST_CHECK( out(Coord2D<>(4,3)) == T(2.625) );
    BOOST_CHECK( out(Coord2D<>(5,2)) == T(2.625) );
    BOOST_CHECK( out(Coord2D<>(6,1)) == T(2.625) );
    BOOST_CHECK( out(Coord2D<>(7,0)) == T(3.000) );
    
    /*
     * Decimate one dimension and interpolate the other
     */
    size[0] = 2;
    size[1] = 8;
    out = resize( iv, size );
    
    BOOST_CHECK( out.size(0) == 2 );
    BOOST_CHECK( out.size(1) == 8 );
    
    BOOST_CHECK( out(Coord2D<>(0,0))[0] >= T(0.71) &&
                 out(Coord2D<>(0,0))[0] <= T(0.72) );
    BOOST_CHECK( out(Coord2D<>(0,1))[0] >= T(0.96) &&
                 out(Coord2D<>(0,1))[0] <= T(0.97) );
    BOOST_CHECK( out(Coord2D<>(0,2))[0] >= T(1.46) &&
                 out(Coord2D<>(0,2))[0] <= T(1.47) );
    BOOST_CHECK( out(Coord2D<>(0,3))[0] >= T(1.89) &&
                 out(Coord2D<>(0,3))[0] <= T(1.90) );
    BOOST_CHECK( out(Coord2D<>(0,4))[0] >= T(2.25) &&
                 out(Coord2D<>(0,4))[0] <= T(2.26) );
    BOOST_CHECK( out(Coord2D<>(0,5))[0] >= T(2.39) &&
                 out(Coord2D<>(0,5))[0] <= T(2.40) );
    BOOST_CHECK( out(Coord2D<>(0,6))[0] >= T(2.32) &&
                 out(Coord2D<>(0,6))[0] <= T(2.33) );
    BOOST_CHECK( out(Coord2D<>(0,7))[0] >= T(2.28) &&
                 out(Coord2D<>(0,7))[0] <= T(2.29) );

    /*
     * Resizing to more than the double
     */
    size.assign(16);
    out = resize( iv, size );
    
    BOOST_CHECK( out.size(0) == size[0] );
    BOOST_CHECK( out.size(1) == size[1] );
    
    BOOST_CHECK( out(Coord2D<>( 0, 0)) == T(0.00) );
    BOOST_CHECK( out(Coord2D<>( 1, 1)) == T(0.00) );
    BOOST_CHECK( out(Coord2D<>( 2, 2)) == T(0.25) );
    BOOST_CHECK( out(Coord2D<>( 3, 3)) == T(0.75) );
    BOOST_CHECK( out(Coord2D<>( 4, 4)) == T(1.25) );
    BOOST_CHECK( out(Coord2D<>( 5, 5)) == T(1.75) );
//    BOOST_CHECK( out(Coord2D<>( 6, 6)) == T(0.0) );
//    BOOST_CHECK( out(Coord2D<>( 7, 7)) == T(0.0) );
//    BOOST_CHECK( out(Coord2D<>( 8, 8)) == T(0.0) );
//    BOOST_CHECK( out(Coord2D<>( 9, 9)) == T(0.0) );
    BOOST_CHECK( out(Coord2D<>(10,10)) == T(1.75) );
    BOOST_CHECK( out(Coord2D<>(11,11)) == T(1.25) );
    BOOST_CHECK( out(Coord2D<>(12,12)) == T(0.75) );
    BOOST_CHECK( out(Coord2D<>(13,13)) == T(0.25) );
    BOOST_CHECK( out(Coord2D<>(14,14)) == T(0.00) );
    BOOST_CHECK( out(Coord2D<>(15,15)) == T(0.00) );
}

BOOST_AUTO_TEST_CASE_TEMPLATE( test_Interpolator_ma_1d, T, ImageDataTypes )
{
    /*
     * Useful typedefs, the real data "Color" (normally integer) and the "interpolated Color" (float)
     */
    typedef T       Color;
    typedef float64 ColorInterp;
    
    /*
     * Creating the test data: an ImaVol with of 4x4 with values from 0 to 3 diagonally increasing
     * and decresing.
     */
    MultiArray<T,1> ma(uint64(4));
    
    Color c0 =  T(0);
    Color c1 =  T(1);
    Color c2 =  T(2);
    Color c3 =  T(3);
    
    ma(Coord<int64,1>(0)) = c0; ma(Coord<int64,1>(1)) = c1; ma(Coord<int64,1>(2)) = c2; ma(Coord<int64,1>(3)) = c3;
    
//    std::cout << "iv = " << std::endl;
//    std::cout <<  iv     << std::endl;

    /*
     * Creating the LINEAR Interpolator
     */
    Interpolator<1> interpolate(LINEAR);
    
    /*
     * Interpolating the Points
     */
    BOOST_CHECK( interpolate(Point<1>(0.00), ma) == ColorInterp(0.00));
    BOOST_CHECK( interpolate(Point<1>(0.25), ma) == ColorInterp(0.25));
    BOOST_CHECK( interpolate(Point<1>(0.50), ma) == ColorInterp(0.50));
    BOOST_CHECK( interpolate(Point<1>(0.75), ma) == ColorInterp(0.75));
    BOOST_CHECK( interpolate(Point<1>(1.00), ma) == ColorInterp(1.00));
    BOOST_CHECK( interpolate(Point<1>(1.25), ma) == ColorInterp(1.25));
    BOOST_CHECK( interpolate(Point<1>(1.50), ma) == ColorInterp(1.50));
    BOOST_CHECK( interpolate(Point<1>(1.75), ma) == ColorInterp(1.75));
    BOOST_CHECK( interpolate(Point<1>(2.00), ma) == ColorInterp(2.00));
    BOOST_CHECK( interpolate(Point<1>(2.25), ma) == ColorInterp(2.25));
    BOOST_CHECK( interpolate(Point<1>(2.50), ma) == ColorInterp(2.50));
    BOOST_CHECK( interpolate(Point<1>(2.75), ma) == ColorInterp(2.75));
    BOOST_CHECK( interpolate(Point<1>(3.00), ma) == ColorInterp(3.00));
    
    /*
     * Interpolating out-of-range Points (Extrapolating)
     */
    BOOST_CHECK( interpolate(Point<1>(-5.00), ma) == ColorInterp(0.00));
    BOOST_CHECK( interpolate(Point<1>( 5.00), ma) == ColorInterp(3.00));
    
    /*
     * Creating the MEAN Interpolator
     */
    interpolate.type(MEAN);
    
    /*
     * Interpolating the Points
     */
    BOOST_CHECK( interpolate(Point<1>(0.00), ma) == ColorInterp(0.50));
    BOOST_CHECK( interpolate(Point<1>(0.25), ma) == ColorInterp(0.50));
    BOOST_CHECK( interpolate(Point<1>(0.50), ma) == ColorInterp(0.50));
    BOOST_CHECK( interpolate(Point<1>(0.75), ma) == ColorInterp(0.50));
    BOOST_CHECK( interpolate(Point<1>(1.00), ma) == ColorInterp(1.00));
    BOOST_CHECK( interpolate(Point<1>(1.25), ma) == ColorInterp(1.50));
    BOOST_CHECK( interpolate(Point<1>(1.50), ma) == ColorInterp(1.50));
    BOOST_CHECK( interpolate(Point<1>(1.75), ma) == ColorInterp(1.50));
    BOOST_CHECK( interpolate(Point<1>(2.00), ma) == ColorInterp(2.00));
    BOOST_CHECK( interpolate(Point<1>(2.25), ma) == ColorInterp(2.50));
    BOOST_CHECK( interpolate(Point<1>(2.50), ma) == ColorInterp(2.50));
    BOOST_CHECK( interpolate(Point<1>(2.75), ma) == ColorInterp(2.50));
    BOOST_CHECK( interpolate(Point<1>(3.00), ma) == ColorInterp(2.50));
    
    /*
     * Interpolating out-of-range Points (Extrapolating)
     */
    BOOST_CHECK( interpolate(Point<1>(-5.00), ma) == ColorInterp(0.50));
    BOOST_CHECK( interpolate(Point<1>( 5.00), ma) == ColorInterp(2.50));
    
    /*
     * Creating the MEAN Interpolator
     */
    interpolate.type(NEAREST_NEIGHBOR);
    
    /*
     * Interpolating the Points
     */
    BOOST_CHECK( interpolate(Point<1>(0.00), ma) == ColorInterp(0.00));
    BOOST_CHECK( interpolate(Point<1>(0.25), ma) == ColorInterp(0.00));
    BOOST_CHECK( interpolate(Point<1>(0.50), ma) == ColorInterp(1.00));
    BOOST_CHECK( interpolate(Point<1>(0.75), ma) == ColorInterp(1.00));
    BOOST_CHECK( interpolate(Point<1>(1.00), ma) == ColorInterp(1.00));
    BOOST_CHECK( interpolate(Point<1>(1.25), ma) == ColorInterp(1.00));
    BOOST_CHECK( interpolate(Point<1>(1.50), ma) == ColorInterp(2.00));
    BOOST_CHECK( interpolate(Point<1>(1.75), ma) == ColorInterp(2.00));
    BOOST_CHECK( interpolate(Point<1>(2.00), ma) == ColorInterp(2.00));
    BOOST_CHECK( interpolate(Point<1>(2.25), ma) == ColorInterp(2.00));
    BOOST_CHECK( interpolate(Point<1>(2.50), ma) == ColorInterp(3.00));
    BOOST_CHECK( interpolate(Point<1>(2.75), ma) == ColorInterp(3.00));
    BOOST_CHECK( interpolate(Point<1>(3.00), ma) == ColorInterp(3.00));
    
    /*
     * Interpolating out-of-range Points (Extrapolating)
     */
    BOOST_CHECK( interpolate(Point<1>(-5.00), ma) == ColorInterp(0.00));
    BOOST_CHECK( interpolate(Point<1>( 5.00), ma) == ColorInterp(3.00));
}

BOOST_AUTO_TEST_CASE_TEMPLATE( test_Interpolator_1d, T, ImageDataTypes )
{
    /*
     * Useful typedefs, the real data "Color" (normally integer) and the "interpolated Color" (float)
     */
    typedef typename ImaVol<T      ,1,1>::Color Color;
    typedef typename ImaVol<float64,1,1>::Color ColorInterp;
    
    /*
     * Creating the test data: an ImaVol with of 4x4 with values from 0 to 3 diagonally increasing
     * and decresing.
     */
    ImaVol<T,1,1> iv(uint64(4));
    
    Color c0 =  T(0);
    Color c1 =  T(1);
    Color c2 =  T(2);
    Color c3 =  T(3);
    
    iv(Coord<int64,1>(0)) = c0; iv(Coord<int64,1>(1)) = c1; iv(Coord<int64,1>(2)) = c2; iv(Coord<int64,1>(3)) = c3;
    
//    std::cout << "iv = " << std::endl;
//    std::cout <<  iv     << std::endl;

    /*
     * Creating the LINEAR Interpolator
     */
    Interpolator<1> interpolate(LINEAR);
    
    /*
     * Interpolating the Points
     */
    BOOST_CHECK( interpolate(Point<1>(0.00), iv) == ColorInterp(0.00));
    BOOST_CHECK( interpolate(Point<1>(0.25), iv) == ColorInterp(0.25));
    BOOST_CHECK( interpolate(Point<1>(0.50), iv) == ColorInterp(0.50));
    BOOST_CHECK( interpolate(Point<1>(0.75), iv) == ColorInterp(0.75));
    BOOST_CHECK( interpolate(Point<1>(1.00), iv) == ColorInterp(1.00));
    BOOST_CHECK( interpolate(Point<1>(1.25), iv) == ColorInterp(1.25));
    BOOST_CHECK( interpolate(Point<1>(1.50), iv) == ColorInterp(1.50));
    BOOST_CHECK( interpolate(Point<1>(1.75), iv) == ColorInterp(1.75));
    BOOST_CHECK( interpolate(Point<1>(2.00), iv) == ColorInterp(2.00));
    BOOST_CHECK( interpolate(Point<1>(2.25), iv) == ColorInterp(2.25));
    BOOST_CHECK( interpolate(Point<1>(2.50), iv) == ColorInterp(2.50));
    BOOST_CHECK( interpolate(Point<1>(2.75), iv) == ColorInterp(2.75));
    BOOST_CHECK( interpolate(Point<1>(3.00), iv) == ColorInterp(3.00));
    
    /*
     * Interpolating out-of-range Points (Extrapolating)
     */
    BOOST_CHECK( interpolate(Point<1>(-5.00), iv) == ColorInterp(0.00));
    BOOST_CHECK( interpolate(Point<1>( 5.00), iv) == ColorInterp(3.00));
    
    /*
     * Creating the MEAN Interpolator
     */
    interpolate.type(MEAN);
    
    /*
     * Interpolating the Points
     */
    BOOST_CHECK( interpolate(Point<1>(0.00), iv) == ColorInterp(0.50));
    BOOST_CHECK( interpolate(Point<1>(0.25), iv) == ColorInterp(0.50));
    BOOST_CHECK( interpolate(Point<1>(0.50), iv) == ColorInterp(0.50));
    BOOST_CHECK( interpolate(Point<1>(0.75), iv) == ColorInterp(0.50));
    BOOST_CHECK( interpolate(Point<1>(1.00), iv) == ColorInterp(1.00));
    BOOST_CHECK( interpolate(Point<1>(1.25), iv) == ColorInterp(1.50));
    BOOST_CHECK( interpolate(Point<1>(1.50), iv) == ColorInterp(1.50));
    BOOST_CHECK( interpolate(Point<1>(1.75), iv) == ColorInterp(1.50));
    BOOST_CHECK( interpolate(Point<1>(2.00), iv) == ColorInterp(2.00));
    BOOST_CHECK( interpolate(Point<1>(2.25), iv) == ColorInterp(2.50));
    BOOST_CHECK( interpolate(Point<1>(2.50), iv) == ColorInterp(2.50));
    BOOST_CHECK( interpolate(Point<1>(2.75), iv) == ColorInterp(2.50));
    BOOST_CHECK( interpolate(Point<1>(3.00), iv) == ColorInterp(2.50));
    
    /*
     * Interpolating out-of-range Points (Extrapolating)
     */
    BOOST_CHECK( interpolate(Point<1>(-5.00), iv) == ColorInterp(0.50));
    BOOST_CHECK( interpolate(Point<1>( 5.00), iv) == ColorInterp(2.50));
    
    /*
     * Creating the MEAN Interpolator
     */
    interpolate.type(NEAREST_NEIGHBOR);
    
    /*
     * Interpolating the Points
     */
    BOOST_CHECK( interpolate(Point<1>(0.00), iv) == ColorInterp(0.00));
    BOOST_CHECK( interpolate(Point<1>(0.25), iv) == ColorInterp(0.00));
    BOOST_CHECK( interpolate(Point<1>(0.50), iv) == ColorInterp(1.00));
    BOOST_CHECK( interpolate(Point<1>(0.75), iv) == ColorInterp(1.00));
    BOOST_CHECK( interpolate(Point<1>(1.00), iv) == ColorInterp(1.00));
    BOOST_CHECK( interpolate(Point<1>(1.25), iv) == ColorInterp(1.00));
    BOOST_CHECK( interpolate(Point<1>(1.50), iv) == ColorInterp(2.00));
    BOOST_CHECK( interpolate(Point<1>(1.75), iv) == ColorInterp(2.00));
    BOOST_CHECK( interpolate(Point<1>(2.00), iv) == ColorInterp(2.00));
    BOOST_CHECK( interpolate(Point<1>(2.25), iv) == ColorInterp(2.00));
    BOOST_CHECK( interpolate(Point<1>(2.50), iv) == ColorInterp(3.00));
    BOOST_CHECK( interpolate(Point<1>(2.75), iv) == ColorInterp(3.00));
    BOOST_CHECK( interpolate(Point<1>(3.00), iv) == ColorInterp(3.00));
    
    /*
     * Interpolating out-of-range Points (Extrapolating)
     */
    BOOST_CHECK( interpolate(Point<1>(-5.00), iv) == ColorInterp(0.00));
    BOOST_CHECK( interpolate(Point<1>( 5.00), iv) == ColorInterp(3.00));
}

BOOST_AUTO_TEST_CASE_TEMPLATE( test_Interpolator_3d, T, ImageDataTypes )
{
    /*
     * Useful typedefs, the real data "Color" (normally integer) and the "interpolated Color" (float)
     */
    typedef typename ImaVol<T      ,1,3>::Color Color;
    typedef typename ImaVol<float64,1,3>::Color ColorInterp;
    
    /*
     * Creating the test data: an ImaVol with of 4x4 with values from 0 to 3 diagonally increasing
     * and decresing.
     */
    ImaVol<T,1,3> iv(4,4,4);
    
    Color c0 =  T(0);
    Color c1 =  T(1);
    Color c2 =  T(2);
    Color c3 =  T(3);
    
    iv(Coord<int64,3>(0,0,0)) = c0; iv(Coord<int64,3>(1,0,0)) = c1; iv(Coord<int64,3>(2,0,0)) = c2; iv(Coord<int64,3>(3,0,0)) = c3;
    iv(Coord<int64,3>(0,1,0)) = c1; iv(Coord<int64,3>(1,1,0)) = c2; iv(Coord<int64,3>(2,1,0)) = c3; iv(Coord<int64,3>(3,1,0)) = c2;
    iv(Coord<int64,3>(0,2,0)) = c2; iv(Coord<int64,3>(1,2,0)) = c3; iv(Coord<int64,3>(2,2,0)) = c2; iv(Coord<int64,3>(3,2,0)) = c1;
    iv(Coord<int64,3>(0,3,0)) = c3; iv(Coord<int64,3>(1,3,0)) = c2; iv(Coord<int64,3>(2,3,0)) = c1; iv(Coord<int64,3>(3,3,0)) = c0;
    
    iv(Coord<int64,3>(0,0,1)) = c1; iv(Coord<int64,3>(1,0,1)) = c2; iv(Coord<int64,3>(2,0,1)) = c3; iv(Coord<int64,3>(3,0,1)) = c2;
    iv(Coord<int64,3>(0,1,1)) = c2; iv(Coord<int64,3>(1,1,1)) = c3; iv(Coord<int64,3>(2,1,1)) = c2; iv(Coord<int64,3>(3,1,1)) = c1;
    iv(Coord<int64,3>(0,2,1)) = c3; iv(Coord<int64,3>(1,2,1)) = c2; iv(Coord<int64,3>(2,2,1)) = c1; iv(Coord<int64,3>(3,2,1)) = c0;
    iv(Coord<int64,3>(0,3,1)) = c2; iv(Coord<int64,3>(1,3,1)) = c1; iv(Coord<int64,3>(2,3,1)) = c0; iv(Coord<int64,3>(3,3,1)) = c1;

    iv(Coord<int64,3>(0,0,2)) = c2; iv(Coord<int64,3>(1,0,2)) = c3; iv(Coord<int64,3>(2,0,2)) = c2; iv(Coord<int64,3>(3,0,2)) = c1;
    iv(Coord<int64,3>(0,1,2)) = c3; iv(Coord<int64,3>(1,1,2)) = c2; iv(Coord<int64,3>(2,1,2)) = c1; iv(Coord<int64,3>(3,1,2)) = c0;
    iv(Coord<int64,3>(0,2,2)) = c2; iv(Coord<int64,3>(1,2,2)) = c1; iv(Coord<int64,3>(2,2,2)) = c0; iv(Coord<int64,3>(3,2,2)) = c1;
    iv(Coord<int64,3>(0,3,2)) = c1; iv(Coord<int64,3>(1,3,2)) = c0; iv(Coord<int64,3>(2,3,2)) = c1; iv(Coord<int64,3>(3,3,2)) = c2;

    iv(Coord<int64,3>(0,0,3)) = c3; iv(Coord<int64,3>(1,0,3)) = c2; iv(Coord<int64,3>(2,0,3)) = c1; iv(Coord<int64,3>(3,0,3)) = c0;
    iv(Coord<int64,3>(0,1,3)) = c2; iv(Coord<int64,3>(1,1,3)) = c1; iv(Coord<int64,3>(2,1,3)) = c0; iv(Coord<int64,3>(3,1,3)) = c1;
    iv(Coord<int64,3>(0,2,3)) = c1; iv(Coord<int64,3>(1,2,3)) = c0; iv(Coord<int64,3>(2,2,3)) = c1; iv(Coord<int64,3>(3,2,3)) = c2;
    iv(Coord<int64,3>(0,3,3)) = c0; iv(Coord<int64,3>(1,3,3)) = c1; iv(Coord<int64,3>(2,3,3)) = c2; iv(Coord<int64,3>(3,3,3)) = c3;

//    std::cout << "iv = " << std::endl;
//    std::cout <<  iv     << std::endl;

    /*
     * Creating the LINEAR Interpolator
     */
    Interpolator<3> interpolate(LINEAR);
    
    /*
     * Interpolating the diagonal Points
     */
    BOOST_CHECK( interpolate(Point<3>(0.00, 0.00, 0.00), iv) == ColorInterp(0.00));
    BOOST_CHECK( interpolate(Point<3>(0.25, 0.25, 0.25), iv) == ColorInterp(0.75));
    BOOST_CHECK( interpolate(Point<3>(0.50, 0.50, 0.50), iv) == ColorInterp(1.50));
    BOOST_CHECK( interpolate(Point<3>(0.75, 0.75, 0.75), iv) == ColorInterp(2.25));
    BOOST_CHECK( interpolate(Point<3>(1.00, 1.00, 1.00), iv) == ColorInterp(3.00));
    BOOST_CHECK( interpolate(Point<3>(1.25, 1.25, 1.25), iv) == ColorInterp(2.25));
    BOOST_CHECK( interpolate(Point<3>(1.50, 1.50, 1.50), iv) == ColorInterp(1.50));
    BOOST_CHECK( interpolate(Point<3>(1.75, 1.75, 1.75), iv) == ColorInterp(0.75));
    BOOST_CHECK( interpolate(Point<3>(2.00, 2.00, 2.00), iv) == ColorInterp(0.00));
    BOOST_CHECK( interpolate(Point<3>(2.25, 2.25, 2.25), iv) == ColorInterp(0.75));
    BOOST_CHECK( interpolate(Point<3>(2.50, 2.50, 2.50), iv) == ColorInterp(1.50));
    BOOST_CHECK( interpolate(Point<3>(2.75, 2.75, 2.75), iv) == ColorInterp(2.25));
    BOOST_CHECK( interpolate(Point<3>(3.00, 3.00, 3.00), iv) == ColorInterp(3.00));
    
    /*
     * Interpolating out-of-range Points (Extrapolating)
     */
    BOOST_CHECK( interpolate(Point<3>(-5.00), iv) == ColorInterp(0.00));
    BOOST_CHECK( interpolate(Point<3>( 5.00), iv) == ColorInterp(3.00));
}

BOOST_AUTO_TEST_CASE_TEMPLATE( test_Interpolator_bilinear, T, ImageDataTypes )
{
    /*
     * Useful typedefs, the real data "Color" (normally integer) and the "interpolated Color" (float)
     */
    typedef typename ImaVol<T      ,1,2>::Color Color;
    typedef typename ImaVol<float64,1,2>::Color ColorInterp;
    
    /*
     * Creating the test data: an ImaVol with of 4x4 with values from 0 to 3 diagonally increasing
     * and decresing.
     */
    ImaVol<T,1,2> iv(4,4);
    
    Color c0 =  T(0);
    Color c1 =  T(1);
    Color c2 =  T(2);
    Color c3 =  T(3);
    
    iv(Coord2D<>(0,0)) = c0; iv(Coord2D<>(1,0)) = c1; iv(Coord2D<>(2,0)) = c2; iv(Coord2D<>(3,0)) = c3;
    iv(Coord2D<>(0,1)) = c1; iv(Coord2D<>(1,1)) = c2; iv(Coord2D<>(2,1)) = c3; iv(Coord2D<>(3,1)) = c2;
    iv(Coord2D<>(0,2)) = c2; iv(Coord2D<>(1,2)) = c3; iv(Coord2D<>(2,2)) = c2; iv(Coord2D<>(3,2)) = c1;
    iv(Coord2D<>(0,3)) = c3; iv(Coord2D<>(1,3)) = c2; iv(Coord2D<>(2,3)) = c1; iv(Coord2D<>(3,3)) = c0;
    
//    std::cout << "iv = " << std::endl;
//    std::cout <<  iv     << std::endl;

    /*
     * Creating the LINEAR Interpolator
     */
    Interpolator<2> interpolate(LINEAR);
    
    /*
     * Interpolating the diagonal Points
     */
    BOOST_CHECK( interpolate(Point<2>(0.00, 0.00), iv) == ColorInterp(0.00));
    BOOST_CHECK( interpolate(Point<2>(0.25, 0.25), iv) == ColorInterp(0.50));
    BOOST_CHECK( interpolate(Point<2>(0.50, 0.50), iv) == ColorInterp(1.00));
    BOOST_CHECK( interpolate(Point<2>(0.75, 0.75), iv) == ColorInterp(1.50));
    BOOST_CHECK( interpolate(Point<2>(1.00, 1.00), iv) == ColorInterp(2.00));
    BOOST_CHECK( interpolate(Point<2>(1.25, 1.25), iv) == ColorInterp(2.375));
    BOOST_CHECK( interpolate(Point<2>(1.50, 1.50), iv) == ColorInterp(2.500));
    BOOST_CHECK( interpolate(Point<2>(1.75, 1.75), iv) == ColorInterp(2.375));
    BOOST_CHECK( interpolate(Point<2>(2.00, 2.00), iv) == ColorInterp(2.00));
    BOOST_CHECK( interpolate(Point<2>(2.25, 2.25), iv) == ColorInterp(1.50));
    BOOST_CHECK( interpolate(Point<2>(2.50, 2.50), iv) == ColorInterp(1.00));
    BOOST_CHECK( interpolate(Point<2>(2.75, 2.75), iv) == ColorInterp(0.50));
    BOOST_CHECK( interpolate(Point<2>(3.00, 3.00), iv) == ColorInterp(0.00));
    
    /*
     * Interpolating the first column of Points
     */
    BOOST_CHECK( interpolate(Point<2>(0.00, 0.00), iv) == ColorInterp(0.00));
    BOOST_CHECK( interpolate(Point<2>(0.00, 0.25), iv) == ColorInterp(0.25));
    BOOST_CHECK( interpolate(Point<2>(0.00, 0.50), iv) == ColorInterp(0.50));
    BOOST_CHECK( interpolate(Point<2>(0.00, 0.75), iv) == ColorInterp(0.75));
    BOOST_CHECK( interpolate(Point<2>(0.00, 1.00), iv) == ColorInterp(1.00));
    BOOST_CHECK( interpolate(Point<2>(0.00, 1.25), iv) == ColorInterp(1.25));
    BOOST_CHECK( interpolate(Point<2>(0.00, 1.50), iv) == ColorInterp(1.50));
    BOOST_CHECK( interpolate(Point<2>(0.00, 1.75), iv) == ColorInterp(1.75));
    BOOST_CHECK( interpolate(Point<2>(0.00, 2.00), iv) == ColorInterp(2.00));
    BOOST_CHECK( interpolate(Point<2>(0.00, 2.25), iv) == ColorInterp(2.25));
    BOOST_CHECK( interpolate(Point<2>(0.00, 2.50), iv) == ColorInterp(2.50));
    BOOST_CHECK( interpolate(Point<2>(0.00, 2.75), iv) == ColorInterp(2.75));
    BOOST_CHECK( interpolate(Point<2>(0.00, 3.00), iv) == ColorInterp(3.00));

    /*
     * Interpolating the last column of Points
     */
    BOOST_CHECK( interpolate(Point<2>(3.00, 0.00), iv) == ColorInterp(3.00));
    BOOST_CHECK( interpolate(Point<2>(3.00, 0.25), iv) == ColorInterp(2.75));
    BOOST_CHECK( interpolate(Point<2>(3.00, 0.50), iv) == ColorInterp(2.50));
    BOOST_CHECK( interpolate(Point<2>(3.00, 0.75), iv) == ColorInterp(2.25));
    BOOST_CHECK( interpolate(Point<2>(3.00, 1.00), iv) == ColorInterp(2.00));
    BOOST_CHECK( interpolate(Point<2>(3.00, 1.25), iv) == ColorInterp(1.75));
    BOOST_CHECK( interpolate(Point<2>(3.00, 1.50), iv) == ColorInterp(1.50));
    BOOST_CHECK( interpolate(Point<2>(3.00, 1.75), iv) == ColorInterp(1.25));
    BOOST_CHECK( interpolate(Point<2>(3.00, 2.00), iv) == ColorInterp(1.00));
    BOOST_CHECK( interpolate(Point<2>(3.00, 2.25), iv) == ColorInterp(0.75));
    BOOST_CHECK( interpolate(Point<2>(3.00, 2.50), iv) == ColorInterp(0.50));
    BOOST_CHECK( interpolate(Point<2>(3.00, 2.75), iv) == ColorInterp(0.25));
    BOOST_CHECK( interpolate(Point<2>(3.00, 3.00), iv) == ColorInterp(0.00));

    /*
     * Interpolating the center column of Points
     */
    BOOST_CHECK( interpolate(Point<2>(1.50, 0.00), iv) == ColorInterp(1.50));
    BOOST_CHECK( interpolate(Point<2>(1.50, 0.25), iv) == ColorInterp(1.75));
    BOOST_CHECK( interpolate(Point<2>(1.50, 0.50), iv) == ColorInterp(2.00));
    BOOST_CHECK( interpolate(Point<2>(1.50, 0.75), iv) == ColorInterp(2.25));
    BOOST_CHECK( interpolate(Point<2>(1.50, 1.00), iv) == ColorInterp(2.50));
    BOOST_CHECK( interpolate(Point<2>(1.50, 1.25), iv) == ColorInterp(2.50));
    BOOST_CHECK( interpolate(Point<2>(1.50, 1.50), iv) == ColorInterp(2.50));
    BOOST_CHECK( interpolate(Point<2>(1.50, 1.75), iv) == ColorInterp(2.50));
    BOOST_CHECK( interpolate(Point<2>(1.50, 2.00), iv) == ColorInterp(2.50));
    BOOST_CHECK( interpolate(Point<2>(1.50, 2.25), iv) == ColorInterp(2.25));
    BOOST_CHECK( interpolate(Point<2>(1.50, 2.50), iv) == ColorInterp(2.00));
    BOOST_CHECK( interpolate(Point<2>(1.50, 2.75), iv) == ColorInterp(1.75));
    BOOST_CHECK( interpolate(Point<2>(1.50, 3.00), iv) == ColorInterp(1.50));
    
    /*
     * Interpolating the center row of Points
     */
    BOOST_CHECK( interpolate(Point<2>(0.00, 1.50), iv) == ColorInterp(1.50));
    BOOST_CHECK( interpolate(Point<2>(0.25, 1.50), iv) == ColorInterp(1.75));
    BOOST_CHECK( interpolate(Point<2>(0.50, 1.50), iv) == ColorInterp(2.00));
    BOOST_CHECK( interpolate(Point<2>(0.75, 1.50), iv) == ColorInterp(2.25));
    BOOST_CHECK( interpolate(Point<2>(1.00, 1.50), iv) == ColorInterp(2.50));
    BOOST_CHECK( interpolate(Point<2>(1.25, 1.50), iv) == ColorInterp(2.50));
    BOOST_CHECK( interpolate(Point<2>(1.50, 1.50), iv) == ColorInterp(2.50));
    BOOST_CHECK( interpolate(Point<2>(1.75, 1.50), iv) == ColorInterp(2.50));
    BOOST_CHECK( interpolate(Point<2>(2.00, 1.50), iv) == ColorInterp(2.50));
    BOOST_CHECK( interpolate(Point<2>(2.25, 1.50), iv) == ColorInterp(2.25));
    BOOST_CHECK( interpolate(Point<2>(2.50, 1.50), iv) == ColorInterp(2.00));
    BOOST_CHECK( interpolate(Point<2>(2.75, 1.50), iv) == ColorInterp(1.75));
    BOOST_CHECK( interpolate(Point<2>(3.00, 1.50), iv) == ColorInterp(1.50));
    
    /*
     * Interpolating the first row of Points
     */
    BOOST_CHECK( interpolate(Point<2>(0.00, 0.00), iv) == ColorInterp(0.00));
    BOOST_CHECK( interpolate(Point<2>(0.25, 0.00), iv) == ColorInterp(0.25));
    BOOST_CHECK( interpolate(Point<2>(0.50, 0.00), iv) == ColorInterp(0.50));
    BOOST_CHECK( interpolate(Point<2>(0.75, 0.00), iv) == ColorInterp(0.75));
    BOOST_CHECK( interpolate(Point<2>(1.00, 0.00), iv) == ColorInterp(1.00));
    BOOST_CHECK( interpolate(Point<2>(1.25, 0.00), iv) == ColorInterp(1.25));
    BOOST_CHECK( interpolate(Point<2>(1.50, 0.00), iv) == ColorInterp(1.50));
    BOOST_CHECK( interpolate(Point<2>(1.75, 0.00), iv) == ColorInterp(1.75));
    BOOST_CHECK( interpolate(Point<2>(2.00, 0.00), iv) == ColorInterp(2.00));
    BOOST_CHECK( interpolate(Point<2>(2.25, 0.00), iv) == ColorInterp(2.25));
    BOOST_CHECK( interpolate(Point<2>(2.50, 0.00), iv) == ColorInterp(2.50));
    BOOST_CHECK( interpolate(Point<2>(2.75, 0.00), iv) == ColorInterp(2.75));
    BOOST_CHECK( interpolate(Point<2>(3.00, 0.00), iv) == ColorInterp(3.00));

    /*
     * Interpolating the last row of Points
     */
    BOOST_CHECK( interpolate(Point<2>(0.00, 3.00), iv) == ColorInterp(3.00));
    BOOST_CHECK( interpolate(Point<2>(0.25, 3.00), iv) == ColorInterp(2.75));
    BOOST_CHECK( interpolate(Point<2>(0.50, 3.00), iv) == ColorInterp(2.50));
    BOOST_CHECK( interpolate(Point<2>(0.75, 3.00), iv) == ColorInterp(2.25));
    BOOST_CHECK( interpolate(Point<2>(1.00, 3.00), iv) == ColorInterp(2.00));
    BOOST_CHECK( interpolate(Point<2>(1.25, 3.00), iv) == ColorInterp(1.75));
    BOOST_CHECK( interpolate(Point<2>(1.50, 3.00), iv) == ColorInterp(1.50));
    BOOST_CHECK( interpolate(Point<2>(1.75, 3.00), iv) == ColorInterp(1.25));
    BOOST_CHECK( interpolate(Point<2>(2.00, 3.00), iv) == ColorInterp(1.00));
    BOOST_CHECK( interpolate(Point<2>(2.25, 3.00), iv) == ColorInterp(0.75));
    BOOST_CHECK( interpolate(Point<2>(2.50, 3.00), iv) == ColorInterp(0.50));
    BOOST_CHECK( interpolate(Point<2>(2.75, 3.00), iv) == ColorInterp(0.25));
    BOOST_CHECK( interpolate(Point<2>(3.00, 3.00), iv) == ColorInterp(0.00));

    /*
     * Interpolating (extrapolating) out-of-range rows of Points
     */
    BOOST_CHECK( interpolate(Point<2>(0.00,  5.00), iv) == ColorInterp(3.00));
    BOOST_CHECK( interpolate(Point<2>(0.25,  5.00), iv) == ColorInterp(2.75));
    BOOST_CHECK( interpolate(Point<2>(0.50,  5.00), iv) == ColorInterp(2.50));
    BOOST_CHECK( interpolate(Point<2>(0.75,  5.00), iv) == ColorInterp(2.25));
    BOOST_CHECK( interpolate(Point<2>(1.00,  5.00), iv) == ColorInterp(2.00));
    BOOST_CHECK( interpolate(Point<2>(1.25,  5.00), iv) == ColorInterp(1.75));
    BOOST_CHECK( interpolate(Point<2>(1.50,  5.00), iv) == ColorInterp(1.50));
    BOOST_CHECK( interpolate(Point<2>(1.75,  5.00), iv) == ColorInterp(1.25));
    BOOST_CHECK( interpolate(Point<2>(2.00,  5.00), iv) == ColorInterp(1.00));
    BOOST_CHECK( interpolate(Point<2>(2.25,  5.00), iv) == ColorInterp(0.75));
    BOOST_CHECK( interpolate(Point<2>(2.50,  5.00), iv) == ColorInterp(0.50));
    BOOST_CHECK( interpolate(Point<2>(2.75,  5.00), iv) == ColorInterp(0.25));
    BOOST_CHECK( interpolate(Point<2>(3.00,  5.00), iv) == ColorInterp(0.00));
    BOOST_CHECK( interpolate(Point<2>(0.00, -5.00), iv) == ColorInterp(0.00));
    BOOST_CHECK( interpolate(Point<2>(0.25, -5.00), iv) == ColorInterp(0.25));
    BOOST_CHECK( interpolate(Point<2>(0.50, -5.00), iv) == ColorInterp(0.50));
    BOOST_CHECK( interpolate(Point<2>(0.75, -5.00), iv) == ColorInterp(0.75));
    BOOST_CHECK( interpolate(Point<2>(1.00, -5.00), iv) == ColorInterp(1.00));
    BOOST_CHECK( interpolate(Point<2>(1.25, -5.00), iv) == ColorInterp(1.25));
    BOOST_CHECK( interpolate(Point<2>(1.50, -5.00), iv) == ColorInterp(1.50));
    BOOST_CHECK( interpolate(Point<2>(1.75, -5.00), iv) == ColorInterp(1.75));
    BOOST_CHECK( interpolate(Point<2>(2.00, -5.00), iv) == ColorInterp(2.00));
    BOOST_CHECK( interpolate(Point<2>(2.25, -5.00), iv) == ColorInterp(2.25));
    BOOST_CHECK( interpolate(Point<2>(2.50, -5.00), iv) == ColorInterp(2.50));
    BOOST_CHECK( interpolate(Point<2>(2.75, -5.00), iv) == ColorInterp(2.75));
    BOOST_CHECK( interpolate(Point<2>(3.00, -5.00), iv) == ColorInterp(3.00));

    /*
     * Interpolating (extrapolating) out-of-range columns of Points
     */
    BOOST_CHECK( interpolate(Point<2>( 5.00, 0.00), iv) == ColorInterp(3.00));
    BOOST_CHECK( interpolate(Point<2>( 5.00, 0.25), iv) == ColorInterp(2.75));
    BOOST_CHECK( interpolate(Point<2>( 5.00, 0.50), iv) == ColorInterp(2.50));
    BOOST_CHECK( interpolate(Point<2>( 5.00, 0.75), iv) == ColorInterp(2.25));
    BOOST_CHECK( interpolate(Point<2>( 5.00, 1.00), iv) == ColorInterp(2.00));
    BOOST_CHECK( interpolate(Point<2>( 5.00, 1.25), iv) == ColorInterp(1.75));
    BOOST_CHECK( interpolate(Point<2>( 5.00, 1.50), iv) == ColorInterp(1.50));
    BOOST_CHECK( interpolate(Point<2>( 5.00, 1.75), iv) == ColorInterp(1.25));
    BOOST_CHECK( interpolate(Point<2>( 5.00, 2.00), iv) == ColorInterp(1.00));
    BOOST_CHECK( interpolate(Point<2>( 5.00, 2.25), iv) == ColorInterp(0.75));
    BOOST_CHECK( interpolate(Point<2>( 5.00, 2.50), iv) == ColorInterp(0.50));
    BOOST_CHECK( interpolate(Point<2>( 5.00, 2.75), iv) == ColorInterp(0.25));
    BOOST_CHECK( interpolate(Point<2>( 5.00, 3.00), iv) == ColorInterp(0.00));
    BOOST_CHECK( interpolate(Point<2>(-5.00, 0.00), iv) == ColorInterp(0.00));
    BOOST_CHECK( interpolate(Point<2>(-5.00, 0.25), iv) == ColorInterp(0.25));
    BOOST_CHECK( interpolate(Point<2>(-5.00, 0.50), iv) == ColorInterp(0.50));
    BOOST_CHECK( interpolate(Point<2>(-5.00, 0.75), iv) == ColorInterp(0.75));
    BOOST_CHECK( interpolate(Point<2>(-5.00, 1.00), iv) == ColorInterp(1.00));
    BOOST_CHECK( interpolate(Point<2>(-5.00, 1.25), iv) == ColorInterp(1.25));
    BOOST_CHECK( interpolate(Point<2>(-5.00, 1.50), iv) == ColorInterp(1.50));
    BOOST_CHECK( interpolate(Point<2>(-5.00, 1.75), iv) == ColorInterp(1.75));
    BOOST_CHECK( interpolate(Point<2>(-5.00, 2.00), iv) == ColorInterp(2.00));
    BOOST_CHECK( interpolate(Point<2>(-5.00, 2.25), iv) == ColorInterp(2.25));
    BOOST_CHECK( interpolate(Point<2>(-5.00, 2.50), iv) == ColorInterp(2.50));
    BOOST_CHECK( interpolate(Point<2>(-5.00, 2.75), iv) == ColorInterp(2.75));
    BOOST_CHECK( interpolate(Point<2>(-5.00, 3.00), iv) == ColorInterp(3.00));
    
    /*
     * Interpolating (extrapolating) out-of-range corners
     */
    BOOST_CHECK( interpolate(Point<2>( -5.00, -5.00), iv) == ColorInterp(0.00));
    BOOST_CHECK( interpolate(Point<2>(  5.00, -5.00), iv) == ColorInterp(3.00));
    BOOST_CHECK( interpolate(Point<2>( -5.00,  5.00), iv) == ColorInterp(3.00));
    BOOST_CHECK( interpolate(Point<2>(  5.00,  5.00), iv) == ColorInterp(0.00));
}

BOOST_AUTO_TEST_CASE_TEMPLATE( test_Interpolator_mean, T, ImageDataTypes )
{
    /*
     * Useful typedefs, the real data "Color" (normally integer) and the "interpolated Color" (float)
     */
    typedef typename ImaVol<T      ,1,2>::Color Color;
    typedef typename ImaVol<float64,1,2>::Color ColorInterp;
    
    /*
     * Creating the test data: an ImaVol with of 4x4 with values from 0 to 3 diagonally increasing
     * and decresing.
     */
    ImaVol<T,1,2> iv(4,4);
    
    Color c0 =  T(0);
    Color c1 =  T(1);
    Color c2 =  T(2);
    Color c3 =  T(3);
    
    iv(Coord2D<>(0,0)) = c0; iv(Coord2D<>(1,0)) = c1; iv(Coord2D<>(2,0)) = c2; iv(Coord2D<>(3,0)) = c3;
    iv(Coord2D<>(0,1)) = c1; iv(Coord2D<>(1,1)) = c2; iv(Coord2D<>(2,1)) = c3; iv(Coord2D<>(3,1)) = c2;
    iv(Coord2D<>(0,2)) = c2; iv(Coord2D<>(1,2)) = c3; iv(Coord2D<>(2,2)) = c2; iv(Coord2D<>(3,2)) = c1;
    iv(Coord2D<>(0,3)) = c3; iv(Coord2D<>(1,3)) = c2; iv(Coord2D<>(2,3)) = c1; iv(Coord2D<>(3,3)) = c0;
    
//    std::cout << "iv = " << std::endl;
//    std::cout <<  iv     << std::endl;

    /*
     * Creating the MEAN Interpolator
     */
    Interpolator<2> interpolate(MEAN);
    
    /*
     * Interpolating the diagonal Points
     */
    BOOST_CHECK( interpolate(Point<2>(0.00, 0.00), iv) == ColorInterp(1.00));
    BOOST_CHECK( interpolate(Point<2>(0.25, 0.25), iv) == ColorInterp(1.00));
    BOOST_CHECK( interpolate(Point<2>(0.50, 0.50), iv) == ColorInterp(1.00));
    BOOST_CHECK( interpolate(Point<2>(0.75, 0.75), iv) == ColorInterp(1.00));
    BOOST_CHECK( interpolate(Point<2>(1.00, 1.00), iv) == ColorInterp(16.0/9.0));
    BOOST_CHECK( interpolate(Point<2>(1.25, 1.25), iv) == ColorInterp(2.50));
    BOOST_CHECK( interpolate(Point<2>(1.50, 1.50), iv) == ColorInterp(2.50));
    BOOST_CHECK( interpolate(Point<2>(1.75, 1.75), iv) == ColorInterp(2.50));
    BOOST_CHECK( interpolate(Point<2>(2.00, 2.00), iv) == ColorInterp(16.0/9.0));
    BOOST_CHECK( interpolate(Point<2>(2.25, 2.25), iv) == ColorInterp(1.00));
    BOOST_CHECK( interpolate(Point<2>(2.50, 2.50), iv) == ColorInterp(1.00));
    BOOST_CHECK( interpolate(Point<2>(2.75, 2.75), iv) == ColorInterp(1.00));
    BOOST_CHECK( interpolate(Point<2>(3.00, 3.00), iv) == ColorInterp(1.00));
    
    /*
     * Interpolating the first column of Points
     */
    BOOST_CHECK( interpolate(Point<2>(0.00, 0.00), iv) == ColorInterp(1.00));
    BOOST_CHECK( interpolate(Point<2>(0.00, 0.25), iv) == ColorInterp(1.00));
    BOOST_CHECK( interpolate(Point<2>(0.00, 0.50), iv) == ColorInterp(1.00));
    BOOST_CHECK( interpolate(Point<2>(0.00, 0.75), iv) == ColorInterp(1.00));
    BOOST_CHECK( interpolate(Point<2>(0.00, 1.00), iv) == ColorInterp(9.0/6.0));
    BOOST_CHECK( interpolate(Point<2>(0.00, 1.25), iv) == ColorInterp(2.00));
    BOOST_CHECK( interpolate(Point<2>(0.00, 1.50), iv) == ColorInterp(2.00));
    BOOST_CHECK( interpolate(Point<2>(0.00, 1.75), iv) == ColorInterp(2.00));
    BOOST_CHECK( interpolate(Point<2>(0.00, 2.00), iv) == ColorInterp(13.0/6.0));
    BOOST_CHECK( interpolate(Point<2>(0.00, 2.25), iv) == ColorInterp(2.50));
    BOOST_CHECK( interpolate(Point<2>(0.00, 2.50), iv) == ColorInterp(2.50));
    BOOST_CHECK( interpolate(Point<2>(0.00, 2.75), iv) == ColorInterp(2.50));
    BOOST_CHECK( interpolate(Point<2>(0.00, 3.00), iv) == ColorInterp(2.50));

    /*
     * Interpolating the last column of Points
     */
    BOOST_CHECK( interpolate(Point<2>(3.00, 0.00), iv) == ColorInterp(2.50));
    BOOST_CHECK( interpolate(Point<2>(3.00, 0.25), iv) == ColorInterp(2.50));
    BOOST_CHECK( interpolate(Point<2>(3.00, 0.50), iv) == ColorInterp(2.50));
    BOOST_CHECK( interpolate(Point<2>(3.00, 0.75), iv) == ColorInterp(2.50));
    BOOST_CHECK( interpolate(Point<2>(3.00, 1.00), iv) == ColorInterp(13.0/6.0));
    BOOST_CHECK( interpolate(Point<2>(3.00, 1.25), iv) == ColorInterp(2.00));
    BOOST_CHECK( interpolate(Point<2>(3.00, 1.50), iv) == ColorInterp(2.00));
    BOOST_CHECK( interpolate(Point<2>(3.00, 1.75), iv) == ColorInterp(2.00));
    BOOST_CHECK( interpolate(Point<2>(3.00, 2.00), iv) == ColorInterp(9.0/6.0));
    BOOST_CHECK( interpolate(Point<2>(3.00, 2.25), iv) == ColorInterp(1.00));
    BOOST_CHECK( interpolate(Point<2>(3.00, 2.50), iv) == ColorInterp(1.00));
    BOOST_CHECK( interpolate(Point<2>(3.00, 2.75), iv) == ColorInterp(1.00));
    BOOST_CHECK( interpolate(Point<2>(3.00, 3.00), iv) == ColorInterp(1.00));

    /*
     * Interpolating the center column of Points
     */
    BOOST_CHECK( interpolate(Point<2>(1.50, 0.00), iv) == ColorInterp(2.00));
    BOOST_CHECK( interpolate(Point<2>(1.50, 0.25), iv) == ColorInterp(2.00));
    BOOST_CHECK( interpolate(Point<2>(1.50, 0.50), iv) == ColorInterp(2.00));
    BOOST_CHECK( interpolate(Point<2>(1.50, 0.75), iv) == ColorInterp(2.00));
    BOOST_CHECK( interpolate(Point<2>(1.50, 1.00), iv) == ColorInterp(13.0/6.0));
    BOOST_CHECK( interpolate(Point<2>(1.50, 1.25), iv) == ColorInterp(2.50));
    BOOST_CHECK( interpolate(Point<2>(1.50, 1.50), iv) == ColorInterp(2.50));
    BOOST_CHECK( interpolate(Point<2>(1.50, 1.75), iv) == ColorInterp(2.50));
    BOOST_CHECK( interpolate(Point<2>(1.50, 2.00), iv) == ColorInterp(13.0/6.0));
    BOOST_CHECK( interpolate(Point<2>(1.50, 2.25), iv) == ColorInterp(2.00));
    BOOST_CHECK( interpolate(Point<2>(1.50, 2.50), iv) == ColorInterp(2.00));
    BOOST_CHECK( interpolate(Point<2>(1.50, 2.75), iv) == ColorInterp(2.00));
    BOOST_CHECK( interpolate(Point<2>(1.50, 3.00), iv) == ColorInterp(2.00));
    
    /*
     * Interpolating the center row of Points
     */
    BOOST_CHECK( interpolate(Point<2>(0.00, 1.50), iv) == ColorInterp(2.00));
    BOOST_CHECK( interpolate(Point<2>(0.25, 1.50), iv) == ColorInterp(2.00));
    BOOST_CHECK( interpolate(Point<2>(0.50, 1.50), iv) == ColorInterp(2.00));
    BOOST_CHECK( interpolate(Point<2>(0.75, 1.50), iv) == ColorInterp(2.00));
    BOOST_CHECK( interpolate(Point<2>(1.00, 1.50), iv) == ColorInterp(13.0/6.0));
    BOOST_CHECK( interpolate(Point<2>(1.25, 1.50), iv) == ColorInterp(2.50));
    BOOST_CHECK( interpolate(Point<2>(1.50, 1.50), iv) == ColorInterp(2.50));
    BOOST_CHECK( interpolate(Point<2>(1.75, 1.50), iv) == ColorInterp(2.50));
    BOOST_CHECK( interpolate(Point<2>(2.00, 1.50), iv) == ColorInterp(13.0/6.0));
    BOOST_CHECK( interpolate(Point<2>(2.25, 1.50), iv) == ColorInterp(2.00));
    BOOST_CHECK( interpolate(Point<2>(2.50, 1.50), iv) == ColorInterp(2.00));
    BOOST_CHECK( interpolate(Point<2>(2.75, 1.50), iv) == ColorInterp(2.00));
    BOOST_CHECK( interpolate(Point<2>(3.00, 1.50), iv) == ColorInterp(2.00));
    
    /*
     * Interpolating the first row of Points
     */
    BOOST_CHECK( interpolate(Point<2>(0.00, 0.00), iv) == ColorInterp(1.00));
    BOOST_CHECK( interpolate(Point<2>(0.25, 0.00), iv) == ColorInterp(1.00));
    BOOST_CHECK( interpolate(Point<2>(0.50, 0.00), iv) == ColorInterp(1.00));
    BOOST_CHECK( interpolate(Point<2>(0.75, 0.00), iv) == ColorInterp(1.00));
    BOOST_CHECK( interpolate(Point<2>(1.00, 0.00), iv) == ColorInterp(9.00/6.0));
    BOOST_CHECK( interpolate(Point<2>(1.25, 0.00), iv) == ColorInterp(2.00));
    BOOST_CHECK( interpolate(Point<2>(1.50, 0.00), iv) == ColorInterp(2.00));
    BOOST_CHECK( interpolate(Point<2>(1.75, 0.00), iv) == ColorInterp(2.00));
    BOOST_CHECK( interpolate(Point<2>(2.00, 0.00), iv) == ColorInterp(13.00/6.0));
    BOOST_CHECK( interpolate(Point<2>(2.25, 0.00), iv) == ColorInterp(2.50));
    BOOST_CHECK( interpolate(Point<2>(2.50, 0.00), iv) == ColorInterp(2.50));
    BOOST_CHECK( interpolate(Point<2>(2.75, 0.00), iv) == ColorInterp(2.50));
    BOOST_CHECK( interpolate(Point<2>(3.00, 0.00), iv) == ColorInterp(2.50));

    /*
     * Interpolating the last row of Points
     */
    BOOST_CHECK( interpolate(Point<2>(0.00, 3.00), iv) == ColorInterp(2.50));
    BOOST_CHECK( interpolate(Point<2>(0.25, 3.00), iv) == ColorInterp(2.50));
    BOOST_CHECK( interpolate(Point<2>(0.50, 3.00), iv) == ColorInterp(2.50));
    BOOST_CHECK( interpolate(Point<2>(0.75, 3.00), iv) == ColorInterp(2.50));
    BOOST_CHECK( interpolate(Point<2>(1.00, 3.00), iv) == ColorInterp(13.00/6.0));
    BOOST_CHECK( interpolate(Point<2>(1.25, 3.00), iv) == ColorInterp(2.00));
    BOOST_CHECK( interpolate(Point<2>(1.50, 3.00), iv) == ColorInterp(2.00));
    BOOST_CHECK( interpolate(Point<2>(1.75, 3.00), iv) == ColorInterp(2.00));
    BOOST_CHECK( interpolate(Point<2>(2.00, 3.00), iv) == ColorInterp(9.00/6.0));
    BOOST_CHECK( interpolate(Point<2>(2.25, 3.00), iv) == ColorInterp(1.00));
    BOOST_CHECK( interpolate(Point<2>(2.50, 3.00), iv) == ColorInterp(1.00));
    BOOST_CHECK( interpolate(Point<2>(2.75, 3.00), iv) == ColorInterp(1.00));
    BOOST_CHECK( interpolate(Point<2>(3.00, 3.00), iv) == ColorInterp(1.00));

    /*
     * Interpolating (extrapolating) out-of-range rows of Points
     */
    BOOST_CHECK( interpolate(Point<2>(0.00,  5.00), iv) == ColorInterp(2.50));
    BOOST_CHECK( interpolate(Point<2>(0.25,  5.00), iv) == ColorInterp(2.50));
    BOOST_CHECK( interpolate(Point<2>(0.50,  5.00), iv) == ColorInterp(2.50));
    BOOST_CHECK( interpolate(Point<2>(0.75,  5.00), iv) == ColorInterp(2.50));
    BOOST_CHECK( interpolate(Point<2>(1.00,  5.00), iv) == ColorInterp(13.00/6.0));
    BOOST_CHECK( interpolate(Point<2>(1.25,  5.00), iv) == ColorInterp(2.00));
    BOOST_CHECK( interpolate(Point<2>(1.50,  5.00), iv) == ColorInterp(2.00));
    BOOST_CHECK( interpolate(Point<2>(1.75,  5.00), iv) == ColorInterp(2.00));
    BOOST_CHECK( interpolate(Point<2>(2.00,  5.00), iv) == ColorInterp(9.00/6.0));
    BOOST_CHECK( interpolate(Point<2>(2.25,  5.00), iv) == ColorInterp(1.00));
    BOOST_CHECK( interpolate(Point<2>(2.50,  5.00), iv) == ColorInterp(1.00));
    BOOST_CHECK( interpolate(Point<2>(2.75,  5.00), iv) == ColorInterp(1.00));
    BOOST_CHECK( interpolate(Point<2>(3.00,  5.00), iv) == ColorInterp(1.00));
    BOOST_CHECK( interpolate(Point<2>(0.00, -5.00), iv) == ColorInterp(1.00));
    BOOST_CHECK( interpolate(Point<2>(0.25, -5.00), iv) == ColorInterp(1.00));
    BOOST_CHECK( interpolate(Point<2>(0.50, -5.00), iv) == ColorInterp(1.00));
    BOOST_CHECK( interpolate(Point<2>(0.75, -5.00), iv) == ColorInterp(1.00));
    BOOST_CHECK( interpolate(Point<2>(1.00, -5.00), iv) == ColorInterp(9.00/6.0));
    BOOST_CHECK( interpolate(Point<2>(1.25, -5.00), iv) == ColorInterp(2.00));
    BOOST_CHECK( interpolate(Point<2>(1.50, -5.00), iv) == ColorInterp(2.00));
    BOOST_CHECK( interpolate(Point<2>(1.75, -5.00), iv) == ColorInterp(2.00));
    BOOST_CHECK( interpolate(Point<2>(2.00, -5.00), iv) == ColorInterp(13.00/6.0));
    BOOST_CHECK( interpolate(Point<2>(2.25, -5.00), iv) == ColorInterp(2.50));
    BOOST_CHECK( interpolate(Point<2>(2.50, -5.00), iv) == ColorInterp(2.50));
    BOOST_CHECK( interpolate(Point<2>(2.75, -5.00), iv) == ColorInterp(2.50));
    BOOST_CHECK( interpolate(Point<2>(3.00, -5.00), iv) == ColorInterp(2.50));

    /*
     * Interpolating (extrapolating) out-of-range columns of Points
     */
    BOOST_CHECK( interpolate(Point<2>( 5.00, 0.00), iv) == ColorInterp(2.50));
    BOOST_CHECK( interpolate(Point<2>( 5.00, 0.25), iv) == ColorInterp(2.50));
    BOOST_CHECK( interpolate(Point<2>( 5.00, 0.50), iv) == ColorInterp(2.50));
    BOOST_CHECK( interpolate(Point<2>( 5.00, 0.75), iv) == ColorInterp(2.50));
    BOOST_CHECK( interpolate(Point<2>( 5.00, 1.00), iv) == ColorInterp(13.00/6.0));
    BOOST_CHECK( interpolate(Point<2>( 5.00, 1.25), iv) == ColorInterp(2.00));
    BOOST_CHECK( interpolate(Point<2>( 5.00, 1.50), iv) == ColorInterp(2.00));
    BOOST_CHECK( interpolate(Point<2>( 5.00, 1.75), iv) == ColorInterp(2.00));
    BOOST_CHECK( interpolate(Point<2>( 5.00, 2.00), iv) == ColorInterp(9.00/6.0));
    BOOST_CHECK( interpolate(Point<2>( 5.00, 2.25), iv) == ColorInterp(1.00));
    BOOST_CHECK( interpolate(Point<2>( 5.00, 2.50), iv) == ColorInterp(1.00));
    BOOST_CHECK( interpolate(Point<2>( 5.00, 2.75), iv) == ColorInterp(1.00));
    BOOST_CHECK( interpolate(Point<2>( 5.00, 3.00), iv) == ColorInterp(1.00));
    BOOST_CHECK( interpolate(Point<2>(-5.00, 0.00), iv) == ColorInterp(1.00));
    BOOST_CHECK( interpolate(Point<2>(-5.00, 0.25), iv) == ColorInterp(1.00));
    BOOST_CHECK( interpolate(Point<2>(-5.00, 0.50), iv) == ColorInterp(1.00));
    BOOST_CHECK( interpolate(Point<2>(-5.00, 0.75), iv) == ColorInterp(1.00));
    BOOST_CHECK( interpolate(Point<2>(-5.00, 1.00), iv) == ColorInterp(9.00/6.00));
    BOOST_CHECK( interpolate(Point<2>(-5.00, 1.25), iv) == ColorInterp(2.00));
    BOOST_CHECK( interpolate(Point<2>(-5.00, 1.50), iv) == ColorInterp(2.00));
    BOOST_CHECK( interpolate(Point<2>(-5.00, 1.75), iv) == ColorInterp(2.00));
    BOOST_CHECK( interpolate(Point<2>(-5.00, 2.00), iv) == ColorInterp(13.00/6.0));
    BOOST_CHECK( interpolate(Point<2>(-5.00, 2.25), iv) == ColorInterp(2.50));
    BOOST_CHECK( interpolate(Point<2>(-5.00, 2.50), iv) == ColorInterp(2.50));
    BOOST_CHECK( interpolate(Point<2>(-5.00, 2.75), iv) == ColorInterp(2.50));
    BOOST_CHECK( interpolate(Point<2>(-5.00, 3.00), iv) == ColorInterp(2.50));
    
    /*
     * Interpolating (extrapolating) out-of-range corners
     */
    BOOST_CHECK( interpolate(Point<2>( -5.00, -5.00), iv) == ColorInterp(1.00));
    BOOST_CHECK( interpolate(Point<2>(  5.00, -5.00), iv) == ColorInterp(2.50));
    BOOST_CHECK( interpolate(Point<2>( -5.00,  5.00), iv) == ColorInterp(2.50));
    BOOST_CHECK( interpolate(Point<2>(  5.00,  5.00), iv) == ColorInterp(1.00));
}

BOOST_AUTO_TEST_CASE_TEMPLATE( test_Interpolator_nearest, T, ImageDataTypes )
{
    /*
     * Useful typedefs, the real data "Color" (normally integer) and the "interpolated Color" (float)
     */
    typedef typename ImaVol<T      ,1,2>::Color Color;
    typedef typename ImaVol<float64,1,2>::Color ColorInterp;
    
    /*
     * Creating the test data: an ImaVol with of 4x4 with values from 0 to 3 diagonally increasing
     * and decresing.
     */
    ImaVol<T,1,2> iv(4,4);
    
    Color c0 =  T(0);
    Color c1 =  T(1);
    Color c2 =  T(2);
    Color c3 =  T(3);
    
    iv(Coord2D<>(0,0)) = c0; iv(Coord2D<>(1,0)) = c1; iv(Coord2D<>(2,0)) = c2; iv(Coord2D<>(3,0)) = c3;
    iv(Coord2D<>(0,1)) = c1; iv(Coord2D<>(1,1)) = c2; iv(Coord2D<>(2,1)) = c3; iv(Coord2D<>(3,1)) = c2;
    iv(Coord2D<>(0,2)) = c2; iv(Coord2D<>(1,2)) = c3; iv(Coord2D<>(2,2)) = c2; iv(Coord2D<>(3,2)) = c1;
    iv(Coord2D<>(0,3)) = c3; iv(Coord2D<>(1,3)) = c2; iv(Coord2D<>(2,3)) = c1; iv(Coord2D<>(3,3)) = c0;
    
//    std::cout << "iv = " << std::endl;
//    std::cout <<  iv     << std::endl;

    /*
     * Creating the NEAREST_NEIGHBOR Interpolator
     */
    Interpolator<2> interpolate(NEAREST_NEIGHBOR);
    
    /*
     * Interpolating the diagonal Points
     */
    BOOST_CHECK( interpolate(Point<2>(0.00, 0.00), iv) == ColorInterp(0.00));
    BOOST_CHECK( interpolate(Point<2>(0.25, 0.25), iv) == ColorInterp(0.00));
    BOOST_CHECK( interpolate(Point<2>(0.50, 0.50), iv) == ColorInterp(2.00));
    BOOST_CHECK( interpolate(Point<2>(0.75, 0.75), iv) == ColorInterp(2.00));
    BOOST_CHECK( interpolate(Point<2>(1.00, 1.00), iv) == ColorInterp(2.00));
    BOOST_CHECK( interpolate(Point<2>(1.25, 1.25), iv) == ColorInterp(2.00));
    BOOST_CHECK( interpolate(Point<2>(1.50, 1.50), iv) == ColorInterp(2.00));
    BOOST_CHECK( interpolate(Point<2>(1.75, 1.75), iv) == ColorInterp(2.00));
    BOOST_CHECK( interpolate(Point<2>(2.00, 2.00), iv) == ColorInterp(2.00));
    BOOST_CHECK( interpolate(Point<2>(2.25, 2.25), iv) == ColorInterp(2.00));
    BOOST_CHECK( interpolate(Point<2>(2.50, 2.50), iv) == ColorInterp(0.00));
    BOOST_CHECK( interpolate(Point<2>(2.75, 2.75), iv) == ColorInterp(0.00));
    BOOST_CHECK( interpolate(Point<2>(3.00, 3.00), iv) == ColorInterp(0.00));
    
    /*
     * Interpolating the first column of Points
     */
    BOOST_CHECK( interpolate(Point<2>(0.00, 0.00), iv) == ColorInterp(0.00));
    BOOST_CHECK( interpolate(Point<2>(0.00, 0.25), iv) == ColorInterp(0.00));
    BOOST_CHECK( interpolate(Point<2>(0.00, 0.50), iv) == ColorInterp(1.00));
    BOOST_CHECK( interpolate(Point<2>(0.00, 0.75), iv) == ColorInterp(1.00));
    BOOST_CHECK( interpolate(Point<2>(0.00, 1.00), iv) == ColorInterp(1.00));
    BOOST_CHECK( interpolate(Point<2>(0.00, 1.25), iv) == ColorInterp(1.00));
    BOOST_CHECK( interpolate(Point<2>(0.00, 1.50), iv) == ColorInterp(2.00));
    BOOST_CHECK( interpolate(Point<2>(0.00, 1.75), iv) == ColorInterp(2.00));
    BOOST_CHECK( interpolate(Point<2>(0.00, 2.00), iv) == ColorInterp(2.00));
    BOOST_CHECK( interpolate(Point<2>(0.00, 2.25), iv) == ColorInterp(2.00));
    BOOST_CHECK( interpolate(Point<2>(0.00, 2.50), iv) == ColorInterp(3.00));
    BOOST_CHECK( interpolate(Point<2>(0.00, 2.75), iv) == ColorInterp(3.00));
    BOOST_CHECK( interpolate(Point<2>(0.00, 3.00), iv) == ColorInterp(3.00));

    /*
     * Interpolating the last column of Points
     */
    BOOST_CHECK( interpolate(Point<2>(3.00, 0.00), iv) == ColorInterp(3.00));
    BOOST_CHECK( interpolate(Point<2>(3.00, 0.25), iv) == ColorInterp(3.00));
    BOOST_CHECK( interpolate(Point<2>(3.00, 0.50), iv) == ColorInterp(2.00));
    BOOST_CHECK( interpolate(Point<2>(3.00, 0.75), iv) == ColorInterp(2.00));
    BOOST_CHECK( interpolate(Point<2>(3.00, 1.00), iv) == ColorInterp(2.00));
    BOOST_CHECK( interpolate(Point<2>(3.00, 1.25), iv) == ColorInterp(2.00));
    BOOST_CHECK( interpolate(Point<2>(3.00, 1.50), iv) == ColorInterp(1.00));
    BOOST_CHECK( interpolate(Point<2>(3.00, 1.75), iv) == ColorInterp(1.00));
    BOOST_CHECK( interpolate(Point<2>(3.00, 2.00), iv) == ColorInterp(1.00));
    BOOST_CHECK( interpolate(Point<2>(3.00, 2.25), iv) == ColorInterp(1.00));
    BOOST_CHECK( interpolate(Point<2>(3.00, 2.50), iv) == ColorInterp(0.00));
    BOOST_CHECK( interpolate(Point<2>(3.00, 2.75), iv) == ColorInterp(0.00));
    BOOST_CHECK( interpolate(Point<2>(3.00, 3.00), iv) == ColorInterp(0.00));

    /*
     * Interpolating the center column of Points
     */
    BOOST_CHECK( interpolate(Point<2>(1.50, 0.00), iv) == ColorInterp(2.00));
    BOOST_CHECK( interpolate(Point<2>(1.50, 0.25), iv) == ColorInterp(2.00));
    BOOST_CHECK( interpolate(Point<2>(1.50, 0.50), iv) == ColorInterp(3.00));
    BOOST_CHECK( interpolate(Point<2>(1.50, 0.75), iv) == ColorInterp(3.00));
    BOOST_CHECK( interpolate(Point<2>(1.50, 1.00), iv) == ColorInterp(3.00));
    BOOST_CHECK( interpolate(Point<2>(1.50, 1.25), iv) == ColorInterp(3.00));
    BOOST_CHECK( interpolate(Point<2>(1.50, 1.50), iv) == ColorInterp(2.00));
    BOOST_CHECK( interpolate(Point<2>(1.50, 1.75), iv) == ColorInterp(2.00));
    BOOST_CHECK( interpolate(Point<2>(1.50, 2.00), iv) == ColorInterp(2.00));
    BOOST_CHECK( interpolate(Point<2>(1.50, 2.25), iv) == ColorInterp(2.00));
    BOOST_CHECK( interpolate(Point<2>(1.50, 2.50), iv) == ColorInterp(1.00));
    BOOST_CHECK( interpolate(Point<2>(1.50, 2.75), iv) == ColorInterp(1.00));
    BOOST_CHECK( interpolate(Point<2>(1.50, 3.00), iv) == ColorInterp(1.00));
    
    /*
     * Interpolating the center row of Points
     */
    BOOST_CHECK( interpolate(Point<2>(0.00, 1.50), iv) == ColorInterp(2.00));
    BOOST_CHECK( interpolate(Point<2>(0.25, 1.50), iv) == ColorInterp(2.00));
    BOOST_CHECK( interpolate(Point<2>(0.50, 1.50), iv) == ColorInterp(3.00));
    BOOST_CHECK( interpolate(Point<2>(0.75, 1.50), iv) == ColorInterp(3.00));
    BOOST_CHECK( interpolate(Point<2>(1.00, 1.50), iv) == ColorInterp(3.00));
    BOOST_CHECK( interpolate(Point<2>(1.25, 1.50), iv) == ColorInterp(3.00));
    BOOST_CHECK( interpolate(Point<2>(1.50, 1.50), iv) == ColorInterp(2.00));
    BOOST_CHECK( interpolate(Point<2>(1.75, 1.50), iv) == ColorInterp(2.00));
    BOOST_CHECK( interpolate(Point<2>(2.00, 1.50), iv) == ColorInterp(2.00));
    BOOST_CHECK( interpolate(Point<2>(2.25, 1.50), iv) == ColorInterp(2.00));
    BOOST_CHECK( interpolate(Point<2>(2.50, 1.50), iv) == ColorInterp(1.00));
    BOOST_CHECK( interpolate(Point<2>(2.75, 1.50), iv) == ColorInterp(1.00));
    BOOST_CHECK( interpolate(Point<2>(3.00, 1.50), iv) == ColorInterp(1.00));
    
    /*
     * Interpolating the first row of Points
     */
    BOOST_CHECK( interpolate(Point<2>(0.00, 0.00), iv) == ColorInterp(0.00));
    BOOST_CHECK( interpolate(Point<2>(0.25, 0.00), iv) == ColorInterp(0.00));
    BOOST_CHECK( interpolate(Point<2>(0.50, 0.00), iv) == ColorInterp(1.00));
    BOOST_CHECK( interpolate(Point<2>(0.75, 0.00), iv) == ColorInterp(1.00));
    BOOST_CHECK( interpolate(Point<2>(1.00, 0.00), iv) == ColorInterp(1.00));
    BOOST_CHECK( interpolate(Point<2>(1.25, 0.00), iv) == ColorInterp(1.00));
    BOOST_CHECK( interpolate(Point<2>(1.50, 0.00), iv) == ColorInterp(2.00));
    BOOST_CHECK( interpolate(Point<2>(1.75, 0.00), iv) == ColorInterp(2.00));
    BOOST_CHECK( interpolate(Point<2>(2.00, 0.00), iv) == ColorInterp(2.00));
    BOOST_CHECK( interpolate(Point<2>(2.25, 0.00), iv) == ColorInterp(2.00));
    BOOST_CHECK( interpolate(Point<2>(2.50, 0.00), iv) == ColorInterp(3.00));
    BOOST_CHECK( interpolate(Point<2>(2.75, 0.00), iv) == ColorInterp(3.00));
    BOOST_CHECK( interpolate(Point<2>(3.00, 0.00), iv) == ColorInterp(3.00));

    /*
     * Interpolating the last row of Points
     */
    BOOST_CHECK( interpolate(Point<2>(0.00, 3.00), iv) == ColorInterp(3.00));
    BOOST_CHECK( interpolate(Point<2>(0.25, 3.00), iv) == ColorInterp(3.00));
    BOOST_CHECK( interpolate(Point<2>(0.50, 3.00), iv) == ColorInterp(2.00));
    BOOST_CHECK( interpolate(Point<2>(0.75, 3.00), iv) == ColorInterp(2.00));
    BOOST_CHECK( interpolate(Point<2>(1.00, 3.00), iv) == ColorInterp(2.00));
    BOOST_CHECK( interpolate(Point<2>(1.25, 3.00), iv) == ColorInterp(2.00));
    BOOST_CHECK( interpolate(Point<2>(1.50, 3.00), iv) == ColorInterp(1.00));
    BOOST_CHECK( interpolate(Point<2>(1.75, 3.00), iv) == ColorInterp(1.00));
    BOOST_CHECK( interpolate(Point<2>(2.00, 3.00), iv) == ColorInterp(1.00));
    BOOST_CHECK( interpolate(Point<2>(2.25, 3.00), iv) == ColorInterp(1.00));
    BOOST_CHECK( interpolate(Point<2>(2.50, 3.00), iv) == ColorInterp(0.00));
    BOOST_CHECK( interpolate(Point<2>(2.75, 3.00), iv) == ColorInterp(0.00));
    BOOST_CHECK( interpolate(Point<2>(3.00, 3.00), iv) == ColorInterp(0.00));

    /*
     * Interpolating (extrapolating) out-of-range rows of Points
     */
    BOOST_CHECK( interpolate(Point<2>(0.00,  5.00), iv) == ColorInterp(3.00));
    BOOST_CHECK( interpolate(Point<2>(0.25,  5.00), iv) == ColorInterp(3.00));
    BOOST_CHECK( interpolate(Point<2>(0.50,  5.00), iv) == ColorInterp(2.00));
    BOOST_CHECK( interpolate(Point<2>(0.75,  5.00), iv) == ColorInterp(2.00));
    BOOST_CHECK( interpolate(Point<2>(1.00,  5.00), iv) == ColorInterp(2.00));
    BOOST_CHECK( interpolate(Point<2>(1.25,  5.00), iv) == ColorInterp(2.00));
    BOOST_CHECK( interpolate(Point<2>(1.50,  5.00), iv) == ColorInterp(1.00));
    BOOST_CHECK( interpolate(Point<2>(1.75,  5.00), iv) == ColorInterp(1.00));
    BOOST_CHECK( interpolate(Point<2>(2.00,  5.00), iv) == ColorInterp(1.00));
    BOOST_CHECK( interpolate(Point<2>(2.25,  5.00), iv) == ColorInterp(1.00));
    BOOST_CHECK( interpolate(Point<2>(2.50,  5.00), iv) == ColorInterp(0.00));
    BOOST_CHECK( interpolate(Point<2>(2.75,  5.00), iv) == ColorInterp(0.00));
    BOOST_CHECK( interpolate(Point<2>(3.00,  5.00), iv) == ColorInterp(0.00));
    BOOST_CHECK( interpolate(Point<2>(0.00, -5.00), iv) == ColorInterp(0.00));
    BOOST_CHECK( interpolate(Point<2>(0.25, -5.00), iv) == ColorInterp(0.00));
    BOOST_CHECK( interpolate(Point<2>(0.50, -5.00), iv) == ColorInterp(1.00));
    BOOST_CHECK( interpolate(Point<2>(0.75, -5.00), iv) == ColorInterp(1.00));
    BOOST_CHECK( interpolate(Point<2>(1.00, -5.00), iv) == ColorInterp(1.00));
    BOOST_CHECK( interpolate(Point<2>(1.25, -5.00), iv) == ColorInterp(1.00));
    BOOST_CHECK( interpolate(Point<2>(1.50, -5.00), iv) == ColorInterp(2.00));
    BOOST_CHECK( interpolate(Point<2>(1.75, -5.00), iv) == ColorInterp(2.00));
    BOOST_CHECK( interpolate(Point<2>(2.00, -5.00), iv) == ColorInterp(2.00));
    BOOST_CHECK( interpolate(Point<2>(2.25, -5.00), iv) == ColorInterp(2.00));
    BOOST_CHECK( interpolate(Point<2>(2.50, -5.00), iv) == ColorInterp(3.00));
    BOOST_CHECK( interpolate(Point<2>(2.75, -5.00), iv) == ColorInterp(3.00));
    BOOST_CHECK( interpolate(Point<2>(3.00, -5.00), iv) == ColorInterp(3.00));

    /*
     * Interpolating (extrapolating) out-of-range columns of Points
     */
    BOOST_CHECK( interpolate(Point<2>( 5.00, 0.00), iv) == ColorInterp(3.00));
    BOOST_CHECK( interpolate(Point<2>( 5.00, 0.25), iv) == ColorInterp(3.00));
    BOOST_CHECK( interpolate(Point<2>( 5.00, 0.50), iv) == ColorInterp(2.00));
    BOOST_CHECK( interpolate(Point<2>( 5.00, 0.75), iv) == ColorInterp(2.00));
    BOOST_CHECK( interpolate(Point<2>( 5.00, 1.00), iv) == ColorInterp(2.00));
    BOOST_CHECK( interpolate(Point<2>( 5.00, 1.25), iv) == ColorInterp(2.00));
    BOOST_CHECK( interpolate(Point<2>( 5.00, 1.50), iv) == ColorInterp(1.00));
    BOOST_CHECK( interpolate(Point<2>( 5.00, 1.75), iv) == ColorInterp(1.00));
    BOOST_CHECK( interpolate(Point<2>( 5.00, 2.00), iv) == ColorInterp(1.00));
    BOOST_CHECK( interpolate(Point<2>( 5.00, 2.25), iv) == ColorInterp(1.00));
    BOOST_CHECK( interpolate(Point<2>( 5.00, 2.50), iv) == ColorInterp(0.00));
    BOOST_CHECK( interpolate(Point<2>( 5.00, 2.75), iv) == ColorInterp(0.00));
    BOOST_CHECK( interpolate(Point<2>( 5.00, 3.00), iv) == ColorInterp(0.00));
    BOOST_CHECK( interpolate(Point<2>(-5.00, 0.00), iv) == ColorInterp(0.00));
    BOOST_CHECK( interpolate(Point<2>(-5.00, 0.25), iv) == ColorInterp(0.00));
    BOOST_CHECK( interpolate(Point<2>(-5.00, 0.50), iv) == ColorInterp(1.00));
    BOOST_CHECK( interpolate(Point<2>(-5.00, 0.75), iv) == ColorInterp(1.00));
    BOOST_CHECK( interpolate(Point<2>(-5.00, 1.00), iv) == ColorInterp(1.00));
    BOOST_CHECK( interpolate(Point<2>(-5.00, 1.25), iv) == ColorInterp(1.00));
    BOOST_CHECK( interpolate(Point<2>(-5.00, 1.50), iv) == ColorInterp(2.00));
    BOOST_CHECK( interpolate(Point<2>(-5.00, 1.75), iv) == ColorInterp(2.00));
    BOOST_CHECK( interpolate(Point<2>(-5.00, 2.00), iv) == ColorInterp(2.00));
    BOOST_CHECK( interpolate(Point<2>(-5.00, 2.25), iv) == ColorInterp(2.00));
    BOOST_CHECK( interpolate(Point<2>(-5.00, 2.50), iv) == ColorInterp(3.00));
    BOOST_CHECK( interpolate(Point<2>(-5.00, 2.75), iv) == ColorInterp(3.00));
    BOOST_CHECK( interpolate(Point<2>(-5.00, 3.00), iv) == ColorInterp(3.00));
    
    /*
     * Interpolating (extrapolating) out-of-range corners
     */
    BOOST_CHECK( interpolate(Point<2>( -5.00, -5.00), iv) == ColorInterp(0.00));
    BOOST_CHECK( interpolate(Point<2>(  5.00, -5.00), iv) == ColorInterp(3.00));
    BOOST_CHECK( interpolate(Point<2>( -5.00,  5.00), iv) == ColorInterp(3.00));
    BOOST_CHECK( interpolate(Point<2>(  5.00,  5.00), iv) == ColorInterp(0.00));
}

BOOST_AUTO_TEST_CASE ( test_grid_1 )
{
    std::vector< Point<2> >  gridp = grid (Point<2> (0.0, 0.0), Point<2> (5.0, 5.0), Point<2> (1.0, 1.0));
    std::vector< Coord2D<> > gridc = grid (Coord2D<>(0,   0  ), Coord2D<>(5  , 5  ), Coord2D<>(1  , 1  ));

    BOOST_CHECK(gridp.size() == 36);
    BOOST_CHECK(gridc.size() == 36);
    
    MultiArray<Point<2>,2> grid( 6, 6 );
    
    for(std::size_t ii=0; ii < gridc.size(); ++ii ) grid(gridc[ii]) = gridp[ii];
    
    for (std::size_t yy = 0; yy < grid.dims(1); ++yy)
    for (std::size_t xx = 0; xx < grid.dims(0); ++xx)
    {
        BOOST_CHECK_SMALL ( grid[xx][yy].x() - xx, 1.0e-5);
        BOOST_CHECK_SMALL ( grid[xx][yy].y() - yy, 1.0e-5);
    }
}

//BOOST_AUTO_TEST_CASE ( points_grid_test_2 )
//{
//    //MultiArray<Point<2>,2> grid2;
//    //grid2 = points_grid (Point<2>(0.0, 0.0), Point<2>(5.0, 5.0), 0.5, 0.5);
//    std::vector< Point<2> > grid2 = grid (Point<2>(0.0, 0.0), Point<2>(5.0, 5.0), Point<2>(0.5, 0.5));
//    
//    BOOST_CHECK(grid2.dims(0) == 11);
//    BOOST_CHECK(grid2.dims(1) == 11);
//
//    for (std::size_t jj = 0; jj < grid2.dims(1); ++jj)
//    for (std::size_t ii = 0; ii < grid2.dims(0); ++ii)
//    {
//        BOOST_CHECK_SMALL ( grid2[ii][jj].x() - ii*0.5, 1.0e-5);
//        BOOST_CHECK_SMALL ( grid2[ii][jj].y() - jj*0.5, 1.0e-5);
//    }
//}

//BOOST_AUTO_TEST_CASE ( points_grid_test_3 )
//{
//    MultiArray<Point<2>,2> grid3;
//    grid3 = points_grid (Point<2>(-2.0, -2.0),Point<2>(2.0, 2.0), 1.0, 0.5);
//    
//    BOOST_CHECK(grid3.dims(0) == 5);
//    BOOST_CHECK(grid3.dims(1) == 9);
//
//    float64 xx;
//    float64 yy=-2.0;
//    for (std::size_t jj = 0; jj < grid3.dims(1); ++jj)
//    {
//        xx  = -2.0;
//        for (std::size_t ii = 0; ii < grid3.dims(0); ++ii)
//        {
//            BOOST_CHECK_SMALL ( grid3[ii][jj].x() - xx, 1.0e-5);
//            BOOST_CHECK_SMALL ( grid3[ii][jj].y() - yy, 1.0e-5);
//            xx +=  1.0;
//        }
//        yy +=  0.5;
//    }
//}
//
//BOOST_AUTO_TEST_CASE ( points_grid_test_4 )
//{
//    MultiArray<Point<2>,2> grid4;
//    grid4 = points_grid (Point<2>(0.0, 0.0), Point<2>(5.0, 5.0), 1.0/3.0, 1.0/3.0);
//    
//    BOOST_CHECK(grid4.dims(0) == 16);
//    BOOST_CHECK(grid4.dims(1) == 16);
//
//    for (std::size_t jj = 0; jj < grid4.dims(1); ++jj)
//    for (std::size_t ii = 0; ii < grid4.dims(0); ++ii)
//    {
//        BOOST_CHECK_SMALL ( grid4[ii][jj].x() - ii*(1.0/3.0), 1.0e-5);
//        BOOST_CHECK_SMALL ( grid4[ii][jj].y() - jj*(1.0/3.0), 1.0e-5);
//    }
//} 



#if 0

BOOST_AUTO_TEST_CASE ( points_grid_test_1 )
{
    MultiArray<Point<2>,2> grid1;
    grid1 = points_grid (Point<2>(0.0, 0.0), Point<2>(5.0, 5.0), 1.0, 1.0);

    BOOST_CHECK(grid1.dims(0) == 6);
    BOOST_CHECK(grid1.dims(1) == 6);
    
    for (std::size_t jj = 0; jj < grid1.dims(1); ++jj)
    for (std::size_t ii = 0; ii < grid1.dims(0); ++ii)
    {
        BOOST_CHECK_SMALL ( grid1[ii][jj].x() - ii, 1.0e-5);
        BOOST_CHECK_SMALL ( grid1[ii][jj].y() - jj, 1.0e-5);
    }
}

BOOST_AUTO_TEST_CASE ( points_grid_test_2 )
{
    MultiArray<Point<2>,2> grid2;
    grid2 = points_grid (Point<2>(0.0, 0.0), Point<2>(5.0, 5.0), 0.5, 0.5);
    
    BOOST_CHECK(grid2.dims(0) == 11);
    BOOST_CHECK(grid2.dims(1) == 11);

    for (std::size_t jj = 0; jj < grid2.dims(1); ++jj)
    for (std::size_t ii = 0; ii < grid2.dims(0); ++ii)
    {
        BOOST_CHECK_SMALL ( grid2[ii][jj].x() - ii*0.5, 1.0e-5);
        BOOST_CHECK_SMALL ( grid2[ii][jj].y() - jj*0.5, 1.0e-5);
    }
}

BOOST_AUTO_TEST_CASE ( points_grid_test_3 )
{
    MultiArray<Point<2>,2> grid3;
    grid3 = points_grid (Point<2>(-2.0, -2.0),Point<2>(2.0, 2.0), 1.0, 0.5);
    
    BOOST_CHECK(grid3.dims(0) == 5);
    BOOST_CHECK(grid3.dims(1) == 9);

    float64 xx;
    float64 yy=-2.0;
    for (std::size_t jj = 0; jj < grid3.dims(1); ++jj)
    {
        xx  = -2.0;
        for (std::size_t ii = 0; ii < grid3.dims(0); ++ii)
        {
            BOOST_CHECK_SMALL ( grid3[ii][jj].x() - xx, 1.0e-5);
            BOOST_CHECK_SMALL ( grid3[ii][jj].y() - yy, 1.0e-5);
            xx +=  1.0;
        }
        yy +=  0.5;
    }
}

BOOST_AUTO_TEST_CASE ( points_grid_test_4 )
{
    MultiArray<Point<2>,2> grid4;
    grid4 = points_grid (Point<2>(0.0, 0.0), Point<2>(5.0, 5.0), 1.0/3.0, 1.0/3.0);
    
    BOOST_CHECK(grid4.dims(0) == 16);
    BOOST_CHECK(grid4.dims(1) == 16);

    for (std::size_t jj = 0; jj < grid4.dims(1); ++jj)
    for (std::size_t ii = 0; ii < grid4.dims(0); ++ii)
    {
        BOOST_CHECK_SMALL ( grid4[ii][jj].x() - ii*(1.0/3.0), 1.0e-5);
        BOOST_CHECK_SMALL ( grid4[ii][jj].y() - jj*(1.0/3.0), 1.0e-5);
    }
} 

typedef boost::mpl::list< /*uint8, int64,*/ float64 > ImageDataTypesOld;

BOOST_AUTO_TEST_CASE_TEMPLATE( interpolation_test_performance, T, ImageDataTypesOld )
{
    /*
     * Creating the test data: an ImaVol and a set of Points 
     */
    ImaVol<T,1,2> iv(3,3);
    ImaVol<T,3,2> iv3(3,3);
    
    for(std::size_t ii=0; ii<iv(0).num_elements(); ++ii)
    {
        iv(0).data()[ii] = ii*ii;
        iv3(0).data()[ii] = ii*ii;
        iv3(1).data()[ii] = ii*ii;
        iv3(2).data()[ii] = ii*ii;
    }
    
    std::cout << "iv=" << std::endl;
    std::cout << iv    << std::endl;
    
    std::vector< Point<2> > vp;
    std::vector< Coord<std::size_t, 2> > vpsize;
    std::vector< Point<2>              > vpfactor;
    for(std::size_t it=0; it<500000;++it)
    {
        vp      .push_back(Point<2>(rand_uniform()        , rand_uniform()));
        //vpsize  .push_back(Point<2>(rand_uniform(1.0,15.0), rand_uniform(1.0,15.0)));
        vpsize  .push_back(Coord<std::size_t, 2>(rand_uniform_int(1,15), rand_uniform_int(1,15)));
        vpfactor.push_back(Point<2>( Point<2>(vpsize[it]) / float64(3.0) ));
        
    }

    /*
     * Test variables
     */
    std::vector< ImaVol<float64,1,2>::Color > voutc  (vp.size());
    std::vector< ImaVol<float64,3,2>::Color > voutc3 (vp.size());
    std::vector< ImaVol<T,1,2>              > voutiv (vp.size());
    std::vector< float64 >                    voutf  (vp.size());
    std::vector< boost::array<float64,3 > >   voutf3 (vp.size());
    Timestamp ts_begin;
    Timestamp ts_end;
    
    ts_begin = clock_ts();
    for(std::size_t it=0; it<vp.size();++it)
    {
        voutiv[it] = resize(iv, vpsize[it], WEIGHTED_MEAN);
    }
    ts_end = clock_ts();
    
    std::cout << "TIME OF resize(iv, vpsize[it], WEIGHTED_MEAN); = " << Timestamp(ts_end - ts_begin) << std::endl;
    

    ts_begin = clock_ts();
    for(std::size_t it=0; it<vp.size();++it)
    {
        voutiv[it](0) = resize(iv(0), vpfactor[it].x(), vpfactor[it].y());
    }
    ts_end = clock_ts();
    
    std::cout << "TIME OF resize(iv(0), vpfactor[it].x(), vpfactor[it].y()); = " << Timestamp(ts_end - ts_begin) << std::endl;



    /*
     * Create the interpolator
     */
    Interpolator<2> interpole(LINEAR);

    
    ts_begin = clock_ts();
    for(std::size_t it=0; it<vp.size();++it)
    {
        voutc[it] = interpole(vp[it], iv);
    }
    ts_end = clock_ts();
    
    std::cout << "TIME OF interpole(vp[it], iv) = " << Timestamp(ts_end - ts_begin) << std::endl;
    

    ts_begin = clock_ts();
    for(std::size_t it=0; it<vp.size();++it)
    {
        voutf[it] = interpolation (iv(0), vp[it], LINEAR);
    }
    ts_end = clock_ts();
    
    std::cout << "TIME OF interpolation (iv(0), vp[it], LINEAR) = " << Timestamp(ts_end - ts_begin) << std::endl;

    
    ts_begin = clock_ts();
    for(std::size_t it=0; it<vp.size();++it)
    {
        voutf[it] = bilinear_interpolation(vp[it], iv(0));
    }
    ts_end = clock_ts();
    
    std::cout << "TIME OF bilinear_interpolation(vp[it], iv(0)) = " << Timestamp(ts_end - ts_begin) << std::endl;
    
    
    ts_begin = clock_ts();
    for(std::size_t it=0; it<vp.size();++it)
    {
        voutc3[it] = interpole(vp[it], iv3);
    }
    ts_end = clock_ts();
    
    std::cout << "TIME OF interpole(vp[it], iv3) = " << Timestamp(ts_end - ts_begin) << std::endl;
    ts_begin = clock_ts();
    for(std::size_t it=0; it<vp.size();++it)
    {
        voutf3[it][0] = bilinear_interpolation(vp[it], iv3(0));
        voutf3[it][1] = bilinear_interpolation(vp[it], iv3(1));
        voutf3[it][2] = bilinear_interpolation(vp[it], iv3(2));
    }
    ts_end = clock_ts();
    
    std::cout << "TIME OF bilinear_interpolation(vp[it], iv3(N)) = " << Timestamp(ts_end - ts_begin) << std::endl;
    
    ts_begin = clock_ts();
    for(std::size_t it=0; it<vp.size();++it)
    {
        voutf3[it][0] = interpolation (iv3(0), vp[it], LINEAR);
        voutf3[it][1] = interpolation (iv3(1), vp[it], LINEAR);
        voutf3[it][2] = interpolation (iv3(2), vp[it], LINEAR);
    }
    ts_end = clock_ts();
    
    std::cout << "TIME OF interpolation (iv3(N), vp[it], LINEAR) = " << Timestamp(ts_end - ts_begin) << std::endl;



    for(std::size_t it=0; it<vp.size();++it)
    {
        BOOST_CHECK_CLOSE(voutc[it][0], voutf[it], 0.0001);
//        if (voutc[it][0] != voutf[it])
//        {
//            std::cout << "it           = " << it           << std::endl;
//            std::cout << "vp[it]       = " << vp[it]       << std::endl;
//            std::cout << "voutc[it][0] = " << voutc[it][0] << std::endl;
//            std::cout << "voutf[it]    = " << voutc[it]    << std::endl;
//        }
    }

    interpole.type(WEIGHTED_MEAN);
    
    ts_begin = clock_ts();
    for(std::size_t it=0; it<vp.size();++it)
    {
        voutc[it] = interpole(vp[it], iv);
    }
    ts_end = clock_ts();
    
    std::cout << "TIME OF interpole(vp[it], iv) WEIGHTED_MEAN= " << Timestamp(ts_end - ts_begin) << std::endl;
    
//    for(std::size_t it=0; it<vp.size();++it)
//    {
//        BOOST_CHECK_CLOSE(voutc[it][0], voutf[it], 0.0001);
////        if (voutc[it][0] != voutf[it])
////        {
////            std::cout << "it           = " << it           << std::endl;
////            std::cout << "vp[it]       = " << vp[it]       << std::endl;
////            std::cout << "voutc[it][0] = " << voutc[it][0] << std::endl;
////            std::cout << "voutf[it]    = " << voutc[it]    << std::endl;
////        }
//    }


    
    interpole.type(MEAN);
    
    ts_begin = clock_ts();
    for(std::size_t it=0; it<vp.size();++it)
    {
        voutc[it] = interpole(vp[it], iv);
    }
    ts_end = clock_ts();
    
    std::cout << "TIME OF interpole(vp[it], iv) = " << Timestamp(ts_end - ts_begin) << std::endl;
    

    ts_begin = clock_ts();
    for(std::size_t it=0; it<vp.size();++it)
    {
        voutf[it] = interpolation (iv(0), vp[it], MEAN);
    }
    ts_end = clock_ts();
    
    std::cout << "TIME OF interpolation (iv(0), vp[it], MEAN) = " << Timestamp(ts_end - ts_begin) << std::endl;

    for(std::size_t it=0; it<vp.size();++it)
    {
        BOOST_CHECK(voutc[it][0] == voutf[it]);
    }
    
    
    interpole.type(MEDIAN);
    
    ts_begin = clock_ts();
    for(std::size_t it=0; it<vp.size();++it)
    {
        voutc[it] = interpole(vp[it], iv);
    }
    ts_end = clock_ts();
    
    std::cout << "TIME OF interpole(vp[it], iv) = " << Timestamp(ts_end - ts_begin) << std::endl;
    

    ts_begin = clock_ts();
    for(std::size_t it=0; it<vp.size();++it)
    {
        voutf[it] = interpolation (iv(0), vp[it], MEDIAN);
    }
    ts_end = clock_ts();
    
    std::cout << "TIME OF interpolation (iv(0), vp[it], MEDIAN) = " << Timestamp(ts_end - ts_begin) << std::endl;

    for(std::size_t it=0; it<vp.size();++it)
    {
        BOOST_CHECK(voutc[it][0] == voutf[it]);
    }

    
    interpole.type(LINEAR);

    std::cout << "cc1=" <<          interpole    (Point<2>(0.25, 0.25), iv   ) << std::endl;
    std::cout << "cc2=" << bilinear_interpolation(Point<2>(0.25, 0.25), iv(0)) << std::endl;

    std::cout << "cc1=" <<          interpole    (Point<2>(0.50, 0.50), iv   ) << std::endl;
    std::cout << "cc2=" << bilinear_interpolation(Point<2>(0.50, 0.50), iv(0)) << std::endl;

    std::cout << "cc1=" <<          interpole    (Point<2>(0.75, 0.75), iv   ) << std::endl;
    std::cout << "cc2=" << bilinear_interpolation(Point<2>(0.75, 0.75), iv(0)) << std::endl;

    std::cout << "cc1=" <<          interpole    (Point<2>(1.00, 1.00), iv   ) << std::endl;
    std::cout << "cc2=" << bilinear_interpolation(Point<2>(1.00, 1.00), iv(0)) << std::endl;
    
    interpole.type(WEIGHTED_MEAN);

    std::cout << "cc11=" <<          interpole    (Point<2>(0.25, 0.25), iv   ) << std::endl;
    std::cout << "cc22=" << bilinear_interpolation(Point<2>(0.25, 0.25), iv(0)) << std::endl;

    std::cout << "cc11=" <<          interpole    (Point<2>(0.50, 0.50), iv   ) << std::endl;
    std::cout << "cc22=" << bilinear_interpolation(Point<2>(0.50, 0.50), iv(0)) << std::endl;

    std::cout << "cc11=" <<          interpole    (Point<2>(0.75, 0.75), iv   ) << std::endl;
    std::cout << "cc22=" << bilinear_interpolation(Point<2>(0.75, 0.75), iv(0)) << std::endl;

    std::cout << "cc11=" <<          interpole    (Point<2>(1.00, 1.00), iv   ) << std::endl;
    std::cout << "cc22=" << bilinear_interpolation(Point<2>(1.00, 1.00), iv(0)) << std::endl;
    
    interpole.type(NEAREST_NEIGHBOR);

    std::cout << "cc11=" <<          interpole    (Point<2>(0.25, 0.25), iv   ) << std::endl;
    std::cout << "cc11=" <<          interpole    (Point<2>(0.50, 0.50), iv   ) << std::endl;
    std::cout << "cc11=" <<          interpole    (Point<2>(0.75, 0.75), iv   ) << std::endl;
    std::cout << "cc11=" <<          interpole    (Point<2>(1.00, 1.00), iv   ) << std::endl;
}
#endif

#ifdef AGIL_COMMENTED_OUT

BOOST_AUTO_TEST_CASE_TEMPLATE( interpolation_test_01, T, ImageDataTypes )
{
    MultiArray<T,2> ma(3,3);
    
    for(std::size_t ii=0; ii<ma.num_elements(); ++ii) ma.data()[ii] = ii*ii;
    
    std::cout << "ma=" << std::endl;
    std::cout << ma    << std::endl;

    float64 out1 = 0.0;
    float64 out2 = 0.0;
    
    BOOST_CHECK( interpolation (ma, Point<2>(0.2, 0.2), MEAN) ==  26.0/4.0 );
    BOOST_CHECK( interpolation (ma, Point<2>(0.8, 0.8), MEAN) ==  26.0/4.0 );
    BOOST_CHECK( interpolation (ma, Point<2>(1.2, 1.2), MEAN) == 154.0/4.0 );
    BOOST_CHECK( interpolation (ma, Point<2>(1.8, 1.8), MEAN) == 154.0/4.0 );
    
    BOOST_CHECK( interpolation (ma, Point<2>(0.2, 0.2), MEDIAN) ==  5.0 );
    BOOST_CHECK( interpolation (ma, Point<2>(0.8, 0.8), MEDIAN) ==  5.0 );
    BOOST_CHECK( interpolation (ma, Point<2>(1.2, 1.2), MEDIAN) == 37.0 );
    BOOST_CHECK( interpolation (ma, Point<2>(1.8, 1.8), MEDIAN) == 37.0 );

//    BOOST_CHECK( interpolation (ma, Point<2>(-0.7, 0.7), MEAN)   ==  0.0 );
//    BOOST_CHECK( interpolation (ma, Point<2>(-0.7, 0.7), MEDIAN) ==  0.0 );
//    BOOST_CHECK( interpolation (ma, Point<2>(-0.7, 0.7), LINEAR)   ==  0.0 );

    std::cout << "MEAN - NEGATIVE     = " << interpolation (ma, Point<2>(-0.7, 0.7), MEAN)  << std::endl;
    std::cout << "MEDIAN - NEGATIVE   = " << interpolation (ma, Point<2>(-0.7, 0.7), MEDIAN)  << std::endl;
    std::cout << "LINEAR - NEGATIVE = " << interpolation (ma, Point<2>(-0.7, 0.7), LINEAR)  << std::endl;
    
//    std::cout << "MEAN - NEGATIVE     = " << interpolation (ma, Point<2>(-1.7, 1.7), MEAN)  << std::endl;
//    std::cout << "MEDIAN - NEGATIVE   = " << interpolation (ma, Point<2>(-1.7, 1.7), MEDIAN)  << std::endl;
//    std::cout << "LINEAR - NEGATIVE = " << interpolation (ma, Point<2>(-1.7, 1.7), LINEAR)  << std::endl;

    
    out1 = interpolation (ma, Point<2>(1.0, 1.0), LINEAR);
    out2 = interpolation (ma, Point<2>(0.0, 0.0), LINEAR);
    std::cout << "LINEAR1 =" << out1 << std::endl;
    std::cout << "LINEAR2 =" << out2 << std::endl;
    std::cout << "LINEAR3 =" << LINEAR_interpolation(ma, Point<2>(1.0, 1.0)) << std::endl;
    std::cout << "LINEAR4 =" << bilinear_interpolation(ma, Point<2>(0.0, 0.0)) << std::endl;
    
    out1 = interpolation (ma, Point<2>(1.0, 1.0), MEAN);
    out2 = interpolation (ma, Point<2>(0.0, 0.0), MEAN);
    std::cout << "MEAN1     =" << out1 << std::endl;
    std::cout << "MEAN2     =" << out2 << std::endl;
    
    out1 = interpolation (ma, Point<2>(1.0, 1.0), MEDIAN);
    out2 = interpolation (ma, Point<2>(0.0, 0.0), MEDIAN);
    std::cout << "MEDIAN1   =" << out1 << std::endl;
    std::cout << "MEDIAN2   =" << out2 << std::endl;
}

typedef boost::mpl::list<float64> DataTypes;

// TODO: 
//  - Interpolation() (with mask and for Image<>)

BOOST_AUTO_TEST_CASE_TEMPLATE( interp2_test, T, DataTypes )
{
    ImageGray<T> ima(3,3);

    ima(0)[0][0] = 3;
    ima(0)[1][0] = 7;
    ima(0)[2][0] = 21;

    ima(0)[0][1] = 4;
    ima(0)[1][1] = 9;
    ima(0)[2][1] = 8;

    ima(0)[0][2] = 0;
    ima(0)[1][2] = 3;
    ima(0)[2][2] = 5;


    // result image
    ImageGray<T> interp_nn(6,6);

    interp_nn(0)[0][0] = 3;
    interp_nn(0)[1][0] = 3;
    interp_nn(0)[2][0] = 7;
    interp_nn(0)[3][0] = 7;
    interp_nn(0)[4][0] = 21;
    interp_nn(0)[5][0] = 21;

    interp_nn(0)[0][1] = 3;  //3.5 
    interp_nn(0)[1][1] = 3;  //5.75
    interp_nn(0)[2][1] = 7;  //8
    interp_nn(0)[3][1] = 7;  //11.25
    interp_nn(0)[4][1] = 21;  //14.5
    interp_nn(0)[5][1] = 21;  //14.5

    interp_nn(0)[0][2] = 4;
    interp_nn(0)[1][2] = 4;  //6.5
    interp_nn(0)[2][2] = 9;
    interp_nn(0)[3][2] = 9;  //8.5
    interp_nn(0)[4][2] = 8;
    interp_nn(0)[5][2] = 8;

    interp_nn(0)[0][3] = 4;  //2
    interp_nn(0)[1][3] = 4;  //4
    interp_nn(0)[2][3] = 9;  //6
    interp_nn(0)[3][3] = 9;  //6.25
    interp_nn(0)[4][3] = 8;  //6.5
    interp_nn(0)[5][3] = 8;  //6.5

    interp_nn(0)[0][4] = 0;
    interp_nn(0)[1][4] = 0;  //1.5
    interp_nn(0)[2][4] = 3;
    interp_nn(0)[3][4] = 3;  //4
    interp_nn(0)[4][4] = 5;
    interp_nn(0)[5][4] = 5;

    interp_nn(0)[0][5] = 0;
    interp_nn(0)[1][5] = 0;  //1.5
    interp_nn(0)[2][5] = 3;
    interp_nn(0)[3][5] = 3;  //4
    interp_nn(0)[4][5] = 5;
    interp_nn(0)[5][5] = 5;


    ImageGray<T> interp_bi(6,6);

    interp_bi(0)[0][0] = 3;
    interp_bi(0)[1][0] = 5;
    interp_bi(0)[2][0] = 7;
    interp_bi(0)[3][0] = 14;
    interp_bi(0)[4][0] = 21;
    interp_bi(0)[5][0] = 21;

    interp_bi(0)[0][1] = 3.5;
    interp_bi(0)[1][1] = 5.75;
    interp_bi(0)[2][1] = 8;
    interp_bi(0)[3][1] = 11.25;
    interp_bi(0)[4][1] = 14.5;
    interp_bi(0)[5][1] = 14.5;

    interp_bi(0)[0][2] = 4;
    interp_bi(0)[1][2] = 6.5;
    interp_bi(0)[2][2] = 9;
    interp_bi(0)[3][2] = 8.5;
    interp_bi(0)[4][2] = 8;
    interp_bi(0)[5][2] = 8;

    interp_bi(0)[0][3] = 2;
    interp_bi(0)[1][3] = 4;
    interp_bi(0)[2][3] = 6;
    interp_bi(0)[3][3] = 6.25;
    interp_bi(0)[4][3] = 6.5;
    interp_bi(0)[5][3] = 6.5;

    interp_bi(0)[0][4] = 0;
    interp_bi(0)[1][4] = 1.5;
    interp_bi(0)[2][4] = 3;
    interp_bi(0)[3][4] = 4;
    interp_bi(0)[4][4] = 5;
    interp_bi(0)[5][4] = 5;

    interp_bi(0)[0][5] = 0;
    interp_bi(0)[1][5] = 1.5;
    interp_bi(0)[2][5] = 3;
    interp_bi(0)[3][5] = 4;
    interp_bi(0)[4][5] = 5;
    interp_bi(0)[5][5] = 5;


    ImageMask mask(3,3);

    mask[0][0] = true;
    mask[1][0] = true;
    mask[2][0] = true;

    mask[0][1] = true;
    mask[1][1] = true;
    mask[2][1] = false;

    mask[0][2] = false;
    mask[1][2] = false;
    mask[2][2] = false;



    // result image (masked)
    ImageGray<T> m_interp_nn(6,6);

    m_interp_nn(0)[0][0] = 3;
    m_interp_nn(0)[1][0] = 3; // 5
    m_interp_nn(0)[2][0] = 7;
    m_interp_nn(0)[3][0] = 7; //14
    m_interp_nn(0)[4][0] = 21;
    m_interp_nn(0)[5][0] = 21;

    m_interp_nn(0)[0][1] = 3;  //3.5 
    m_interp_nn(0)[1][1] = 3;  //5.75
    m_interp_nn(0)[2][1] = 7;  //8
    m_interp_nn(0)[3][1] = 7;  //11.25
    m_interp_nn(0)[4][1] = 21;  //14.5
    m_interp_nn(0)[5][1] = 21;  //14.5

    m_interp_nn(0)[0][2] = 4;
    m_interp_nn(0)[1][2] = 4;  //6.5
    m_interp_nn(0)[2][2] = 9;
    m_interp_nn(0)[3][2] = 9;  //8.5
    m_interp_nn(0)[4][2] = 0;
    m_interp_nn(0)[5][2] = 0;

    m_interp_nn(0)[0][3] = 4;  //2
    m_interp_nn(0)[1][3] = 4;  //4
    m_interp_nn(0)[2][3] = 9;  //6
    m_interp_nn(0)[3][3] = 9;  //6.25
    m_interp_nn(0)[4][3] = 0;  //6.5
    m_interp_nn(0)[5][3] = 0;  //6.5

    m_interp_nn(0)[0][4] = 0;
    m_interp_nn(0)[1][4] = 0;  //1.5
    m_interp_nn(0)[2][4] = 0;
    m_interp_nn(0)[3][4] = 0;  //4
    m_interp_nn(0)[4][4] = 0;
    m_interp_nn(0)[5][4] = 0;

    m_interp_nn(0)[0][5] = 0;
    m_interp_nn(0)[1][5] = 0;  //1.5
    m_interp_nn(0)[2][5] = 0;
    m_interp_nn(0)[3][5] = 0;  //4
    m_interp_nn(0)[4][5] = 0;
    m_interp_nn(0)[5][5] = 0;


    ImageGray<T> m_interp_bi(6,6);

    m_interp_bi(0)[0][0] = 3;
    m_interp_bi(0)[1][0] = 5;
    m_interp_bi(0)[2][0] = 7;
    m_interp_bi(0)[3][0] = 14;
    m_interp_bi(0)[4][0] = 21;
    m_interp_bi(0)[5][0] = 21; //???

    m_interp_bi(0)[0][1] = 3.5;
    m_interp_bi(0)[1][1] = 5.75;
    m_interp_bi(0)[2][1] = 8;
    m_interp_bi(0)[3][1] = 37.0/3.0;
    m_interp_bi(0)[4][1] = 21;
    m_interp_bi(0)[5][1] = 21;

    m_interp_bi(0)[0][2] = 4;
    m_interp_bi(0)[1][2] = 6.5;
    m_interp_bi(0)[2][2] = 9;
    m_interp_bi(0)[3][2] = 9;
    m_interp_bi(0)[4][2] = 0;
    m_interp_bi(0)[5][2] = 0;

    m_interp_bi(0)[0][3] = 4;
    m_interp_bi(0)[1][3] = 6.5;
    m_interp_bi(0)[2][3] = 9;
    m_interp_bi(0)[3][3] = 9;
    m_interp_bi(0)[4][3] = 0;
    m_interp_bi(0)[5][3] = 0;

    m_interp_bi(0)[0][4] = 0;
    m_interp_bi(0)[1][4] = 0;
    m_interp_bi(0)[2][4] = 0;
    m_interp_bi(0)[3][4] = 0;
    m_interp_bi(0)[4][4] = 0;
    m_interp_bi(0)[5][4] = 0;

    m_interp_bi(0)[0][5] = 0;
    m_interp_bi(0)[1][5] = 0;
    m_interp_bi(0)[2][5] = 0;
    m_interp_bi(0)[3][5] = 0;
    m_interp_bi(0)[4][5] = 0;
    m_interp_bi(0)[5][5] = 0;



    // Value interpolation

    Point2D p1(0.5, 0.5);
    Point2D p2(0.5, 0.0);
    Point2D p3(1.5, 0.5);

    float64 val1 = interpolation (ima(0), p1, LINEAR);

    BOOST_CHECK_EQUAL (val1, 5.75);

    float64 val2 = interpolation (ima(0), p2, LINEAR);

    BOOST_CHECK_EQUAL (val2, 5.0);




    uint32 n_nei = 0;

    float64 val3 = interpolation (ima(0), mask(0), p2, LINEAR, n_nei);

    BOOST_CHECK_EQUAL (val3,  5.0);
    BOOST_CHECK_EQUAL (n_nei, (uint64)2);


    float64 val4 = interpolation (ima(0), mask(0), p3, LINEAR, n_nei);

    BOOST_CHECK_EQUAL (val4, 37.0/3.0);
    BOOST_CHECK_EQUAL (n_nei, (uint64)3);

    // -----------------------------------------------------------------------



    // Interpolation

    MultiArray<Point<2>,2> points(interp_nn(0).dims(0), interp_nn(0).dims(1));

    float64 posy=0.0;
    for (uint64 j=0; j < points.dims(1); j++)
    {
        float64 posx=0.0;
        for (uint64 i=0; i < points.dims(0); i++)
        {
            points[i][j] = Point<2>(posx,posy);
            posx += 0.5;
        }
        posy += 0.5;
    }

	MultiArray<T,2> out_nn;
    out_nn = interpolation (ima(0), points, NEAREST_NEIGHBOR);

	MultiArray<T,2> out_bi;
    out_bi = interpolation (ima(0), points, LINEAR);

    BOOST_CHECK (out_nn == interp_nn(0));
    BOOST_CHECK (out_bi == interp_bi(0));




    // Version for Image<T,1>
	ImageGray<T> imout_nn;
    imout_nn = interpolation (ima, points, NEAREST_NEIGHBOR);

	ImageGray<T> imout_bi;
    imout_bi = interpolation (ima, points, LINEAR);


    BOOST_CHECK (imout_nn == interp_nn);
    BOOST_CHECK (imout_bi == interp_bi);

////ok



    // Version for Image<T,1> & mask
    ImageMask out_mask(points.dims(0), points.dims(1));
    out_mask = true;


	ImageGray<T> m_imout_bi;

    m_imout_bi = interpolation (ima, mask, points, out_mask, LINEAR);

    BOOST_CHECK (m_imout_bi == m_interp_bi);


	ImageGray<T> m_imout_nn;
    m_imout_nn = interpolation (ima, mask, points, out_mask, NEAREST_NEIGHBOR);
    BOOST_CHECK (m_imout_nn == m_interp_nn);




#if 0
    for (uint64 j=0; j < points.dims(1); j++)
    {
        for (uint64 i=0; i < points.dims(0); i++)
        {
            std::cout <<  "(" << i << "," << j << ") ";
            BOOST_CHECK_EQUAL (m_imout_bi(0)[i][j], m_interp_bi(0)[i][j]);
        }
    }



    for (uint64 j=0; j < points.dims(1); j++)
    {
        for (uint64 i=0; i < points.dims(0); i++)
        {
            std::cout <<  "(" << i << "," << j << ") ";
            BOOST_CHECK_EQUAL (m_imout_nn(0)[i][j], m_interp_nn(0)[i][j]);
        }
    }


    std::cout << "Points (" << points.dims(0) << "," << points.dims(1) << ")" << std::endl;

    for (uint64 j=0; j < points.dims(1); j++)
    {
        for (uint64 i=0; i < points.dims(0); i++)
        {
            std::cout <<  "(" << points[i][j].x() << "," << points[i][j].y() << ") ";
        }
        std::cout << std::endl;
    }

    std::cout << "Interp (" << interp(0).dims(0) << "," << interp(0).dims(1) << ")" << std::endl;

    for (uint64 j=0; j < interp(0).dims(1); j++)
    {
        for (uint64 i=0; i < interp(0).dims(0); i++)
        {
            std::cout <<  interp(0)[i][j] << " ";
        }
        std::cout << std::endl;
    }

    std::cout << "out (" << out.dims(0) << "," << out.dims(1) << ")" << std::endl;
    for (uint64 j=0; j < out.dims(1); j++)
    {
        for (uint64 i=0; i < out.dims(0); i++)
        {
            std::cout <<  out[i][j] << " ";
        }
        std::cout << std::endl;
    }

    for (uint64 j=0; j < points.dims(1); j++)
    {
        for (uint64 i=0; i < points.dims(0); i++)
        {
            std::cout <<  "(" << i << "," << j << ") ";
            BOOST_CHECK_EQUAL (out_bi[i][j], interp_bi(0)[i][j]);
        }
    }
#endif

} 


BOOST_AUTO_TEST_CASE_TEMPLATE( changeSampling_test, T, DataTypes )
{
    ImageGray<T> ima(3,3);

    ima(0)[0][0] = 3;
    ima(0)[1][0] = 7;
    ima(0)[2][0] = 21;

    ima(0)[0][1] = 4;
    ima(0)[1][1] = 9;
    ima(0)[2][1] = 8;

    ima(0)[0][2] = 0;
    ima(0)[1][2] = 3;
    ima(0)[2][2] = 5;


    ImageGray<T> interp_nn(5,5);


    interp_nn(0)[0][0] = 3;
    interp_nn(0)[1][0] = 3;
    interp_nn(0)[2][0] = 7;
    interp_nn(0)[3][0] = 7;
    interp_nn(0)[4][0] = 21;
    // interp_nn(0)[5][0] = 21;

    interp_nn(0)[0][1] = 3;  //3.5 
    interp_nn(0)[1][1] = 3;  //5.75
    interp_nn(0)[2][1] = 7;  //8
    interp_nn(0)[3][1] = 7;  //11.25
    interp_nn(0)[4][1] = 21;  //14.5
    // interp_nn(0)[5][1] = 21;  //14.5

    interp_nn(0)[0][2] = 4;
    interp_nn(0)[1][2] = 4;  //6.5
    interp_nn(0)[2][2] = 9;
    interp_nn(0)[3][2] = 9;  //8.5
    interp_nn(0)[4][2] = 8;
    // interp_nn(0)[5][2] = 8;

    interp_nn(0)[0][3] = 4;  //2
    interp_nn(0)[1][3] = 4;  //4
    interp_nn(0)[2][3] = 9;  //6
    interp_nn(0)[3][3] = 9;  //6.25
    interp_nn(0)[4][3] = 8;  //6.5
    // interp_nn(0)[5][3] = 8;  //6.5

    interp_nn(0)[0][4] = 0;
    interp_nn(0)[1][4] = 0;  //1.5
    interp_nn(0)[2][4] = 3;
    interp_nn(0)[3][4] = 3;  //4
    interp_nn(0)[4][4] = 5;
    // interp_nn(0)[5][4] = 5;

    //interp_nn(0)[0][5] = 0;
    //interp_nn(0)[1][5] = 0;  //1.5
    //interp_nn(0)[2][5] = 3;
    //interp_nn(0)[3][5] = 3;  //4
    //interp_nn(0)[4][5] = 5;
    //interp_nn(0)[5][5] = 5;



    ImageGray<T> interp_bi(5,5);

    interp_bi(0)[0][0] = 3;
    interp_bi(0)[1][0] = 5;
    interp_bi(0)[2][0] = 7;
    interp_bi(0)[3][0] = 14;
    interp_bi(0)[4][0] = 21;
    //interp_bi(0)[5][0] = 21;

    interp_bi(0)[0][1] = 3.5;
    interp_bi(0)[1][1] = 5.75;
    interp_bi(0)[2][1] = 8;
    interp_bi(0)[3][1] = 11.25;
    interp_bi(0)[4][1] = 14.5;
    //interp_bi(0)[5][1] = 14.5;

    interp_bi(0)[0][2] = 4;
    interp_bi(0)[1][2] = 6.5;
    interp_bi(0)[2][2] = 9;
    interp_bi(0)[3][2] = 8.5;
    interp_bi(0)[4][2] = 8;
    //interp_bi(0)[5][2] = 8;

    interp_bi(0)[0][3] = 2;
    interp_bi(0)[1][3] = 4;
    interp_bi(0)[2][3] = 6;
    interp_bi(0)[3][3] = 6.25;
    interp_bi(0)[4][3] = 6.5;
    //interp_bi(0)[5][3] = 6.5;

    interp_bi(0)[0][4] = 0;
    interp_bi(0)[1][4] = 1.5;
    interp_bi(0)[2][4] = 3;
    interp_bi(0)[3][4] = 4;
    interp_bi(0)[4][4] = 5;
    //interp_bi(0)[5][4] = 5;

    //interp_bi(0)[0][5] = 0;
    //interp_bi(0)[1][5] = 1.5;
    //interp_bi(0)[2][5] = 3;
    //interp_bi(0)[3][5] = 4;
    //interp_bi(0)[4][5] = 5;
    //interp_bi(0)[5][5] = 5;

	MultiArray<T,2> out_nn;
    out_nn = imageplus::math::numeric::resize (ima(0), 2.0, 2.0, NEAREST_NEIGHBOR);

	MultiArray<T,2> out_bi;
    out_bi = imageplus::math::numeric::resize (ima(0), 2.0, 2.0, LINEAR);

    BOOST_CHECK (out_nn == interp_nn(0));
    BOOST_CHECK (out_bi == interp_bi(0));

	ImageGray<T> imout_nn;
    imout_nn = imageplus::math::numeric::resize (ima, 2.0, 2.0, NEAREST_NEIGHBOR);

	ImageGray<T> imout_bi;
    imout_bi = imageplus::math::numeric::resize (ima, 2.0, 2.0, LINEAR);

    BOOST_CHECK (imout_nn == interp_nn);
    BOOST_CHECK (imout_bi == interp_bi);

}

#endif //AGIL

BOOST_AUTO_TEST_SUITE_END ();
