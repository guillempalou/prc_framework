// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------

//!
//!  \file ortho_basis_codec.cpp
//!
//!  Methods for region-based texture coding based on orthogonal basis
//!

#include <imageplus/coding/texture/ortho_basis_codec.hpp>

#include <imageplus/math/numeric/numeric_util.hpp>
#include <imageplus/math/statistics/multiarray_statistics.hpp>

#include <texture/fill_regions.hpp>

#include <imageplus/math/numeric/products.hpp>
#include <imageplus/math/numeric/transformations.hpp>

#include <imageplus/math/transforms/zigzag.hpp>

#include <texture/quantization_auxiliar.hpp>
#include <texture/region_texture.hpp>


namespace mn = imageplus::math::numeric;

namespace imageplus
{
namespace coding
{
namespace texture
{

    MultiArray<float64,2> _cosine_matrix (uint64 order, uint64 size);


    float64 _pot (float64 a, float64 b);

    template<typename image_type, std::size_t num_channels, typename partition_type>
    void _compute_shape_basis( const RegionTexture<image_type,num_channels,partition_type>& region,
                               uint64 order,
                               OrthoBasisCodec::Model type,
                               const MultiArray<float64,2>& cosm,
                               const MultiArray<float64,2>& cosn,
                               std::vector< MultiArray<float64,2> >& BB );

    template<typename image_type, std::size_t num_channels, typename partition_type>
    void _compute_texture_shape_vectors( const RegionTexture<image_type,num_channels,partition_type>& region,
                                         uint64 order,
                                         OrthoBasisCodec::Model type,
                                         const MultiArray<float64,2>& cosm,
                                         const MultiArray<float64,2>& cosn,
                                         std::vector< MultiArray<float64,1> >& RB );

    void _orthogonalize_basis( const std::vector< MultiArray<float64,2> >& BB,
                               uint64 order,
                               float64 _llinda,
                               std::vector< MultiArray<float64,2> >& H );

    void _projection( const std::vector< MultiArray<float64,1> >& RB,
                      const std::vector< MultiArray<float64,2> >& H,
                      std::vector< MultiArray<float64,1> >& A );

    template<typename T, std::size_t N, typename partition_type>
    void _reconstruct( const std::vector< MultiArray<float64,2> >& H,
                       const std::vector< MultiArray<float64,1> >& A,
                       uint64 order,
                       OrthoBasisCodec::Model type,
                       const MultiArray<float64,2>& cosm,
                       const MultiArray<float64,2>& cosn,
                       RegionTexture<T,N,partition_type>& region);


    OrthoBasisCodec::OrthoBasisCodec (int64 order,
                                      uint8 ac_model,
                                      uint64 gop_size,
                                      uint8 min_q,
                                      Model type,
                                      FrameType frame,
                                      uint64 min_size_region,
                                      float64 llinda )
    :   TextureCodec<OrthoBasisCodec>("OrthoBasisCodec"),
        _order(order),
        _ac_model(ac_model),
        _gop_size(gop_size),
        _gop_size_counter(0),
        _min_q(min_q),
        _type(type),
        _frame(frame),
        _min_size_region(min_size_region),
        _llinda(llinda)
    {
        _ac_num_models = 0;

        switch (_ac_model )
        {
            case 1:
                _ac_num_models = 1;
                break;
            case 2:
                _ac_num_models = (_order+1)*(_order+1);
                break;
        }
        _amodels.resize(_ac_num_models);

        // Initialize models with maximum number of symbols (depends on the Q)
        for (uint64 i=0; i < _ac_num_models; i++)
        {
            _amodels[i].set_alphabet(1 << _bits(_min_q) );
        }

    }

    // BB can be recovered from region shape (does not depend on region data)
    // H depends only on BB
    template<typename image_type, std::size_t num_channels, typename partition_type>
    void OrthoBasisCodec::decoding (const ImagePartition<partition_type>& label,
                                    const QTextureCoeffs<num_channels>& coeffs,
                                    Image<image_type,num_channels>& rec) const throw (ImagePlusError)

    {
        const uint64 im_size = label.num_total_data_elements();

        /* Initialization */
        const partition_type maxlabel = math::statistics::maxval (label(PARTITION_CHANNEL));
        const partition_type minlabel = math::statistics::minval (label(PARTITION_CHANNEL));

        // Pointer to partition map
        const partition_type* plab= label(PARTITION_CHANNEL).data();

        int32 quant = 0;

        RegionTexture<image_type,num_channels,partition_type> reg;

        const uint64 dim  = (_order+1) * (_order+1);


        // Initialize reconstructed image
        rec = 0;

        std::vector< MultiArray<float64,2> > BB;
        std::vector< MultiArray<float64,2> > H;
        std::vector< MultiArray<float64,1> > A;

        std::vector< MultiArray<float64,2> > Qtable;

        for (uint64 channel=0; channel < rec.num_channels(); channel++)
        {
            BB.push_back(MultiArray<float64,2>(dim, dim));
            H.push_back (MultiArray<float64,2>(dim, dim));
            Qtable.push_back( MultiArray<float64,2>(_order+1, _order+1) );
            A.push_back(MultiArray<float64,1>(dim));
        }

        /* Process all regions that are marked in map */
        for (partition_type numreg = minlabel; numreg <= maxlabel ;numreg++)
        {
            /* Check if this region exists and if it has to be processed */
            bool flag = false;

            for (uint64 i = 0; i < im_size; i++)
            {
                if ( plab[i] == numreg && coeffs[numreg].quant() )
                {
                    flag  = true;
                    quant = coeffs[numreg].quant() - 4; // qmap = 4  =>  2^(4-4) = 2^0 = 1
                    break;
                }
            }
    
            /* This region has to be processed */
            if (flag == true)
            {
                /* Initialize Quantization tables */

                float64 qdc = std::pow(2.0, quant);
                float64 qac = std::pow(2.0, quant);

                for (uint64 channel=0; channel < rec.num_channels(); channel++)
                {
                    //_fill_qtable (Qtable[channel], qmap_channels[channel]*qdc, qmap_channels[channel]*qac);
                    _fill_qtable (Qtable[channel], qdc, qac);
                }

                /* compute the size of the current region */
                uint64 size_region = comparison_count (label(PARTITION_CHANNEL), numreg, "==");

                /* if region size not large enough, approx. by the mean */
                if (size_region < _min_size_region)
                {
                    for (uint64 channel=0; channel < rec.num_channels(); channel++)
                    {
                        image_type mean = mn::mnint<image_type>(coeffs[numreg][channel][0] * Qtable[channel][0][0]);

                        ma_compare (label(PARTITION_CHANNEL), numreg, "==", mean, rec(channel), rec(channel));
                    }
                }
                else
                {
                    reg.extract_region (rec, label, numreg);

                    const uint64 width  = reg.side_x();
                    const uint64 height = reg.side_y();

                    MultiArray<float64,2> cosm, cosn;

                    cosm = _cosine_matrix (_order, width);
                    cosn = _cosine_matrix (_order, height);

                    _compute_shape_basis (reg, _order, _type, cosm, cosn, BB);
                    _orthogonalize_basis (BB, _order, _llinda, H);
                    _dequantify_coeffs   (coeffs[numreg], Qtable, A);
                    _reconstruct         (H, A, _order, _type, cosm, cosn, reg);

                    reg.save_region(label, rec);
                }
            }
        }
    }


    template<typename image_type, std::size_t num_channels, typename partition_type>
    Image<image_type,num_channels> OrthoBasisCodec::encoding(const Image<image_type,num_channels>& ori,
                                                             const ImagePartition<partition_type>& label,
                                                             const MultiArray<uint8,1>& qmap,
                                                             QTextureCoeffs<num_channels>& coeffs) const throw (ImagePlusError)
    {

        //ASSERT (label map ori compatible);

        const uint64 im_size = label.num_total_data_elements();

        /* Initialization */
        const partition_type maxlabel = math::statistics::maxval (label(PARTITION_CHANNEL));
        const partition_type minlabel = math::statistics::minval (label(PARTITION_CHANNEL));

        const uint64 dim  = (_order+1) * (_order+1);

        coeffs = QTextureCoeffs<num_channels>(maxlabel+1, dim);
        coeffs = 0;

        // Pointer to partition map
        const partition_type* plab= label(PARTITION_CHANNEL).data();

        Image<image_type,num_channels> cod(ori.size_x(), ori.size_y());

        // coding with the mean
        Image<image_type,num_channels> coded_mean (ori.size_x(), ori.size_y());

        for (uint64 channel=0; channel < num_channels; channel++)
        {
            coded_mean = fill_regions (ori, label, MODEL_POLY0);
        }

        /* Cleanning of the out image */
        cod = 0;

        /* Initialize ZigZag map */
        math::transforms::ZigZagScan zz (_order+1);
        MultiArray<Coord2D<int64>,1> zigzag = zz.coords();


        std::vector< MultiArray<float64,2> > BB;
        std::vector< MultiArray<float64,2> > H;
        std::vector< MultiArray<float64,1> > RB;
        std::vector< MultiArray<float64,1> > A;

        std::vector< MultiArray<float64,2> > Qtable;

        for (uint64 channel=0; channel < num_channels; channel++)
        {
            BB.push_back(MultiArray<float64,2>(dim, dim));
            H.push_back (MultiArray<float64,2>(dim, dim));
            RB.push_back(MultiArray<float64,1>(dim));
            Qtable.push_back( MultiArray<float64,2>(_order+1, _order+1) );
            A.push_back(MultiArray<float64,1>());
        }

        RegionTexture<image_type,num_channels,partition_type> reg;

        int32 quant = 0;

        /* Process all regions that are marked in map */
        for (partition_type numreg = minlabel; numreg <= maxlabel ;numreg++)
        {
            /* Check if this region exists and if it has to be processed */
            bool flag = false;

            for (uint64 i = 0; i < im_size; i++)
            {
                if (plab[i] == numreg && qmap[numreg])
                {
                    flag  = true;
                    coeffs[numreg].quant( qmap[numreg] );
                    quant = qmap[numreg] - 4;  // qmap=4 =>  2^(4-4)=2^0=1
                    break;
                }
            }

            /* This region has to be processed */
            if (flag == true)
            {
                /* Initialize Quantization tables */
                //_set_ob_quantizers (quant, &qdc, &qac);

                float64 qdc = std::pow(2.0, quant);
                float64 qac = std::pow(2.0, quant);

                for (uint64 channel=0; channel < cod.num_channels(); channel++)
                {
                    //_fill_qtable (Qtable[channel], qmap_channels[channel]*qdc, qmap_channels[channel]*qac);
                    _fill_qtable (Qtable[channel], qdc, qac);
                }

                /* compute the size of the current region */
                uint64 size_region = comparison_count (label(PARTITION_CHANNEL), numreg, "==");

                /* if region size not large enough, approx. by the mean */
                if (size_region < _min_size_region)
                {
                    for (uint64 channel=0; channel < cod.num_channels(); channel++)
                    {
                        image_type* pcm  = coded_mean(channel).data();
                        image_type* pcod = cod(channel).data();

                        for (uint64 i=0; i < im_size; i++)
                        {
                            if (plab[i] == numreg)
                            {
                                image_type mean = pcm[i];
                                mean = mn::mnint<int64>( static_cast<float64>(mean) / Qtable[channel][0][0] );

                                coeffs[numreg][channel][0] = mean;
                                pcod[i] = mn::mnint<int64>( mean * Qtable[channel][0][0] );
                            }
                        }
                    }
                }
                else
                {
                    reg.extract_region (ori, label, numreg);

                    const uint64 width  = reg.side_x();
                    const uint64 height = reg.side_y();

                    MultiArray<float64,2> cosm, cosn;

                    cosm = _cosine_matrix (_order, width);
                    cosn = _cosine_matrix (_order, height);

                    _compute_shape_basis  (reg, _order, _type, cosm, cosn, BB);
                    _compute_texture_shape_vectors (reg, _order, _type, cosm, cosn, RB);
                    _orthogonalize_basis (BB, _order, _llinda, H);
                    _projection (RB, H, A);
                    _quantify_coeffs (quant, Qtable, A, coeffs[numreg]);
                    _reconstruct    (H, A, _order, _type, cosm, cosn, reg);

                    reg.save_region(label, cod);
                }
            }
        }

        return cod;
    }
    


    template<std::size_t num_channels, typename partition_type>
    uint64 OrthoBasisCodec::compressing(const ImagePartition<partition_type>& label,
                                        const QTextureCoeffs<num_channels>& coeffs,
                                        io::WriteBitStream& bs) throw (ImagePlusError)
    {
    
        uint64 total_bits = 0;
    
        // Make sure all quant are the same
        for (uint64 reg = 1; reg < coeffs.size() ; reg++)
        {
            if ( coeffs[reg].quant() != _min_q )
            {
                throw ImagePlusError("Orthobasis compress only works for the same Q for all regions");
            }
        }

        // Write Q value (not really needed but just in case)
        bs.write(_min_q, 4);
        total_bits += 4;
    
        // Create an arithmetic coding for each frame
        compress::Arithmetic_Codec ace;
        if (_ac_model > 0)
        {
            ace.set_buffer( 2 * coeffs.num_elements() );
            ace.start_encoder();
        }
        
        for (uint64 ii = 1 ; ii < coeffs.size(); ii++)
        {
            // BitStream writing

            for (uint64 jj = 0 ; jj < num_channels; jj++)
            {

                for (uint64 kk = 0 ; kk < coeffs[ii][jj].size(); kk++)
                {

                    switch (_ac_model)
                    {
                        case 0:
                            bs.write(coeffs[ii][jj][kk], (uint8)_bits(coeffs[ii].quant()));
                            total_bits += _bits(coeffs[ii].quant());
                            break;
                        case 1:
                            ace.encode(coeffs[ii][jj][kk], _amodels[0]);
                            break;
                        case 2:
                            ace.encode(coeffs[ii][jj][kk], _amodels[kk]);
                            break;
                        default:
                            throw ImagePlusError("ac_model not supported");
                            break;
                    }
                    
                }
            }
        }

        if (_ac_model>0)
        {
            uint64 num_bytes = ace.stop_encoder(); // return number of bytes used for compression

            // Write number of bytes in the file
            if ( num_bytes > 65535)
                throw ImagePlusError("Number of bytes can not be greater than 65535");
            bs.write(num_bytes, 16);

            // Write bitstream
            for (uint64 x = 0; x < num_bytes; x++)
            {
                bs.write(ace.buffer()[x],8);
            }

            total_bits += 16 + 8 * num_bytes;

        }

        _reset_amodels_if_needed();

        return total_bits;
    }
    
    void OrthoBasisCodec::_reset_amodels_if_needed()
    {
        if (_gop_size_counter++ >= _gop_size)
        {
            _gop_size_counter = 0;
            for (uint64 i=0; i < _ac_num_models; i++)
                _amodels[i].reset();
        }
    }

    template<std::size_t num_channels, typename partition_type>
    void OrthoBasisCodec::decompressing(const ImagePartition<partition_type>& label,
                                        io::ReadBitStream& bs,
                                        QTextureCoeffs<num_channels>& coeffs) throw (ImagePlusError)
    {
        // Get total number of regions from partition
        const partition_type maxlabel = math::statistics::maxval (label(PARTITION_CHANNEL));

        if ( math::statistics::minval (label(PARTITION_CHANNEL)) == 0 )
            throw ImagePlusError("Partition must start at label 1");

        const uint64 dim  = (_order+1) * (_order+1);

        coeffs = QTextureCoeffs<num_channels>(maxlabel+1, dim);
        coeffs = 0;

        // Read Q value (not really needed but just in case)
        uint8 q = bs.read(4);
        for (uint64 reg = 1; reg < coeffs.size() ; reg++)
        {
            coeffs[reg].quant( q );
        }

        if (_ac_model > 0)
        {

            // Read buffer size
            uint64 codec_size = bs.read(16);

            uint64 buffer_size = ( codec_size < 16 ) ? 16 : codec_size;

            // Need to read all bitstream into a buffer (at least orders_size bits)
            uint8 *buffer = new uint8[buffer_size];
            for (uint64 i = 0; i < buffer_size; i++)
                buffer[i] = 0;
            for (uint64 i = 0; i < codec_size; i++)
                buffer[i] = bs.read(8);

            compress::Arithmetic_Codec ace(buffer_size,buffer);

            ace.start_decoder();

            for (uint64 ii = 1 ; ii < coeffs.size(); ii++)
            {
                for (uint64 jj = 0 ; jj < num_channels; jj++)
                {

                    for (uint64 kk = 0 ; kk < coeffs[ii][jj].size(); kk++)
                    {

                        switch (_ac_model)
                        {
                            case 1:
                                coeffs[ii][jj][kk] = ace.decode(_amodels[0]);
                                break;
                            case 2:
                                coeffs[ii][jj][kk] = ace.decode(_amodels[kk]);
                                break;
                            default:
                                throw ImagePlusError("ac_model not supported");
                                break;
                        }

                    }
                }
            }

            ace.stop_decoder();

        } else {

            for (uint64 ii = 1 ; ii < coeffs.size(); ii++)
            {
                for (uint64 jj = 0 ; jj < num_channels; jj++)
                {
                    for (uint64 kk = 0 ; kk < coeffs[ii][jj].size(); kk++)
                    {
                        coeffs[ii][jj][kk] = bs.read(_bits((uint8)coeffs[ii].quant() ));
                    }
                }
            }
        }

        _reset_amodels_if_needed();

    }



    /* =================================================================== */
    /* From the region, compute the scalar product of the region texture with the region shape */
    /* =================================================================== */
    template<typename image_type, std::size_t num_channels, typename partition_type>
    void _compute_texture_shape_vectors( const RegionTexture<image_type,num_channels,partition_type>& region,
                                         uint64 order,
                                         OrthoBasisCodec::Model type,
                                         const MultiArray<float64,2>& cosm,
                                         const MultiArray<float64,2>& cosn,
                                         std::vector< MultiArray<float64,1> >& RB )
    {
        const uint64 width  = region.side_x();
        const uint64 height = region.side_y();

        const float64 sq2  = M_SQRT2;  /* sqrt(2), defined in math.h */


        // Get the size of the region in pixels
        const uint64 nd = region.size();


        for (uint64 chan = 0; chan < num_channels; chan++)
        {
            // Compute RB

            uint64 pos1 = 0;

            if(type == OrthoBasisCodec::POL_ORT)
            {
                for (uint64 k1 = 0; k1 < order+1; k1++)
                for (uint64 l1 = 0; l1 < order+1; l1++, pos1++)
                {
                    RB[chan][pos1] = 0;

                    for (uint64 i = 0; i < width; i++)
                    for (uint64 j = 0; j < height; j++)
                    {
                        if(region(chan)[i][j] != -1)
                        {
                            float64 tmpj = 1;
                            for (uint64 k = 0; k <= l1-1; k++)
                            {
                                // ??
                                tmpj *= (j+1);
                            }
                            RB[chan][pos1] += region(chan)[i][j] * _pot(static_cast<float64>(i+1),static_cast<float64>(k1)) * tmpj;
                        }
                    }
                    RB[chan][pos1] /= nd;
                }
            }
            else
            {
                for (uint64 k1 = 0; k1 < order + 1; k1++)
                for (uint64 l1 = 0; l1 < order + 1; l1++, pos1++)
                {
                    float64 Ak1 = (k1 == 0) ? 1 : sq2;
                    float64 Al1 = (l1 == 0) ? 1 : sq2;

                    float64 Ak1Al1 = Ak1 * Al1;

                    RB[chan][pos1] = 0;
                    for (uint64 i = 0; i < width; i++)
                    {
                        float64 tmpi = Ak1Al1 * cosm[i][k1];
                        for (uint64 j = 0; j < height; j++)
                        {
                            if (region(chan)[i][j]!=(-1.0))
                            {
                                RB[chan][pos1] += region(chan)[i][j]*cosn[j][l1]*tmpi;
                            }
                        }
                    }
                    RB[chan][pos1] /= nd;
                }
            }
        }
    }



    template<typename image_type, std::size_t num_channels, typename partition_type>
    void _compute_shape_basis( const RegionTexture<image_type,num_channels,partition_type>& region,
                               uint64 order,
                               OrthoBasisCodec::Model type,
                               const MultiArray<float64,2>& cosm,
                               const MultiArray<float64,2>& cosn,
                               std::vector< MultiArray<float64,2> >& BB )
    {
        const uint64 width  = region.side_x();
        const uint64 height = region.side_y();

        const float64 sq2  = M_SQRT2;  /* sqrt(2), defined in math.h */

        // Get the size of the region in pixels
        const uint64 nd = region.size();

        for (uint64 chan = 0; chan < num_channels; chan++)
        {
            /* Compute PE */

            MultiArray<float64,2> PE(2*order+1, 2*order+1);

            if(type == OrthoBasisCodec::POL_ORT)
            {
                for (uint64 k1 = 0; k1 <= 2*order; k1++)
                for (uint64 l1 = 0; l1 <= 2*order; l1++)
                {
                    PE[k1][l1] = 0;
                    for (uint64 i = 0; i < width; i++)
                    { 
                        float64 tmpi = 1;
                        for (uint64 k = 0; k <= k1; k++)
                        {
                            //????
                            tmpi *= (i+1);
                        }

                        for(uint64 j = 0; j < height;j++)
                        {
                            if(region(chan)[i][j] != -1.0)
                            {
                                float64 tmpj = 1.0;
                                for(uint64 k = 0; k <= l1; k++)
                                {
                                    tmpj *= (j+1);
                                }
                                PE[k1][l1] += (tmpi*tmpj);
                            }
                        }
                    }
                }
            }
            else
            {
                for (uint64 k1 = 0; k1 <= 2*order; k1++)
                {
                    //uint64 k11 = k1+1;
                    for(uint64 l1 = 0;l1 <= 2*order; l1++)
                    {
                        //uint64 l11 = l1+1;

                        PE[k1][l1] = 0;

                        for (uint64 i = 0;i < width; i++)
                        { 
                            //float64 tmpi = cosm[i][k11];
                            float64 tmpi = cosm[i][k1];

                            for (uint64 j = 0;j < height; j++)
                            {
                                if (region(chan)[i][j]!=(-1.0))
                                {
                                    //PE[k1][l1] += tmpi * cosn[j][l11];
                                    PE[k1][l1] += tmpi * cosn[j][l1];
                                }
                            }
                        }
                    }
                }
            }

            /* Compute BB */
            if(type == OrthoBasisCodec::POL_ORT)
            {
                for (uint64 k1 = 0, pos1 = 0; k1 <= order; k1++)
                for (uint64 l1 = 0; l1 <= order; l1++, pos1++)
                for (uint64 k2 = 0, pos2 = 0; k2 <= order; k2++)
                for (uint64 l2 = 0; l2 <= order; l2++, pos2++)
                {
                    BB[chan][pos1][pos2] = PE[k1+k2][l1+l2] / nd;
                }
            }
            else
            {
                uint64 pos1 = 0;

                for(uint64 k1 = 0; k1 <= order; k1++)
                {
                    float64 Ak1 = (k1 == 0) ? 1 : sq2;

                    for (uint64 l1 = 0; l1<=order; l1++,pos1++)
                    {
                        float64 Al1    = (l1 == 0) ? 1 : sq2;
                        float64 Ak1Al1 = Ak1*Al1;

                        uint64 pos2 = 0;

                        for (uint64 k2 = 0; k2 <= order; k2++)
                        {
                            float64 Ak2       = (k2 == 0) ? 1 : sq2;

                            float64 Ak1Al1Ak2 = Ak1Al1*Ak2;
                            uint64 k1k2       = k1+k2;
                            uint64 k1mk2      = static_cast<uint64>(std::abs(static_cast<int64>(k1) - static_cast<int64>(k2)));

                            for(uint64 l2 = 0; l2 <= order; l2++,pos2++)
                            {
                                float64 Al2          = (l2 == 0) ? 1 : sq2;
                                float64 Ak1Al1Ak2Al2 = Ak1Al1Ak2*Al2/4/nd;
                                uint64  l1l2         = l1+l2;
                                uint64  l1ml2        = static_cast<uint64>(std::abs(static_cast<int64>(l1) - static_cast<int64>(l2)));
                                BB[chan][pos1][pos2] = Ak1Al1Ak2Al2 * (PE[k1k2][l1l2]   +
                                                                       PE[k1mk2][l1l2]+ PE[k1k2][l1ml2] +
                                                                       PE[k1mk2][l1ml2]);
                            }
                        }
                    }
                }
            }
        }
    }


    // Ok index des de zero
    MultiArray<float64,2> _cosine_matrix (uint64 order, uint64 size)
    {
        MultiArray<float64,2> cosm(size,2*order+1);

        for (uint64 i=0; i < size; i++)
        for (uint64 j=0; j < 2*order+1; j++)
        {
            cosm[i][j] = cos (M_PI*(2*i+1)*j/(2*size));
        }

        return cosm;
    }


    // Ok index des de zero
    MultiArray<int64,2> _make_qtable (uint64 width, uint64 height, int64 qdc, int64 qac)
    {
        MultiArray<int64,2> Qtable(width,height);

        Qtable = qac;

        Qtable[0][0] = qdc;

        return Qtable;
    }

    float64 _pot (float64 a, float64 b)
    {
            if (b == 0.0) return 1.0;
            else return std::pow(a,b);
    }
    



    void _orthogonalize_basis (const std::vector< MultiArray<float64,2> >& BB, uint64 order, float64 _llinda,
                               std::vector< MultiArray<float64,2> >& H)
    {
        const uint64 dim = (order+1)*(order+1);
        const uint64 num_channels = BB.size();

        for (uint64 chan = 0; chan < num_channels; chan++)
        {
            H[chan] = 0.0;

            // Compute H
            H[chan][0][0] = 1.0 / std::sqrt(BB[chan][0][0]);

            for(uint64 k = 0; k < dim-1; k++)
            {
                BBox2D bb1(Coord2D<>(0,0), k+1, k+1);
                //BBox2D bb2(Coord2D<>(k+1, 0), 2, k+2); //???????
                BBox2D bb2(Coord2D<>(0, k+1), k+1, 1); //???????


                MultiArray<float64,2> Hk;
                MultiArray<float64,2> S;
                Hk = copy_view(H[chan], bb1);

                S = mn::prod(mn::trans(Hk), Hk);
                MultiArray<float64,1> vec_(k+1);

                vec_ = row(copy_view(BB[chan], bb2),0);

                MultiArray<float64,1> H_;

                H_ = mn::prod( S, vec_ );


                // Get the squared module of Vk
                float64 mod=0;
                for (uint64 i = 0; i <= k; i++)
                {
                    for(uint64 j = 0; j < i; j++)
                    {
                        //mod += 2 * H_[i] * H_[j] * BB[chan][i][j];
                        mod += 2 * H_[i] * H_[j] * BB[chan][j][i];
                    }
                    mod += H_[i] * H_[i] * BB[chan][i][i];
                }

                for (uint64 j = 0; j < k+1; j++)
                {
                    // mod += (-2) * H_[j] * BB[chan][k+1][j];
                    mod += (-2) * H_[j] * BB[chan][j][k+1];
                }
                mod += BB[chan][k+1][k+1];

                /* Get Hk+1 */
                if (mod < _llinda * BB[chan][k+1][k+1])
                {
                    for (uint64 i = 0; i <= k+1; i++)
                    {
                        //H[chan][k+1][i] = 0;
                        H[chan][i][k+1] = 0;
                    }
                }
                else
                {
                    mod = std::sqrt(mod);
                    for (uint64 i = 0; i <= k; i++)
                    {
                        //H[chan][k+1][i]=(-1) * H_[i] / mod;
                        H[chan][i][k+1]=(-1) * H_[i] / mod;
                    }
                    H[chan][k+1][k+1] = 1.0 / mod;
                }
            }

            // Instead of doing that, change the above code
            //H[chan] = mn::trans (H[chan]);
        }
    }



    void _projection (const std::vector< MultiArray<float64,1> >& RB, const std::vector< MultiArray<float64,2> >& H,
                      std::vector< MultiArray<float64,1> >& A)
    {
        const uint64 num_channels = RB.size();

        for (uint64 chan = 0; chan < num_channels; chan++)
        {
            // Projection
            A[chan] = mn::prod (H[chan], RB[chan]);
        }
    }



    /* =================================================================== */
    /*       Reconstruction of the function from the coefficients          */
    /* =================================================================== */

    template<typename T, std::size_t N, typename partition_type>
    void _reconstruct (const std::vector< MultiArray<float64,2> >& H,
                       const std::vector< MultiArray<float64,1> >& A,
                       uint64 order,
                       OrthoBasisCodec::Model type,
                       const MultiArray<float64,2>& cosm,
                       const MultiArray<float64,2>& cosn,
                       RegionTexture<T,N,partition_type>& region)
    {
        const uint64 width  = region.side_x();
        const uint64 height = region.side_y();

        const uint64 num_channels = H.size();

        const float64 sq2  = M_SQRT2; /* sqrt(2.0), Defined in math.h */

        for (uint64 chan = 0; chan < num_channels; chan++)
        {
            MultiArray<float64,1> P;

            P = mn::prod (A[chan], H[chan]);

            if (type == OrthoBasisCodec::POL_ORT)
            {
                for (uint64 i = 0; i < width;  i++)
                for (uint64 j = 0; j < height; j++)
                {
                    if(region(chan)[i][j] != -1.0)
                    { 
                        region(chan)[i][j] = 0;

                        uint64 pos = 0;

                        for (uint64 k=0; k < order+1; k++)
                        {
                            float64 tmp = std::pow (static_cast<float64>(i+1),static_cast<float64>(k));

                            float64 linea = 0;
                            for (uint64 l=0; l < order+1; l++, pos++)
                            {
                                linea += P[pos] * pow (static_cast<float64>(j+1),static_cast<float64>(l));
                            }
                            region(chan)[i][j] += (linea*tmp);
                        }
                    }
                }
            }
            else
            {
                for(uint64 i=0; i < width;  i++)
                for(uint64 j=1; j < height; j++)
                {
                    if(region(chan)[i][j] != -1.0)
                    {
                        region(chan)[i][j] = 0;

                        uint64 pos = 0;
                        for (uint64 k = 0; k < order+1; k++)
                        { 
                            float64 Ak = (k == 0) ? 1 : sq2;

                            Ak *= cosm[i][k];

                            float64 linea = 0;
                            for (uint64 l=0; l < order+1; l++, pos++)
                            {
                                float64 Al = (l == 0) ? 1 : sq2;

                                linea += P[pos] * Al * cosn[j][l];
                            }

                            region(chan)[i][j] += (linea*Ak);
                        }
                    }
                }
            }
        }
    }
} // ns texture
} // ns coding
} // ns imageplus


/*
 * Instantiations
 */
namespace imageplus
{
namespace coding
{
namespace texture
{
    template
    Image<uint8,3> OrthoBasisCodec::encoding(const Image<uint8,3>& ori,
                                             const ImagePartition<uint32>& label,
                                             const MultiArray<uint8,1>& qmap,
                                             QTextureCoeffs<3>& coeffs) const throw (ImagePlusError);
    template
    void OrthoBasisCodec::decoding (const ImagePartition<uint32>& label,
                                    const QTextureCoeffs<3>& coeffs,
                                    Image<uint8,3>& rec) const throw (ImagePlusError);

    template
    Image<uint8,1> OrthoBasisCodec::encoding(const Image<uint8,1>& ori,
                                             const ImagePartition<uint32>& label,
                                             const MultiArray<uint8,1>& qmap,
                                             QTextureCoeffs<1>& coeffs) const throw (ImagePlusError);
    template
    void OrthoBasisCodec::decoding (const ImagePartition<uint32>& label,
                                    const QTextureCoeffs<1>& coeffs,
                                    Image<uint8,1>& rec) const throw (ImagePlusError);


    template
    uint64 OrthoBasisCodec::compressing(const ImagePartition<uint32>& label,
                                        const QTextureCoeffs<1>& coeffs,
                                        io::WriteBitStream& bs) throw (ImagePlusError);

    template
    uint64 OrthoBasisCodec::compressing(const ImagePartition<uint32>& label,
                                        const QTextureCoeffs<3>& coeffs,
                                        io::WriteBitStream& bs) throw (ImagePlusError);


    template
    void OrthoBasisCodec::decompressing(const ImagePartition<uint32>& label,
                                        io::ReadBitStream& bs,
                                        QTextureCoeffs<1>& coeffs) throw (ImagePlusError);

    template
    void OrthoBasisCodec::decompressing(const ImagePartition<uint32>& label,
                                        io::ReadBitStream& bs,
                                        QTextureCoeffs<3>& coeffs) throw (ImagePlusError);

} // ns texture
} // ns coding
} // ns imageplus






    // Deprecated functions
#if 0

void _ortho_project (const std::vector< MultiArray<float64,2> >& BB, const std::vector< MultiArray<float64,1> >& RB, uint64 order, float64 _llinda, std::vector< MultiArray<float64,2> >& H, std::vector< MultiArray<float64,1> >& A);

template<typename image_type, std::size_t num_channels>
void _compute_basis (const RegionTexture<image_type,num_channels>& region, uint64 order, OrthoBasisModel type, 
                                     std::vector< MultiArray<float64,2> >& BB, std::vector< MultiArray<float64,1> >& RB);


/* =================================================================== */
/*           Orthogonalization of the basis and projection             */
/* =================================================================== */

void _ortho_project (const std::vector< MultiArray<float64,2> >& BB, const std::vector< MultiArray<float64,1> >& RB, uint64 order, float64 _llinda, std::vector< MultiArray<float64,2> >& H, std::vector< MultiArray<float64,1> >& A)
{

    const uint64 dim = (order+1)*(order+1);
    const uint64 num_channels = BB.size();

    for (uint64 chan = 0; chan < num_channels; chan++)
    {
        H[chan] = 0.0;

        // Compute H         
        H[chan][0][0] = 1.0 / sqrt(BB[chan][0][0]);

        for(uint64 k = 0; k < dim-1; k++) 
        {
            BBox2D bb1(Coord2D<>(0,0), k+1, k+1); 
            BBox2D bb2(Coord2D<>(k+1, 0), 1, k+1); //???????

            MultiArray<float64,2> Hk;
            Hk = copy_view(H[chan], bb1);

            MultiArray<float64,1> H_;
            H_ = mn::prod( mn::prod(mn::trans(Hk), Hk), column(copy_view(BB[chan], bb2), 0) );


            // Get the squared modul of Vk
            float64 mod=0;
            for (uint64 i = 0; i <= k; i++) 
            { 
                for(uint64 j = 0; j < i; j++)
                {
                    mod += 2 * H_[i] * H_[j] * BB[chan][i][j];
                }
                mod += H_[i] * H_[i] * BB[chan][i][i];
            }

            for (uint64 j = 0; j < k+1; j++)
            {
                mod += (-2) * H_[j] * BB[chan][k+1][j];
            }
            mod += BB[chan][k+1][k+1];

            /* Get Hk+1 */ 
            if (mod < _llinda * BB[chan][k+1][k+1])  
            {
                for (uint64 i = 0; i <= k+1; i++)
                {
                    H[chan][k+1][i] = 0;
                }
            }
            else 
            {
                mod = std::sqrt(mod);
                for (uint64 i = 0; i <= k; i++)
                {
                    H[chan][k+1][i]=(-1) * H_[i] / mod;
                }
                H[chan][k+1][k+1] = 1.0 / mod;
            }
        } 

        /* Projection */ 
        A[chan] = mn::prod (H[chan], RB[chan]);
    }
}

/* =================================================================== */
/*                       Compute the Orthonormal basis                 */
/* From the region, compute the scalar product of the vectors and of   */
/* the region with the vectors                                         */
/* =================================================================== */
template<typename image_type, std::size_t num_channels>
void _compute_basis (const RegionTexture<image_type,num_channels>& region, uint64 order, OrthoBasisModel type, std::vector< MultiArray<float64,2> >& BB, 
                                      std::vector< MultiArray<float64,1> >& RB)
{
    const uint64 width  = region.side_x();
    const uint64 height = region.side_y();

    //const uint64 num_channels = BB.size();

    const float64 sq2  = M_SQRT2;  /* sqrt(2), defined in math.h */


    MultiArray<float64,2> cosm, cosn;

    cosm = _cosine_matrix (order, width);
    cosn = _cosine_matrix (order, height);

    // Get the size of the region in pixels
    const uint64 nd = region.size();


    for (uint64 chan = 0; chan < num_channels; chan++)
    {
        // Compute RB

        uint64 pos1 = 0;

        if(type == POL_ORT) 
        {
            for (uint64 k1 = 0; k1 < order+1; k1++)
            for (uint64 l1 = 0; l1 < order+1; l1++, pos1++) 
            {       
                RB[chan][pos1] = 0;
                
                for (uint64 i = 0; i < width; i++)
                for (uint64 j = 0; j < height; j++)
                {
                    if(region(chan)[i][j] != -1) 
                    {
                        float64 tmpj = 1;
                        for (uint64 k = 0; k <= l1-1; k++) 
                        {
                            // ??
                            tmpj *= (j+1);
                        } 
                        RB[chan][pos1] += region(chan)[i][j] * _pot(static_cast<float64>(i+1),static_cast<float64>(k1)) * tmpj;
                    }
                }
                RB[chan][pos1] /= nd;
            }
        }
        else 	
        {
            for (uint64 k1 = 0; k1 < order + 1; k1++) 
            for (uint64 l1 = 0; l1 < order + 1; l1++, pos1++) 
            {       
                float64 Ak1 = (k1 == 0) ? 1 : sq2;
                float64 Al1 = (l1 == 0) ? 1 : sq2;

                float64 Ak1Al1 = Ak1 * Al1;

                RB[chan][pos1] = 0;
                for (uint64 i = 0; i < width; i++) 
                {       
                    float64 tmpi = Ak1Al1 * cosm[i][k1];
                    for (uint64 j = 0; j < height; j++)
                    {						
                        if (region(chan)[i][j]!=(-1.0))
                        {						
                            RB[chan][pos1] += region(chan)[i][j]*cosn[j][l1]*tmpi;
                        }
                    }			  
                }
                RB[chan][pos1] /= nd;
            }
        }
 
        /* Compute PE */
  
        MultiArray<float64,2> PE(2*order+1, 2*order+1);
  
        if(type == POL_ORT) 
        {
            for (uint64 k1 = 0; k1 <= 2*order; k1++)
            for (uint64 l1 = 0; l1 <= 2*order; l1++)
            {
                PE[k1][l1] = 0;
                for (uint64 i = 0; i < width; i++) 
                { 
                    float64 tmpi = 1;
                    for (uint64 k = 0; k <= k1; k++)
                    {
                        //????
                        tmpi *= (i+1);
                    }
                
                    for(uint64 j = 0; j < height;j++)
                    {
                        if(region(chan)[i][j] != -1.0) 
                        { 
                            float64 tmpj = 1.0;
                            for(uint64 k = 0; k <= l1; k++) 
                            {
                                tmpj *= (j+1);
                            }  
                            PE[k1][l1] += (tmpi*tmpj); 
                        }
                    }
                }
            }
        }
        else 
        {
            for (uint64 k1 = 0; k1 <= 2*order; k1++) 
            {
                uint64 k11 = k1+1;
                for(uint64 l1 = 0;l1 <= 2*order; l1++) 
                {
                    uint64 l11 = l1+1;

                    PE[k1][l1] = 0;

                    for (uint64 i = 0;i < width; i++) 
                    { 
                        float64 tmpi = cosm[i][k11]; 
                        for (uint64 j = 0;j < height; j++)
                        {
                            if (region(chan)[i][j]!=(-1.0))
                            {
                                PE[k1][l1] += tmpi * cosn[j][l11];
                            }
                        }
                    }
                }
            }
        }

        /* Compute BB */
        if(type == POL_ORT) 
        {
            for (uint64 k1 = 0, pos1 = 0; k1 <= order; k1++)
            for (uint64 l1 = 0; l1 <= order; l1++, pos1++)
            for (uint64 k2 = 0, pos2 = 0; k2 <= order; k2++)
            for (uint64 l2 = 0; l2 <= order; l2++, pos2++)
            {			  
                BB[chan][pos1][pos2] = PE[k1+k2][l1+l2] / nd;
            }
        }              
        else 
        {
            uint64 pos1 = 0;

            for(uint64 k1 = 0; k1 <= order; k1++) 
            { 
                float64 Ak1 = (k1 == 0) ? 1 : sq2;

                for (uint64 l1 = 0; l1<=order; l1++,pos1++) 
                {     
                    float64 Al1    = (l1 == 0) ? 1 : sq2;
                    float64 Ak1Al1 = Ak1*Al1;

                    uint64 pos2 = 0;

                    for (uint64 k2 = 0; k2 <= order; k2++) 
                    {   
                        float64 Ak2       = (k2 == 0) ? 1 : sq2;

                        float64 Ak1Al1Ak2 = Ak1Al1*Ak2;
                        uint64 k1k2       = k1+k2; 
                        uint64 k1mk2      = static_cast<uint64>(std::abs(static_cast<int64>(k1) - static_cast<int64>(k2)));

                        for(uint64 l2 = 0; l2 <= order; l2++,pos2++) 
                        { 
                            float64 Al2          = (l2 == 0) ? 1 : sq2;
                            float64 Ak1Al1Ak2Al2 = Ak1Al1Ak2*Al2/4/nd;
                            uint64  l1l2         = l1+l2; 
                            uint64  l1ml2        = static_cast<uint64>(std::abs(static_cast<int64>(l1) - static_cast<int64>(l2)));
                            BB[chan][pos1][pos2] = Ak1Al1Ak2Al2 * (PE[k1k2][l1l2]   +
                                                                   PE[k1mk2][l1l2]+ PE[k1k2][l1ml2] +
                                                                   PE[k1mk2][l1ml2]);
                        }
                    }
                }
            }
        }  
    }									
}
#endif
