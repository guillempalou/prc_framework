// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------

//!
//!  \file imagelbp.hpp
//!
//!  Interface for ImageLBP class
//!
#ifndef IMAGEPLUS_CORE_IMAGELBP_HPP
#define IMAGEPLUS_CORE_IMAGELBP_HPP

#include <imageplus/core/image.hpp>

namespace imageplus
{
    //!
    //! \brief base class to lbp images
    //!
    //! The declaration should be:
    //! \code
    //!    ImageLBP a(4,4);
    //! \endcode
    //!
    //! This creates a lbp image of uint8 values with size 4x4.
    //!
    //! The access of a pixel is done as the ImaVol class:
    //! \code
    //!    a(0)[1][3] = 0 // Access to pixel (x=1,y=3)
    //!    a(LBP_CHANNEL)[1][3] = 0 // Access to pixel (x=1,y=3)
    //! \endcode
    //! or directly (and equally fast):
    //! \code
    //!    a[1][3] = 0 // Access to pixel (x=1,y=3)
    //! \endcode
    //!
    //! See file multiarray.hpp to a more detail explanation on access
    //!
    //! \author Josep Ramon Morros <morros@gps.tsc.upc.edu>
    //! \date 31-3-2011
    //!
    class ImageLBP :public Image <uint64,1>
    {
        public:

            //!
            //! \brief Default constructor
            //!
            ImageLBP();

            //!
            //! \brief Constructor for 2 dimensions
            //!
            //! \param[in] x : X size of the image
            //! \param[in] y : Y size of the image
            //!
            ImageLBP(uint64 x, uint64 y);

            //!
            //! \brief Copy constructor for ImaVol
            //!
            //! \param[in] copy : Creates a copy (including values) of this imavol
            //!
            ImageLBP(const ImaVol<uint64,1,2>& copy);

            //!
            //! \brief Copy constructor for Image
            //!
            //! \param[in] copy : Creates a copy (including values) of this image
            //!
            ImageLBP(const Image<uint64,1>& copy);

            //!
            //! \brief Copy constructor for ImageLBP
            //!
            //! \param[in] copy : Creates a copy (including values) of this ImageLBP
            //!
            ImageLBP( const ImageLBP& copy );

            //!
            //! \brief Constructor with a vector of dimentions
            //!
            //! \param[in] dims: Vector of vectors with the dimension of each channel
            //!
            explicit 
            ImageLBP(const std::vector< std::vector<uint64> >& dims);

            //!
            //! \brief Destructor
            //!
            virtual 
            ~ImageLBP();

            //!
            //! \brief Assignment operator for ImaVol
            //!
            //! \param[in] copy : Creates a copy (size,channels and data) of this imavol
            //!
            //! \return Reference to (this) so a = b = c; works.
            //!
            const ImageLBP& operator=( const ImaVol<uint64,1,2>& copy );

            //!
            //! \brief Assignment operator for Image
            //!
            //! \param[in] copy : Creates a copy (size,channels and data) of this Image
            //!
            //! \return Reference to (this) so a = b = c; works.
            //!
            const ImageLBP& operator=( const Image<uint64,1>& copy );

            //!
            //! \brief Assignment operator for ImageLBP
            //!
            //! \param[in] copy : Creates a copy (size,channels and data) of this ImageLBP
            //!
            //! \return Reference to (this) so a = b = c; works.
            //!
            const ImageLBP& operator=( const ImageLBP& copy );

            //!
            //! \brief Assignment operator for values (fills the entire image)
            //!
            //! \param[in] val : Value to fill all pixel
            //!
            //! \return Reference to value to a = b = 1; works
            //!
            const uint64& operator=( const uint64& val );

            //!
            //! \brief Overload of operator[] to be able to use imagelbp[x][y] instead of imagelbp(0)[x][y]
            //!
            //! \param[in] pos : coordinate X of the image
            //!
            //! \return Reference to sub_array with 1 dimension (to be able to access coordinate Y)
            //!
            boost::detail::multi_array::sub_array<uint64,1> operator[]( std::size_t pos )
            {
                return (*this)(0)[pos];
            }

            //!
            //! \brief Overload of operator[] to be able to use imagelbp[x][y] instead of imagelbp(0)[x][y] (const access)
            //!
            //! \param[in] pos : coordinate X of the image
            //!
            //! \return Reference to sub_array with 1 dimension (to be able to access coordinate Y)
            //!
            boost::detail::multi_array::const_sub_array<uint64,1> operator[]( std::size_t pos ) const
            {
                return (*this)(0)[pos];
            }
    };
}

#endif //IMAGEPLUS_CORE_IMAGELBP_HPP
