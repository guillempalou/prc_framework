// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------
//!
//!  \file writevolume.cpp
//!
//!  \brief Implementation of class WriteRoom
//!

#include <imageplus/io/writeroom.hpp>

#include <cstdio>

using namespace imageplus;
using namespace std;
using namespace imageplus::io;
using namespace imageplus::compress;

WriteRoom::WriteRoom():_filename("")
{
}
WriteRoom::WriteRoom( const std::string& filename )
{
    _filename=filename;
}
WriteRoom::~WriteRoom()
{
}
void WriteRoom::open(const std::string& filename)
{
    FILE *fp=fopen(filename.c_str(), "wb");
    if (fp==NULL) throw ImagePlusFileNotFound( "ERROR(WriteRoom) : Cannot open  " + filename );
    else
    {
        fclose(fp);
        _filename=filename;
    }
}
template<typename T>
void WriteRoom::operator<<(const Room<T,3>& r) const
{
    uint16 fileVersion =3; // file version (Hardcoded)
    string extension;
    FILE *fp;
    uint32 cubesX, cubesY, cubesZ;
    float32 voxelSize;
    uint8 numChannels;
    uint8 dataType;
    float32 offsetX,offsetY,offsetZ;
    uint16 useCompress;
    
    size_t write_size;

    if  (r.volume()(0).dims(0)!=r.volume()(1).dims(0) || r.volume()(1).dims(0)!=r.volume()(2).dims(0) ||
    		r.volume()(0).dims(1)!=r.volume()(1).dims(1) || r.volume()(1).dims(1)!=r.volume()(2).dims(1) || 
    		r.volume()(0).dims(2)!=r.volume()(1).dims(2) || r.volume()(1).dims(2)!=r.volume()(2).dims(2)) 
    {
    	throw ImagePlusNotImplemented ("This version of Write Volume does not support 4:2:2 or 4:2:0 formats. " );
    }
    
    if(typeid(T)== typeid(uint8))//unsigned char
    {
        dataType = 0;
    }
    else if(typeid(T)== typeid(int8))
    {
        dataType = 1; 
    }
    else if(typeid(T)== typeid(uint16))
    {
        dataType = 2; 
    }
    else if(typeid(T)== typeid(int16))
    {
        dataType = 3; 
    }
    else if(typeid(T)== typeid(uint32))
    {
        dataType = 4; 
    }
    else if(typeid(T)== typeid(int32))
    {
        dataType = 5; 
    }
    else if(typeid(T)== typeid(float32))
    {
        dataType = 6; 
    }
    else if(typeid(T)== typeid(float64))
    {
        dataType = 7; 
    }
   
    
    //Analyze filename extension in order to define whether x3d or rle format is required
    extension=_filename.substr(_filename.length()-4,4);

    if (extension.compare(".rle")==0)
    {
        //write rle volume file
        fp=fopen(_filename.c_str(),"wb");
        if (fp==NULL) throw ImagePlusFileNotFound("ERROR(WriteRoom) Cannot open file "+ _filename);
        //data union needed due to RLE compressor
        union _data_to_compress
        {
            const T *data_voxel_original;
            uint8 *data_voxel_char;
        }data_to_compress;
 
        offsetX=static_cast<float32> (r.offset().x());
        offsetY=static_cast<float32> (r.offset().y());
        offsetZ=static_cast<float32> (r.offset().z());
        voxelSize=static_cast<float32> (r.voxel_size());
        cubesX=static_cast<uint32> (r.volume().size_x());
        cubesY=static_cast<uint32> (r.volume().size_y());
        cubesZ=static_cast<uint32> (r.volume().size_z());
        useCompress = 1;
        numChannels = 3;
        
        //Write file header
        write_size = fwrite(&fileVersion,sizeof(uint16),1,fp);
        if (write_size != 1)
        {
            throw ImagePlusError( "ERROR(ReadRoom) : Data written is not consistent");
        }   
        write_size = fwrite(&cubesX,sizeof(uint32),1,fp);
        if (write_size != 1)
        {
            throw ImagePlusError( "ERROR(ReadRoom) : Data written is not consistent");
        }   
        write_size = fwrite(&cubesY,sizeof(uint32),1,fp);
        if (write_size != 1)
        {
            throw ImagePlusError( "ERROR(ReadRoom) : Data written is not consistent");
        }   
        write_size = fwrite(&cubesZ,sizeof(uint32),1,fp);
        if (write_size != 1)
        {
            throw ImagePlusError( "ERROR(ReadRoom) : Data written is not consistent");
        }   
        write_size = fwrite(&numChannels,sizeof(uint8),1,fp);
        if (write_size != 1)
        {
            throw ImagePlusError( "ERROR(ReadRoom) : Data written is not consistent");
        }   
        write_size = fwrite(&dataType,sizeof(uint8),1,fp);
        if (write_size != 1)
        {
            throw ImagePlusError( "ERROR(ReadRoom) : Data written is not consistent");
        }   
        write_size = fwrite(&voxelSize,sizeof(float32),1,fp);
        if (write_size != 1)
        {
            throw ImagePlusError( "ERROR(ReadRoom) : Data written is not consistent");
        }   
        write_size = fwrite(&offsetX,sizeof(float32),1,fp);
        if (write_size != 1)
        {
            throw ImagePlusError( "ERROR(ReadRoom) : Data written is not consistent");
        }   
        write_size = fwrite(&offsetY,sizeof(float32),1,fp);
        if (write_size != 1)
        {
            throw ImagePlusError( "ERROR(ReadRoom) : Data written is not consistent");
        }   
        write_size = fwrite(&offsetZ,sizeof(float32),1,fp);
        if (write_size != 1)
        {
            throw ImagePlusError( "ERROR(ReadRoom) : Data written is not consistent");
        }   
        write_size = fwrite(&useCompress,sizeof(uint16),1,fp);
        if (write_size != 1)
        {
            throw ImagePlusError( "ERROR(ReadRoom) : Data written is not consistent");
        }   
   
        
        uint64 insize, outsize;
        //Consider the number of channels
        uint8 * buffer=new uint8[r.volume().num_total_data_elements()*sizeof(T)];

        //Room size
        insize=r.volume().num_total_data_elements()*sizeof(T);

        //Compress volume data
        Rle cprss;
        //Copy the 3 channels onto a MA
        MultiArray<T, 1> cp_data(r.volume().num_total_data_elements());
        
        T *iter = cp_data.data();
        T *end = cp_data.data()+cp_data.num_elements();
        const T *iter_0 = r.volume()(0).data();
        const T *iter_1 = r.volume()(1).data();
        const T *iter_2 = r.volume()(2).data();
        
        while (iter!=end)
        {
           	*iter=*iter_0;
            iter++; iter_0++;
        	*iter=*iter_1;
        	iter++; iter_1++;
           	*iter=*iter_2;
            iter++; iter_2++;	
        }
 
        data_to_compress.data_voxel_original=cp_data.data(); //Point to the first channel
        outsize=cprss.compress(data_to_compress.data_voxel_char,buffer,insize);
        //write volume data
        write_size = fwrite(buffer,sizeof(uint8),outsize,fp);
        if (write_size != outsize)
        {
            throw ImagePlusError( "ERROR(ReadRoom) : Data written is not consistent");
        }   

        fclose(fp);
        delete[] buffer;
    }
    else if (extension.compare(".vol")==0)
    {
        //write raw volume file
        fp=fopen(_filename.c_str(),"wb");
        if (fp==NULL) throw ImagePlusFileNotFound("ERROR(WriteRoom) Cannot open file "+ _filename);
        
        offsetX=static_cast<float32> (r.offset().x());
        offsetY=static_cast<float32> (r.offset().y());
        offsetZ=static_cast<float32> (r.offset().z());
        voxelSize=static_cast<float32> (r.voxel_size());
        cubesX=static_cast<uint32> (r.volume().size_x());
        cubesY=static_cast<uint32> (r.volume().size_y());
        cubesZ=static_cast<uint32> (r.volume().size_z());
        useCompress = 0;
        numChannels = 3;
        
        //Write file header
        write_size = fwrite(&fileVersion,sizeof(uint16),1,fp);
        if (write_size != 1)
        {
            throw ImagePlusError( "ERROR(ReadRoom) : Data written is not consistent");
        }   
        write_size = fwrite(&cubesX,sizeof(uint32),1,fp);
        if (write_size != 1)
        {
            throw ImagePlusError( "ERROR(ReadRoom) : Data written is not consistent");
        }   
        write_size = fwrite(&cubesY,sizeof(uint32),1,fp);
        if (write_size != 1)
        {
            throw ImagePlusError( "ERROR(ReadRoom) : Data written is not consistent");
        }   
        write_size = fwrite(&cubesZ,sizeof(uint32),1,fp);
        if (write_size != 1)
        {
            throw ImagePlusError( "ERROR(ReadRoom) : Data written is not consistent");
        }   
        write_size = fwrite(&numChannels,sizeof(uint8),1,fp);
        if (write_size != 1)
        {
            throw ImagePlusError( "ERROR(ReadRoom) : Data written is not consistent");
        }   
        write_size = fwrite(&dataType,sizeof(uint8),1,fp);
        if (write_size != 1)
        {
            throw ImagePlusError( "ERROR(ReadRoom) : Data written is not consistent");
        }   
        write_size = fwrite(&voxelSize,sizeof(float32),1,fp);
        if (write_size != 1)
        {
            throw ImagePlusError( "ERROR(ReadRoom) : Data written is not consistent");
        }   
        write_size = fwrite(&offsetX,sizeof(float32),1,fp);
        if (write_size != 1)
        {
            throw ImagePlusError( "ERROR(ReadRoom) : Data written is not consistent");
        }   
        write_size = fwrite(&offsetY,sizeof(float32),1,fp);
        if (write_size != 1)
        {
            throw ImagePlusError( "ERROR(ReadRoom) : Data written is not consistent");
        }   
        write_size = fwrite(&offsetZ,sizeof(float32),1,fp);
        if (write_size != 1)
        {
            throw ImagePlusError( "ERROR(ReadRoom) : Data written is not consistent");
        }   
        write_size = fwrite(&useCompress,sizeof(uint16),1,fp);
        if (write_size != 1)
        {
            throw ImagePlusError( "ERROR(ReadRoom) : Data written is not consistent");
        }   
        //Copy the 3 channels onto a MA
         MultiArray<T, 1> cp_data(r.volume().num_total_data_elements()*numChannels);
         
         T *iter = cp_data.data();
         T *end = cp_data.data()+cp_data.num_elements();
         
         const T *iter_0 = r.volume()(0).data();
         const T *iter_1 = r.volume()(1).data();
         const T *iter_2 = r.volume()(2).data();
         
         while (iter!=end)
         {
            *iter=*iter_0;
            iter++; iter_0++;
         	*iter=*iter_1;
         	iter++; iter_1++;
            *iter=*iter_2;
            iter++; iter_2++;	
         }
  
        T *dataVoxel = cp_data.data();
        uint64 numVoxels= r.volume().num_total_data_elements();
        write_size = fwrite(dataVoxel,sizeof(T),numVoxels,fp);
        if (write_size != numVoxels)
        {
            throw ImagePlusError( "ERROR(ReadRoom) : Data written is not consistent");
        }   
        
        fclose(fp);
        
    }
    else if (extension.compare(".x3d")==0)
    {
        //write in x3d format
        float64 VoxelSize=r.voxel_size()*100;
        register int32 iLoopX=0,iLoopY=0,iLoopZ=0, vx, vy, vz;
        int32  lin, col, hgt; //, pln; //AGIL: pln was set but not used, so it has been removed to avoid warnings in GCC-4.6
        float64 ch0, ch1, ch2, max_intensity, min_intensity;
        FILE* f;
        int32 roomSizeX, roomSizeY, roomSizeZ;
        int32 win2wall, win2floor, door2wall, doorheight, doorwidth;
        f=fopen(_filename.c_str(),"w");
        if (f==NULL) throw ImagePlusFileNotFound("ERROR(WriteRoom) Cannot open file "+ _filename);
        //Header
        fprintf(f,"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n");
        fprintf(f,"<!DOCTYPE X3D PUBLIC \"ISO//Web3D//DTD X3D 3.0//EN\" ");
        fprintf(f,"\"http://www.web3d.org/specifications/x3d-3.0.dtd\">\n\n");
        fprintf(f,"<X3D profile=\"Immersive\" version=\"3.0\">\n<Scene>\n");

        //Find the maximum and minimum intensity value depending on the typeid. 
        //Color 0,0,0 is reserved for background voxels.
        //Therefore, foreground color values should be different than 0,0,0.
        if (typeid(T)!=typeid(float64) && typeid(T)!=typeid(float32))
        {   
        	max_intensity=static_cast<float64>(std::numeric_limits<T>::max());
        	min_intensity=static_cast<float64>(std::numeric_limits<T>::min());
        }
        else
        {
        	max_intensity=1.0;
        	min_intensity=0.0;
        }
        // draw walls & lines for reference
        //      UPC Room: 400x520x240cm, 50-80-20-200-90
        //      ITC Room: 475x592x450cm
        roomSizeX = static_cast<int32>(r.size_x()*r.voxel_size()*100);//400;//475;//
        roomSizeY = static_cast<int32>(r.size_y()*r.voxel_size()*100);//520;//592;//520;
        roomSizeZ = static_cast<int32>(r.size_z()*r.voxel_size()*100);//240;//240;
        win2wall  =  5000;
        win2floor =  8000;
        door2wall =  2000;
        doorheight= 20000;
        doorwidth =  9000;
        // LIGHT GREEN WALLS, with window and door holes (IndexedFaceSet)
        fprintf(f,"\t<Shape>\n");
        fprintf(f,"\t\t<Appearance>\n\t\t\t<Material diffuseColor=\"0.5 1 0.5\"/>\n\t\t</Appearance>\n");
        fprintf(f,"\t\t<IndexedFaceSet coordIndex=\"0 1 2 3 -1\n");
        fprintf(f,"\t\t\t\t\t  0  4  8 16 -1\n\t\t\t\t\t 16 9 10 17 -1\n");
        fprintf(f,"\t\t\t\t\t 17 11  5  1 -1\n\t\t\t\t\t 3 7 4 0 -1\n");
        fprintf(f,"\t\t\t\t\t  2  6 19 15 -1\n\t\t\t\t\t 14 19 18 13 -1\n");
        fprintf(f,"\t\t\t\t\t 12 18  7  3 -1\n\t\t\t\t\t 1 5 6 2 -1\">\n");
        // floor points counter-clockwise (CCW)
        fprintf(f,"\t\t<Coordinate point=\"   0   0   0,  %d   0   0,  %d  %d   0,   0  %d   0,\n",
                roomSizeX, roomSizeX, roomSizeY, roomSizeY);
        // ceiling points CCW
        fprintf(f,     "\n\t\t\t              0   0  %d,  %d   0  %d,  %d  %d  %d,   0  %d  %d,\n",
                roomSizeZ, roomSizeX, roomSizeZ, roomSizeX, roomSizeY, roomSizeZ, roomSizeY, roomSizeZ);
        // window points clockwise (CW)
        fprintf(f,     "\n\t\t\t             %d   0  %d,  %d   0  %d,  %d   0  %d,  %d   0  %d,\n",
                win2wall, roomSizeZ, win2wall, win2floor, roomSizeX-win2wall, win2floor, roomSizeX-win2wall, roomSizeZ);
        // door points CW
        fprintf(f,     "\n\t\t\t             %d  %d   0,  %d  %d  %d,  %d  %d  %d,  %d  %d   0,\n",
                door2wall, roomSizeY, door2wall, roomSizeY, doorheight, door2wall+doorwidth, roomSizeY, doorheight, door2wall+doorwidth, roomSizeY);
        // strange point couples (below window and above door)
        fprintf(f,     "\n\t\t\t             %d   0   0,  %d   0   0,  %d  %d  %d,  %d  %d  %d\"/>\n",
                win2wall, roomSizeX-win2wall, door2wall, roomSizeY, roomSizeZ, door2wall+doorwidth, roomSizeY, roomSizeZ);
        fprintf(f,"\t\t</IndexedFaceSet>\n");
        fprintf(f,"\t</Shape>\n");
        // LIGHT YELLOW WIREFRAME (IndexedLineSet)
        fprintf(f,"\t<Shape>\n");
        fprintf(f,"\t\t<Appearance>\n\t\t\t<Material diffuseColor=\"1 1 0.5\"/>\n\t\t</Appearance>\n");
        fprintf(f,"\t\t<IndexedLineSet coordIndex=\"0 1 2 3 -1\n\t\t\t\t\t 0 4 8 9 10 11 5 1 -1\n");
        fprintf(f,"\t\t\t\t\t 3 7 4 0 -1\n\t\t\t\t\t 2 6 7 3 12 13 14 15 -1\">\n");
        // floor points CCW
        fprintf(f,"\t\t<Coordinate point=\"   0   0   0,  %d   0   0,  %d  %d   0,   0  %d   0,\n",
                roomSizeX, roomSizeX, roomSizeY, roomSizeY);
        // ceiling points CCW
        fprintf(f,     "\n\t\t\t              0   0  %d,  %d   0  %d,  %d  %d  %d,   0  %d  %d,\n",
                roomSizeZ, roomSizeX, roomSizeZ, roomSizeX, roomSizeY, roomSizeZ, roomSizeY, roomSizeZ);
        // window points CW
        fprintf(f,     "\n\t\t\t             %d   0  %d,  %d   0  %d,  %d   0  %d,  %d   0  %d,\n",
                win2wall, roomSizeZ, win2wall, win2floor, roomSizeX-win2wall, win2floor, roomSizeX-win2wall, roomSizeZ);
        // door points CW
        fprintf(f,     "\n\t\t\t             %d  %d   0,  %d  %d  %d,  %d  %d  %d,  %d  %d   0,\n",
                door2wall, roomSizeY, door2wall, roomSizeY, doorheight, door2wall+doorwidth, roomSizeY, doorheight, door2wall+doorwidth, roomSizeY);
        // strange point couples (below window and above door)
        fprintf(f,     "\n\t\t\t             %d   0   0,  %d   0   0,  %d  %d  %d,  %d  %d  %d\"/>\n",
                win2wall, roomSizeX-win2wall, door2wall, roomSizeY, roomSizeZ, door2wall+doorwidth, roomSizeY, roomSizeZ);
        fprintf(f,"\t\t</IndexedLineSet>\n");
        fprintf(f,"\t</Shape>\n");

        // define VOXEL at 1,1,1
        fprintf(f,"<Transform translation=\"1 1 1\">\n");
        fprintf(f,"\t<Shape DEF=\"VOXEL\">\n\t\t<Box  DEF=\"VOXELB\" size=\"%5.2f %5.2f %5.2f\"/>\n",
                VoxelSize, VoxelSize,VoxelSize);
        fprintf(f,"\t\t<Appearance>\n\t\t\t<Material diffuseColor=\"1 1 1\"/>\n\t\t</Appearance>\n\t</Shape>\n</Transform>\n");
        // define CORNER (red) and set one at each one of the four corners
        fprintf(f,"<Transform translation=\"0 0 0\">\n");
        fprintf(f,"\t<Shape DEF=\"CORNER\">\n\t\t<Sphere radius=\"%3.2f\"/>\n", 2*VoxelSize);
        fprintf(f,"\t\t<Appearance>\n\t\t\t<Material diffuseColor=\"1 0 0\"/>\n");
        fprintf(f,"\t\t</Appearance>\n\t</Shape>\n</Transform>\n");
        fprintf(f,"<Transform translation=\" %d  %d   0\">", roomSizeX, roomSizeY);
        fprintf(f,"<Shape USE=\"CORNER\"/></Transform>\n");
        fprintf(f,"<Transform translation=\" %d   0   0\">", roomSizeX);
        fprintf(f,"<Shape USE=\"CORNER\"/></Transform>\n");
        fprintf(f,"<Transform translation=\"  0  %d   0\">", roomSizeY);
        fprintf(f,"<Shape USE=\"CORNER\"/></Transform>\n");

        // main loop
       
        // set shortcuts
        lin = r.volume().size_x();
        col = r.volume().size_y();
        hgt = r.volume().size_z();
        //pln = lin * col; //AGIL: plan was set but not used, so it has been removed to avoid warnings in GCC-4.6
        // loop through voxels
        for (iLoopZ=0;iLoopZ<hgt;iLoopZ++)
            for (iLoopY=0;iLoopY<col;iLoopY++)
                for (iLoopX=0;iLoopX<lin;iLoopX++)
                {
                    // check if this is a FG voxel
                	//std::cout << "Voxel " << r.volume()(0)[iLoopX][iLoopY][iLoopZ] << " " <<
                	//r.volume()(1)[iLoopX][iLoopY][iLoopZ] << " " <<
                	//r.volume()(2)[iLoopX][iLoopY][iLoopZ] << std::endl;
                	
                    if (r.volume()(0)[iLoopX][iLoopY][iLoopZ] || 
                    		r.volume()(1)[iLoopX][iLoopY][iLoopZ] ||
                    		r.volume()(2)[iLoopX][iLoopY][iLoopZ]  )
                    {
                        // if so, it should be on the surface to be visible
                        if ( (iLoopX==0) || (iLoopX>=lin-1) || (iLoopY==0) || (iLoopY>=col-1) || (iLoopZ==0) || (iLoopZ>=hgt-1) // on walls
                                || ( !r.volume()(0)[iLoopX+1][iLoopY][iLoopZ] 
	                                && !r.volume()(1)[iLoopX+1][iLoopY][iLoopZ]  
	                                && !r.volume()(2)[iLoopX+1][iLoopY][iLoopZ] )// next X is empty
                                || (!r.volume()(0)[iLoopX-1][iLoopY][iLoopZ] 
			                        && !r.volume()(1)[iLoopX-1][iLoopY][iLoopZ]
			                        && !r.volume()(2)[iLoopX-1][iLoopY][iLoopZ] )// previous X is empty
                                || (!r.volume()(0)[iLoopX][iLoopY+1][iLoopZ]  
			                        && !r.volume()(1)[iLoopX][iLoopY+1][iLoopZ]
			                        && !r.volume()(2)[iLoopX][iLoopY+1][iLoopZ] ) // next Y is empty
                                || (!r.volume()(0)[iLoopX][iLoopY-1][iLoopZ] 
			                        && !r.volume()(1)[iLoopX][iLoopY-1][iLoopZ]  
			                        && !r.volume()(2)[iLoopX][iLoopY-1][iLoopZ] )// previous Y is empty
                                || (!r.volume()(0)[iLoopX][iLoopY][iLoopZ+1]
                                	&& !r.volume()(1)[iLoopX][iLoopY][iLoopZ+1]
                                	&& !r.volume()(2)[iLoopX][iLoopY][iLoopZ+1] ) // next Z empty
                                || (!r.volume()(0)[iLoopX][iLoopY][iLoopZ-1] 
                                	&& !r.volume()(1)[iLoopX][iLoopY][iLoopZ-1]
                                	&& !r.volume()(2)[iLoopX][iLoopY][iLoopZ-1] ) // previous Z empty
                                             
                           )
                        {
                            // voxel coordinates
                            vx=static_cast<int32>(iLoopX*VoxelSize);
                            vy=static_cast<int32>(iLoopY*VoxelSize);
                            vz=static_cast<int32>(iLoopZ*VoxelSize);
                            //Add color info
                            ch0=(static_cast<float64>(r.volume()(0)[iLoopX][iLoopY][iLoopZ])-min_intensity)/(max_intensity-min_intensity); 
                            ch1=(static_cast<float64>(r.volume()(1)[iLoopX][iLoopY][iLoopZ])-min_intensity)/(max_intensity-min_intensity);
                            ch2=(static_cast<float64>(r.volume()(2)[iLoopX][iLoopY][iLoopZ])-min_intensity)/(max_intensity-min_intensity);
                            //std::cout << "Writing voxel with color " << ch0 << " " << ch1 << " " << ch2 << std::endl;   
                           // fprintf(f,"<Appearance>\n\t\t\t<Material diffuseColor=\"%f %f %f\"/>", ch0, ch1, ch2 );
                            
                            //fprintf(f,"<Transform translation=\"%d %d %d\"> ", vx, vy, vz);
                            //fprintf(f,"<Shape USE=\"VOXEL\"/><Appearance>\n\t\t\t<Material diffuseColor=\"%1.3f %1.3f %1.3f\"/></Appearance></Transform>\n",ch0, ch1, ch2);
                             fprintf(f,"<Transform translation=\"%d %d %d\">\n", vx, vy, vz);
                             fprintf(f,"\t<Shape>\n\t\t<Box size=\"%5.2f %5.2f %5.2f\"/>\n",
                                     VoxelSize, VoxelSize,VoxelSize);
                             fprintf(f,"\t\t<Appearance>\n\t\t\t<Material diffuseColor=\"%1.3f %1.3f %1.3f\"/>\n\t\t</Appearance>\n\t</Shape>\n</Transform>\n", ch0, ch1, ch2);
                            //vCounter++; // count as displayed
                        }
                        //else nsCounter++; // count as a non surface (but FG) voxel
                    }
                }


        // close scene markup and output file
        fprintf(f,"</Scene>\n</X3D>\n");
        fclose(f);
        //cout << "\t ...done: " << vCounter <<" voxels represented (" << nsCounter<< " not on the surface)" <<  endl;
    }
    else
    {
        throw ImagePlusError("ERROR(WriteRoom): Non-valid volume file extension");
    }
}
template<typename T>
void WriteRoom::operator<<( const Room<T,1>& r) const
{
    uint16 fileVersion =3; // file version (Hardcoded)
    string extension;
    FILE *fp;
    uint32 cubesX, cubesY, cubesZ;
    float32 voxelSize;
    uint8 numChannels;
    uint8 dataType;
    float32 offsetX,offsetY,offsetZ;
    uint16 useCompress;
    
    size_t write_size;


    if(typeid(T)== typeid(uint8))//unsigned char
    {
        dataType = 0;
    }
    else if(typeid(T)== typeid(int8))
    {
        dataType = 1; 
    }
    else if(typeid(T)== typeid(uint16))
    {
        dataType = 2; 
    }
    else if(typeid(T)== typeid(int16))
    {
        dataType = 3; 
    }
    else if(typeid(T)== typeid(uint32))
    {
        dataType = 4; 
    }
    else if(typeid(T)== typeid(int32))
    {
        dataType = 5; 
    }
    else if(typeid(T)== typeid(float32))
    {
        dataType = 6; 
    }
    else if(typeid(T)== typeid(float64))
    {
        dataType = 7; 
    }
   
    
    //Analyze filename extension in order to define whether x3d or rle format is required
    extension=_filename.substr(_filename.length()-4,4);

    if (extension.compare(".rle")==0)
    {
        //write rle volume file
        fp=fopen(_filename.c_str(),"wb");
        if (fp==NULL) throw ImagePlusFileNotFound("ERROR(WriteRoom) Cannot open file "+ _filename);
        //data union needed due to RLE compressor
        union _data_to_compress
        {
            const T *data_voxel_original;
            uint8 *data_voxel_char;
        }data_to_compress;
 
        offsetX=static_cast<float32> (r.offset().x());
        offsetY=static_cast<float32> (r.offset().y());
        offsetZ=static_cast<float32> (r.offset().z());
        voxelSize=static_cast<float32> (r.voxel_size());
        cubesX=static_cast<uint32> (r.volume().size_x());
        cubesY=static_cast<uint32> (r.volume().size_y());
        cubesZ=static_cast<uint32> (r.volume().size_z());
        useCompress = 1;
        numChannels = 1;
        
        //Write file header
        write_size = fwrite(&fileVersion,sizeof(uint16),1,fp);
        if (write_size != 1)
        {
            throw ImagePlusError( "ERROR(ReadRoom) : Data written is not consistent");
        }   
        write_size = fwrite(&cubesX,sizeof(uint32),1,fp);
        if (write_size != 1)
        {
            throw ImagePlusError( "ERROR(ReadRoom) : Data written is not consistent");
        }   
        write_size = fwrite(&cubesY,sizeof(uint32),1,fp);
        if (write_size != 1)
        {
            throw ImagePlusError( "ERROR(ReadRoom) : Data written is not consistent");
        }   
        write_size = fwrite(&cubesZ,sizeof(uint32),1,fp);
        if (write_size != 1)
        {
            throw ImagePlusError( "ERROR(ReadRoom) : Data written is not consistent");
        }   
        write_size = fwrite(&numChannels,sizeof(uint8),1,fp);
        if (write_size != 1)
        {
            throw ImagePlusError( "ERROR(ReadRoom) : Data written is not consistent");
        }   
        write_size = fwrite(&dataType,sizeof(uint8),1,fp);
        if (write_size != 1)
        {
            throw ImagePlusError( "ERROR(ReadRoom) : Data written is not consistent");
        }   
        write_size = fwrite(&voxelSize,sizeof(float32),1,fp);
        if (write_size != 1)
        {
            throw ImagePlusError( "ERROR(ReadRoom) : Data written is not consistent");
        }   
        write_size = fwrite(&offsetX,sizeof(float32),1,fp);
        if (write_size != 1)
        {
            throw ImagePlusError( "ERROR(ReadRoom) : Data written is not consistent");
        }   
        write_size = fwrite(&offsetY,sizeof(float32),1,fp);
        if (write_size != 1)
        {
            throw ImagePlusError( "ERROR(ReadRoom) : Data written is not consistent");
        }   
        write_size = fwrite(&offsetZ,sizeof(float32),1,fp);
        if (write_size != 1)
        {
            throw ImagePlusError( "ERROR(ReadRoom) : Data written is not consistent");
        }   
        write_size = fwrite(&useCompress,sizeof(uint16),1,fp);
        if (write_size != 1)
        {
            throw ImagePlusError( "ERROR(ReadRoom) : Data written is not consistent");
        }   
   
        
        uint64 insize, outsize;
        
        uint8 * buffer=new uint8[r.volume().num_total_data_elements()*sizeof(T)];        

        //Room size
        insize=r.volume().num_total_data_elements()*sizeof(T);

        //Compress volume data
        Rle cprss;
        data_to_compress.data_voxel_original=r.volume()(0).data();
        outsize=cprss.compress(data_to_compress.data_voxel_char,buffer,insize);
        //write volume data
        write_size = fwrite(buffer,sizeof(uint8),outsize,fp);
        if (write_size != outsize)
        {
            throw ImagePlusError( "ERROR(ReadRoom) : Data written is not consistent");
        }   

        fclose(fp);
        delete[] buffer;
    }else if (extension.compare(".vol")==0)
    {
        //write raw volume file
        fp=fopen(_filename.c_str(),"wb");
        if (fp==NULL) throw ImagePlusFileNotFound("ERROR(WriteRoom) Cannot open file "+ _filename);
        
        offsetX=static_cast<float32> (r.offset().x());
        offsetY=static_cast<float32> (r.offset().y());
        offsetZ=static_cast<float32> (r.offset().z());
        voxelSize=static_cast<float32> (r.voxel_size());
        cubesX=static_cast<uint32> (r.volume().size_x());
        cubesY=static_cast<uint32> (r.volume().size_y());
        cubesZ=static_cast<uint32> (r.volume().size_z());
        useCompress = 0;
        numChannels = 1;
        
        //Write file header
        write_size = fwrite(&fileVersion,sizeof(uint16),1,fp);
        if (write_size != 1)
        {
            throw ImagePlusError( "ERROR(ReadRoom) : Data written is not consistent");
        }   
        write_size = fwrite(&cubesX,sizeof(uint32),1,fp);
        if (write_size != 1)
        {
            throw ImagePlusError( "ERROR(ReadRoom) : Data written is not consistent");
        }   
        write_size = fwrite(&cubesY,sizeof(uint32),1,fp);
        if (write_size != 1)
        {
            throw ImagePlusError( "ERROR(ReadRoom) : Data written is not consistent");
        }   
        write_size = fwrite(&cubesZ,sizeof(uint32),1,fp);
        if (write_size != 1)
        {
            throw ImagePlusError( "ERROR(ReadRoom) : Data written is not consistent");
        }   
        write_size = fwrite(&numChannels,sizeof(uint8),1,fp);
        if (write_size != 1)
        {
            throw ImagePlusError( "ERROR(ReadRoom) : Data written is not consistent");
        }   
        write_size = fwrite(&dataType,sizeof(uint8),1,fp);
        if (write_size != 1)
        {
            throw ImagePlusError( "ERROR(ReadRoom) : Data written is not consistent");
        }   
        write_size = fwrite(&voxelSize,sizeof(float32),1,fp);
        if (write_size != 1)
        {
            throw ImagePlusError( "ERROR(ReadRoom) : Data written is not consistent");
        }   
        write_size = fwrite(&offsetX,sizeof(float32),1,fp);
        if (write_size != 1)
        {
            throw ImagePlusError( "ERROR(ReadRoom) : Data written is not consistent");
        }   
        write_size = fwrite(&offsetY,sizeof(float32),1,fp);
        if (write_size != 1)
        {
            throw ImagePlusError( "ERROR(ReadRoom) : Data written is not consistent");
        }   
        write_size = fwrite(&offsetZ,sizeof(float32),1,fp);
        if (write_size != 1)
        {
            throw ImagePlusError( "ERROR(ReadRoom) : Data written is not consistent");
        }   
        write_size = fwrite(&useCompress,sizeof(uint16),1,fp);
        if (write_size != 1)
        {
            throw ImagePlusError( "ERROR(ReadRoom) : Data written is not consistent");
        }   
   
        const T *dataVoxel = r.volume()(0).data();
        uint64 numVoxels= r.volume().num_total_data_elements();
        write_size = fwrite(dataVoxel,sizeof(T),numVoxels,fp);
        if (write_size != numVoxels)
        {
            throw ImagePlusError( "ERROR(ReadRoom) : Data written is not consistent");
        }   
        
        fclose(fp);
        
    }
    else if (extension.compare(".x3d")==0)
    {
        //write in x3d format
        float64 VoxelSize=r.voxel_size()*100;
        register int32 iLoopX=0,iLoopY=0,iLoopZ=0, vx, vy, vz;
        int32  lin, col, hgt; //, pln; // AGIL: pln set but not used, so removed to avoid warnings on GCC-4.6
        FILE* f;
        int32 roomSizeX, roomSizeY, roomSizeZ;
        int32 win2wall, win2floor, door2wall, doorheight, doorwidth;
        f=fopen(_filename.c_str(),"w");
        if (f==NULL) throw ImagePlusFileNotFound("ERROR(WriteRoom) Cannot open file "+ _filename);
        //Header
        fprintf(f,"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n");
        fprintf(f,"<!DOCTYPE X3D PUBLIC \"ISO//Web3D//DTD X3D 3.0//EN\" ");
        fprintf(f,"\"http://www.web3d.org/specifications/x3d-3.0.dtd\">\n\n");
        fprintf(f,"<X3D profile=\"Immersive\" version=\"3.0\">\n<Scene>\n");

        // draw walls & lines for reference
        //      UPC Room: 400x520x240cm, 50-80-20-200-90
        //      ITC Room: 475x592x450cm
        roomSizeX = static_cast<int32>(r.size_x()*r.voxel_size()*100);//400;//475;//
        roomSizeY = static_cast<int32>(r.size_y()*r.voxel_size()*100);//520;//592;//520;
        roomSizeZ = static_cast<int32>(r.size_z()*r.voxel_size()*100);//240;//240;
        win2wall  =  5000;
        win2floor =  8000;
        door2wall =  2000;
        doorheight= 20000;
        doorwidth =  9000;
        // LIGHT GREEN WALLS, with window and door holes (IndexedFaceSet)
        fprintf(f,"\t<Shape>\n");
        fprintf(f,"\t\t<Appearance>\n\t\t\t<Material diffuseColor=\"0.5 1 0.5\"/>\n\t\t</Appearance>\n");
        fprintf(f,"\t\t<IndexedFaceSet coordIndex=\"0 1 2 3 -1\n");
        fprintf(f,"\t\t\t\t\t  0  4  8 16 -1\n\t\t\t\t\t 16 9 10 17 -1\n");
        fprintf(f,"\t\t\t\t\t 17 11  5  1 -1\n\t\t\t\t\t 3 7 4 0 -1\n");
        fprintf(f,"\t\t\t\t\t  2  6 19 15 -1\n\t\t\t\t\t 14 19 18 13 -1\n");
        fprintf(f,"\t\t\t\t\t 12 18  7  3 -1\n\t\t\t\t\t 1 5 6 2 -1\">\n");
        // floor points counter-clockwise (CCW)
        fprintf(f,"\t\t<Coordinate point=\"   0   0   0,  %d   0   0,  %d  %d   0,   0  %d   0,\n",
                roomSizeX, roomSizeX, roomSizeY, roomSizeY);
        // ceiling points CCW
        fprintf(f,     "\n\t\t\t              0   0  %d,  %d   0  %d,  %d  %d  %d,   0  %d  %d,\n",
                roomSizeZ, roomSizeX, roomSizeZ, roomSizeX, roomSizeY, roomSizeZ, roomSizeY, roomSizeZ);
        // window points clockwise (CW)
        fprintf(f,     "\n\t\t\t             %d   0  %d,  %d   0  %d,  %d   0  %d,  %d   0  %d,\n",
                win2wall, roomSizeZ, win2wall, win2floor, roomSizeX-win2wall, win2floor, roomSizeX-win2wall, roomSizeZ);
        // door points CW
        fprintf(f,     "\n\t\t\t             %d  %d   0,  %d  %d  %d,  %d  %d  %d,  %d  %d   0,\n",
                door2wall, roomSizeY, door2wall, roomSizeY, doorheight, door2wall+doorwidth, roomSizeY, doorheight, door2wall+doorwidth, roomSizeY);
        // strange point couples (below window and above door)
        fprintf(f,     "\n\t\t\t             %d   0   0,  %d   0   0,  %d  %d  %d,  %d  %d  %d\"/>\n",
                win2wall, roomSizeX-win2wall, door2wall, roomSizeY, roomSizeZ, door2wall+doorwidth, roomSizeY, roomSizeZ);
        fprintf(f,"\t\t</IndexedFaceSet>\n");
        fprintf(f,"\t</Shape>\n");
        // LIGHT YELLOW WIREFRAME (IndexedLineSet)
        fprintf(f,"\t<Shape>\n");
        fprintf(f,"\t\t<Appearance>\n\t\t\t<Material diffuseColor=\"1 1 0.5\"/>\n\t\t</Appearance>\n");
        fprintf(f,"\t\t<IndexedLineSet coordIndex=\"0 1 2 3 -1\n\t\t\t\t\t 0 4 8 9 10 11 5 1 -1\n");
        fprintf(f,"\t\t\t\t\t 3 7 4 0 -1\n\t\t\t\t\t 2 6 7 3 12 13 14 15 -1\">\n");
        // floor points CCW
        fprintf(f,"\t\t<Coordinate point=\"   0   0   0,  %d   0   0,  %d  %d   0,   0  %d   0,\n",
                roomSizeX, roomSizeX, roomSizeY, roomSizeY);
        // ceiling points CCW
        fprintf(f,     "\n\t\t\t              0   0  %d,  %d   0  %d,  %d  %d  %d,   0  %d  %d,\n",
                roomSizeZ, roomSizeX, roomSizeZ, roomSizeX, roomSizeY, roomSizeZ, roomSizeY, roomSizeZ);
        // window points CW
        fprintf(f,     "\n\t\t\t             %d   0  %d,  %d   0  %d,  %d   0  %d,  %d   0  %d,\n",
                win2wall, roomSizeZ, win2wall, win2floor, roomSizeX-win2wall, win2floor, roomSizeX-win2wall, roomSizeZ);
        // door points CW
        fprintf(f,     "\n\t\t\t             %d  %d   0,  %d  %d  %d,  %d  %d  %d,  %d  %d   0,\n",
                door2wall, roomSizeY, door2wall, roomSizeY, doorheight, door2wall+doorwidth, roomSizeY, doorheight, door2wall+doorwidth, roomSizeY);
        // strange point couples (below window and above door)
        fprintf(f,     "\n\t\t\t             %d   0   0,  %d   0   0,  %d  %d  %d,  %d  %d  %d\"/>\n",
                win2wall, roomSizeX-win2wall, door2wall, roomSizeY, roomSizeZ, door2wall+doorwidth, roomSizeY, roomSizeZ);
        fprintf(f,"\t\t</IndexedLineSet>\n");
        fprintf(f,"\t</Shape>\n");

        // define VOXEL at 1,1,1
        fprintf(f,"<Transform translation=\"1 1 1\">\n");
        fprintf(f,"\t<Shape DEF=\"VOXEL\">\n\t\t<Box  DEF=\"VOXELB\" size=\"%5.2f %5.2f %5.2f\"/>\n",
                VoxelSize, VoxelSize,VoxelSize);
        fprintf(f,"\t\t<Appearance>\n\t\t\t<Material diffuseColor=\"1 1 1\"/>\n\t\t</Appearance>\n\t</Shape>\n</Transform>\n");
        // define CORNER (red) and set one at each one of the four corners
        fprintf(f,"<Transform translation=\"0 0 0\">\n");
        fprintf(f,"\t<Shape DEF=\"CORNER\">\n\t\t<Sphere radius=\"%3.2f\"/>\n", 2*VoxelSize);
        fprintf(f,"\t\t<Appearance>\n\t\t\t<Material diffuseColor=\"1 0 0\"/>\n");
        fprintf(f,"\t\t</Appearance>\n\t</Shape>\n</Transform>\n");
        fprintf(f,"<Transform translation=\" %d  %d   0\">", roomSizeX, roomSizeY);
        fprintf(f,"<Shape USE=\"CORNER\"/></Transform>\n");
        fprintf(f,"<Transform translation=\" %d   0   0\">", roomSizeX);
        fprintf(f,"<Shape USE=\"CORNER\"/></Transform>\n");
        fprintf(f,"<Transform translation=\"  0  %d   0\">", roomSizeY);
        fprintf(f,"<Shape USE=\"CORNER\"/></Transform>\n");

        // main loop

        // set shortcuts
        lin = r.volume().size_x();
        col = r.volume().size_y();
        hgt = r.volume().size_z();
        //pln = lin * col; // AGIL: pln set but not used, so removed to avoid warnings in GCC-4.6
        // loop through voxels
        for (iLoopZ=0;iLoopZ<hgt;iLoopZ++)
            for (iLoopY=0;iLoopY<col;iLoopY++)
                for (iLoopX=0;iLoopX<lin;iLoopX++)
                {
                    // check if this is a FG voxel
                    if (r.volume()(0)[iLoopX][iLoopY][iLoopZ])
                    {
                        // if so, it should be on the surface to be visible
                        if ( (iLoopX==0) || (iLoopX>=lin-1) || (iLoopY==0) || (iLoopY>=col-1) || (iLoopZ==0) || (iLoopZ>=hgt-1) // on walls
                                || !r.volume()(0)[iLoopX+1][iLoopY][iLoopZ]    // next X is empty
                                || !r.volume()(0)[iLoopX-1][iLoopY][iLoopZ]    // previous X is empty
                                || !r.volume()(0)[iLoopX][iLoopY+1][iLoopZ]  // next Y is empty
                                || !r.volume()(0)[iLoopX][iLoopY-1][iLoopZ]  // previous Y is empty
                                || !r.volume()(0)[iLoopX][iLoopY][iLoopZ+1]  // next Z empty
                                || !r.volume()(0)[iLoopX][iLoopY][iLoopZ-1]  // previous Z empty
                           )
                        {
                            // voxel coordinates
                            vx=static_cast<int32>(iLoopX*VoxelSize);
                            vy=static_cast<int32>(iLoopY*VoxelSize);
                            vz=static_cast<int32>(iLoopZ*VoxelSize);
                            fprintf(f,"<Transform translation=\"%d %d %d\"> ", vx, vy, vz);
                            fprintf(f,"<Shape USE=\"VOXEL\"/></Transform>\n");
                            //vCounter++; // count as displayed
                        }
                        //else nsCounter++; // count as a non surface (but FG) voxel
                    }
                }


        // close scene markup and output file
        fprintf(f,"</Scene>\n</X3D>\n");
        fclose(f);
        //cout << "\t ...done: " << vCounter <<" voxels represented (" << nsCounter<< " not on the surface)" <<  endl;
    }
    else
    {
        throw ImagePlusError("ERROR(WriteRoom): Non-valid volume file extension");
    }

}

//ReadRoom instantiations
namespace imageplus
{
    namespace io
    {

        template void WriteRoom::operator<<<uint8> (const Room<uint8,1>& ) const;
        template void WriteRoom::operator<<<uint8> (const Room<uint8,3>& ) const;

        template void WriteRoom::operator<<<uint32> (const Room<uint32,1>& ) const;
        template void WriteRoom::operator<<<uint32> (const Room<uint32,3>& ) const;

        template void WriteRoom::operator<<<int32> (const Room<int32,1>& ) const;
        template void WriteRoom::operator<<<int32> (const Room<int32,3>& ) const;

        
        template void WriteRoom::operator<<<int64> (const Room<int64,1>& ) const;
        template void WriteRoom::operator<<<int64> (const Room<int64,3>& ) const;

        template void WriteRoom::operator<<<float64> (const Room<float64,1>& ) const;
        template void WriteRoom::operator<<<float64> (const Room<float64,3>& ) const;
    }
}
