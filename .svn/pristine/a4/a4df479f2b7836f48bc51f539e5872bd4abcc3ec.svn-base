// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------

//!
//!  \file linear_convolution.hpp
//!

#ifndef IMAGEPLUS_FILTERS_LINEAR_CONVOLUTION_HPP
#define IMAGEPLUS_FILTERS_LINEAR_CONVOLUTION_HPP

#include <imageplus/core/filter.hpp>
#include <imageplus/core/multiarray.hpp>
#include <imageplus/core/imagegray.hpp>

namespace imageplus
{

    //!
    //! \namespace imageplus::filters
    //!
    //! \brief Module for several kind of filters
    //!
    namespace filters
    {
        //!
        //! \brief Linear Convolution Filter
        //!
        //! This class implements the linear convolution filter: a squared kernel
        //! that is evaluated for every pixel value. The kernel is a MultiArray<float64,2> (n, m) where n
        //! and m are odd.
        //!
        //!
        //! \author Adolfo LÃ³pez <alopez@gps.tsc.upc.edu>
        //! \author Ramon Morros <ramon.morros@upc.edu>
        //!
        //! \date 4-9-2009
        //!
        //! \todo The concept is extensive to 3D with a cubic kernel
        //!
        class LinearConvolution : public Filter<LinearConvolution>
        {

            public:

                //!
                //! \brief Default constructor
                //!
                LinearConvolution();

                //!
                //! \brief Constructor with a specific kernel
                //!
                //! \param[in] kernel: the kernel used to do the linear convolution
                //!
                LinearConvolution(const MultiArray<float64,2>& kernel);

                //!
                //! \brief Destructor
                //!
                ~LinearConvolution();

                //!
                //! \brief Overloading of method implementation()
                //!
                //! WARNING!: Never use this method. Use filter() instead.
                //!
                //! \param[in] in : MultiArray to be filtered
                //!
                //! \return Filtered MultiArray (copies output)
                //!
                template<typename T>
                MultiArray<T,2> implementation(const MultiArray<T,2>& in) const throw (ImagePlusError);

                //!
                //! \brief Overloading of method implementation()
                //!
                //! WARNING!: Never use this method. Use filter() instead.
                //!
                //! \param[in] m : Gray Image to be filtered
                //!
                //! \return Filtered gray image (copies output)
                //!
                template<typename T>
                ImageGray<T> implementation(const ImageGray<T>& m) const throw (ImagePlusError);


            private:

                //! Horizontal kernel size
                uint64 _size_x;

                //! Vertical kernel size
                uint64 _size_y;

                //! Square Kernel.
                MultiArray<float64,2> _kernel;

        };



        /*!
         * \brief Class to define a kernel of a convolution.
         *
         * The origin is kept at 0 and it allows positive and negative coordinates.
         *
         * \note Although it is template of dimension, it just works for 1D.
         * \todo Extend to N dimensions
         * \tparam D: Dimension of the kernel
         *
         * \author Jordi Pont   <jordi.pont@upc.edu>
         * \date 06-04-2010
         */
        template<std::size_t D>
        class Kernel : public MultiArray<float64,D>
        {
        public:
            /*! Default Constructor, it defines a "delta"
             */
            Kernel() :_half_size(0)
            {
                MultiArray<float64,D>::resize(boost::extents[1]);
                (*this)[0] = 1;
            }

            /*! Constructor receiving half its size (total size 2*N+1).
             *
             * \param[in] half_size: Half the size of the kernel
             */
            Kernel(std::size_t half_size): _half_size(half_size)
            {
                MultiArray<float64,D>::resize(boost::extents[2*half_size+1]);
                MultiArray<float64,D>::reindex(-half_size);
            }

            /*!
             * Copy constructor
             *
             * \param[in] copy: Kernel to be copied
             * \note Done with operator= for MSVC
             * \todo Use copy constructor instead
             */
            Kernel(const Kernel& copy): _half_size(copy._half_size)
            {
                MultiArray<float64,D>::operator=(copy);
                MultiArray<float64,D>::reindex(-_half_size);
            }


            /*!
             * \param  copy: Kernel to copy
             * \return copy, to concatenate
             */
            const Kernel& operator=( const Kernel& copy)
            {
                _half_size =  copy._half_size;
                MultiArray<float64,D>::operator=(copy);
                MultiArray<float64,D>::reindex(-_half_size);
                return copy;
            }

            /*!
             * \returns the total size of the kernel
             */
            std::size_t size() const
            {
                return this->shape()[0];
            }

            /*!
             * \returns half the size of the kernel
             *          (i.e., the size of the border we should put to a signal in order to
             *          filter it without going out of bound)
             */
            std::size_t border_size() const
            {
                return _half_size;
            }

            /*! Resize the Kernel to a certain half size
             * \param half_size :  New half size
             */
            void resize(std::size_t half_size)
            {
                _half_size = half_size;
                MultiArray<float64,D>::resize(boost::extents[2*half_size+1]);
                MultiArray<float64,D>::reindex(-half_size);
            }
        private:
            //! Half size of the Kernel
            std::size_t _half_size;
        };



        /*! \brief Class to handle 1D linear convolutions
         *
         * \author Jordi Pont   <jordi.pont@upc.edu>
         * \date 06-04-2010
         */
        class LinearConvolution1D
        {
        public:
            /*!
             * The internal kernel type
             */
            typedef Kernel<1> kernel_type;

            /*! Constructor receiving the kernel to convolve (by default a delta)
             * \param kernel : Kernel to be set
             */
            LinearConvolution1D(Kernel<1> kernel=Kernel<1>())
                :_kernel(kernel), _border_size(kernel.border_size()), _kernel_size(kernel.size())
            {
            }

            /*! Function to convolve a 1D multiarray, padding is applied if needed.
             * \param[in] in : Multiarray to be convolved
             * \param[out] out: Resulting multiarray (with padding)
             * \tparam T1 : Type of data of the first MultiArray
             * \tparam T2 : Type of data of the second MultiArray
             */
            template<class T1, typename T2>
            void calculate(const MultiArray<T1, 1>& in, MultiArray<T2, 1>& out)
            {
                // Apply padding
                MultiArray<T1, 1> in_border(boost::extents[in.size()+2*_border_size]);
                typename MultiArray<T1, 1>::iterator it_border=in_border.begin();
                for(std::size_t ii=0; ii<_border_size; ++ii)
                    ++it_border;
                for(typename MultiArray<T1, 1>::const_iterator it=in.begin(); it!=in.end(); ++it, ++it_border)
                    *it_border = *it;

                // Resize out
                out.resize(boost::extents[in.size()]);

                calculate(in_border.begin(), in_border.end(), out.begin());
            }

            /*! Function to convolve a multiarray using iterators, padding is assumed to be already applied.
             * \param[in] first_in   : Iterator pointing to the first value of the input
             * \param[in] last_in    : Iterator pointing to the last value of the input
             * \param[out] first_out : Iterator pointing to the first value of the output (with padding)
             * \tparam InputIterator : Type of iterator of the input
             * \tparam OutputIterator : Type of iterator of the output
             */
            template<class InputIterator, class OutputIterator>
            void calculate(InputIterator first_in, InputIterator last_in, OutputIterator first_out)
            {
                InputIterator begin_in = first_in;
                for(std::size_t ii=0; ii<_kernel_size-1; ++ii)
                    ++first_in;
                InputIterator end_in = first_in;

                do
                {
                    InputIterator it_in = begin_in;
                    *first_out = 0;
                    for(int32 ii=-_border_size; ii<=(int32)_border_size; ++ii, ++it_in)
                    {
                        *first_out += (*it_in)*_kernel[ii];
                    }
                    ++first_out; ++begin_in; ++end_in;
                }
                while(end_in!=last_in);
            }

            //! \returns the internal kernel
            const Kernel<1>& kernel() const
            {
                return _kernel;
            }

            //! Sets the kernel
            //! \param ker Kernel to be set
            void kernel(Kernel<1> ker)
            {
                _kernel = ker;
                _border_size = ker.border_size();
                _kernel_size = ker.size();
            }

            /*!
             * \param copy : LinearConvolution1D to copy
             *
             * \return copy, to concatenate
             */
            const LinearConvolution1D& operator=( const LinearConvolution1D& copy)
            {
                kernel(copy.kernel());
                return copy;
            }

        private:
            //! Kernel to convolve
            Kernel<1> _kernel;

            //! Half size of the Kernel
            std::size_t _border_size;

            //! Full size of the Kernel
            std::size_t _kernel_size;
        };




        /*! \brief Class to handle 2D separable linear convolutions.
         *
         *  It convolves first in one dimensions
         *  and then in the other using 1D convolutions.
         *
         * \author Jordi Pont   <jordi.pont@upc.edu>
         * \date 06-04-2010
         */
        class SeparableLinearConvolution2D
        {
        public:
            /*!
             * The internal kernel type
             */
            typedef Kernel<1> kernel_type;

            /*! Constructor receiving a 1D kernel to convolve (by default a delta) that is used in both dimensions
             * \param kernel : 1D kernel to be set
             */
            SeparableLinearConvolution2D(Kernel<1> kernel)
                :_kernel1(kernel), _kernel2(kernel),
                 _border_size1(kernel.border_size()), _border_size2(kernel.border_size()),
                 _kernel_size1(kernel.size()), _kernel_size2(kernel.size())
            {
            }
            /*! Constructor receiving two 1D kernels to convolve (by default a delta) in each dimension
             * \param kernel1 : 1D kernel to be set in dimension 1
             * \param kernel2 : 1D kernel to be set in dimension 2
             */
            SeparableLinearConvolution2D(Kernel<1> kernel1, Kernel<1> kernel2)
                :_kernel1(kernel1), _kernel2(kernel2),
                 _border_size1(kernel1.border_size()), _border_size2(kernel2.border_size()),
                 _kernel_size1(kernel1.size()), _kernel_size2(kernel2.size())
            {
            }

            /*! Function to convolve a 2D multiarray, padding is applied if needed.
             * \param[in] in : Multiarray to be convolved
             * \param[out] out: Resulting multiarray (with padding)
             * \tparam T1 : Type of data of the first MultiArray
             * \tparam T2 : Type of data of the second MultiArray
             */
            template<typename T1, typename T2>
            void calculate(const MultiArray<T1, 2>& in, MultiArray<T2, 2>& out)
            {
                boost::array<size_type, 2> bases  = {{-_border_size1,0}};
                boost::array<size_type, 2> border = {{ _border_size1,0}};
                MultiArray<T1, 2>  in_border;
                zero_padding(in,border,in_border);
                in_border.reindex(bases);

                std::size_t sx = in.shape()[0];
                std::size_t sy = in.shape()[1];

                out.resize(boost::extents[sx][sy]);
                out = 0;

                typedef boost::multi_array_types::index_range range;
                typename MultiArray<T1, 2>::index_gen indices;
                typename MultiArray<T2, 2>::index_gen indices_out;

                LinearConvolution1D conv1(_kernel1);
                LinearConvolution1D conv2(_kernel2);

                // Convolve rows
                for(std::size_t ii = 0; ii<sy; ++ii)
                {
                    typename MultiArray<T1, 2>::template array_view<1>::type view_in = in_border[indices[range(-_border_size1,sx+_border_size1)][ii]];
                    typename MultiArray<T2, 2>::template array_view<1>::type view_out = out[indices_out[range(0,sx)][ii]];
                    conv1.calculate(view_in.begin(), view_in.end(), view_out.begin());
                }

                boost::array<size_type, 2> bases2  = {{0,-_border_size2}};
                boost::array<size_type, 2> border2 = {{0, _border_size2}};
                MultiArray<T2, 2>  out_border;
                zero_padding(out,border2,out_border);
                out_border.reindex(bases2);

                // Convolve rows
                for(std::size_t ii = 0; ii<sx; ++ii)
                {
                    typename MultiArray<T2, 2>::template array_view<1>::type view_in  = out_border[indices_out[ii][range(-_border_size2,sy+_border_size2)]];
                    typename MultiArray<T2, 2>::template array_view<1>::type view_out = out[indices_out[ii][range(0,sy)]];

                    conv2.calculate(view_in.begin(), view_in.end(), view_out.begin());
                }
            }

            //! Sets the kernel
            //! \param ker: 1D kernel to be set for each dimension
            void kernel(Kernel<1> ker)
            {
                _kernel1 = ker;
                _kernel2 = ker;
                _border_size1 = ker.border_size();
                _border_size2 = ker.border_size();
                _kernel_size1 = ker.size();
                _kernel_size2 = ker.size();
            }
        private:
            //! Kernel for dimension 1
            Kernel<1> _kernel1;

            //! Kernel for dimension 2
            Kernel<1> _kernel2;

            //! Half size of kernel for dimension 1
            std::size_t _border_size1;

            //! Half size of kernel for dimension 2
            std::size_t _border_size2;

            //! Full size of kernel for dimension 1
            std::size_t _kernel_size1;

            //! Full size of kernel for dimension 2
            std::size_t _kernel_size2;
        };



        /*! \brief Class to handle 2D separable linear convolutions.
         *
         *  It convolves first in one dimensions
         *  and then in the other using 1D convolutions.
         *
         * \warning this class should be replaced for a generic convolution ND
         *
         * \author Jordi Pont <jordi.pont@upc.edu>
         * \author Albert Gil <albert.gil@upc.edu>
         * \date 06-04-2010
         */
        class SeparableLinearConvolution3D
        {
        public:
            /*!
             * The internal kernel type
             */
            typedef Kernel<1> kernel_type;

            /*!
             * Constructor receiving a 1D kernel to convolve (by default a delta) that is used in all dimensions
             *
             * \param kernel : 1D kernel to be set
             */
            SeparableLinearConvolution3D(Kernel<1> kernel)
            :   _kernel1(kernel),
                _kernel2(kernel),
                _kernel3(kernel),
                _border_size1(kernel.border_size()),
                _border_size2(kernel.border_size()),
                _border_size3(kernel.border_size()),
                _kernel_size1(kernel.size()),
                _kernel_size2(kernel.size()),
                _kernel_size3(kernel.size())
            {
            }

            /*!
             * Constructor receiving two 1D kernels to convolve (by default a delta) in each dimension
             *
             * \param kernel1 : 1D kernel to be set in dimension 1
             * \param kernel2 : 1D kernel to be set in dimension 2
             * \param kernel3 : 1D kernel to be set in dimension 3
             */
            SeparableLinearConvolution3D(Kernel<1> kernel1, Kernel<1> kernel2, Kernel<1> kernel3)
            :   _kernel1(kernel1),
                _kernel2(kernel2),
                _kernel3(kernel3),
                _border_size1(kernel1.border_size()),
                _border_size2(kernel2.border_size()),
                _border_size3(kernel3.border_size()),
                _kernel_size1(kernel1.size()),
                _kernel_size2(kernel2.size()),
                _kernel_size3(kernel3.size())
            {
            }

            /*! Function to convolve a 2D multiarray, padding is applied if needed.
             * \param[in] in : Multiarray to be convolved
             * \param[out] out: Resulting multiarray (with padding)
             * \tparam T1 : Type of data of the first MultiArray
             * \tparam T2 : Type of data of the second MultiArray
             */
            template<typename T1, typename T2>
            void calculate(const MultiArray<T1, 3>& in, MultiArray<T2, 3>& out)
            {
                /*
                 * MultiArray View types and variables
                 */
                typedef boost::multi_array_types::index_range                    range;
                typedef typename MultiArray<T1, 3>::template array_view<1>::type view_1d_type;

                typename MultiArray<T1, 3>::index_gen indices;
                typename MultiArray<T2, 3>::index_gen indices_out;

                /*
                 * 1D filters
                 */
                LinearConvolution1D conv1(_kernel1);
                LinearConvolution1D conv2(_kernel2);
                LinearConvolution1D conv3(_kernel3);

                /*
                 * Temporal variables
                 */
                MultiArray<T1, 3>  in_border_d1;
                MultiArray<T1, 3>  in_d2;
                MultiArray<T1, 3>  in_border_d2;
                MultiArray<T1, 3>  in_d3;
                MultiArray<T1, 3>  in_border_d3;

                /*
                 * Initialize the output
                 */
                std::size_t sx = in.shape()[0];
                std::size_t sy = in.shape()[1];
                std::size_t sz = in.shape()[2];

                //out.resize(in.shape());
                in_d2.resize(boost::extents[sx][sy][sz]);
                in_d3.resize(boost::extents[sx][sy][sz]);
                out  .resize(boost::extents[sx][sy][sz]);
                in_d2 = 0;
                in_d3 = 0;
                out   = 0;


                /*
                 * First dimension
                 */
                boost::array<size_type, 3> bases_d1  = {{-_border_size1,0, 0}};
                boost::array<size_type, 3> border_d1 = {{ _border_size1,0, 0}};

                zero_padding(in,border_d1,in_border_d1);
                in_border_d1.reindex(bases_d1);

                for(std::size_t ii = 0; ii<sy; ++ii)
                {
                    for(std::size_t jj = 0; jj<sz; ++jj)
                    {
                        view_1d_type view_in  = in_border_d1[ indices[range(-_border_size1,sx+_border_size1)][ii][jj] ];
                        view_1d_type view_out = in_d2       [ indices_out[range(0,sx)][ii][jj]];

                        conv1.calculate(view_in.begin(), view_in.end(), view_out.begin());
                    }
                }

                /*
                 * Second dimension
                 */
                boost::array<size_type, 3> bases_d2  = {{0,-_border_size2, 0}};
                boost::array<size_type, 3> border_d2 = {{0, _border_size2, 0}};

                zero_padding(in_d2,border_d2,in_border_d2);
                in_border_d2.reindex(bases_d2);

                // Convolve columns
                for(std::size_t ii = 0; ii<sx; ++ii)
                {
                    for(std::size_t jj = 0; jj<sz; ++jj)
                    {
                        view_1d_type view_in  = in_border_d2[ indices_out[ii][range(-_border_size2,sy+_border_size2)][jj]];
                        view_1d_type view_out = in_d3       [ indices_out[ii][range(0,sy)][jj]];

                        conv2.calculate(view_in.begin(), view_in.end(), view_out.begin());
                    }
                }

                /*
                 * Third dimension
                 */
                boost::array<size_type, 3> bases_d3  = {{0, 0, -_border_size3}};
                boost::array<size_type, 3> border_d3 = {{0, 0,  _border_size3}};

                zero_padding(in_d3,border_d3,in_border_d3);
                in_border_d3.reindex(bases_d3);

                // Convolve in depth
                for(std::size_t ii = 0; ii<sx; ++ii)
                {
                    for(std::size_t jj = 0; jj<sy; ++jj)
                    {
                        view_1d_type view_in  = in_border_d2[ indices_out[ii][jj][range(-_border_size3,sz+_border_size3)]];
                        view_1d_type view_out = out         [ indices_out[ii][jj][range(0,sz)]];

                        conv2.calculate(view_in.begin(), view_in.end(), view_out.begin());
                    }
                }
            }

            //! Sets the kernel
            //! \param ker: 1D kernel to be set for each dimension
            void kernel(Kernel<1> ker)
            {
                _kernel1 = ker;
                _kernel2 = ker;
                _kernel3 = ker;

                _border_size1 = ker.border_size();
                _border_size2 = ker.border_size();
                _border_size3 = ker.border_size();

                _kernel_size1 = ker.size();
                _kernel_size2 = ker.size();
                _kernel_size3 = ker.size();
            }
        private:
            //! Kernel for dimension 1
            Kernel<1> _kernel1;

            //! Kernel for dimension 2
            Kernel<1> _kernel2;

            //! Kernel for dimension 3
            Kernel<1> _kernel3;

            //! Half size of kernel for dimension 1
            std::size_t _border_size1;

            //! Half size of kernel for dimension 2
            std::size_t _border_size2;

            //! Half size of kernel for dimension 3
            std::size_t _border_size3;

            //! Full size of kernel for dimension 1
            std::size_t _kernel_size1;

            //! Full size of kernel for dimension 2
            std::size_t _kernel_size2;

            //! Full size of kernel for dimension 3
            std::size_t _kernel_size3;
        };


    }
}

#endif
