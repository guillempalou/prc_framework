// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------

//!
//!  \file partition_functions.hpp
//!
//!  Region-oriented partitions
//!

#ifndef IMAGEPLUS_CORE_PARTITION_FUNCTIONS_HPP
#define IMAGEPLUS_CORE_PARTITION_FUNCTIONS_HPP

#include <deque>
#include <sstream>

#include <imageplus/core/partition.hpp>
//#include <imageplus/core/region.hpp>
//#include <imageplus/core/region_contour.hpp>


namespace imageplus
{
	//! Creates an ImagePartition from a set of regions defined by the region iterators, i.e., it fills 
	//! their coordinates with their identifier
	//!
	//! \param[in] first: Iterator to the first region to be filled
	//! \param[in] last : Iterator to the last region to be filled
	//! \param[out] partition_out : ImagePartition that is filled
    template<class RegionIteratorModel, class ImagePartitionModel>
    void create_image_partition(RegionIteratorModel& first, RegionIteratorModel& last, ImagePartitionModel& partition_out)
    {
#ifndef NDEBUG
        uint32 n_labeled=0;
#endif
        for(; first!=last; ++first)
        {
            typename RegionIteratorModel::RegionType& curr_reg = *first;
            typename RegionIteratorModel::RegionType::position_iterator coord_it = curr_reg.begin();
            typename RegionIteratorModel::RegionType::position_iterator coord_it_end = curr_reg.end();
            for(; coord_it!=coord_it_end; ++coord_it)
            {
#ifndef NDEBUG
                n_labeled++;
#endif
                partition_out(*coord_it) = curr_reg.label();
            }
        }
        
        ASSERT(partition_out.size_x()*partition_out.size_y()<=n_labeled, "create_image_partition: Not all pixels have been labeled");
        ASSERT(partition_out.size_x()*partition_out.size_y()>=n_labeled, "create_image_partition: Some pixels have been labeled twice");

    }
    
	//! Creates an ImagePartition from a BPT and the number of regions we want.
	//!
	//! \param[in] partition_in: Partition from which the ImagePartition is created
	//! \param[in] num_regions : number of regions of the ImagePartition
	//! \param[out] partition_out : ImagePartition that is filled
    template<class PartitionModel, class ImagePartitionModel>
    void create_image_partition(PartitionModel& partition_in, std::size_t num_regions, ImagePartitionModel& partition_out)
    {
        typedef typename PartitionModel::RegionPointer RegPointer;
        std::set<RegPointer> set_of_ident;
        
        std::size_t curr_num_reg = 0;
        typename PartitionModel::leaves_iterator leaves_it = partition_in.begin();
        typename PartitionModel::leaves_iterator leaves_it_end = partition_in.end();
        for(; leaves_it!=leaves_it_end; ++leaves_it, ++curr_num_reg)
        {
            set_of_ident.insert(RegPointer(&(*leaves_it)));
        }

        typename PartitionModel::non_leaves_iterator non_leaves_it = partition_in.begin();
        for(; curr_num_reg>num_regions; --curr_num_reg, ++non_leaves_it)
        {
            set_of_ident.insert(RegPointer(&(*non_leaves_it)));
            typename std::vector<RegPointer>::const_iterator it = (*non_leaves_it).parts().begin();
            typename std::vector<RegPointer>::const_iterator it_end = (*non_leaves_it).parts().end();
            for(; it!=it_end; ++it)
            {
                set_of_ident.erase(*it);
            }
        }
        
        typename std::set<typename PartitionModel::RegionPointer>::iterator first = set_of_ident.begin();
        typename std::set<typename PartitionModel::RegionPointer>::iterator last  = set_of_ident.end();
        for(; first!=last; ++first)
        {
            typename PartitionModel::RegionType& curr_reg = **first;
            typename PartitionModel::RegionType::position_iterator coord_it = curr_reg.begin();
            typename PartitionModel::RegionType::position_iterator coord_it_end = curr_reg.end();
            for(; coord_it!=coord_it_end; ++coord_it)
            {
                partition_out(*coord_it) = curr_reg.label();
            }
        }
    }
    
    
    //!
    //! \brief Prunes a branch of the tree, i.e., it deletes all the subregions of the region with given label
    //!
    //! \param[in] region: Region we want to prune
    //! \param[in] bpt: Tree want to prune
    template<class PartitionModel>
    void prune(typename PartitionModel::RegionType& region, PartitionModel& bpt)
    {
        // ASSERT region is inside bpt
        typedef typename PartitionModel::RegionType RegionType;
        typedef typename PartitionModel::RegionPointer RegPointer;

        if(region.parts().size()>0)
        {
            // Get the coordinates of the leaves
        	if (region.size() == 0) {
        		for (typename RegionType::position_iterator it = region.begin(); it != region.end(); ++it) {
        			region.push_back(*it);
        		}
        	}
        	
        	std::deque<RegPointer> to_look;
            std::size_t n_to_look = 0;
            for(std::size_t ii=0; ii<region.parts().size(); ii++)
            {
                to_look.push_back(region.parts()[ii]);
                n_to_look++;
            }
            region.clear_parts();
            
            while(n_to_look>0)
            {
                RegPointer curr = to_look.back();
                to_look.pop_back();
                 
                std::size_t n_children;
                if((n_children=curr->parts().size())==0)
                {
                    n_to_look--;
                }
                else
                {
                    for(std::size_t ii=0; ii<n_children; ii++)
                    {
                        to_look.push_back(curr->parts()[ii]);
                    }
                    n_to_look = n_to_look + n_children - 1;
                }

                // Relabel the part of the partition involved
                for(typename RegionType::position_iterator it2=curr->begin(), it2_end=curr->end(); it2!=it2_end; ++it2)
                    bpt._leaves_partition(0)(*it2) = region.label();
                
                // Erase the region
                typename PartitionModel::map_type::iterator it = bpt._regions.find(curr->label());
                ASSERT(it!=bpt._regions.end(), "prune: Region index not found.");
                delete(it->second);
                bpt._regions.erase(it);
            }
        }
    }
    
    
    //!
    //! \brief Prunes a branch of the tree, i.e., it deletes all the subregions of the region with given label
    //!
    //! \param[in] label: Label of the region we want to prune
    //! \param[in] bpt: Tree want to prune
    template<class PartitionModel>
    void prune(typename PartitionModel::IdentifierType label, PartitionModel& bpt)
    {
        prune(bpt[label], bpt);
    }


    
    //! Adds a new region, formed by the merging of two of the exisitng ones
    //!
    //! \param[in] reg1 : One of the regions to be merged
    //! \param[in] reg2 : The other region to be merged
    //! \param[in] father : Identifier of the new region to be created
    //! \param[in] bpt: Tree we want to modify
    template<class PartitionModel>
    void merge_regions(typename PartitionModel::RegionType& reg1, typename PartitionModel::RegionType& reg2, typename PartitionModel::IdentifierType father, PartitionModel& bpt)
    {
    	/*
    	 * AGIL: The first ASSERT is not correct because the condition is
    	 *       not strictly mandatory. We can merge non-neighbor regions.
    	 */
    	//ASSERT(reg1.neighbors_find(&reg2)!=reg1.neighbors_end(), "merge_regions: reg2 is not a neighbor of reg1.")
        ASSERT(bpt._regions.find(reg1.label())!=bpt._regions.end(), "merge_regions: one of the sons is not in the partition.");
        ASSERT(bpt._regions.find(reg2.label())!=bpt._regions.end(), "merge_regions: one of the sons is not in the partition.");
        ASSERT(bpt._regions.find(reg1.label())->second == &reg1, "merge_regions: Region 1 is not a member of the partition." );
        ASSERT(bpt._regions.find(reg2.label())->second == &reg2, "merge_regions: Region 2 is not a member of the partition." );
        ASSERT(bpt._regions.find(father)==bpt._regions.end(), "merge_regions: the label of the father was already in the partition.");
        ASSERT(reg1.parent()==0, "merge_regions: trying to merge a region that already has a father.");
        ASSERT(reg2.parent()==0, "merge_regions: trying to merge a region that already has a father.");
            
        bpt._curr_max_label = std::max(bpt._curr_max_label, father);
         
        typedef typename PartitionModel::RegionType RegionType;
        typedef typename PartitionModel::RegionPointer RegPointer;

        typedef typename PartitionModel::map_pair_type map_pair_type;

        const RegPointer& ptr_reg1 = bpt._regions.find(reg1.label())->second;
        const RegPointer& ptr_reg2 = bpt._regions.find(reg2.label())->second;
        RegPointer father_reg = RegPointer(new RegionType(ptr_reg1, ptr_reg2, father));
        bpt._regions.insert(map_pair_type(father, father_reg));
        reg1.parent(father_reg);
        reg2.parent(father_reg);
       
        // Delete link between merged regions
        reg1.neighbors_erase(ptr_reg2);
         
        // Create the neighbor pointers from the sons
        typename RegionType::neighbor_iterator neigh_it = reg1.neighbors_begin();
        for(; neigh_it!=reg1.neighbors_end(); ++neigh_it)
        {
            father_reg->neighbors_insert(*neigh_it, neigh_it);
        }
         
        neigh_it = reg2.neighbors_begin();
        for(; neigh_it!=reg2.neighbors_end(); ++neigh_it)
        {
            father_reg->neighbors_insert(*neigh_it, neigh_it);
        }
        
        reg1.neighbors_clear();
        reg2.neighbors_clear();
        
        // Generate the partition for the new created region
        bpt._update_roots_partition(father_reg);
    }
    
    //! Adds a new region, formed by the merging of two of the exisitng ones
    //!
    //! \param[in] label1 : Label of one of the regions to be merged
    //! \param[in] label2 : Label of the other region to be merged
    //! \param[in] father : Identifier of the new region to be created
    //! \param[in] bpt: Tree want to modify
    template<class PartitionModel>
    void merge_regions(uint32 label1, uint32 label2, uint32 father, PartitionModel& bpt)
    {
        typename PartitionModel::global_iterator it, it2;
    
        it  = bpt.find(label1);
        it2 = bpt.find(label2);
         
        ASSERT(it !=bpt.end(), "merge_regions: one of the sons is not in the partition.");
        ASSERT(it2!=bpt.end(), "merge_regions: one of the sons is not in the partition.");
        ASSERT(bpt.find(father)==bpt.end(), "merge_regions: the label of the father was already in the partition.");
        ASSERT((*it).parent()==0, "merge_regions: trying to merge a region that already has a father.");
        ASSERT((*it2).parent()==0, "merge_regions: trying to merge a region that already has a father.");
        
        merge_regions((*it), (*it2), father, bpt);
    }
    
    /*!
     * Adds a new region, formed by the merging of two of the exisitng ones
     *
     * \param[in] reg1      : One of the regions to be merged
     * \param[in] reg2      : The other region to be merged
     * \param[in] father    : Identifier of the new region to be created
     * \param[in] bpt       : Tree we want to modify
     * \param[in] to_put    : Set of neighbor links created
     * \param[in] to_delete : Set of neighbor links deleted
     */
    template<class PartitionModel>
    void merge_regions( typename PartitionModel::RegionType&                                               reg1,
                        typename PartitionModel::RegionType&                                               reg2,
                        typename PartitionModel::IdentifierType                                            father,
                        PartitionModel&                                                                    bpt,
                        std::list<typename PartitionModel::RegionType::NeighborLinkPointer>&               to_put,
                        std::vector<std::list<typename PartitionModel::RegionType::NeighborLinkPointer> >& to_delete )
    {
        ASSERT(bpt._regions.find(reg1.label())!=bpt._regions.end(), "merge_regions: one of the sons is not in the partition.");
        ASSERT(bpt._regions.find(reg2.label())!=bpt._regions.end(), "merge_regions: one of the sons is not in the partition.");
        ASSERT(bpt._regions.find(reg1.label())->second == &reg1, "merge_regions: Region 1 is not a member of the partition." );
        ASSERT(bpt._regions.find(reg2.label())->second == &reg2, "merge_regions: Region 2 is not a member of the partition." );
        ASSERT(bpt._regions.find(father)==bpt._regions.end(), "merge_regions: the label of the father was already in the partition.");
        ASSERT(reg1.parent()==0, "merge_regions: trying to merge a region that already has a father: region "<< reg1.label());
        ASSERT(reg2.parent()==0, "merge_regions: trying to merge a region that already has a father.");
            
        bpt._curr_max_label = std::max(bpt._curr_max_label, father);
         
        typedef typename PartitionModel::RegionType RegionType;
        typedef typename PartitionModel::RegionPointer RegPointer;
    
        typedef typename PartitionModel::map_pair_type map_pair_type;
    
        const RegPointer& ptr_reg1 = bpt._regions.find(reg1.label())->second;
        const RegPointer& ptr_reg2 = bpt._regions.find(reg2.label())->second;
        RegPointer father_reg = RegPointer(new RegionType(ptr_reg1, ptr_reg2, father));
        bpt._regions.insert(map_pair_type(father, father_reg));
        reg1.parent(father_reg);
        reg2.parent(father_reg);
       
        // Delete link between merged regions
        typename PartitionModel::RegionType::NeighborLinkPointer one_to_delete;
        reg1.neighbors_erase(ptr_reg2, one_to_delete);
        std::list<typename PartitionModel::RegionType::NeighborLinkPointer> tmp;
        tmp.push_back(one_to_delete);
        to_delete.push_back(tmp);
         
        // Create the neighbor pointers from the sons
        typename RegionType::neighbor_iterator neigh_it = reg1.neighbors_begin();
        for(; neigh_it!=reg1.neighbors_end(); ++neigh_it)
        {
            typename PartitionModel::RegionType::NeighborLinkPointer one_to_put = father_reg->neighbors_insert(*neigh_it, neigh_it);
            if(one_to_put!=0x0)
                if(one_to_put->neighbor1()!=0 && one_to_put->neighbor2()!=0)
                    to_put.push_back(one_to_put);
        }
         
        neigh_it = reg2.neighbors_begin();
        for(; neigh_it!=reg2.neighbors_end(); ++neigh_it)
        {
            typename PartitionModel::RegionType::NeighborLinkPointer one_to_put = father_reg->neighbors_insert(*neigh_it, neigh_it);
            if(one_to_put!=0x0)
                if(one_to_put->neighbor1()!=0 && one_to_put->neighbor2()!=0)
                    to_put.push_back(one_to_put);
        }
        
        std::list<typename PartitionModel::RegionType::NeighborLinkPointer> list_to_delete; 
        reg1.neighbors_clear(list_to_delete);
        to_delete.push_back(list_to_delete);
        list_to_delete.clear();
        reg2.neighbors_clear(list_to_delete);
        to_delete.push_back(list_to_delete);
        
        // Generate the partition for the new created region
        bpt._update_roots_partition(father_reg);
    }
    
    

    //! 
    //! \param[in] bpt1 : Tree to be compared
    //! \param[in] bpt2 : Tree to be compared
    //!
    //! \returns true if two bpt are equal (does not check descriptors computed)
    //!
    template<class RegionModel>
    bool operator== (const Partition<RegionModel>& bpt1, const Partition<RegionModel>& bpt2)
    {
        if((bpt1._leaves_partition==bpt2._leaves_partition)&&(bpt1.num_regions()==bpt2.num_regions()))
        {   
            typename Partition<RegionModel>::const_non_leaves_iterator it1 = bpt1.begin();
            typename Partition<RegionModel>::const_non_leaves_iterator it1_end = bpt1.end();
            typename Partition<RegionModel>::const_non_leaves_iterator it2 = bpt2.begin();
            
            for(; it1!=it1_end; ++it1, ++it2)
            {
                bool one_way = ((*it1).parts()[0]->label()==(*it2).parts()[0]->label()) && ((*it1).parts()[1]->label()==(*it2).parts()[1]->label());
                bool another = ((*it1).parts()[0]->label()==(*it2).parts()[1]->label()) && ((*it1).parts()[1]->label()==(*it2).parts()[0]->label());
                if(!(one_way||another))
                {
                    return false;
                }
            }
            
            return true;
        }
        else
            return false;
    }
    
    
    //! Divides a tree between the upper part an the lower part
    //! 
    //! \param[in] num_regions_cut : Number of regions where to perform the cut
    //! \param[in] bpt_in : Original BPT and as output, its lower part
    //! \param[in] bpt_up : Upper part of the tree
    template<class PartitionModel>
    void divide_partition_tree(std::size_t num_regions_cut, PartitionModel& bpt_in, PartitionModel& bpt_up)
    {
        // Set of regions that are in the limit between bpt_in and bpt_up
        std::set<typename PartitionModel::RegionPointer> border_regions;
        
        typename PartitionModel::roots_iterator roots_it = bpt_in.begin();
        while(roots_it!=bpt_in.end())
        {
            border_regions.insert(&(*roots_it));
            ++roots_it;
        }
        
        ASSERT(border_regions.size() <= num_regions_cut, "divide_partition_tree: num_regions_cut is smaller than the number of roots of the tree");
        num_regions_cut -= border_regions.size();
        
        // Set of regions that are not in the limit but have to be moved
        std::set<typename PartitionModel::RegionPointer> up_regions;
        typename PartitionModel::map_type::reverse_iterator reg_it = bpt_in._regions.rbegin();
        while(num_regions_cut>0)
        {
            ASSERT(reg_it!= bpt_in._regions.rend(), "divide_partition_tree: num_regions_cut is bigger than the number of leaves of the tree");
            typename PartitionModel::RegionPointer curr_reg = reg_it->second;
            
            ASSERT(border_regions.find(curr_reg)!=border_regions.end(), "divide_partition_tree: the order we are scanning the regions is not correct (id=" << curr_reg->id() << ")");
            border_regions.erase(curr_reg);

            up_regions.insert(curr_reg);
            border_regions.insert(curr_reg->parts().begin(), curr_reg->parts().end());
            ++reg_it;
            num_regions_cut--;
        }
        
        // Copy the coordinates for the border regions
        for (typename std::set<typename PartitionModel::RegionPointer>::iterator it = border_regions.begin(); it != border_regions.end(); it++) {
        	for (typename PartitionModel::RegionType::position_iterator pos = it->begin(); pos != it->end(); ++pos) {
        		it->push_back(*pos);
        	}
        }
        
        
        // Set of copied limit regions
        std::set<typename PartitionModel::RegionPointer> new_border_regions;

        // Modify relation parent - sons
        typename std::set<typename PartitionModel::RegionPointer>::iterator it = border_regions.begin();
        for(; it!=border_regions.end(); ++it)
        {
            typename PartitionModel::RegionPointer curr_reg = *it;
            typename PartitionModel::RegionPointer copy_reg(new typename PartitionModel::RegionType(*curr_reg));
            new_border_regions.insert(copy_reg);

            copy_reg->parts().clear();
            copy_reg->parent(curr_reg->parent());
            if(curr_reg->parent()!=0)
            {
                curr_reg->parent()->parts().clear();
            }
            
            curr_reg->parent(typename PartitionModel::RegionPointer());
        }
        it = new_border_regions.begin();
        for(; it!=new_border_regions.end(); ++it)
        {
            typename PartitionModel::RegionPointer curr_reg = *it;
            if(curr_reg->parent()!=0)
            {
                curr_reg->parent()->parts().push_back(curr_reg);
            }
        }

        // Modifiy both _regions
        it = up_regions.begin();
        for(; it!=up_regions.end(); ++it)
        {
            bpt_in._regions.erase((*it)->id());
            bpt_up._regions.insert(typename PartitionModel::map_pair_type((*it)->id(),*it));
        }
        it = new_border_regions.begin();
        for(; it!=new_border_regions.end(); ++it)
        {
            bpt_up._regions.insert(typename PartitionModel::map_pair_type((*it)->id(),*it));
        }
        
        // Recompute _curr_max_label
        bpt_up._curr_max_label = (--bpt_up._regions.end())->first;
        bpt_in._curr_max_label = (--bpt_in._regions.end())->first;
        
        // Redo bpt_up._leaves_partition
        bpt_up._leaves_partition.resize(bpt_in._leaves_partition.size_x(), bpt_in._leaves_partition.size_y());
        typename PartitionModel::leaves_iterator root_it = bpt_up.begin();
        typename PartitionModel::leaves_iterator root_it_end = bpt_up.end();
        create_image_partition(root_it, root_it_end, bpt_up._leaves_partition);
        
        // Redo neighbors
        // 2 "up-left" neighbors to be scanned for each pixel
        Neighborhood2D ngb;
        ngb.resize(2);
        ngb[0]=Neighborhood2D::CoordType(0,-1);
        ngb[1]=Neighborhood2D::CoordType(-1,0);
         
        // 2 "down-right" neighbors to be scanned for each pixel (looking for border)
        Neighborhood2D ngb2;
        ngb2.resize(2);
        ngb2[0]=Neighborhood2D::CoordType(0,1);
        ngb2[1]=Neighborhood2D::CoordType(1,0);
         
        boost::array<std::size_t, 2> borders2d;
        borders2d[0]=1;
        borders2d[1]=1;
         
        typename PartitionModel::IdentifierType border_value = not_assigned<typename PartitionModel::IdentifierType>();
        const Border<typename PartitionModel::ImagePartitionType>& part_borders = calc_descriptor(new Border<typename PartitionModel::ImagePartitionType>(borders2d, border_value), bpt_up._leaves_partition);

        // Scan neighbors
        for(typename Border<typename PartitionModel::ImagePartitionType>::template const_iterator<> part_it = part_borders.colors_begin(), part_it_end = part_borders.colors_end() ; part_it!= part_it_end; ++part_it)
        {
            typename PartitionModel::RegionPointer curr_region = &(bpt_in[(*part_it)[PARTITION_CHANNEL]]);

            // Up-left
            for (typename Border<typename PartitionModel::ImagePartitionType>::template const_iterator<>::neighbor_iterator nit = part_it.local_begin(ngb); nit != part_it.local_end(ngb); ++nit)
            {
                if ((*nit)[PARTITION_CHANNEL]==border_value)
                {
                    typename PartitionModel::CoordType border_coord;
                    border_coord = nit.pos_coord() + part_it.pos_coord();
                         
                    // Add a neighbor with the border of the image (RegionPointer())     
                    curr_region->neighbors_insert(typename PartitionModel::RegionPointer(), border_coord);
                }
                else if ((*nit)[PARTITION_CHANNEL]!=(*part_it)[PARTITION_CHANNEL])
                {
                    typename PartitionModel::map_type::iterator it2 = bpt_in._regions.find((*nit)[PARTITION_CHANNEL]);
                     
                    ASSERT(it2!= bpt_in._regions.end(), "Label not found in LUT");
                     
                    const typename PartitionModel::RegionPointer& neighb_reg = it2->second;
                     
                    ASSERT(curr_region!=0, "curr_region is NULL");

                    typename PartitionModel::CoordType border_coord;
                    border_coord = nit.pos_coord() + part_it.pos_coord();

                    // Add a new neighbor
                    curr_region->neighbors_insert(neighb_reg, border_coord);
                }
            }
             
            // Down-right, just for borders
            for (typename Border<typename PartitionModel::ImagePartitionType>::template const_iterator<>::neighbor_iterator nit = part_it.local_begin(ngb2); nit != part_it.local_end(ngb2); ++nit)
            {
                if ((*nit)[PARTITION_CHANNEL]==border_value)
                {
                    typename PartitionModel::CoordType border_coord;
                    border_coord = nit.pos_coord() + part_it.pos_coord();
                       
                    // Add a neighbor with the border of the image (RegionPointer())     
                    curr_region->neighbors_insert(typename PartitionModel::RegionPointer(), border_coord);
                }
            }
        }
    }
    
    /*!
     * Cuts the lower part of a BPT
     *
     * \param[in] num_regions_cut : Number of regions where to perform the cut
     * \param[in] bpt: BPT to be cut
     *
     * \author ?
     */
    template<class PartitionModel>
    void cut_partition_tree_down(std::size_t num_regions_cut, PartitionModel& bpt)
    {
        // Set of regions that are in the limit between bpt_in and bpt_up
        std::set<typename PartitionModel::RegionPointer> border_regions;
        
        typename PartitionModel::roots_iterator roots_it = bpt.begin();
        while(roots_it!=bpt.end())
        {
            border_regions.insert(&(*roots_it));
            ++roots_it;
        }
        
        ASSERT(border_regions.size() <= num_regions_cut, "divide_partition_tree: num_regions_cut is smaller than the number of roots of the tree");
        num_regions_cut -= border_regions.size();
        
        // Set of regions that are not in the limit but have to be moved
        std::set<typename PartitionModel::RegionPointer> up_regions;
        typename PartitionModel::map_type::reverse_iterator reg_it = bpt._regions.rbegin();
        while(num_regions_cut>0)
        {
            ASSERT(reg_it!= bpt._regions.rend(), "divide_partition_tree: num_regions_cut is bigger than the number of leaves of the tree");
            typename PartitionModel::RegionPointer curr_reg = reg_it->second;
            
            ASSERT(border_regions.find(curr_reg)!=border_regions.end(), "divide_partition_tree: the order we are scanning the regions is not correct (id=" << curr_reg->label() << ")");
            border_regions.erase(curr_reg);
            border_regions.insert(curr_reg->parts().begin(), curr_reg->parts().end());
            ++reg_it;
            num_regions_cut--;
        }
        
        // Prune the regions in the limit
        typename std::set<typename PartitionModel::RegionPointer>::iterator it = border_regions.begin();
        typename std::set<typename PartitionModel::RegionPointer>::iterator it_end = border_regions.end();
        for( ; it!=it_end; ++it)
        {
            prune(**it, bpt);
        }
    }
    
    /*!
     * Relabels a BPT
     *
     * \param[in] bpt_in : BPT to be relabeled
     */
    template<class PartitionModel>
    void relabel(PartitionModel& bpt_in)
    {
        part_bimap bimap;
        typename PartitionModel::IdentifierType max_label = relabel(bpt_in._leaves_partition, bpt_in._leaves_partition, bimap);

        typename PartitionModel::map_type tmp;
        typename PartitionModel::map_type::iterator reg_it     = bpt_in._regions.begin();
        typename PartitionModel::map_type::iterator reg_it_end = bpt_in._regions.end();

        typedef typename PartitionModel::map_pair_type reg_pair;
        
        part_bimap::left_const_iterator  label_it;
        part_bimap::left_const_iterator  label_it_end = bimap.left.end();
        
        for(; reg_it!=reg_it_end; ++reg_it)
        {   
            label_it = bimap.left.find(reg_it->first);
            if(label_it!=label_it_end)
            {
                tmp.insert(reg_pair(label_it->second, reg_it->second));
                reg_it->second->label(label_it->second);
            }
            else            
            {
                max_label++;            
                tmp.insert(reg_pair(max_label, reg_it->second));
                reg_it->second->label(max_label);
            }
        }
        bpt_in._regions.swap(tmp);

        bpt_in._curr_max_label = max_label;
    }
}


#endif
