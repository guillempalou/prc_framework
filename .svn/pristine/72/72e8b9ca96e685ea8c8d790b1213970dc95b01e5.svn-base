/*
 * model_optical_flow.hpp
 *
 *  Created on: Dec 19, 2012
 *      Author: gpalou
 */

#ifndef MODEL_OPTICAL_FLOW_HPP_
#define MODEL_OPTICAL_FLOW_HPP_

#include <imageplus/math/algebra/robust_regression.hpp>
#include <imageplus/math/math_types.hpp>

namespace imageplus {
namespace video_segmentation {

	template<class BPT, class OpticalFlowFrame>
	void projective_flow_model(BPT& bpt, OpticalFlowFrame& img, OpticalFlowFrame& modeled, uint64 frame, uint64 id) {

		typedef typename OpticalFlowFrame::value_type flow_type;

		uint64 N = 0;
		for (typename BPT::RegionType::iterator c = bpt(id).begin(); c != bpt(id).end(); ++c) {
			uint64 t = (*c)(2);
			if (t != frame) continue;
			N++;
		}

		if (N < 9)
			return;

		typedef math::algebra::RobustRegression<math::numeric::L1Robust> RobustRegression; // We fit 8 parameters, hence the dimension is 8

		uint64 p = 0;
		math::Matrix A = math::Matrix::Zero(2*N,8);
		math::Vector b = math::Vector::Zero(2*N);

		for (typename BPT::RegionType::iterator c = bpt(id).begin(); c != bpt(id).end(); ++c) {
			uint64 x = (*c)(0);
			uint64 y = (*c)(1);
			uint64 t = (*c)(2);

			if (t != frame) continue;

			// Each point contributes to 2 equations
			b(p)  = img(x,y)(0);
			b(p+1) = img(x,y)(1);

			A(p,0) = 1; A(p,1) = x; A(p,2) = y; A(p,6) = x*x; A(p,7) = x*y;
			A(p+1,3) = 1; A(p+1,4) = x; A(p+1,5) = y; A(p+1,6) = x*y; A(p+1,7) = y*y;

			p+=2;
		}

		//std::cout << b.transpose() << " " << std::endl;
		//std::cout << A << std::endl;

		//
		// Fitting:
		//
		// vx = a0 + a1 * x + a2 * y + a6 * x^2 +   a7 * x * y
		// vy = a3 + a4 * x + a5 * y + a6 * x * y + a7 * y * y
		//
		//
		math::numeric::L1Robust f;
		RobustRegression rr;
		rr.fit(A,b);

		math::Vector a = rr.solution();

		// Compute the error
		for (typename BPT::RegionType::iterator c = bpt(id).begin(); c != bpt(id).end(); ++c) {
			uint32 x = (*c)(0);
			uint32 y = (*c)(1);
			uint64 t = (*c)(2);
			if (t != frame) continue;

			float64 u = a(0) + a(1)*x + a(2)*y + a(6)*x*x + a(7)*x*y;
			float64 v = a(3) + a(4)*x + a(5)*y + a(6)*x*y + a(7)*y*y;

			modeled(x,y) = flow_type(u,v);
		}
	}

	template<class BPT, class OpticalFlowFrame>
	void affine_flow_model(BPT& bpt, OpticalFlowFrame& img, OpticalFlowFrame& modeled, uint64 frame, uint64 id) {

		typedef typename OpticalFlowFrame::value_type flow_type;

		uint64 N = 0;
		for (typename BPT::RegionType::iterator c = bpt(id).begin(); c != bpt(id).end(); ++c) {
			uint64 t = (*c)(2);
			if (t != frame) continue;
			N++;
		}

		if (N < 9)
			return;

		typedef math::algebra::RobustRegression<math::numeric::L1Robust> RobustRegression; // We fit 8 parameters, hence the dimension is 8

		uint64 p = 0;
		math::Matrix A = math::Matrix::Zero(2*N,6);
		math::Vector b = math::Vector::Zero(2*N);

		for (typename BPT::RegionType::iterator c = bpt(id).begin(); c != bpt(id).end(); ++c) {
			uint64 x = (*c)(0);
			uint64 y = (*c)(1);
			uint64 t = (*c)(2);

			if (t != frame) continue;

			// Each point contributes to 2 equations
			b(p)  = img(x,y)(0);
			b(p+1) = img(x,y)(1);

			A(p,0) = 1; A(p,1) = x; A(p,2) = y;
			A(p+1,3) = 1; A(p+1,4) = x; A(p+1,5) = y;

			p+=2;
		}

		//std::cout << b.transpose() << " " << std::endl;
		//std::cout << A << std::endl;

		//
		// Fitting:
		//
		// vx = a0 + a1 * x + a2 * y
		// vy = a3 + a4 * x + a5 * y
		//
		//
		math::numeric::L1Robust f;
		RobustRegression rr;
		rr.fit(A,b);

		math::Vector a = rr.solution();

		// Compute the error
		for (typename BPT::RegionType::iterator c = bpt(id).begin(); c != bpt(id).end(); ++c) {
			uint32 x = (*c)(0);
			uint32 y = (*c)(1);
			uint64 t = (*c)(2);
			if (t != frame) continue;

			float64 u = a(0) + a(1)*x + a(2)*y;
			float64 v = a(3) + a(4)*x + a(5)*y;

			modeled(x,y) = flow_type(u,v);
		}
	}

	}
}


#endif /* MODEL_OPTICAL_FLOW_HPP_ */
