// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------

//!
//!  \file multiview.hpp
//!
//!  \brief Public interface for the main functionalities of the Multiview module
//!

#ifndef IMAGEPLUS_MULTIVIEW_HPP
#define IMAGEPLUS_MULTIVIEW_HPP

#include <imageplus/core.hpp>
#include <imageplus/multiview/camera_implementations.hpp>
#include <imageplus/math/geometry/line.hpp>

#include <boost/tuple/tuple.hpp>
#include <boost/utility.hpp>

namespace imageplus
{
    //!
    //! \namespace imageplus::multiview
    //!
    //! \brief Multiple view computations to relate 2D Points with a three-dimensional coordinate system.
    //!
    //! Module Multiview aims for the relation between a set of 2D images and
    //! a three-dimensional coordinate system (world or world 3D). Every image is associated to a view, 
    //! and the camera that produces that view is represented by the core class Camera with 
    //! some associated features.
    //!
    //! The main functionalities found in the module can be splitted into two main groups:
    //!
    //! <ul>
    //! <li>
    //! <b>Single view functions</b>: Before fusing the multiple view information, some processing must be done on every single
    //! view. The final purpose of single view functions is to relate the 2D with the 3D coordinate system by means of
    //! Camera parameters.
    //! </li>
    //!
    //! <li>
    //! <b>Multiple view functions</b>: Multiple views information is processed in order to go from 2D coordinates to world points
    //! or, the other way around, to go from a 3D coordinate to a two-dimensional point. Even it has been designed for
    //! several approaches, module Multiview provides Look-Up-Tables and methods focused on the
    //! <a href="http://en.wikipedia.org/wiki/Voxel">voxel</a> techniques.
    //! </li>
    //! </ul>
    //!
    //! Some of the main princples underlying the algorithms of this module can be found in
    //! <A HREF="http://gps-tsc.upc.es/imatge/Main/CHIL/files/WG5_RoomSetup/PFC_OscarGarcia_041008.pdf">Oscar Garcia PFC</A>
    //!
    namespace multiview
    {
        /*!
         * Type to be use by functions that not care about the view type, but do not want to be a template function.
         * 
         * See the \ref multiview_example.cpp "sample code" to learn how to use it.
         * 
         * \sa MultiView.
         */
        typedef boost::tuples::null_type AnyView;
        
        /*!
         * 
         * \brief Class to handle any type of multi-view objects.
         *
         * The aim of this class is to help multi-view algorithms.\n
         * See the \ref multiview_example.cpp "sample code for a fast tutorial". 
         * 
         * 
         * <b> CONTAINER OF \em Views </b>
         * 
         * This class is basically a container of \em views, and the needed information to relate them:
         * 
         * \li \b View:      Any type of data that you have per camera, e.g. an Image
         * \li \b Camera:    Calibration parameters to relate views in the 3D space
         * \li \b Timestamp: A temporal mark to relate views in time (synchronization)
         *
         * There is also another optional parameter to store global information for all views:
         * 
         * \li \b Info: Global information for all views. It can be any type of class or struct.
         * 
         * Note that this global information parameter is optional, and by default is \em null. 
         * 
         * See the \ref multiview_example.cpp "sample code to learn how to acces to all members of a MultiView object".
         * 
         * 
         * <b> CONTAINER OF Look-Up-Tables (LUTs) </b>
         *      
         * \ref LUT "LUTs" store useful information for algorithm's efficiency in multicamera environments.
         * They can store different kinds of information that relate 3D world and image spaces.
         * They can store projected pixels, distances, foreground probabilities, etc...
         * 
         * Normally, instead of one LUT, we want to create a LUT per camera, so we can create an object like this:
         * 
         * \code
         * MultiView< LUTType > mv_lut(5);
         * \endcode
         * 
         * These types of objects can also include extra information with:
         * 
         * \code
         * MultiView< LUTType, MyExtraInfoType > mv_lut(5);
         * \endcode 
         * 
         * 
         * See \ref create_distance_lut "create_******_lut()" functions to see how to create \em MultiViewLUT objects 
         * 
         * 
         * <b> IMPLICIT CASTS BETWEEN MultiView OBJECTS </b>
         * 
         * <b>Why we need to different types of MultiView objects?</b>
         * 
         * Simply, these are two different types of MultiView objects and we want use to use both: 
         * 
         * \code
         * MultiView< ImageRGB<uint8> > 
         * MultiView< ImageMask >.
         * \endcode
         * 
         * We can also have MultiView objects without global information (e.g. the above ones), or
         * with different types of global information:
         *  
         * \code
         * MultiView<ImageRGB<uint8>,   MyGlobalInfoType >
         * MultiView<ImageRGB<uint8>, YourGlobalInfoType >
         * \endcode
         * 
         * <b> Why we need to cast between different types of MultiView objects? </b>
         * 
         * There are a lot of MultiView functions that doesn't care about the type of Views, but only
         * on camera positions (e.g. creation of LUTs). For these reason we want to receive a MultiView<AnyView> 
         * object, but we have a MultiView< MyViewType > objects, so we need to cast objects.
         * 
         * 
         * <b> How the casts works? </b>
         * 
         * We have considered a lot of different conversions needed beetwen different types of MultiView objects. \n
         * In order to do all these conversion the MultiView class has \em cast-constructors, and \em cast-assignment operators. \n
         * (see the constructors and the assignment operators for more information on this)
         * 
         * 
         * <b> What is and when I have to use the AnyView type? </b>
         * 
         * \ref AnyView type must be used by all these functions that do not care about the \em ViewType, but do not want to 
         * be a templated function. Instead of this, they can receive MultiView objects of \ref AnyView type 
         * (with or without global info):
         * 
         * \code
         * void my_function           ( MultiView< AnyView >             mv_cams           );
         * void my_function_with_info ( MultiView< AnyView, MyInfoType > mv_cams_with_info );
         * \endcode
         * 
         * Note that thanks to the implicit casts, a user can call this functions with any type MultiView objects! \n
         * Well, note that the second one will need any type of MultiView object, but with a specific type of global info.
         *  
         * Finally, don't worry too much about the implicit casts, \ref multiview_example.cpp 
         * "see by yourself how easy is to use this class!" 
         * 
         * 
         * \tparam ViewType       : The type of the data you have per camera, e.g. an Image
         * \tparam GlobalInfoType : The type of the global info for all views. By default there is no global info.
         *
         * \sa AnyView
         *  
         *    
         * \todo Timestamp is not yet implemented
         * \todo How do we manage different types of cameras? We should allow it?
         * 
         * 
         * \author Albert Gil Moreno <agil@gps.tsc.upc.edu>
         * 
         * \date 07-07-2009
         */
        template <typename ViewType, typename GlobalInfoType = boost::tuples::null_type >
        
        class MultiView : public std::vector < boost::tuples::tuple< Camera, Timestamp, ViewType > >
        {
        private: /* Types and Constants */
            static const std::size_t camera_in_tuple = 0; //!< the position of the Camera in the tuple
            static const std::size_t ts_in_tuple     = 1; //!< the position of the Timestamp in the tuple
            static const std::size_t view_in_tuple   = 2; //!< the position of the View in the tuple

            typedef boost::tuples::tuple< Camera, Timestamp, ViewType > ViewTuple;       //!< the tuple class
            typedef std::vector < ViewTuple >                           ViewsContainer;  //!< the base class (container of tuples)
            
        public:
            
            typedef ViewType               View;        /*!< The type of the view */
            typedef GlobalInfoType         GlobalInfo;  /*!< The type of the global multiview info */
            

            // AGIL: TODO: add a contructor to MultiView from MultiView<> ,that copies only the cameras            
            // AGIL: TODO: remove "view()" method and use "operator()" instead
            
            /*!
             * \brief Default constructor
             */
            MultiView()
                    : ViewsContainer()
            {}
            
            /*!
             * \brief Main constructor with the number of views
             * 
             * \param[in] num_views : the number of views you will have
             */
            MultiView( std::size_t num_views )
                    : ViewsContainer(num_views)
            {}
            
            /*!
             * \brief Cast-Constructor from any type of MultiView objects.
             * 
             * Cast-Constructors are used to pass any MultiView object to functions that are only interested in cameras, 
             * in the global info and may be in timestamp.
             * 
             * Note that there are different cast-constructors, depending on the template matching (template specialization):
             * - No Templates match: only cameras and timestamps are copied
             * - GlobalInfoType match: cameras, timestamps and global info are copied
             * - All templates match: also views are copied (this is copy-constructor)
             * 
             * In this case, there is no templates matching. \n
             * Only cameras and timestamps are copied.
             * 
             * \tparam CastViewType       : The ViewType from the input MultiView, it is ignored.
             * \tparam CastGlobalInfoType : The GlobalInfoType from the input MultiView, it is ignored.
             * 
             * \param[in] cpy : The MultiView object to copy from.
             */
            template <typename CastViewType, typename CastGlobalInfoType >
            MultiView ( const MultiView< CastViewType, CastGlobalInfoType >& cpy)
                    : ViewsContainer(cpy.size())
            {
                ASSERT(typeid(GlobalInfoType) == typeid(boost::tuples::null_type), "Cast from any type of MultiView objects to another can be only done if global info is not imoprtant");
                
                for( std::size_t i = 0; i< this->size(); ++i)
                {
                    this->cam(i) = cpy.cam(i);
                    this->ts(i)  = cpy.ts(i);
                }
            }
            
            /*!
             * \brief Cast-Constructor from any type of MultiView objects.
             * 
             * Cast-Constructors are used to pass any MultiView object to functions that are only interested in cameras, 
             * in the global info and may be in timestamps.
             * 
             * Note that there are different cast-constructors, depending on the template matching (template specialization):
             * - No Templates match: only cameras and timestamps are copied
             * - GlobalInfoType match: cameras, timestamps and global info are copied
             * - All templates match: also views are copied (this is copy-constructor)
             * 
             * In this case, GlobalInfoType match. \n
             * Cameras, timestamps and global info are copied.
             * 
             * \tparam CastViewType       : The ViewType from the input MultiView, it is ignored.
             * 
             * \param[in] cpy : The MultiView object to copy from.
             */
            template <typename CastViewType >
            MultiView ( const MultiView< CastViewType, GlobalInfoType >& cpy)
                    : ViewsContainer(cpy.size()), _info(cpy.info())
            {
                for( std::size_t i = 0; i< this->size(); ++i)
                {
                    this->cam(i) = cpy.cam(i);
                    this->ts(i)  = cpy.ts(i);
                }
            }

            /*!
             * \brief Cast-Assignment from any type of MultiView objects.
             * 
             * Cast-Assignments are used to copy any MultiView object to another MultiView object with diferent types of Views. \n
             * Only camera information, timestamps and the global info and may be copied. \n
             * Only if MultiView objects has the same view type, then the views are also copied. 
             * 
             * 
             * Note that there are different cast-assignments, depending on the template matching (template specialization):
             * - No Templates match: only cameras and timestimes are copied
             * - GlobalInfoType match: cameras, timestamps and global info are copied
             * - All templates match: also views are copied (this is copy-assignment)
             * 
             * In this case, no templates match. \n
             * Only cameras and timestamps are copied.
             * 
             * \tparam CastViewType       : The ViewType from the input MultiView, it is ignored.
             * \tparam CastGlobalInfoType : The GlobalInfoType from the input MultiView, it is ignored.
             * 
             * \param[in] cpy : The MultiView object to copy from.
             *
             * \returns cpy, just to be able to concatenate assignments
             */
            template <typename CastViewType, typename CastGlobalInfoType >
            const MultiView< CastViewType, CastGlobalInfoType >& operator=( const MultiView< CastViewType, CastGlobalInfoType >& cpy)
            {
                //ASSERT(typeid(GlobalInfoType) == typeid(boost::tuples::null_type), "Cast from any type of MultiView objects to another can be only done if global info is not imoprtant");
                // ASSERT SIZE or RESIZE
                
                for( std::size_t i = 0; i< this->size(); ++i)
                {
                    this->cam(i) = cpy.cam(i);
                    this->ts(i)  = cpy.ts(i);
                }
                
                return cpy;
            }
            
            /*!
             * \brief Cast-Assignment from any type of MultiView objects.
             *
             * Cast-Assignments are used to copy any MultiView object to another MultiView object with diferent types of Views. \n
             * Only camera information, timestamps and the global info and may be copied. \n
             * Only if MultiView objects has the same view type, then the views are also copied.
             *
             *
             * Note that there are different cast-assignments, depending on the template matching (template specialization):
             * - No Templates match: only cameras and timestimes are copied
             * - GlobalInfoType match: cameras, timestamps and global info are copied
             * - All templates match: also views are copied (this is copy-assignment)
             *
             * In this case, GlobalInfoType match. \n
             * Cameras, timestamps and global info are copied.
             *
             * \tparam CastViewType       : The ViewType from the input MultiView, it is ignored.
             *
             * \param[in] cpy : The MultiView object to copy from.
             *
             * \returns cpy, just to concatenate assignments
             */
            template <typename CastViewType >
            const MultiView< CastViewType, GlobalInfoType >& operator=( const MultiView< CastViewType, GlobalInfoType >& cpy)
            {
                //ASSERT(typeid(GlobalInfoType) == typeid(boost::tuples::null_type), "Cast from any type of MultiView objects to another can be only done if global info is not imoprtant");
                // ASSERT SIZE or RESIZE
                
                for( std::size_t i = 0; i< this->size(); ++i)
                {
                    this->cam(i) = cpy.cam(i);
                    this->ts(i)  = cpy.ts(i);
                }
                _info = cpy.info();
                
                return cpy;
            }
            
            /*!
             * \brief const access to a camera
             * 
             * \param[in] cam_num : the camera number to access
             * 
             * \return a const reference to the Camera of the view cam_num
             */
            const Camera& cam( std::size_t cam_num ) const 
            {
                ASSERT( cam_num < this->size(), "MultiView: Cam number is out of range." );
                return boost::tuples::get<camera_in_tuple>( (*this)[cam_num] );
            }
            
            /*!
             * \brief access to a camera
             * 
             * \param[in] cam_num : the camera number to access
             * 
             * \return a reference to the Camera of the view cam_num
             */
            Camera& cam( std::size_t cam_num ) 
            {
                ASSERT( cam_num < this->size(), "MultiView: Cam number is out of range." );
                return boost::tuples::get<camera_in_tuple>( (*this)[cam_num] );
            }
            
            /*!
             * \brief const access to global multiview info
             * 
             * \return a const reference to the global multiview info
             */
            const GlobalInfoType& info() const 
            {
                return _info;
            }
            
            /*!
             * \brief access to global multiview info
             * 
             * \return a reference to the global multiview info
             */
            GlobalInfoType& info() 
            {
                return _info;
            }


            /*!
             * \brief Const access to the desired View
             * 
             * \param[in] view_num : the number of the view to access
             * 
             * \return a const reference to the ViewType number view_num
             * 
             * \todo Must be deprectaed in favor of the operator()?
             */
            const ViewType& view( std::size_t view_num ) const 
            {
                ASSERT( view_num < this->size(), "MultiView: Cam number is out of range." );
                return boost::tuples::get<view_in_tuple>( (*this)[view_num] );
            }
            
            /*!
             * \brief Access to the desired View
             * 
             * \param[in] view_num : the number of the view to access
             * 
             * \return a reference to the ViewType number view_num
             * 
             * \todo Must be deprectaed in favor of the operator()?
             */
            ViewType& view( std::size_t view_num ) 
            {
                ASSERT( view_num < this->size(), "MultiView: Cam number is out of range." );
                
                return boost::tuples::get<view_in_tuple>( (*this)[view_num] );
            }

            /*!
             * Timestamp const access
             *
             * \param[in] cam_num : the number (index) of the camera to get its Timestamp
             *
             * \returns the Timestamp of the cam_num view
             */
            const Timestamp& ts( std::size_t cam_num ) const 
            {
                ASSERT( cam_num < this->size(), "MultiView: Cam number is out of range." );
                
                return boost::tuples::get<ts_in_tuple>( (*this)[cam_num] );
            }
            
            /*!
             * Timestamp access
             *
             * \param[in] cam_num : the number (index) of the camera to get its Timestamp
             *
             * \returns the Timestamp of the cam_num view
             */
            Timestamp& ts( std::size_t cam_num ) 
            {
                ASSERT( cam_num < this->size(), "MultiView: Cam number is out of range." );
                
                return boost::tuples::get<ts_in_tuple>( (*this)[cam_num] );
            }
            
            /*!
             * \brief Const access to the desired View
             * 
             * \param[in] view_num : the number of the view to access
             * 
             * \return a const reference to the ViewType number view_num
             */
            const ViewType& operator()( std::size_t view_num ) const 
            {
                ASSERT( view_num < this->size(), "MultiView: Cam number is out of range." );
                
                return boost::tuples::get<view_in_tuple>( (*this)[view_num] );
            }
            
            /*!
             * \brief Access to the desired View
             * 
             * \param[in] view_num : the number of the view to access
             * 
             * \return a reference to the ViewType number view_num
             */
            ViewType& operator()( std::size_t view_num ) 
            {
                ASSERT( view_num < this->size(), "MultiView: Cam number is out of range." );
                
                return boost::tuples::get<view_in_tuple>( (*this)[view_num] );
            }
            
        private:
            
            GlobalInfoType _info; //!< the global info variable
        };
        
        
        //!
        //! \brief Projects point worldPoint onto a camera
        //!
        //! From camera information contained in input object Camera, the projection
        //! of a point3D is computed. This is a fast implementation
        //!
        //! \param[in] p3d : The point3d to project
        //! \param[in] cam : a camera object (with camera parameters)
        //! \param[in] out : Point2D  result of the projection
        //!
        //!
        //! \author Cristian Canton  <ccanton@gps.tsc.upc.es>
        //! \author JoseLuis Landabaso  <jl@gps.tsc.upc.es>
        //! \author Jordi Salvador  <aljsal@gps.tsc.upc.es>
        //! \author JoseCarlos Pujol  <jpujol@tsc.uc3m.es>
        //! \author Marcel Alcoverro <marcel@gps.tsc.upc.edu>
        //!
        //! \date 18-01-2008
        //!
        void  fast_world2image( const Point3D & p3d, const Camera& cam, Point2D & out);
        
        //!
        //! \brief Projects point worldPoint onto a camera and returs if the point is inside the image
        //!
        //! From camera information contained in input object Camera, the projection
        //! of a point3D is computed. This is a fast implementation. Also, this function returns if the 
        //! resulting 2D point is inside the image or not.
        //!
        //! \param[in] p3d : The point3d to project
        //! \param[in] cam : a camera object (with camera parameters)
        //! \param[in] out : Point2D  result of the projection
        //!
        //! \return true if the 2D point is inside the camera
        //!
        //! \author Cristian Canton  <ccanton@gps.tsc.upc.es>
        //! \author JoseLuis Landabaso  <jl@gps.tsc.upc.es>
        //! \author Jordi Salvador  <aljsal@gps.tsc.upc.es>
        //! \author JoseCarlos Pujol  <jpujol@tsc.uc3m.es>
        //! \author Marcel Alcoverro <marcel@gps.tsc.upc.edu>
        //! \author Sergio Segura <alsegura@gps.tsc.upc.edu>
        //!
        //! \date 31-01-2011
        //!
        bool fast_world2image_assert(const Point3D & p3d, const Camera& cam, Point2D & out);
        
        //!
        //! \brief Estimates a world point given its projections in some of the input cameras.
        //!
        //! \param[in] mv_points : MultiView of Point2Ds (projections). Each point is the projection of the
        //!                        same 3D point on the corresponding camera.
        //! \param[in] is_in_cam  : A MultiView object that if a cam does not see the 3D point to be estimated, is_in_cam[i] must be set
        //!                         to 0. It must be set to 1 otherwise. Required visibility from at least 2 cameras.
        //!
        //! \return a Point3D as result of the projection
        //!
        //!
        //! \author Oscar Garcia
        //! \author Adolfo López <alopez@gps.tsc.upc.edu>
        //!
        //! \date 5-02-2008
        //!
        Point3D images2world(const MultiView<Point2D>& mv_points, const MultiView<uint8>& is_in_cam) throw (ImagePlusMultiviewVisibility);
        
        //!
        //! \brief Computes fundamental matrix that relates cameras cam1 and cam2
        //!
        //! \param[in] cam1 : Calibration information for origin camera
        //! \param[in] cam2 : Calibration information for destination camera
        //!
        //! \return MultiArray (bidimensional) as computed fundamental matrix.
        //!
        //!
        //! \author Oscar Garcia
        //! \author Jordi Salvador <jordi@gps.tsc.upc.edu>
        //!
        //! \date 04-03-2008
        //!
        MultiArray<float64,2> fundamental_matrix( const Camera& cam1, const Camera& cam2 );
        
        //!
        //! \brief Computes epipolar line equation in cam2 given a 2D point coordinate in cam1. It DOESN'T take distortion into account.
        //!
        //! \param[in] x1  : Image coordinates of projection on cam1
        //! \param[in] F12 : Fundamental matrix computed as fundamental_matrix(cam1,cam2)
        //!
        //! \return Point3D as epipolar line coefficients (a,b,c) in cam2. The equation of 
        //!         the epipolar line is given by: a*x+b*y+c=0, where a*a+b*b=1. (x,y) coordinates are taken
        //!         as usual: image origin is top-left corner and y-axis increases downwards.
        //!
        //!
        //! \author Oscar Garcia
        //! \author Jordi Salvador <jordi@gps.tsc.upc.edu>
        //!
        //! \date 04-03-2008
        //!
        Point3D epipolar_line_from_fundamental_matrix_undistorted(const Point2D& x1, const MultiArray<float64,2>& F12);
        
        //!
        //! \brief Returns Geometric shape with all the samples of the epipolar line lying inside
        //! of the image
        //!
        //! \param[in] cam   : camera where the epipolar line is drawn
        //! \param[in] eline : epipolar line equation (a*x+b*y+c=0)
        //!
        //! \return Line samples lying inside of the specified camera's image
        //!
        //!
        //! \author Jordi Salvador <jordi@gps.tsc.upc.edu>
        //!
        //! \date 07-Nov-2008
        //!
        math::geometry::Line2D<int16> epipolar_line_samples( const Camera & cam, const Point3D& eline );
        
        //!
        //! \brief Projects point worldPoint onto a camera
        //! considering null distortion
        //!
        //! \author Jordi Salvador Marcos <jordi@gps.tsc.upc.edu>
        //!
        //! \date 8-Nov-2008
        //!
        //! From camera information contained in input object Camera, the projection
        //! of a point3D is computed. This is a fast implementation that does not
        //! compute distortion (it assumes undistorted images are being used)
        //!
        //! \param[in] p3d : The point3d to project
        //! \param[in] cam : a camera object (with camera parameters)
        //! \param[out] out : Point2D  result of the projection
        //!
        void world_to_image_undistorted( const Point3D & p3d, const Camera & cam, Point2D & out );
        
        //!
        //! \brief Estimates a world point given its projections on two input cameras
        //! when the pixels are known to be a pair of projections of the desired world point
        //!
        //! \author Jordi Salvador Marcos <jordi@gps.tsc.upc.edu>
        //!
        //! \date 10-Nov-2008
        //!
        //! \param[in] c1 : First camera
        //! \param[in] c2 : Second camera
        //! \param[in] p1 : first camera point
        //! \param[in] p2 : second camera point
        //! \param[out] d1 : first camera's depth
        //! \param[out] d2 : second camera's depth
        //! \param[out] out : estimation of the world point
        //!
        void two_cameras_triangulation( const Camera & c1, const Camera & c2, const Point2D & p1, const Point2D & p2, float64 & d1, float64 & d2, Point3D & out );
        
        //!
        //! \brief Estimates a world point given its projections on two input cameras
        //! when the pixels are known to be a pair of projections of the desired world point
        //!
        //! \author Jordi Salvador Marcos <jordi@gps.tsc.upc.edu>
        //!
        //! \date 10-Nov-2008
        //!
        //! \param[in] v1 : First camera's ray director vector
        //! \param[in] v2 : Second camera's ray director vector
        //! \param[in] cop1 : First camera's center of projections
        //! \param[in] cop2 : Second camera's center of projections
        //! \param[out] d1 : first camera's depth
        //! \param[out] d2 : second camera's depth
        //! \param[out] out : estimation of the world point
        //!
        void two_cameras_triangulation( const Point3D & v1, const Point3D & v2, const Point3D & cop1, const Point3D & cop2, float64 & d1, float64 & d2, Point3D & out );
        
        //!
        //! \brief Obtains the depth of a point, measured as its distance to the plane where
        //! the center of projections of a camera lies (OpenGL-style)
        //!
        //! \author Jordi Salvador Marcos <jordi@gps.tsc.upc.edu>
        //!
        //! \date 20-May-2010
        //!
        //! \param[in] p : 3D point in world coordinates
        //! \param[in] cam : Camera
        //!
        //! \return The point's depth
        //!
        float64 point_depth( const Point3D & p, const Camera & cam );
        
    }//namespace multiview

} //namespace imageplus

#endif
