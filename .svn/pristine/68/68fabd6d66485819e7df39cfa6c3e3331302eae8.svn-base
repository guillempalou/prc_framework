// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------

//! 
//! \file arithmetic_codec.test
//!
//! Tests for class ReadSequence 
//!

#include <iostream>


#include <imageplus/core.hpp>
#include <imageplus/compress/arithmetic_codec.hpp>
#include <imageplus/io/writebitstream.hpp> 
#include <imageplus/io/readbitstream.hpp> 
#include <imageplus/math/statistics/random_generators.hpp>

BOOST_AUTO_TEST_SUITE ( ArithCodecSuite );

using namespace std;
using namespace imageplus;
using namespace imageplus::io;
using namespace imageplus::compress;

BOOST_AUTO_TEST_CASE( ArithCodecRandom)
{   
    // Create an array with a non uniform distribution
    uint64 len = 10000;

    MultiArray<uint8,1> vec(len);

    
    for (uint64 x = 0; x < vec.size(); x++)
    {
        float64 f = imageplus::math::statistics::rand_normal (128.0, 10.0);
        if ( f < 0.0 ) f = 0.0;
        if ( f > 255.0) f = 255.0;
        vec[x] = static_cast<uint8>(f);        
    }
    
    // Compress the array with arithmetic codec 
    Arithmetic_Codec ace(vec.size());
    
    Adaptive_Data_Model model(256);
    ace.start_encoder();

    for (uint64 x = 0; x < vec.size(); x++)
    {
        ace.encode(vec[x], model);
    }
    
    uint64 num_bytes = ace.stop_encoder(); // return number of bytes used for compression
    
    BOOST_CHECK(num_bytes < len);
    
    // Now we decompress the data
    MultiArray<uint8,1> vec2( (uint64)vec.size());
    vec2 = 255;
    Arithmetic_Codec ace2(vec2.size(),ace.buffer());
    Adaptive_Data_Model model2(256);
    ace2.start_decoder();
    
    for (uint64 x = 0; x < vec2.size(); x++)
    {
        vec2[x] = ace2.decode(model2);
    } 
    ace2.stop_decoder();

    BOOST_CHECK_EQUAL(vec,vec2);

}    


BOOST_AUTO_TEST_CASE( ArithCodecRandomDisk )
{   
    // Create an array with a non uniform distribution
    uint64 len = 10000;

    MultiArray<uint8,1> vec(len);

    for (uint64 x = 0; x < vec.size(); x++)
    {
        float64 f = imageplus::math::statistics::rand_normal (128.0, 10.0);
        if ( f < 0.0 ) f = 0.0;
        if ( f > 255.0) f = 255.0;
        vec[x] = static_cast<uint8>(f);
    }

    // Compress the array with arithmetic codec 
    Arithmetic_Codec ace(vec.size());
    
    Adaptive_Data_Model model(256);
    ace.start_encoder();

    for (uint64 x = 0; x < vec.size(); x++)
    {
        ace.encode(vec[x], model);
    }
    
    uint64 num_bytes = ace.stop_encoder(); // return number of bytes used for compression

    BOOST_CHECK(num_bytes < len);


    // Write bitstream 
    io::WriteBitStream wbs;
    wbs.open(string(TEST_DATA_PATH_W) + "/arith.data");
    for (uint64 x = 0; x < num_bytes; x++)
    {
        wbs.write(ace.buffer()[x],8);
    }
    wbs.force_write();
    wbs.close();	

    
    MultiArray<uint8,1> vec_coded(num_bytes);

    // Read bistream
    io::ReadBitStream rbs;
    rbs.open(string(TEST_DATA_PATH_W) + "/arith.data");
    for (uint64 x = 0; x < num_bytes; x++)
    {
        vec_coded[x] = rbs.read(8);
    }
    rbs.close();	
    
    // Now we decompress the data
    MultiArray<uint8,1> vec2( (uint64)vec.size());
    vec2 = 255;
    Arithmetic_Codec ace2(num_bytes,vec_coded.data());
    Adaptive_Data_Model model2(256);
    ace2.start_decoder();
    
    for (uint64 x = 0; x < vec2.size(); x++)
    {
        vec2[x] = ace2.decode(model2);
    }
    
    ace2.stop_decoder();

    BOOST_CHECK_EQUAL(vec,vec2);

}    



BOOST_AUTO_TEST_SUITE_END ();
