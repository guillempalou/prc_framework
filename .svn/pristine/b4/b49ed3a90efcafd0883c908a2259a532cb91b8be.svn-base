// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------
//!
//! \example xml_example.cpp
//!
//! This is an example of how to use the xml helper functions
//!

#ifndef IMAGEPLUS_DOXYGEN_DO_NOT_COMMENT_MAIN_FUNCTION

#include <iostream>
#include <string>

#include <imageplus/core.hpp>
#include <imageplus/io/io_types.hpp>

using namespace imageplus;
using namespace io;

//
// The USE_XML define is needed to work with the XML functions
//
#ifdef USE_XML
#include <imageplus/io/xml_auxiliar.hpp>
XERCES_CPP_NAMESPACE_USE
#endif


int main (int argc, char* argv[])
{
#ifdef USE_XML
    
    // XML variables
    DOMNode *curr_node;
    DOMNode *curr_node2;
    DOMNode *curr_node3;
    DOMNodeList *child_list, *child_list2;
    DOMNamedNodeMap *node_attr;

    // Output merging sequence
    std::vector<uint32> fathers;
    std::vector<uint32> sons1;
    std::vector<uint32> sons2;
    
    // Other variables
    char *name;
    int jj;
    int64 num_children, num_children2;
    int num_sons_found;
    uint32 num_father, num_son1, num_son2;
    
    // Open XML file and initialize the structure. It returns the root node of the XML    
    curr_node = xml_init("tests/data_r/io/xml_example.xml");

    //Check that the name of the node is "Mpeg7"
    if(strcmp(toNative(curr_node->getNodeName()).c_str(),"Mpeg7") != 0)
        throw ImagePlusError("XML reading: 'Mpeg7' node not found");

    // Check that there is a sequence of sons named:
    // "Description/MultimediaContent/Image"
    // and returns a pointer to it
    curr_node = xml_get_check_son(curr_node, "Description");
    curr_node = xml_get_check_son(curr_node, "MultimediaContent");
    curr_node = xml_get_check_son(curr_node, "Image");
    
    // Let's check that there is  a node "CreationInformation/RelatedMaterial (id=PartitionSearchFile)/MediaLocator/MediaUri
    curr_node2 = xml_get_check_son(curr_node, "CreationInformation");

    curr_node3 = xml_get_check_son_by_field(curr_node2, "RelatedMaterial", "id", "NotAvailableID");

    if(curr_node3 !=0x0)
        throw ImagePlusError("We shouldn't find a node called 'RelatedMaterial' with an 'id' field with 'NotAvailableID'.");
        
    curr_node2 = xml_get_check_son_by_field(curr_node2, "RelatedMaterial", "id", "PartitionSearchFile");
    
    if(curr_node2 ==0x0)
        throw ImagePlusError("We should find a node called 'RelatedMaterial' with an 'id' field with 'PartitionSearchFile'.");
        
    curr_node2 = xml_get_check_son(curr_node2, "MediaLocator");
    curr_node2 = xml_get_check_son(curr_node2, "MediaUri");

    // Check it has a text node with "Dummy data"
    std::string text = xml_get_text_son(curr_node2, curr_node2);
        
    if(text!="Dummy data")
           throw ImagePlusError("The text node should have 'dummy data'.");
    
    if(strcmp(toNative(curr_node2->getNodeValue()).c_str(), "Dummy data")!=0)
        throw ImagePlusError("The text node should have 'dummy data'.");

    // Go on with the structure 
    curr_node = xml_get_check_son(curr_node, "SpatialDecomposition");
    
    // Gets the list of children
    child_list = curr_node->getChildNodes();
    
    // Gets the number of children
    num_children = child_list->getLength();
    
    if(num_children==0)
        throw ImagePlusError("An empty merging sequence has been found.");
    else
    {
        // We go through all the children
        for(int64 ii=0; ii<num_children; ii++ )
        {
            // Pointer to the specific child
            curr_node = child_list->item(ii);
            
            // Discard those child that are not "real" nodes 
            if(curr_node->getNodeType() == DOMNode::ELEMENT_NODE)
            {
                // Check it has sons
                if(curr_node->hasChildNodes())
                {
                    // Get attributes of a node
                    node_attr = curr_node->getAttributes();

                    // Get an specific attribute "id"
                    curr_node2 = node_attr->getNamedItem(fromNative("id").c_str());
                    
                    // We expect it to be of the form "Regioni", so we get the value
                    sscanf(toNative(curr_node2->getNodeValue()).c_str(), "Region%u", &num_father);

                    // Get a node named "SpatialDecomposition"
                    curr_node = xml_get_check_son(curr_node, "SpatialDecomposition");
                    
                    // Get the children
                    child_list2 = curr_node->getChildNodes();
                    
                    // Get number of children
                    num_children2 = child_list2->getLength();
                    
                    num_sons_found = 0;
                    jj=0;
                    
                    do
                    {
                        curr_node = child_list2->item(jj);
                        
                        // Discard those child that are not "real" nodes 
                        if(curr_node->getNodeType() == DOMNode::ELEMENT_NODE)
                        {
                            if(strcmp(toNative(curr_node->getNodeName()).c_str(), "StillRegionRef") == 0)
                            {
                                node_attr = curr_node->getAttributes();
                                curr_node2 = node_attr->getNamedItem(fromNative("idref").c_str());
                                if(num_sons_found == 0)
                                    sscanf(toNative(curr_node2->getNodeValue()).c_str(), "Region%u", &num_son1);
                                else
                                    sscanf(toNative(curr_node2->getNodeValue()).c_str(), "Region%u", &num_son2);
                                
                                num_sons_found++;
                            }
                        }
                        
                        jj++;
                    }
                    while(jj<num_children2 && num_sons_found<2);
                    
                    // We expect every "father" to have 2 children
                    if(num_sons_found<2)
                        throw ImagePlusError("There is a region description that is not correct.");
                    
                    // Save the values obtained
                    fathers.push_back(num_father);
                    sons1.push_back(num_son1);
                    sons2.push_back(num_son2);
                }
            }
        }
    }
    
    XMLString::release(&name);
    
    
    // Show the result
    std::cout << "Father" << "\t" << "Son1" << "\t" << "Son2" << std::endl;
    for(uint32 ii=0; ii<fathers.size(); ii++)
        std::cout << fathers[ii] << "\t" << sons1[ii] << "\t" << sons2[ii] << std::endl; 
    
#endif
}


#endif
