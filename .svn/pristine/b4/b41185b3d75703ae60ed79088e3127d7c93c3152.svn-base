// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------

//!
//!  \file bounding_box.test
//!
//!  Tests for the BoundingBox classs 
//!

#include <imageplus/core/partition.hpp>
#include <imageplus/core/imagepartition.hpp>
#include <imageplus/core/imagergb.hpp>
#include <imageplus/core/volumergb.hpp>
#include <imageplus/core/region_contour.hpp>


#include <imageplus/core/bounding_box.hpp>
#include <imageplus/core/coord.hpp>
#include <imageplus/core/coord2d.hpp>
#include <imageplus/core/coord3d.hpp>

BOOST_AUTO_TEST_SUITE ( suite_bounding_box );

using namespace imageplus;

BOOST_AUTO_TEST_CASE ( test_BoundingBox )
{
    typedef ImageRGB<uint8>::CoordType coord2d;
    typedef VolumeRGB<uint8>::CoordType coord3d; 
    
    coord2d or_2d(1, 2);
    coord3d or_3d(1, 2, 1);
    int64 width = 3, height = 5, depth = 3; 
    coord2d op_2d(3, 6);
    coord3d op_3d(3, 6, 3);

    // Default constructor
    BoundingBox<coord2d> bb;
    BOOST_CHECK_EQUAL(bb.dimension(), (std::size_t)2);
    BOOST_CHECK(bb.origin() == coord2d(0,0));
    BOOST_CHECK(bb.side(0) == 1);
    BOOST_CHECK(bb.side(1) == 1);
    BOOST_CHECK(bb.opposite() == coord2d(0,0));

    // Contructor for 2 dimensions
    BoundingBox<coord2d> bb_2d(or_2d, width, height);
    BOOST_CHECK(bb_2d.dimension() == 2);
    BOOST_CHECK(bb_2d.origin() == or_2d);
    BOOST_CHECK(bb_2d.side(0) == width);
    BOOST_CHECK(bb_2d.side(1) == height);
    BOOST_CHECK(bb_2d.opposite() == op_2d);

    // Contructor for 3 dimensions
    BoundingBox<coord3d>  bb_3d(or_3d, width, height, depth);
    BOOST_CHECK(bb_3d.dimension() == 3);
    BOOST_CHECK(bb_3d.origin() == or_3d);
    BOOST_CHECK(bb_3d.side(0) == width);
    BOOST_CHECK(bb_3d.side(1) == height);
    BOOST_CHECK(bb_3d.side(2) == depth);
    BOOST_CHECK(bb_3d.opposite() == op_3d);

    
    // Contructor for n dimensions
    BoundingBox<coord3d> bb_other_3d(or_3d, op_3d);
    BOOST_CHECK(bb_other_3d.dimension() == 3);
    BOOST_CHECK(bb_other_3d.origin() == or_3d);
    BOOST_CHECK(bb_other_3d.side(0) == width);
    BOOST_CHECK(bb_other_3d.side(1) == height);
    BOOST_CHECK(bb_other_3d.side(2) == depth);
    BOOST_CHECK(bb_other_3d.opposite() == op_3d);

    // Copy constructor
    BoundingBox<coord2d> bb_copy_2d(bb_2d);
    BOOST_CHECK(bb_copy_2d.dimension() == 2);
    BOOST_CHECK(bb_copy_2d.origin() == or_2d);
    BOOST_CHECK(bb_copy_2d.side(0) == width);
    BOOST_CHECK(bb_copy_2d.side(1) == height);
    BOOST_CHECK(bb_copy_2d.opposite() == op_2d);

    // operator =
    BoundingBox<coord3d>  bb_copy_3d = bb_other_3d; 
    BOOST_CHECK(bb_copy_3d.dimension() == 3);
    BOOST_CHECK(bb_copy_3d.origin() == or_3d);
    BOOST_CHECK(bb_copy_3d.side(0) == width);
    BOOST_CHECK(bb_copy_3d.side(1) == height);
    BOOST_CHECK(bb_copy_3d.side(2) == depth);
    BOOST_CHECK(bb_copy_3d.opposite() == op_3d);
    
    
    
    coord2d new_or_2d(0, 0);

    // Set origin
    bb_2d.origin(new_or_2d);
    BOOST_CHECK(bb_2d.dimension() == 2);
    BOOST_CHECK(bb_2d.origin() == new_or_2d);
    BOOST_CHECK(bb_2d.side(0) == 4);
    BOOST_CHECK(bb_2d.side(1) == 7);
    BOOST_CHECK(bb_2d.opposite() == op_2d);
    
    // Set sides
    bb_2d.side(0,3);
    bb_2d.side(1,3);
    BOOST_CHECK(bb_2d.dimension() == 2);
    BOOST_CHECK(bb_2d.origin() == new_or_2d);
    BOOST_CHECK(bb_2d.side(0) == 3);
    BOOST_CHECK(bb_2d.side(1) == 3);
    BOOST_CHECK(bb_2d.opposite() == coord2d(2,2));
    
    // Set opposite
    bb_2d.opposite(coord2d(0,0));
    BOOST_CHECK(bb_2d.dimension() == 2);
    BOOST_CHECK(bb_2d.origin() == new_or_2d);
    BOOST_CHECK(bb_2d.side(0) == 1);
    BOOST_CHECK(bb_2d.side(1) == 1);
    BOOST_CHECK(bb_2d.opposite() == coord2d(0,0));

}



BOOST_AUTO_TEST_CASE( BoundingBox_calculate_test)
{    
    ImagePartition<> my_im_part(3,3);
    my_im_part[0][0] = 25;
    my_im_part[0][1] = 25;
    my_im_part[0][2] = 10;
    my_im_part[1][0] = 12;
    my_im_part[1][1] = 10;
    my_im_part[1][2] = 10;
    my_im_part[2][0] = 3;
    my_im_part[2][1] = 3;
    my_im_part[2][2] = 2;
    
    ImageRGB<uint8> my_image(3,3);
    my_image(0) = 1;
    my_image(1) = 2;
    my_image(2) = 3;
    my_image(0)[0][0] = 25;
    my_image(0)[2][0] = 2;
    my_image(0)[1][2] = 6;
    
    typedef ImageRGB<uint8> InputType;
    typedef RegionContour<Coord2D<int64> > RegionType;
    typedef Partition<RegionType> partition_type;
    partition_type my_part(my_im_part);
    
    merge_regions(2, 3, 26, my_part);
    merge_regions(10, 26, 27, my_part);
    merge_regions(25, 12, 30, my_part);
        
    // Recursive calculate
    BoundingBox<InputType::CoordType> bbox;
    bbox.calculate(my_image.colors_begin(my_part[30]), my_image.colors_end(my_part[30]), &(my_part[30].coll_vd()));
    
    BOOST_CHECK( (bbox.origin()   == InputType::CoordType(0,0)));
    BOOST_CHECK( (bbox.opposite() == InputType::CoordType(1,1)));
    BOOST_CHECK( bbox.side(0) == 2);
    BOOST_CHECK( bbox.side(1) == 2);
    
    // Global calculate
    bbox.calculate(my_image.colors_begin(),my_image.colors_end(), &(my_image.coll_vd()));
    BOOST_CHECK( (bbox.origin()   == InputType::CoordType(0,0)));
    BOOST_CHECK( (bbox.opposite() == InputType::CoordType(2,2)));
    BOOST_CHECK( bbox.side(0) == 3);
    BOOST_CHECK( bbox.side(1) == 3);
}

BOOST_AUTO_TEST_SUITE_END ();

