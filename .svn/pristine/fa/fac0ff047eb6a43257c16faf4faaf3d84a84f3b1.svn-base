// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------

//!
//!  \file imavol.hpp
//!
//!  Interface for ImaVol class, base class of all images and volumes in ImagePlus
//!

#ifndef IMAGEPLUS_CORE_IMAVOL_HPP
#define IMAGEPLUS_CORE_IMAVOL_HPP


#include <vector>

#include <imageplus/core/exceptions.hpp>
#include <imageplus/core/imageplus_types.hpp>
#include <imageplus/core/multiarray.hpp>
#include <imageplus/core/pixel.hpp>
#include <imageplus/core/iterator.hpp>
#include <imageplus/core/color.hpp>


// For coords access
#include <imageplus/core/coord.hpp>

#include <imageplus/core/visual_descriptors.hpp>

// For Neighbours
#include <imageplus/core/geometric_shape.hpp>

// For ostream
#include <imageplus/core/multiarray_ostream.hpp>

namespace imageplus
{
    //! Constant to access gray channel
    const uint64 GRAY_CHANNEL = 0;

    //! Constants to access red channel in RGB imavols
    const uint64 RED_CHANNEL = 0;
    //! Constants to access green channel in RGB imavols
    const uint64 GREEN_CHANNEL = 1;
    //! Constants to access blue channel in RGB imavols
    const uint64 BLUE_CHANNEL = 2;

    //! Constants to acces y channel in YUV imavols
    const uint64 Y_CHANNEL = 0;
    //! Constants to acces u channel in YUV imavols
    const uint64 U_CHANNEL = 1;
    //! Constants to acces v channel in YUV imavols
    const uint64 V_CHANNEL = 2;
    
    //! Constants to acces r channel in RIQ imavols
    const uint64 R_CHANNEL = 0;
    //! Constants to acces i channel in RIQ imavols
    const uint64 I_CHANNEL = 1;
    //! Constants to acces q channel in RIQ imavols
    const uint64 Q_CHANNEL = 2;
    
    
    
    //! Constants to acces cr channel in RCQ imavols
    const uint64 Cr_CHANNEL = 1;
    
    //! Constants to acces cr channel in RUV imavols
    const uint64 Cb_CHANNEL = 2;

    //! Constants to access L* channel in CIE L*ab imavols
    const uint64 L_CHANNEL = 0;
    //! Constants to access a channel in CIE L*ab imavols
    const uint64 A_CHANNEL = 1;
    //! Constants to access b channel in CIE L*ab imavols
    const uint64 B_CHANNEL = 2;

    //! Constants to acces partition channel in partition images
    const uint64 PARTITION_CHANNEL = 0;

    //! Constants to acces mask channel in mask images
    const uint64 MASK_CHANNEL = 0;
    
    //! Constants to acces partition channel in contour images
    const uint64 CONTOUR_CHANNEL = 0;

    //! Maximum representable value representable (used to recognize the unassigned labels or border pixels that do not have to be taken into account)
    //! \return Maximum representable integer
    //! \throw If numeric_limits throws
    template<typename T>
    static T not_assigned() throw()
    {
        return std::numeric_limits<T>::max();
    };
    
    //!
    //! \brief Base class to all images and volumes.
    //!
    //! See the \ref iterators_example.cpp "iterators and colors example" to know how to use it.
    //!
    //! You should not instantiate this class (better use ImageGray, ImageRGB or the corresponding volumes)
    //! unless you want to implement functions that work equally for all images and volumes
    //!
    //! The declaration should be:
    //! \code
    //!    ImaVol<uint8,1,2> a(3,3);
    //! \endcode
    //!
    //! This creates an imavol of uint8 values with 1 channel and 2 dimensions
    //! with size 3x3. Note that you can only use the 2 argument constructor with
    //! an imavol of 2 dimensions, for 3 dimensions use the 3 argument constructor
    //!    
    //! \tparam  T : the type of the internal data (normally uint8, int64...)
    //! \tparam  N : the number of channels in the imavol (3 for RGB, 1 for Gray...)
    //! \tparam  D : dimensions of the ImaVol: 2 for images, 3 for volumes
    //!
    //! \author Javier Ruiz Hidalgo <j.ruiz@upc.edu>
    //! \author Josep Ramon Morros  <morros@gps.tsc.upc.edu>
    //! \author Albert Gil Moreno   <albert.gil@upc.edu>
    //! \author Jordi Pont-Tuset    <jordi.pont@upc.edu>
    //!
    //! \date 10-1-2008
    //!
    template<typename T, std::size_t N, std::size_t D>
    class ImaVol : public collaborative_descriptors_traits
    {
    public:
        typedef      ImaVol<uint32,1,D> partition_type;     //!< Type of partition coherent with the ImaVol
        typedef      T                  data_type;          //!< The data_type of the ImaVol
        static const std::size_t        channels   = N;     //!< The number of channels
        static const std::size_t        dimensions = D;     //!< The dimensions of all channels
        typedef      Coord<int64, D>   CoordType;           //!< Type of the coord to access it
        typedef      ImaVol<T,1,D>      single_channel_type;       //!< Single channel image type
        typedef      Pixel<ImaVol, ImaVol, data_type> pixel_type;  //!< Pixel type
        typedef      MultiArray<data_type,dimensions> ChannelType; //!< the internal Channel class

    protected:
        /*! \cond SKIP_DOC */
        // ColorView types
        typedef ColorViewBase<       data_type, N, boost::array<       data_type*, N> >            color_view;
        typedef ColorViewBase< const data_type, N, boost::array< const data_type*, N> >      const_color_view;
        typedef ColorViewBase<       data_type, 1, boost::array<       data_type*, 1> >        sch_color_view;
        typedef ColorViewBase< const data_type, 1, boost::array< const data_type*, 1> >  const_sch_color_view;
        /*! \endcond */

        template< class RT, class IVT, typename DT >
        friend class Pixel; 
        
        template< class RT, class IVT, typename DT >
        friend class ChannelPixel; 

        template< class RT, class IVT, typename DT, class PT>
        friend class DataIteratorBase;
    
    public:

        /*!
         * The public Color type of the ImaVol.
         *
         * See the \ref iterators_example.cpp "iterators and colors example" to know how to use it.
         */
        typedef typename ColorViewBase<T, N, boost::array<T*, N> >::Color      Color;
        
    public:

        /*!
         * \brief ImaVol's iterator.
         *
         * See the \ref iterators_example.cpp "iterators and colors example" to know how to use it.
         */
        template< class RegionType = ImaVol >
        class iterator; 
        
        /*! 
         * \brief ImaVol's constant iterator.
         * 
         * See the \ref iterators_example.cpp "iterators and colors example" to know how to use it.
         */
        template< class RegionType = const ImaVol >
        class const_iterator;

    public:
        

        //!
        //! \brief Default constructor
        //!
        ImaVol( );

        //!
        //! \brief Constructor for 1 dimensions
        //!
        //! \param[in] width  : X size of the image
        //!
        ImaVol( uint64 width );

        //!
        //! \brief Constructor for 2 dimensions
        //!
        //! \param[in] width  : X size of the image
        //! \param[in] height : Y size of the image
        //!
        ImaVol( uint64 width, uint64 height );

        //!
        //! \brief Constructor for 3 dimensions
        //!
        //! \param[in] width  : X size of the volume
        //! \param[in] height : Y size of the volume
        //! \param[in] depth  : Z size of the volume
        //!
        ImaVol( uint64 width, uint64 height, uint64 depth );

        //!
        //! \brief Constructor with a vector of dimentions
        //!
        //! \param[in] dims: Vector of vectors with the dimension of each channel
        //!
        template <typename ExtentList>
        explicit
        ImaVol( const ExtentList& dims);
        
//#ifdef MSVC
        //!
        //! \brief Copy constructor
        //!
        //! \param[in] copy : Creates a copy (including values) of this imavol
        //!
        ImaVol( const ImaVol& copy );
        
//#endif

        //!
        //! \brief Destructor
        //!
        virtual ~ImaVol();

        //!
        //! \brief Assignment operator for ImaVol
        //!
        //! \param[in] copy : Creates a copy (size,channels and data) of this imavol
        //!
        //! \return Reference to (this) so a = b = c; works.
        //!
        const ImaVol& operator=( const ImaVol& copy );

        //!
        //! \brief Assignment operator for values (fills the entire imavol)
        //!
        //! \param[in] val : Value to fill all pixel / voxels
        //!
        //! \return val, to concatenate
        //!
        const T& operator=(const T& val);
        
        //!
        //! \brief Assignment operator for colors (fills the entire imavol)
        //!
        //! \param[in] val : Color to fill all pixel / voxels
        //!
        //! \return val, to concatenate
        //!
        const Color& operator=(const Color& val);
        
        
        //!
        //! \brief Resize method with a vector of dimensions.
        //! 
        //! The number of dimensions must remain the same, but the extent of each dimension may be increased and decreased as desired. <br>
        //! When an array is made strictly larger, the existing elements will be preserved by copying them into the new underlying memory and subsequently destructing the elements in the old underlying memory. <br>
        //! Any new elements in the array are default constructed. However, if the new array size shrinks some of the dimensions, <B>some elements will no longer be available </B>. <br>
        //! In this case, the image is cropped from the origin mantaining only the corresponding values relying on the new dimensions.
        //!
        //! \param[in] dims: Vector of vectors with the dimension of each channel
        //!
        //! \sa imageplus::math::numeric::resize()  (in imageplus/math/numeric/interpolation.hpp)
        //!
        void resize( const std::vector< std::vector<uint64> >& dims);
        
        //!
        //! \brief Resize method with a vector of dimensions.
        //! 
        //! The number of dimensions must remain the same, but the extent of each dimension may be increased and decreased as desired. <br>
        //! When an array is made strictly larger, the existing elements will be preserved by copying them into the new underlying memory and subsequently destructing the elements in the old underlying memory. <br>
        //! Any new elements in the array are default constructed. However, if the new array size shrinks some of the dimensions, <B>some elements will no longer be available </B>. <br>
        //! In this case, the image is cropped from the origin mantaining only the corresponding values relying on the new dimensions.
        //!
        //! \param[in] width  : X size of the volume
        //! \param[in] height : Y size of the volume
        //! \param[in] depth  : Z size of the volume
        //!
        //! \sa imageplus::math::numeric::resize()  (in imageplus/math/numeric/interpolation.hpp)
        //!
        void resize( uint64 width, uint64 height, uint64 depth );
        
        
        //!
        //! \brief Resize method with a vector of dimensions.
        //! 
        //! The number of dimensions must remain the same, but the extent of each dimension may be increased and decreased as desired. <br>
        //! When an array is made strictly larger, the existing elements will be preserved by copying them into the new underlying memory and subsequently destructing the elements in the old underlying memory. <br>
        //! Any new elements in the array are default constructed. However, if the new array size shrinks some of the dimensions, <B>some elements will no longer be available </B>. <br>
        //! In this case, the image is cropped from the origin mantaining only the corresponding values relying on the new dimensions.
        //!
        //! \param[in] width  : X size of the image
        //! \param[in] height : Y size of the image
        //!
        //! \sa imageplus::math::numeric::resize() (in imageplus/math/numeric/interpolation.hpp)
        //!
        void resize( uint64 width, uint64 height );
        
        //!
        //! \brief Resize method with a vector of dimensions
        //!
        //! The number of dimensions must remain the same, but the extent of each dimension may be increased and decreased as desired. <br>
        //! When an array is made strictly larger, the existing elements will be preserved by copying them into the new underlying memory and subsequently destructing the elements in the old underlying memory. <br>
        //! Any new elements in the array are default constructed. However, if the new array size shrinks some of the dimensions, <B>some elements will no longer be available </B>. <br>
        //! In this case, the image is cropped from the origin mantaining only the corresponding values relying on the new dimensions.
        //!
        //! \param[in] dims: Vector of vectors with the dimension of each channel
        //!
        template<class ExtentList>
        void resize( const ExtentList& dims)
        {
            for(std::size_t ch = 0; ch < channels; ++ch ) (*this)(ch).resize(dims);
        }

        //!
        //! \brief Changes the coordinate of the left-up corner of the image
        //!
        //! \param[in] new_origin: Coordinate of the up-left corner of the image
        //!
        void reindex(CoordType new_origin)
        {
            for(std::size_t ch = 0; ch < channels; ++ch )
            {
                (*this)(ch).reindex(new_origin);
            }
        }

        //!
        //! \brief Access number of channels
        //!
        //! \return The number of channels of the imaVol
        //!
        uint64 num_channels () const;

        //!
        //! \brief Color space
        //!
        //! \return Color space
        //!
        virtual
        ColorSpace color_space() const
        {
            return Undefined;
        }

        //!
        //! \brief Access number of elements in the imavol
        //!
        //! Note that for images with diferent resolution per channel, this is not num_channels()*num_elements()
        //!
        //! \return the TOTAL number of elements (pixels/voxels for grayscale and color components for color images/volumes) of the imaVol
        //!
        uint64 num_total_data_elements() const;
        
        //!
        //! \brief Access number of elements in a channel
        //!
        //! Note that without input parameters this funcion returns the number of elements of the first channel, 
        //! that in general can be considered as the number of elements "per" channel.
        //!
        //! This is not true for multi-resolution ImaVols
        //!
        //! \param[in] channel : the channel to get the number of elements
        //!
        //! \return the number of elements (pixels/voxels) of the first channel
        //!
        uint64 num_elements_in_channel(std::size_t channel = 0) const;


        //!
        //! \brief Direct access to image channels
        //!
        //! \param[in] n : Channel number to get
        //!
        //! \return Reference to the ChannelType of the channel selected
        //!
        const ChannelType& operator()( uint64 n ) const;

        //!
        //! \brief Direct access to image channels
        //!
        //! \param[in] n : Channel number to get
        //!
        //! \return Reference to the ChannelType of the channel selected
        //!
        ChannelType& operator()( uint64 n );
        
        
        //!
        //! \brief Overload of operator[] to be able to use imavol[x][y] instead of imavol(0)[x][y] for single channel imavols
        //!
        //! \param[in] pos : coordenate X of the image
        //!
        //! \return Reference to sub_array with D-1 dimension (to be able to access coordinate Y)
        //!
        boost::detail::multi_array::sub_array<T,D-1> operator[]( std::size_t pos )
        {
            ASSERT( _c.size() == 1, "Using imavol[] instead of imavol()[] in an imavol with multiple channels. It only works in sigle channel ImaVols")
            return (*this)(0)[pos];
        }


        
        //!
        //! \brief Overload of operator[] to be able to use imavol[x][y] instead of imavol(0)[x][y] for single channel imavols
        //!
        //! \param[in] pos : coordenate X of the image
        //!
        //! \return Reference to sub_array with D-1 dimension (to be able to access coordinate Y)
        //!
        boost::detail::multi_array::const_sub_array<T,D-1> operator[]( std::size_t pos ) const
        {
            ASSERT( _c.size() == 1, "Using imavol[] instead of imavol()[] in an imavol with multiple channels. It only works in sigle channel ImaVols")
            return (*this)(0)[pos];
        }

        //!
        //! \brief Access dimension of the ImaVol
        //!
        //! \return Vector with N values, each value is a vector with the size of all dimensions for that channel
        //!
        const std::vector< std::vector<size_type> > dims() const;

        /*!
         * \returns the size of the given dimension
         *
         * \param[in] dim : the dimension index (from 0 to D)
         *
         * \note since at this moment ImaVol channels *can* have different sizes per dimension, this function
         *       returns the first channel sizes
         *
         * \author 2011-07 - Albert Gil Moreno - Added for clarity and convenience.
         *                                       Normally the developers use imavol(0).dims(dim) instead...
         */
        size_type size(std::size_t dim) const
        {
            //imageplus::size_type dims(imageplus::size_type d) const;
            return _c[0].dims(dim);
        }

        /*!
         * \returns the sizes of all dimensions
         *
         * \note since at this moment ImaVol channels *can* have different sizes per dimension, this function
         *       returns the first channel sizes
         *
         * \author 2011-07 - Albert Gil Moreno - Added for clarity and convenience.
         *                                       Normally the developers use imavol(0).dims() instead...
         */
        boost::array<size_type,D> sizes() const
        {
            //imageplus::size_type dims(imageplus::size_type d) const;
            boost::array<size_type,D> out;

            for(std::size_t ii=0; ii<D; ++ii ) out[ii] = _c[0].shape()[ii];
            return out;
        }


        //!
        //! \brief Access to X dimension (only for ImaVols with D >= 1) 
        //!
        //! \return The size of the X dimension (first)
        //!
        size_type size_x() const;

        //!
        //! \brief Access to Y dimension (only for ImaVols with D >= 2)
        //!
        //! \return The size of the Y dimension (second)
        //!
        size_type size_y() const;
        
        //!
        //! \brief Access to Z dimension (only for ImaVols with D >= 3)
        //!
        //! \return The size of the Z dimension (third)
        //!
        size_type size_z() const;
               
        
        /*!
         * \brief Color access by Coords
         * 
         * See the \ref iterators_example.cpp "iterators and colors example" to know how to use it.
         * 
         * \tparam TC : This template allows us to use different types of coords.
         * 
         * \param[in] coord : Coord position to get the color from.
         * 
         * \return The color_view object in the position coord.
         */
        template<typename TC>
        color_view operator()(const Coord<TC,D>& coord)
        {
            color_view col;
            
            for(std::size_t i=0; i<N; ++i) col.assign_ptr(i, &(_c[i](coord)));
            
            return col;
        }

        /*!
         * \brief Color access by DataIndex
         * 
         * See the \ref iterators_example.cpp "iterators and colors example" to know how to use it.
         * 
         * \param[in] data_index : DataIndex position to get the color from.
         * 
         * \return The color_view object in the position data_index.
         */
        color_view operator()(DataIndex data_index) 
        {
            color_view col;
            
            for(std::size_t i=0; i<N; ++i)
            {
                col.assign_ptr(i, &(_c[i]( data_index )));
            }
            
            return col;
        }
        
        
        /*!
         * \brief Constant access to Colors by Coords
         * 
         * See the \ref iterators_example.cpp "iterators and colors example" to know how to use it.
         * 
         * \tparam TC : This template allows us to use different types of coords.
         * 
         * \param[in] coord : Coord position to get the color from.
         * 
         * \return A constant color_view object in the position coord.
         */
        template<typename TC>
        const_color_view operator()(const Coord<TC,D>& coord) const
        {
            const_color_view col;
            for(std::size_t i=0; i<N; ++i) col.assign_ptr(i, &(_c[i](coord)));
            
            return col;
        }

        
        /*!
         * \brief Constant access to Colors by DataIndex
         * 
         * See the \ref iterators_example.cpp "iterators and colors example" to know how to use it.
         * 
         * \param[in] data_index : DataIndex position to get the color from.
         * 
         * \return The constant color_view object in the position data_index.
         */
        const_color_view operator()(DataIndex data_index) const
        {
            const_color_view col;
            for(std::size_t i=0; i<N; ++i)
            {
                col.assign_ptr(i, &(_c[i](data_index )));
            }
            
            return col;
        }
        
    public:
        
        /*!
         * See the \ref iterators_example.cpp "iterators and colors example" to know how to use it. 
         * 
         * This iterator will loop to the whole ImaVol.
         *
         * \return the first color iterator
         */
        iterator<> colors_begin() 
        {
            return iterator<>( this, position_begin() );
        }

        /*!
         * See the \ref iterators_example.cpp "iterators and colors example" to know how to use it.
         * 
         * \return an iterator pointing to the last+1 color.
         * 
         * \warning this iterator points to a non-valid position.
         */
        iterator<> colors_end(  ) 
        {
            return iterator<>( this, position_end() );
        }

        /*!
         * See the \ref iterators_example.cpp "iterators and colors example" to know how to use it. 
         * 
         * This iterator will loop to the whole ImaVol.
         *
         * \return the first color iterator (constant access)
         */
        const_iterator<> colors_begin() const  
        {
            return const_iterator<>( this, position_begin() );
        }

        /*!
         * See the \ref iterators_example.cpp "iterators and colors example" to know how to use it.
         * 
         * \return an iterator pointing to the last+1 color (constant access)
         * 
         * \warning this iterator points to a non-valid position.
         */
        const_iterator<> colors_end() const 
        {
            return const_iterator<>( this, position_end() );
        }

        /*!
         * See the \ref iterators_example.cpp "iterators and colors example" to know how to use it.
         * 
         * This iterator will loop from coord position to the end.
         * 
         * \param[in] coord : Coord to start looping.  
         * 
         * \return the color iterator pointing to a desired coord
         */
        iterator<> colors_begin( CoordType coord ) 
        {
            return iterator<>( this, position_begin( coord ) );
        }

        /*!
         * See the \ref iterators_example.cpp "iterators and colors example" to know how to use it.
         * 
         * This iterator will loop from coord position to the end.
         * 
         * \param[in] coord : Coord to start looping.  
         * 
         * \return the color iterator pointing to a desired coord (constant access)
         */
        const_iterator<> colors_begin( CoordType coord ) const  
        {
            return const_iterator<>( this, position_begin( coord ) );
        }
        
        
        /*!
         * \brief Get the color iterator to loop in a desired RegionType
         * 
         * See the \ref iterators_example.cpp "iterators and colors example" to know how to use it.
         * 
         * \tparam RegionType : This template allows us to use any Region type.
         * 
         * \param[in] region : The RegionType to iterate.  
         * 
         * This iterator will loop to the desired region in the ImaVol.
         *
         * \return the color iterator to loop in a desired RegionType
         * 
         * \todo Add the RegionConcept documentation 
         */
        template< class RegionType >
        iterator< RegionType > colors_begin( const RegionType& region ) 
        {
            return iterator< RegionType >( this, region.begin(  ) );
        }
        
        /*!
         * \brief Get the color iterator poitin to the end of a desired RegionType
         * 
         * See the \ref iterators_example.cpp "iterators and colors example" to know how to use it.
         * 
         * \tparam RegionType : This template allows us to use any Region type.
         * 
         * \param[in] region : The RegionType to iterate.  
         * 
         * \return the color iterator pointing to the last+1 element of a desired RegionType
         *
         * \warning the returned iterator points to a non-valid position.
         */
        template< class RegionType >
        iterator< RegionType > colors_end( const RegionType& region ) 
        {
            return iterator< RegionType >( this, region.end() );
        }
        

        /*!
         * \brief Get the color iterator to loop in a desired RegionType (constant access)
         * 
         * See the \ref iterators_example.cpp "iterators and colors example" to know how to use it.
         * 
         * \tparam RegionType : This template allows us to use any Region type.
         * 
         * \param[in] region : The RegionType to iterate.  
         * 
         * This iterator will loop to the desired region in the ImaVol.
         *
         * \return the color iterator to loop in a desired RegionType (constant access)
         * 
         * \todo Add the RegionConcept documentation 
         */
        template< class RegionType >
        const_iterator< RegionType > colors_begin( const RegionType& region ) const  
        {
            return const_iterator< RegionType >( this, region.begin() );
        }
        
        /*!
         * \brief Get the color iterator pointing to the last+1 element of a desired RegionType (constant access)
         * 
         * See the \ref iterators_example.cpp "iterators and colors example" to know how to use it.
         * 
         * \tparam RegionType : This template allows us to use any Region type.
         * 
         * \param[in] region : The RegionType to iterate.  
         * 
         * \return the color iterator pointing to the last+1 element of a desired RegionType (constant access)
         *
         * \warning This iterator points to a non-valid position.
         */
        template< class RegionType >
        const_iterator< RegionType > colors_end( const RegionType& region ) const  
        {
            return const_iterator< RegionType >( this, region.end() );
        }

        


    private:

        //! vector storing all channels as ChannelType
        std::vector< ChannelType > _c;
        
        
    public:

		/*!
		 * \brief Get region label.
		 *
		 * This function allows to use an entire ImaVol as a Region, so it has been defined to
		 * match the RegionConcept.
		 *
		 * This value is fixed to "1" because when considering the ImaVol as
		 * a Region this region covers the whole ImaVol. Therefore, this
		 * identifier is the same for every ImaVol.
		 *
		 * \returns the Region label of this ImaVol in the context of a Partition.
		 */
		uint32 label() const
		{
			return 1;
		}
        
        /*!
         * \cond SKIP_DOC
         * 
         * Internal class to model the RegionConcept.
         * 
         * This class allows us to use an ImaVol as a Region, that is, to iterate to the whole ImaVol. 
         */
        class RegionIterator
        {

        protected:
            CoordType _pos;
            boost::array<int64, D> _limits;
            boost::array<int64, D> _bases;
            
//            RegionIterator( CoordType pos)
//                    : _pos(pos)
//            {
//            }
            
            template<class ExtentList1, class ExtentList2>
            RegionIterator( CoordType pos, const ExtentList1& dims, const ExtentList2& bases)
                    : _pos(pos), _limits(), _bases(bases)
            {
                for(std::size_t ii=0; ii<D; ++ii)
                    _limits[ii] = _bases[ii] + dims[ii];
            }

            template<class ExtentList>
            RegionIterator( CoordType pos, const ExtentList& dims)
                    : _pos(pos), _limits()
            {
                for(std::size_t dd = 0; dd<D; ++dd)
                    _bases[dd] = 0;
                
                for(std::size_t ii=0; ii<D; ++ii)
                    _limits[ii] =  dims[ii];
            }
            
        public:
            
            //iterator traits
            typedef std::input_iterator_tag    iterator_category;
            typedef CoordType                  value_type;
            typedef Coord<int64,D>             difference_type;
            typedef value_type*                pointer;
            typedef value_type&                reference;

            RegionIterator()
                    : _pos()
            {
            }

            
            RegionIterator& operator++() 
            {
                _pos[0]++;
                for(std::size_t dd=0; dd<D-1; ++dd) 
                {
                    if(_pos[dd]==_limits[dd])
                    {
                        _pos[dd] = _bases[dd];
                        _pos[dd+1]++;
                    }
                    else
                        break;
                }
           
                return *this;
            }
            
            
            CoordType operator*()
            {
                return _pos;
            }
            
            friend
            bool operator!=(const RegionIterator& it1, const RegionIterator& it2)
            {
                return it1._pos != it2._pos;
            }
            
            friend
            bool operator==(const RegionIterator& it1, const RegionIterator& it2)
            {
                return it1._pos == it2._pos;
            }

            
            friend class ImaVol;
        };
        

        
        /* AGIL: non-const region iterator has sense? */
        
        //typedef RegionIterator       position_iterator;
        typedef RegionIterator const_position_iterator;


        RegionIterator position_begin() const 
        {
            return RegionIterator( (*this)(0).bases(), (*this)(0).dims(), (*this)(0).bases());
        }
        
        RegionIterator position_end() const 
        {
            CoordType end;
            for(std::size_t dd=0; dd<D-1; ++dd)
                end[dd] =  (*this)(0).bases()[dd];
            end[D-1] = (*this)(0).bases()[D-1] + (*this)(0).dims()[D-1];
            
            return RegionIterator( end, (*this)(0).dims(), (*this)(0).bases());
        }
        
        RegionIterator position_begin( CoordType coord ) const 
        {
            return RegionIterator( coord, (*this)(0).dims(), (*this)(0).bases());
        }
        
    public:
        
        template< class IteratorType = iterator<ImaVol> >
        class ChannelIterator;
        
        template< class IteratorType = const_iterator<const ImaVol> >
        class ConstChannelIterator;
        
        template< class RegionType >
        class iterator : public DataIteratorBase< RegionType, ImaVol, data_type, Pixel<RegionType, ImaVol, data_type> >
        {
        public:
            typedef DataIteratorBase< RegionType, ImaVol, data_type, Pixel<RegionType, ImaVol, data_type> > base_class;
            typedef typename base_class::position_iterator position_iterator;
            typedef RegionType region_type;
            typedef ChannelIterator<iterator> channel_iterator;

            iterator( const base_class& copy )
                    : base_class(copy)
            {
            }
                    
            iterator( ImaVol* iv , position_iterator it )
                    : base_class(iv, it)
            {
            }
        };
        
        template< class RegionType >
        class const_iterator : public DataIteratorBase< RegionType, const ImaVol, const data_type, Pixel<RegionType, const ImaVol, const data_type> >
        {
        public:
            typedef DataIteratorBase< RegionType, const ImaVol, const data_type, Pixel<RegionType, const ImaVol, const data_type> > base_class;
            typedef typename base_class::position_iterator position_iterator;
            typedef RegionType region_type; 
            typedef ConstChannelIterator<const_iterator> channel_iterator;

            const_iterator( const base_class& copy )
                    : base_class(copy)
            {
            }                
            
            const_iterator( const ImaVol* const iv , position_iterator it )
                    : base_class(iv, it)
            {
            }                
        };
        
        
        template< class IteratorType >
        class ChannelIterator : public DataIteratorBase< typename IteratorType::region_type, ImaVol, data_type, Pixel<typename IteratorType::region_type, ImaVol, data_type> >
        {
            typedef DataIteratorBase< typename IteratorType::region_type, ImaVol, data_type, Pixel<typename IteratorType::region_type, ImaVol, data_type> > parent_type;
            typedef ChannelPixel<typename IteratorType::region_type, ImaVol, data_type> pixel_type;
        public:
            ChannelIterator( const IteratorType& copy, uint64 channel)
            : parent_type(copy), _channel(channel)
            {
            }

            pixel_type operator*()
            {
                return pixel_type(this->_iv,  *(this->_it), _channel);
            }

        private:
            uint64 _channel;
        };
        
        
        template< class IteratorType >
        class ConstChannelIterator : public DataIteratorBase< typename IteratorType::region_type, const ImaVol, const data_type, Pixel<typename IteratorType::region_type, const ImaVol, const data_type> >
        {
            typedef DataIteratorBase< typename IteratorType::region_type, const ImaVol, const data_type, Pixel<typename IteratorType::region_type, const ImaVol, const data_type> > parent_type;
            typedef ChannelPixel<typename IteratorType::region_type, const ImaVol, const data_type> pixel_type;
        public:
            ConstChannelIterator( const IteratorType& copy, uint64 channel)
            : parent_type(copy), _channel(channel)
            {
            }
            
            pixel_type operator*()
            {
                return pixel_type(this->_iv,  *(this->_it), _channel);
            }
            
        private:
            uint64 _channel;
        };
        
        
        /*! 
         * \endcond
         */
            
    };
    
    
    //
    // Inline methods implementation
    //
    
    template<typename T, std::size_t N, std::size_t D>
    IMAGEPLUS_INLINE
    ImaVol<T,N,D>::ImaVol ( ) :
            _c(N, ChannelType())
    {
    }

    template<typename T, std::size_t N, std::size_t D>
    IMAGEPLUS_INLINE
    ImaVol<T,N,D>::ImaVol ( uint64 width )
            : _c(N,ChannelType(width))
    {
        ASSERT(D==1, "ImaVol<T,N,D>::ImaVol(x) constructor can only be called with D=1 dimensions.")
    }


    template<typename T, std::size_t N, std::size_t D>
    IMAGEPLUS_INLINE
    ImaVol<T,N,D>::ImaVol ( uint64 width, uint64 height )
            : _c(N,ChannelType(width,height))
    {
        ASSERT(D==2, "ImaVol<T,N,D>::ImaVol(x,y) constructor can only be called with D=2 dimensions.")
    }


    template<typename T, std::size_t N, std::size_t D>
    IMAGEPLUS_INLINE
    ImaVol<T,N,D>::ImaVol (uint64 width, uint64 height, uint64 depth )
            : _c(N,ChannelType(width,height,depth))
    {
        ASSERT(D==3, "ImaVol<T,N,D>::ImaVol(x,y,z) constructor can only be called with D=3 dimensions." )
    }


//#ifdef MSVC
    template<typename T, std::size_t N, std::size_t D>
    IMAGEPLUS_INLINE
    ImaVol<T,N,D>::ImaVol( const ImaVol& copy ) : collaborative_descriptors_traits(),
            _c (copy._c)
    {
    }
    
//#endif

    template<typename T, std::size_t N, std::size_t D>
    template <typename ExtentList>
    IMAGEPLUS_INLINE
    ImaVol<T,N,D>::ImaVol( const ExtentList& dims )
    {
        ASSERT(dims.size() == N, "Dimensions of dims must be equal to the number of channels.")

        //TODO: it can be done with MultiArray<T,D>(dims) ???
        
        // Create vector with empty multiarrays for each channel
        this->_c.assign(N,ChannelType());

        for (uint64 c=0; c < N; c++)
        {
            ASSERT(dims[c].size() == D, "Dimensions for each dims[i] must be equal to the number " << 
                                        "of dimensions of the imavol (2 for images or 3 for volumes).")
            this->_c[c].resize( dims[c] );
        }
    }

    template<typename T, std::size_t N, std::size_t D>
    IMAGEPLUS_INLINE
    ImaVol<T,N,D>::~ImaVol()
    {
    }

    template<typename T, std::size_t N, std::size_t D>
    IMAGEPLUS_INLINE
    const ImaVol<T,N,D>& ImaVol<T,N,D>::operator=( const ImaVol& copy )
    {
        ASSERT( &copy != this, "ImaVol<T,N,D>::operator=: Self Assignment")

        // Not needed as we use MultiArray instead of boost::multi_array and the copy constructor takes care of arrays with
        // different sizes and dimensions
        //this->_c.clear();

        // std::vector class takes cares of colling the operator= for all memeber of the vector
        this->_c       = copy._c;

        return *this;
    }
    
    
    template<typename T, std::size_t N, std::size_t D>
    IMAGEPLUS_INLINE
    void ImaVol<T,N,D>::resize (uint64 width, uint64 height, uint64 depth )
    {
        ASSERT(D==3, "ImaVol<T,N,D>::resize(x,y,z) can only be called with D=3 dimensions." )
        
        std::vector<uint64> dims;
        dims.push_back(width);
        dims.push_back(height);
        dims.push_back(depth);
        
        for (uint64 c=0; c < N; c++)
        {
            ASSERT(dims.size() == D, "Dimensions for each dims[i] must be equal to the number " << 
                                        "of dimensions of the imavol (2 for images or 3 for volumes).")
            this->_c[c].resize( dims );
        }
    }
    

    template<typename T, std::size_t N, std::size_t D>
    IMAGEPLUS_INLINE
    void ImaVol<T,N,D>::resize ( uint64 width, uint64 height )
    {
        ASSERT(D==2, "ImaVol<T,N,D>::resize(x,y) can only be called with D=2 dimensions.")
        
        std::vector<uint64> dims;
        dims.push_back(width);
        dims.push_back(height);
        
        for (uint64 c=0; c < N; c++)
        {
            ASSERT(dims.size() == D, "Dimensions for each dims[i] must be equal to the number " << 
                                        "of dimensions of the imavol (2 for images or 3 for volumes).")
            this->_c[c].resize( dims );
        }
    }
    
    
    
    template<typename T, std::size_t N, std::size_t D>
    IMAGEPLUS_INLINE
    void ImaVol<T,N,D>::resize( const std::vector< std::vector<uint64> >& dims )
    {
        ASSERT(dims.size() == N || dims.size() == 1, "Dimensions of dims must be equal to the number of channels or 1.")

        if(dims.size()==1)
        {
            for (uint64 c=0; c < N; c++)
            {
                ASSERT(dims[0].size() == D, "Dimensions for each dims[i] must be equal to the number " << 
                                            "of dimensions of the imavol (2 for images or 3 for volumes).")
                this->_c[c].resize( dims[0] );
            }            
        }
        else
        {
            for (uint64 c=0; c < N; c++)
            {
                ASSERT(dims[c].size() == D, "Dimensions for each dims[i] must be equal to the number " << 
                                            "of dimensions of the imavol (2 for images or 3 for volumes).")
                this->_c[c].resize( dims[c] );
            }
        }
    }

    // num_elements returns the number of elements (pixels for gray scale or color components for color images/volumes)
    template<typename T, std::size_t N, std::size_t D>
    IMAGEPLUS_INLINE
    uint64 ImaVol<T,N,D>::num_total_data_elements() const
    {
        uint64 n = 0;

        for (uint64 i = 0;  i < N; i++)
        {
            ASSERT(i < _c.size(), "ImaVol<T,N,D>::num_elements: ImaVol vector size error")
            n += this->_c[i].num_elements();
        }
        return n;
    }
    
    template<typename T, std::size_t N, std::size_t D>
    IMAGEPLUS_INLINE
    uint64 ImaVol<T,N,D>::num_elements_in_channel(std::size_t channel) const
    {
        ASSERT(channel < _c.size(), "ImaVol<T,N,D>::num_elements_in_channel: ImaVol vector size error")
        return this->_c[channel].num_elements();
    }


    template<typename T, std::size_t N, std::size_t D>
    IMAGEPLUS_INLINE
    uint64 ImaVol<T,N,D>::num_channels() const
    {
        return ( N );
    }

    // fill an imavol
    template<typename T, std::size_t N, std::size_t D>
    const T& ImaVol<T,N,D>::operator=( const T& val )
    {

        for (uint64 c = 0; c < N; c++)
        {
            ASSERT(c < _c.size(), "ImaVol<T,N,D>::operator=: ImaVol vector size error")
            this->_c[c] = val;
        }

        return val;
    }
    
    // fill an imavol
    template<typename T, std::size_t N, std::size_t D>
    const typename ImaVol<T,N,D>::Color& ImaVol<T,N,D>::operator=( const Color& val )
    {

        for (uint64 c = 0; c < N; c++)
        {
            ASSERT(c < _c.size(), "ImaVol<T,N,D>::operator=: ImaVol vector size error")
            this->_c[c] = val[c];
        }

        return val;
    }

    
    // Acces to data channels
    template<typename T, std::size_t N, std::size_t D>
    IMAGEPLUS_INLINE
    const typename ImaVol<T,N,D>::ChannelType& ImaVol<T,N,D>::operator()( uint64 n ) const
    {
        ASSERT(n < _c.size(), "ImaVol<T,N,D>::operator(): Value out of range")
        return (this->_c[n]);
    }


    // Acces to data channels
    template<typename T, std::size_t N, std::size_t D>
    IMAGEPLUS_INLINE
    typename ImaVol<T,N,D>::ChannelType& ImaVol<T,N,D>::operator()( uint64 n )
    {
        ASSERT(n < _c.size(), "ImaVol<T,N,D>::operator(): Value out of range")
        return (this->_c[n]);
    }

    // ImaVol dimensions
    template<typename T, std::size_t N, std::size_t D>
    IMAGEPLUS_INLINE
    const std::vector< std::vector<size_type> > ImaVol<T,N,D>::dims() const
    {
        std::vector< std::vector<size_type> > d(N);

        for (uint64 c=0; c<N; c++)
        {
            d[c] = this->_c[c].dims();
        }

        return d;
    }

    template<typename T, std::size_t N, std::size_t D>
    IMAGEPLUS_INLINE 
    size_type ImaVol<T,N,D>::size_x() const
    {
        ASSERT(D >= 1, "Access to X dimension of ImaVol with D = " << D)
        return static_cast<size_type>((*this)(0).dims(0));
    }
    
    template<typename T, std::size_t N, std::size_t D>
    IMAGEPLUS_INLINE 
    size_type ImaVol<T,N,D>::size_y() const
    {
        ASSERT(D >= 2, "Access to Y dimension of ImaVol with D = " << D)
        return static_cast<size_type>((*this)(0).dims(1));
    }

    template<typename T, std::size_t N, std::size_t D>
    IMAGEPLUS_INLINE 
    size_type ImaVol<T,N,D>::size_z() const
    {
        ASSERT(D >= 3, "Access to Z dimension of ImaVol with D = " << D)
        return static_cast<size_type>((*this)(0).dims(2));
    }
    

    /*!
     * \brief ostream operator for ImaVols
     * 
     * Use it only to debug  small ImaVols
     * 
     * \tparam T : ImaVol's data type
     * \tparam N : the number of channels of the ImaVol 
     * \tparam D : ImaVol's dimensions
     * 
     * \param[in] os : the ostream to print out (usually std::cout)
     * \param[in] iv : the ImaVol to print out
     * 
     * \return os
     */
    template<typename T, std::size_t N, std::size_t D>
    std::ostream& operator<<(std::ostream& os, ImaVol<T, N, D>& iv)
    {
        for (std::size_t i=0; i<N; i++)
        {
            os << "Channel " << i << ": " << std::endl;
            os << iv(i) << std::endl;
        }
        return os;
    }

}




#endif
