// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------


//!
//! \file readsequenceffmpeg.cpp
//!
//! \author Javier Ruiz Hidalgo <j.ruiz@upc.edu>
//!
//! \date 10-1-2008
//!
//! Implementation for ReadSequenceFfmpeg class
//!

#ifdef USE_FFMPEG

#include <readsequenceffmpeg.hpp>

using namespace imageplus;
using namespace imageplus::io;


#define NEW_FFMPEG_INTERFACE 1

#ifndef _TRACE
//!
//! \brief Method to control ffmpeg log output
//!
//! This method is necessary because ffmpeg logs some messages in std::cerr.
//!
//! See the ffmpeg for reference on his parameters
//!
static void ffmpeg_log_callback(void* ptr, int level, const char* fmt, va_list vl)
{
}
#endif


ReadSequenceFfmpeg::ReadSequenceFfmpeg()
        : _filename(""), 
          _framecont(0), 
          _format_ctx(NULL), 
          _codec_ctx(NULL), 
          _codec(NULL), _frame(NULL), 
          _video_stream(-1),
          _frame_already_read(false)
{
    for (uint32 i = 0; i < 4; i++)
    {
        _frame_buffer[i] = NULL;
        _frame_conv[i] = NULL;
        _img_convert_ctx[i] = NULL;
   }

#ifndef _TRACE
    // remove ffmpeg in release mode 
    av_log_set_callback(ffmpeg_log_callback);
#endif
    
}

ReadSequenceFfmpeg::ReadSequenceFfmpeg( const std::string& filename, uint64 skip = 0 )
{
    this->open(filename, skip);
}

void ReadSequenceFfmpeg::open( const std::string& filename, uint64 skip = 0) throw (ImagePlusError,ImagePlusFileNotFound,ImagePlusFileError)
{
    if (skip > 0)
    {
        throw ImagePlusError("Skipping every other frame not yet implemented");
    }

    // Private data
    _filename = filename;
    _framecont = 0;
    _format_ctx = NULL;
    _codec_ctx = NULL;
    _codec = NULL;
    _frame = NULL;
    _frame_already_read = false;
    _video_stream = -1;

    _frame_format[0] = PIX_FMT_GRAY8;
    _frame_format[1] = PIX_FMT_RGB24;
    _frame_format[2] = PIX_FMT_YUV444P;
    _frame_format[3] = PIX_FMT_YUV420P;

    for (int32 i = 0; i < 4; i++)
    {
        _frame_conv[i] = NULL;
        _frame_buffer[i] = NULL;
    }

    // Register all formats and codecs
    av_register_all();
    
    // Open video file
    // Deprecated. use 

#if NEW_FFMPEG_INTERFACE
    if(avformat_open_input(&_format_ctx, _filename.c_str(), NULL, NULL) !=0)
#else
    if(av_open_input_file(&_format_ctx, _filename.c_str(), NULL, 0, NULL)!=0)
#endif
    {    
        throw ImagePlusFileNotFound(_filename);
    }

    // Retrieve stream information
    // Deprecated. Use avformat_find_stream_info(_format_ctx, NULL)
#if NEW_FFMPEG_INTERFACE
    if (avformat_find_stream_info(_format_ctx, NULL)<0)
#else
    if(av_find_stream_info(_format_ctx)<0)
#endif
    {
        throw ImagePlusFileError(_filename, "Couldn't find stream information");
    }
    
    TRACE( "FFmpeg file information: ");
#ifndef NDEBUG
#ifdef _TRACE
    dump_format(_format_ctx, 0, _filename.c_str(), 0);
#endif
#endif
    
    // Find the first video stream
    for(uint32 i=0; i<_format_ctx->nb_streams; i++)
    {

#if NEW_FFMPEG_INTERFACE
        if(_format_ctx->streams[i]->codec->codec_type==AVMEDIA_TYPE_VIDEO) 
#else
        if(_format_ctx->streams[i]->codec->codec_type==CODEC_TYPE_VIDEO) 
#endif
        {
            _video_stream = i;
            break;
        }
    }
    
    if(_video_stream==-1)
    {
        this->free_private_data();
        throw ImagePlusFileError(_filename, "Didn't find a video stream");
    }

    // Get a pointer to the codec context for the video stream
    _codec_ctx = _format_ctx->streams[_video_stream]->codec;

    // Find the decoder for the video stream
    _codec = avcodec_find_decoder(_codec_ctx->codec_id);
    if(_codec==NULL)
    {
        this->free_private_data();
        throw ImagePlusFileError(_filename,"Unsupported codec to open file");
    }
    
    // Open codec
#if NEW_FFMPEG_INTERFACE
    if(avcodec_open2(_codec_ctx, _codec, NULL)<0)  //??????
#else
    if(avcodec_open(_codec_ctx, _codec)<0)
#endif
    {
        this->free_private_data();
        throw ImagePlusFileError(_filename,"Could not open codec to open file");
    }

    // Allocate AVFrame structures
    _frame = avcodec_alloc_frame();
    if(_frame==NULL)
    {
        this->free_private_data();
        throw ImagePlusError("Could not allocate frame in ffmpeg");
    }

    for (int32 i = 0; i < 4; i++)
    {
        int num_bytes = 0;
        _frame_conv[i] = avcodec_alloc_frame();
        if(_frame_conv[i]==NULL)
        {
            this->free_private_data();
            throw ImagePlusError("Could not allocate frame in ffmpeg");
        }
        num_bytes = avpicture_get_size(_frame_format[i], 
                                       _codec_ctx->width, 
                                       _codec_ctx->height);

        _frame_buffer[i] = (uint8_t *)av_malloc(num_bytes*sizeof(uint8_t));
        avpicture_fill((AVPicture *)_frame_conv[i], 
                       _frame_buffer[i], 
                       _frame_format[i],
                       _codec_ctx->width, 
                       _codec_ctx->height);
    }

    // prepare img_convert
    for (int32 i = 0; i < 4; i++)
    {
        // _img_convert_ctx[i] = sws_alloc_context();
        // int sws_init_context(_img_convert_ctx[i], NULL, NULL);

        // Deprecated in new versions
        // Use sws_alloc_context() and sws_init_context() instead
        _img_convert_ctx[i] = sws_getContext(_codec_ctx->width, 
                                             _codec_ctx->height, 
                                             _codec_ctx->pix_fmt,
                                             _codec_ctx->width, 
                                             _codec_ctx->height, 
                                             _frame_format[i],
                                             SWS_FAST_BILINEAR, //SWS_BICUBIC, 
                                             NULL, NULL, NULL);
        if(_img_convert_ctx[i] == NULL) 
        {
            this->free_private_data();
            throw ImagePlusError("Cannot initialize the conversion context");
        }
    }

}

void ReadSequenceFfmpeg::free_private_data()
{

    // Free frames
    for (int32 i = 0; i < 4; i++)
    {
        if ( _frame_buffer[i] != NULL )
        {
            av_free(_frame_buffer[i]);
        }

        if ( _frame_conv[i] != NULL )
        {
            av_free(_frame_conv[i]);
        }
    }
    
    if (_frame != NULL)
    {
        av_free(_frame);
    }
    
    // free convert context
    for (int32 i = 0; i < 4; i++)
    {
        if ( _img_convert_ctx[i] != NULL )
        {
            sws_freeContext(_img_convert_ctx[i]);
        }
    }

    // Close the codec
    if (_codec != NULL)
    {
        avcodec_close(_codec_ctx);
    }
    
    // Close the video file
    if (_format_ctx != NULL) 
    {

#if NEW_FFMPEG_INTERFACE
        avformat_close_input(&_format_ctx);
#else
        // Deprecated
        av_close_input_file(_format_ctx);
#endif
    }

}

ReadSequenceFfmpeg::~ReadSequenceFfmpeg()
{
    free_private_data();
}

ReadSequenceFfmpeg& ReadSequenceFfmpeg::operator[]( uint64 frame ) throw (ImagePlusError)
{
#if 1
//    std::cout << "Prev #frame []: " << _framecont << std::endl;
    if (frame >= _framecont)
    {
        this->skip_frames (frame - _framecont);
    }
    else
    {
        throw ImagePlusError("Changing frame to previous frames not yet implemented");
    }

//    std::cout << "Next #frame []: " << _framecont << std::endl;
    
#else
    throw ImagePlusError("Changing frame to read next not yet implemented");
#endif
    return *this;
}

template<typename T>
void ReadSequenceFfmpeg::operator>>( ImageGray<T>& g )
{
    
    uint64 opt = 0;

    // read / decode / convert input frame
    convert_frame(opt);

    // Copy data from _frame_conv[] to imageplus format
    ImageGray<uint8> u(_codec_ctx->width,_codec_ctx->height);

    // copy data from _frame_conv[0]
    for (uint64 p = 0, y = 0; y < (uint64)_codec_ctx->height; y++)
    {
        for (uint64 x = 0; x < (uint64)_codec_ctx->width; x++, p++)
        {
            u(0).data()[p] = *(_frame_conv[opt]->data[0] + _frame_conv[opt]->linesize[0] * y + x);
        }
    }
    g = convert<T>(u);

    // mark frame as read
    _frame_already_read = false;

    // Increase the number for next frame
    //this->skip_frames(_skip);
}

template<typename T>
void ReadSequenceFfmpeg::operator>>( ImageRGB<T>& rgb )
{
//    std::cout << "Prev #frame : " << _framecont << std::endl;

    uint64 opt = 1;

    // read / decode / convert input frame
    convert_frame(opt);

    // Copy data from _frame_conv[] to imageplus format
    ImageRGB<uint8> u(_codec_ctx->width,_codec_ctx->height);

    // copy data from _frame_conv[0]
    for (uint64 p = 0, y = 0; y < (uint64)_codec_ctx->height; y++)
    {
        for (uint64 x = 0; x < (uint64)_codec_ctx->width; x++, p++)
        {
            uint8 *pos = _frame_conv[opt]->data[0] + _frame_conv[opt]->linesize[0] * y + 3*x;
            u(0).data()[p] = *( pos + 0);
            u(1).data()[p] = *( pos + 1);
            u(2).data()[p] = *( pos + 2);
        }
    }
    rgb = convert<T>(u);

    // mark frame as read
    _frame_already_read = false;

    // Increase the number for next frame
    //this->skip_frames(_skip);

//    std::cout << "Next #frame : " << _framecont << std::endl;

}

template<typename T>
void ReadSequenceFfmpeg::operator>>( ImageYUV<T>& yuv )
{

    uint64 opt = 2;

    // read / decode / convert input frame
    convert_frame(opt);

    // Copy data from _frame_conv[] to imageplus format
    ImageYUV<uint8> u(_codec_ctx->width,_codec_ctx->height);

    // copy data
    for (uint64 p = 0, y = 0; y < (uint64)_codec_ctx->height; y++)
    {
        for (uint64 x = 0; x < (uint64)_codec_ctx->width; x++, p++)
        {
            u(0).data()[p] = *( _frame_conv[opt]->data[0] + _frame_conv[opt]->linesize[0] * y + x );
            u(1).data()[p] = *( _frame_conv[opt]->data[1] + _frame_conv[opt]->linesize[1] * y + x );
            u(2).data()[p] = *( _frame_conv[opt]->data[2] + _frame_conv[opt]->linesize[2] * y + x );
        }
    }
    yuv = convert<T>(u);

    // mark frame as read
    _frame_already_read = false;

    // Increase the number for next frame
    //this->skip_frames(_skip);
}

template<typename T>
void ReadSequenceFfmpeg::operator>>( ImageYUV420<T>& yuv )
{

    uint64 opt = 3;

    // read / decode / convert input frame
    convert_frame(opt);

    // Copy data from _frame_conv[] to imageplus format
    ImageYUV420<uint8> u(_codec_ctx->width,_codec_ctx->height);

    // copy data
    for (uint64 p = 0, y = 0; y < (uint64)_codec_ctx->height; y++)
    {
        for (uint64 x = 0; x < (uint64)_codec_ctx->width; x++, p++)
        {
            u(0).data()[p] = *( _frame_conv[opt]->data[0] + _frame_conv[opt]->linesize[0] * y + x );
        }
    }
    for (uint64 p = 0, y = 0; y < (uint64)_codec_ctx->height/2; y++)
    {
        for (uint64 x = 0; x < (uint64)_codec_ctx->width/2; x++, p++)
        {
            u(1).data()[p] = *( _frame_conv[opt]->data[1] + _frame_conv[opt]->linesize[1] * y + x );
            u(2).data()[p] = *( _frame_conv[opt]->data[2] + _frame_conv[opt]->linesize[2] * y + x );
        }
    }
    yuv = convert<T>(u);

    // mark frame as read
    _frame_already_read = false;

    // Increase the number for next frame
    //this->skip_frames(_skip);
}


bool ReadSequenceFfmpeg::eof()
{
    // There is no information of final number of frames
    // try to read one frame and if not possible then mark eof
    if (_frame_already_read == false)
    {
        // try to read one frame, if not posible then return false
        try 
        {
            this->read_next_frame();
        }
        catch (std::exception &e)
        {
            TRACE("exception catched in ReadSequenceFfmpeg::eof()")
            return true;
        }
    }

    // all other cases we're not at the end of the file
    return false;
}

#if 1
void ReadSequenceFfmpeg::skip_frames(uint64 skip)  throw (ImagePlusError)
{
    int32 frame_finished = 0;
    AVPacket packet;
    
    for (uint64 ii=0; ii < skip; ++ii)
    {
        std::cout << ii << std::endl;
        while ( frame_finished == 0 ) 
        {
            // Read a packet and check if it comes from the video stream?
            if ( av_read_frame(_format_ctx, &packet) >= 0 )
            {
                if (packet.stream_index == _video_stream ) 
                {
                    // Not sure if decoding can be skipped !!  
                    //frame_finished = 1;

                    // Decode video frame
#if NEW_FFMPEG_INTERFACE
                    avcodec_decode_video2(_codec_ctx, 
                                          _frame, 
                                          &frame_finished,
                                          &packet); 
#else
                    avcodec_decode_video(_codec_ctx, 
                                         _frame, 
                                         &frame_finished,
                                         packet.data, 
                                         packet.size);
#endif
                }

                // Free the packet that was allocated by av_read_frame
                av_free_packet(&packet);
            }
            else 
            {
                throw ImagePlusFileError(_filename,"Video is finished, no more packets");
            }

        }
    }

    _frame_already_read = false;

    _framecont += skip;
}

#endif

void ReadSequenceFfmpeg::read_next_frame() throw (ImagePlusError)
{
    
    int32 frame_finished = 0;
    AVPacket packet;
    
    while ( frame_finished == 0 ) 
    {
        if ( av_read_frame(_format_ctx, &packet) >= 0 ) 
        {
    
            // Is this a packet from the video stream?
            if( packet.stream_index == _video_stream ) 
            {
                // Deprecated: use avcodec_decode_video2()
                // Decode video frame 

#if NEW_FFMPEG_INTERFACE
                avcodec_decode_video2(_codec_ctx, 
                                      _frame, 
                                      &frame_finished,
                                      &packet); 
#else
                avcodec_decode_video(_codec_ctx, 
                                     _frame, 
                                     &frame_finished,
                                     packet.data, 
                                     packet.size);
#endif
            }
            
            // Free the packet that was allocated by av_read_frame
            av_free_packet(&packet);
        }
        else 
        {
            std::cout << "throwing exception in read_next_frame" << std::endl;
            throw ImagePlusFileError(_filename,"Video is finished, no more packets");
        }
        
    }
    
    _frame_already_read = true;
    
    // JRMR - 18/02/2012
    _framecont++;

}

void ReadSequenceFfmpeg::convert_frame(uint64 opt)
{

    // make sure frame is read from disk
    if ( _frame_already_read == false)
    {
        read_next_frame();
    }
    
    // convert frame format
    sws_scale(_img_convert_ctx[opt], 
              _frame->data, 
              _frame->linesize, 
              0, 
              _codec_ctx->height, 
              _frame_conv[opt]->data, 
              _frame_conv[opt]->linesize);

}

template void imageplus::io::ReadSequenceFfmpeg::operator>><uint8>(ImageGray<uint8>&);
template void imageplus::io::ReadSequenceFfmpeg::operator>><int64>(ImageGray<int64>&);
template void imageplus::io::ReadSequenceFfmpeg::operator>><float64>(ImageGray<float64>&);

template void imageplus::io::ReadSequenceFfmpeg::operator>><uint8>(ImageRGB<uint8>&);
template void imageplus::io::ReadSequenceFfmpeg::operator>><int64>(ImageRGB<int64>&);
template void imageplus::io::ReadSequenceFfmpeg::operator>><float64>(ImageRGB<float64>&);

template void imageplus::io::ReadSequenceFfmpeg::operator>><uint8>(ImageYUV<uint8>&);
template void imageplus::io::ReadSequenceFfmpeg::operator>><int64>(ImageYUV<int64>&);
template void imageplus::io::ReadSequenceFfmpeg::operator>><float64>(ImageYUV<float64>&);
        
template void imageplus::io::ReadSequenceFfmpeg::operator>><uint8>(ImageYUV420<uint8>&);
template void imageplus::io::ReadSequenceFfmpeg::operator>><int64>(ImageYUV420<int64>&);
template void imageplus::io::ReadSequenceFfmpeg::operator>><float64>(ImageYUV420<float64>&);

#endif
