// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------

//!
//!  \file region_links.hpp
//!

#ifndef IMAGEPLUS_CORE_REGION_LINKS_HPP
#define IMAGEPLUS_CORE_REGION_LINKS_HPP

#include <list>
#include <vector>
#include <algorithm>

#include <imageplus/core/config.hpp>
#include <imageplus/core/imageplus_types.hpp>
#include <imageplus/core/b_search_tree.hpp>   

#include <cmath>

namespace imageplus
{
	/*! 
	 * \cond SKIP_DOC 
	 */
    template<class RegionModel>
    class neighbor_base_link
    {
        public:
            typedef RegionModel RegionType;
            typedef RegionType* RegionPointer;
            
            neighbor_base_link()
               : _neighbor1(), _neighbor2()
            {
                
            };
               
            neighbor_base_link(RegionPointer neighbor1, RegionPointer neighbor2)
               : _neighbor1(neighbor1), _neighbor2(neighbor2)
            {
            };
               
            RegionPointer neighbor1() const
            {
                return _neighbor1;
            }
            
            RegionPointer neighbor2() const
            {
                return _neighbor2;
            }
            
            template<class PartitionModel>
            void update_traits(PartitionModel& curr_part)
            {
                if(_neighbor1!=0)
                {
                    _neighbor1 = &(curr_part[_neighbor1->label()]);
                }
                if(_neighbor2!=0)
                {
                    _neighbor2 = &(curr_part[_neighbor2->label()]);
                }
            }
            
            IMAGEPLUS_INLINE
            void add_neighbor_coord(typename RegionModel::CoordType new_coord)
            {
            }
       
            IMAGEPLUS_INLINE
            void add_neighbor_coord(std::list<typename RegionModel::CoordType>& new_coord)
            {
            }
            
            
            IMAGEPLUS_INLINE
            const std::list<typename RegionModel::CoordType>& neighbor_coords() const
            {
                return _neighb_coords;
            }
            
            IMAGEPLUS_INLINE
            std::list<typename RegionModel::CoordType>& neighbor_coords()
            {
                return _neighb_coords;
            }
               
        protected:
            RegionPointer _neighbor1;
            RegionPointer _neighbor2;
            
            template<class RM>
            friend class Partition;
            
            std::list<typename RegionModel::CoordType> _neighb_coords;
    };
    
    
    
    template<class RegionModel, class Derived>
    class neighbor_base_order_link : public neighbor_base_link<RegionModel>,
                                     public bst_base_node<Derived>
    {
    public:
        typedef RegionModel RegionType;
//        typedef neighbor_order_link<RegionModel> Derived;
        typedef RegionType* RegionPointer;
           
        neighbor_base_order_link()
          : neighbor_base_link<RegionModel>(NULL,NULL), _order(-1)
        {
        };
              
        neighbor_base_order_link(RegionPointer neighbor1, RegionPointer neighbor2, float32 order = -1)
          : neighbor_base_link<RegionModel>(neighbor1,neighbor2), _order(order)
        {
        };
              
        neighbor_base_order_link(RegionPointer neighbor1, RegionPointer neighbor2, Derived* neigh_data)
          : neighbor_base_link<RegionModel>(neighbor1,neighbor2), _order(-1)
        {
        };
           
        neighbor_base_order_link(RegionPointer neighbor1, RegionPointer neighbor2, typename RegionModel::CoordType first_coord)
          : neighbor_base_link<RegionModel>(neighbor1,neighbor2), _order(-1)
        {
        };

           
        //! Functions to compare the nodes of the AVL tree
        struct compare_functor
        {
            //! This funtion defines the order of the nodes. 
            //! If "order" is the same, then the order is set depending on the vertex indices.
            //! \param[in] *a : Pointer to a node to be compared
            //! \param[in] *b : Pointer the other node to be compared
            bool operator()(Derived* a, Derived* b)
            {  
                return a->_order <= b->_order;
            }
        };
           
        float32 order() const
        {
            return _order;
        }
           
        void order(float32 new_order)
        {
            _order = new_order;
        }
           
    protected:
        float32 _order;
              
        template<class container,class compare_function>
        friend class BST;
        
        template<class RM>
        friend class Partition;
    };
    
    
    
    template<class RegionModel>
    class neighbor_order_link : public neighbor_base_order_link<RegionModel, neighbor_order_link<RegionModel> >
    {
    public:
        typedef RegionModel RegionType;
        typedef neighbor_base_order_link<RegionModel, neighbor_order_link<RegionModel> > BaseClass;
        typedef RegionType* RegionPointer;
        
        
        neighbor_order_link()
          : BaseClass()
        {
        };
           
        neighbor_order_link(RegionPointer neighbor1, RegionPointer neighbor2, float32 order = -1)
           : BaseClass(neighbor1,neighbor2,order)
        {
        };
           
        neighbor_order_link(RegionPointer neighbor1, RegionPointer neighbor2, neighbor_order_link* neigh_data)
           : BaseClass(neighbor1,neighbor2,neigh_data)
        {
        };
        
        neighbor_order_link(RegionPointer neighbor1, RegionPointer neighbor2, typename RegionModel::CoordType first_coord)
           : BaseClass(neighbor1,neighbor2,first_coord)
        {
        };
        
    };
    
    
    
    
    template<class RegionModel>
    class neighbor_contour_link : public neighbor_base_link<RegionModel>
    {
    public:
        typedef RegionModel RegionType;
        typedef RegionType* RegionPointer;
        typedef std::list<typename RegionModel::CoordType> contour_container;
        
        neighbor_contour_link() : neighbor_base_link<RegionModel>()
        {
            
        };
           
        neighbor_contour_link(RegionPointer neighbor1, RegionPointer neighbor2, typename RegionModel::CoordType first_coord)
           : neighbor_base_link<RegionModel>(neighbor1,neighbor2), _neighbor_coords(1,first_coord)
        {
        };
           
        neighbor_contour_link(RegionPointer neighbor1, RegionPointer neighbor2, neighbor_contour_link* neigh_data)
           : neighbor_base_link<RegionModel>(neighbor1,neighbor2), _neighbor_coords()
        {
            add_neighbor_coord(neigh_data->_neighbor_coords);
        };
        
        void add_neighbor_coord(typename RegionModel::CoordType new_coord)
        {
            _neighbor_coords.push_back(new_coord);
        }
        
        void add_neighbor_coord(contour_container& new_coord)
        {
            _neighbor_coords.splice(_neighbor_coords.end(), new_coord);
        }

    public: 
        const contour_container& neighbor_coords() const
        {
            return _neighbor_coords;
        }
        
        contour_container& neighbor_coords()
        {
            return _neighbor_coords;
        }
        
    protected:
        contour_container _neighbor_coords;
    };
    

    template<class RegionModel>
    class neighbor_contour_order_link : public neighbor_base_order_link<RegionModel, neighbor_contour_order_link<RegionModel> >
    {
    public:
        typedef RegionModel RegionType;
        typedef RegionType* RegionPointer;
        typedef std::list<typename RegionModel::CoordType> contour_container;
        


        neighbor_contour_order_link() 
          : neighbor_base_order_link<RegionModel, neighbor_contour_order_link<RegionModel> >()
        {
        };
           
        neighbor_contour_order_link(RegionPointer neighbor1, RegionPointer neighbor2, typename RegionModel::CoordType first_coord)
           : neighbor_base_order_link<RegionModel, neighbor_contour_order_link<RegionModel> >(neighbor1,neighbor2),
            _neighbor_coords(1,first_coord)
        {
        };
           
        neighbor_contour_order_link(RegionPointer neighbor1, RegionPointer neighbor2, neighbor_contour_order_link* neigh_data)
           : neighbor_base_order_link<RegionModel, neighbor_contour_order_link<RegionModel> >(neighbor1,neighbor2),
            _neighbor_coords()
        {
            add_neighbor_coord(neigh_data->_neighbor_coords);
        };
        
        ~neighbor_contour_order_link() {
        }

        void add_neighbor_coord(typename RegionModel::CoordType new_coord)
        {
            _neighbor_coords.push_back(new_coord);
        }
        
        void add_neighbor_coord(contour_container& new_coord)
        {
            _neighbor_coords.splice(_neighbor_coords.end(), new_coord);
        }
        
        void neighbors_change(RegionPointer neighbor1, RegionPointer neighbor2) 
        {
            this->_neighbor1 = neighbor1;
            this->_neighbor2 = neighbor2;
        };

    public: 
        const contour_container& neighbor_coords() const
        {
            return _neighbor_coords;
        }
        
        contour_container& neighbor_coords()
        {
            return _neighbor_coords;
        }
        
    protected:
        contour_container _neighbor_coords;
    };

    template<class RegionModel, class LinkDataType>
    class neighbor_ordered_contour_link : public neighbor_base_order_link<RegionModel, neighbor_ordered_contour_link<RegionModel, LinkDataType> >
    {
    public:
    	typedef RegionModel RegionType;
    	typedef RegionType* RegionPointer;
    	typedef std::deque<typename RegionModel::CoordType> ContourType;
    	typedef std::deque<ContourType> AllContours;
    	typedef std::pair<typename AllContours::iterator,uint32> PT;

    	neighbor_ordered_contour_link()
    	: neighbor_base_order_link<RegionModel, neighbor_ordered_contour_link<RegionModel, LinkDataType> >()
    	  {

    	  };

    	neighbor_ordered_contour_link(RegionPointer neighbor1, RegionPointer neighbor2, typename RegionModel::CoordType first_coord)
    	: neighbor_base_order_link<RegionModel, neighbor_ordered_contour_link<RegionModel, LinkDataType> >(neighbor1,neighbor2),
    	  _neighbor_coords()
    	  {
    		add_neighbor_coord(first_coord);
    	  };

    	neighbor_ordered_contour_link(RegionPointer neighbor1, RegionPointer neighbor2, neighbor_ordered_contour_link* neigh_data)
    	: neighbor_base_order_link<RegionModel, neighbor_ordered_contour_link<RegionModel, LinkDataType> >(neighbor1,neighbor2),
    	  _neighbor_coords()
    	  {
    		add_neighbor_coord(neigh_data->_neighbor_coords);
    	  };

    	bool is_contact_point(typename RegionModel::CoordType a, typename RegionModel::CoordType b) {
    		int32 ax = a[0];
    		int32 ay = a[1];
    		int32 bx = b[0];
    		int32 by = b[1];
    		//float64 eps = 1e-3;
    		  
    		if (std::abs(by-ay)==1 && std::abs(bx-ax) == 1) return true; // this is a corner

    		if (ax % 2 == 1) { // check for horizontal contact points
    			if (std::abs(bx-ax) == 2 && by == ay) return true;
    			return false;
    		}
    		else { // check for vertical contact points
    			if (std::abs(by-ay) == 2 && bx == ax) return true;
    			return false;
    		}
    		return false;
		}

    	//fusionate the lists a and b from _neighbor_coords in sorted order
    	void fusion_lists(std::vector<PT> n) {
    		typename AllContours::iterator a = n[0].first; // list to be fusioned
    		typename AllContours::iterator b = n[1].first; // list to be fusioned

    		if (n[1].second == 0) {
    			typename ContourType::iterator it = b->begin();
    			typename ContourType::iterator end = b->end();
    			if (n[0].second == 0) {
    				// join the lists
    				for (; it != end; it++) {
    					a->push_front(*it);
    				}
    			}
    			if (n[0].second == 1) {
    				// join the lists
    				for (; it != end; it++) {
    					a->push_back(*it);
    				}
    			}
    		}

    		if (n[1].second == 1) {
    			typename ContourType::reverse_iterator it = b->rbegin();
    			typename ContourType::reverse_iterator end = b->rend();
    			if (n[0].second == 0) {
    				// join the lists
    				for (; it != end; it++) {
    					a->push_front(*it);
    				}
    			}
    			if (n[0].second == 1) {
    				// join the lists
    				for (; it != end; it++) {
    					a->push_back(*it);
    				}
    			}
    		}
			// Delete the joined list
			_neighbor_coords.erase(b);
    	}

    	void add_neighbor_coord(typename RegionModel::CoordType new_coord)
    	{
    		// Try to insert the contours sorted (as a curve)

    		//std::cout << "(" << (int)new_coord[0] << "," << (int)new_coord[1] << ") - ";

    		std::vector<PT> n;
    		for (typename AllContours::iterator i = _neighbor_coords.begin(); i != _neighbor_coords.end(); i++) {
    			typename RegionModel::CoordType first = i->front();
    			typename RegionModel::CoordType last = i->back();
    			//std::cout << "TEST " << new_coord[0] << "," << new_coord[1] << " " << first[0] << "," << first[1] << std::endl;
    			//std::cout << "TEST " << new_coord[0] << "," << new_coord[1] << " " << last[0] << "," << last[1] << std::endl;
    			if (is_contact_point(new_coord, first)) {
    				//std::cout << "YES " << new_coord[0] << "," << new_coord[1] << " " << first[0] << "," << first[1] << std::endl;
    				n.push_back(PT(i,0)); // we now that the first position in the curve i is a neighbor
    				continue;
    			}
    			if (is_contact_point(new_coord, last)) {
    				//std::cout << "YES " << new_coord[0] << "," << new_coord[1] << " " << last[0] << "," << last[1] << std::endl;
    				n.push_back(PT(i,1)); // we now that the last position in the curve i is a neighbor
    				continue;
    			}
    		}
    		
    		//std::cout << "Adding (" << new_coord[0] << "," << new_coord[1] <<  ") -- " << n.size()  << std::endl;

    		if (n.size() == 0) { // it is an isolated point
    			ContourType ct; ct.push_back(new_coord);
    			_neighbor_coords.push_back(ct);
    		}
    		if (n.size() > 0) { // The added point is a neighbor of an end of a curve
    			if (n[0].second == 0) {
    				n[0].first->push_front(new_coord);
    			} else {
    				n[0].first->push_back(new_coord);
    			}
    		}
    		if (n.size() == 2) { // we have to concatenate the lists
    			fusion_lists(n);
    		}
    	}

    	void add_neighbor_coord(ContourType& new_coord)
    	{
    		// Mirar amb quina llista es concatena

    		typename RegionModel::CoordType first = new_coord.front();
    		typename RegionModel::CoordType last = new_coord.back();

    		//put the new list onto the vector for possible fusions
    		_neighbor_coords.push_back(new_coord);
    		if (_neighbor_coords.size() == 1) return;
    		typename AllContours::iterator added = (--_neighbor_coords.end());

    		std::vector<PT> n_first;
    		std::vector<PT> n_last;

    		// Search for neighbors of the first element
    		for (typename AllContours::iterator i = _neighbor_coords.begin(); i != added; i++) {
    			typename RegionModel::CoordType f = i->front();
    			typename RegionModel::CoordType l = i->back();
    			if (is_contact_point(f, first)) {
    				n_first.push_back(PT(i,0)); // we now that the first position in the curve i is a neighbor
    				n_first.push_back(PT(added,0));
    				continue;
    			}
    			if (is_contact_point(l, first)) {
    				n_first.push_back(PT(i,1)); // we now that the last position in the curve i is a neighbor
    				n_first.push_back(PT(added,0));
    				continue;
    			}
    		}

    		// Search for neighbors of the last element
    		for (typename AllContours::iterator i = _neighbor_coords.begin(); i != added; i++) {
    			typename RegionModel::CoordType f = i->front();
    			typename RegionModel::CoordType l = i->back();
    			if (is_contact_point(f, last)) {
    				n_last.push_back(PT(i,0)); // we now that the first position in the curve i is a neighbor
    				n_last.push_back(PT(added,1));
    				continue;
    			}
    			if (is_contact_point(l,last)) {
    				n_last.push_back(PT(i,1)); // we now that the last position in the curve i is a neighbor
    				n_last.push_back(PT(added,1));
    				continue;
    			}
    		}

    		if (n_first.size() == 0 && n_last.size() == 0); // do nothing, the new list is already inserted as independent
    		if (n_first.size() != 0 && n_last.size() == 0) {
    			fusion_lists(n_first); // join the neighbor lists
    		}
    		if (n_first.size() == 0 && n_last.size() != 0) {
    			fusion_lists(n_last);
    		}
    		if (n_first.size() != 0 && n_last.size() != 0) {
    			fusion_lists(n_first); // we will erase the last added lists
    			n_last[1].first = n_first[0].first; // the new list to be added is the one joined in the line above
    			n_last[1].second = n_first[0].second; // if we add the new list in front of another, then the second one will also be on front and vicerversa
    			if (n_last[1].first != n_last[0].first) // check that we are not fusioning the same contour
    				fusion_lists(n_last);
    		}
    	}

    	void add_neighbor_coord(AllContours& new_coord) {
    		for (typename AllContours::iterator i = new_coord.begin(); i != new_coord.end(); i++){
    			add_neighbor_coord(*i);
    		}
    	}

    	void add_link_data(typename LinkDataType::ElementType &element) {
    		_data.insert(element);
    	}

    public:
    	const LinkDataType& data() const {
    		return _data;
    	}

    	LinkDataType& data() {
    		return _data;
    	}

    	const AllContours& neighbor_coords() const
    	{
    		return _neighbor_coords;
    	}

    	AllContours& neighbor_coords() {
    		return _neighbor_coords;
    	}

    protected:
    	AllContours _neighbor_coords;
    	LinkDataType _data;
    };
    /*! 
	 * \endcond SKIP_DOC 
	 */
}

#endif

