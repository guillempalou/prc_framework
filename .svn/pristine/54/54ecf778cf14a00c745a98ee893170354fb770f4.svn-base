/*
 * tjunctions.hpp
 *
 *  Created on: Feb 29, 2012
 *      Author: guillem
 */

#ifndef TJUNCTIONS_HPP_
#define TJUNCTIONS_HPP_

#include <set>
#include <vector>

#include <imageplus/core/imageplus_types.hpp>
#include <imageplus/core/coord2d.hpp>

#include <imageplus/math/optimization/emd.hpp>
#include <imageplus/math/sampling/interpolation.hpp>
#include <imageplus/math/statistics/k_means.hpp>
#include <imageplus/math/statistics/signature.hpp>

#include <imageplus/descriptors/geometry/area.hpp>

namespace imageplus {
	namespace descriptors {


	//! Tjunction structure
	struct TJunction {

		//! Struct of the Angle Confidence
		struct AngleConfidenceStruct {
			//! Id of the region forming the largest angle
			uint64 largest;
			//! The three region angles
			float64 angle1,angle2,angle3;
			//! Angle of each of the three boudnaries (0...2PI)
			float64 angle_pos1, angle_pos2, angle_pos3;
			//! Angle confidence
			float64 conf;
		};

		//! Struct of the Color Confidence
		struct ColorConfidenceStruct {
			//! Color confidence
			float64 conf;
			//! Number of pixels of each region inside the local window
			uint64 n1,n2,n3;
			//! Ids of the three regions
			uint64 id1,id2,id3;
		};

		//! Type for the Curvature Confidence
		typedef float64 CurvatureConfidenceType;

		//! True if the T-junction is inverted
		bool inverted;
		//! Id of the T-junctions
		uint32 id;
		//! Coordinates in the image
		Coord2D<> coords;

		//! Regions forming it
		std::set<uint64> regions;

		//! Color structure
		ColorConfidenceStruct 	color;

		//! Angle structure
		AngleConfidenceStruct 	angle;

		//! Curvature structure
		CurvatureConfidenceType curvature;

		//! confidence function
		//! \return confidence value 0-1
		float64 confidence() {return color.conf*angle.conf*curvature; }

		//! Cost
		//! \return the same as confidence
		float64 cost() {return confidence(); } //*std::min(color.n1,std::min(color.n2,color.n3));}

		//! Operator to compare two junctions
		//! \return boolean depending on the junctions ids
		bool operator<(const TJunction& a) const {
			if (id < a.id) return true;
			return false;
		}

		//! Operator to compare two junctions
		//! \return boolean depending on the junctions ids
		bool operator>(const TJunction& a) const {
			if (id > a.id) return true;
			return false;
		}
	};

	//! Operator overload to allow reading/writing of T-junction structure
	//! \param[in] is : stream
	//! \param[in] tj : tjunction to write
	//! \return Stream
	inline std::ostream& operator<<(std::ostream& os, const TJunction& tj) {
		std::vector<uint64> reg;

		for (std::set<uint64>::iterator r = tj.regions.begin(); r != tj.regions.end(); r++) {
			reg.push_back(*r);
		}

		os << tj.id << " " << tj.coords.x() << " " << tj.coords.y() << " " << reg[0] << " " << reg[1] << " " << reg[2] << " " << tj.angle.largest << " ";
		os << tj.color.conf << " " << tj.angle.conf << " " << tj.curvature << " ";
		os << tj.angle.angle1 << " " << tj.angle.angle2 << " " << tj.angle.angle3 << " ";
		os << tj.angle.angle_pos1 << " " << tj.angle.angle_pos2 << " " << tj.angle.angle_pos3 << " ";
		return os;
	}

	//! Operator overload to allow reading/writing of T-junction structure
	//! \param[in] is : stream
	//! \param[in] tj : tjunction to read
	//! \return Stream
	inline std::istream& operator>>(std::istream& is, TJunction& tj) {
		uint32 reg1,reg2,reg3;
		float64 x, y;
		tj.regions.clear();

		is >> tj.id >> x >> y >> reg1 >> reg2 >> reg3 >> tj.angle.largest ;
		is >> tj.color.conf >> tj.angle.conf >> tj.curvature;
		is >> tj.angle.angle1 >> tj.angle.angle2 >> tj.angle.angle3;
		is >> tj.angle.angle_pos1 >> tj.angle.angle_pos2 >> tj.angle.angle_pos3;
		tj.coords[0] = x;
		tj.coords[1] = y;
		tj.regions.insert(reg1);
		tj.regions.insert(reg2);
		tj.regions.insert(reg3);
		return is;
	}

	//! Struct to detect junction parameters
	struct TJunctionDetectorParameters {

		//! Parameter list

		//! local window size
		int64 window_size;

		// For color

		//! minimum area inside the window
		float64 min_area_threshold;

		//! minimum area proportion of the regions forming the T-junction
		float64 min_area_proportion;

		//! Minimum number of points inside the window
		uint64 minimum_points;
		//! minimum area proportion of the points inside the window with respect unwanted pixels
		float64 outlier_coefficient;

		// For angle
		//! Angle forgetting factor for the contour
		float64 angle_lambda;
		//! Radius to neglect
		float64 internal_radius;
		//! Variance of the perceptual vision of the biggest angle
		float64 angle_big_sigma;
		//! Variance of the perceptual vision of the smallest angle
		float64 angle_small_sigma;

		// for curvature
		//! Margin for the window (practical values)
		int64 margin;
		//! Variance for the curvture confidence
		float64 curvature_sigma;

		//!Default constructor with parameter values
		TJunctionDetectorParameters() : window_size(10), 																									// general
										min_area_threshold(50), min_area_proportion(0.01), minimum_points(20), outlier_coefficient(0.5), 					// color
										angle_lambda(0.9), internal_radius(3), angle_big_sigma((M_PI/6)*(M_PI/6)), angle_small_sigma((M_PI/6)*(M_PI/6)), 	//angle
										margin(2), curvature_sigma(0.5)																						//curvature
		{

		}

	};


	//!
	//! \brief T-junction Detector between two regions inside a BPT
	//!
	//! \author Guillem Palou <guillem.palou@upc.edu>
	//!
	//! \date 10-05-2012
	template<class BPT, class ImageModel>
	class TJunctionDetector {

		//! Color confidence type
		typedef TJunction::ColorConfidenceStruct 	ColorConfidence;

		//! Angle confidence type
		typedef TJunction::AngleConfidenceStruct 	AngleConfidence;

		//! curvature confidence type
		typedef TJunction::CurvatureConfidenceType 	CurvatureConfidence;

		//! Region type
		typedef typename BPT::RegionType RegionType;

		// Types of contours used in the model

		//! Contour of two regions
		typedef typename RegionType::coords_container ContourType;

		//! Contours of all regions
		typedef typename RegionType::contour_container AllContours;

		//! Coordinate types
		typedef typename RegionType::CoordType CoordType;

	public:

		//! Default empty constructor
		TJunctionDetector() {

		}

		//!Default constructor with parameters
		TJunctionDetector(TJunctionDetectorParameters& pars) : _pars(pars) {

		}

		//! Main function. Detects common T-junction between two regions and third ones
		//! \param[in] bpt : BPT
		//! \param[in] image: image where the junctions should appear
		//! \param[in] reg1 : region
		//! \param[in] reg2 : region
		//! \return Vector of the detected T-junctions
		std::vector<TJunction>& detect_tjunctions(BPT& bpt, ImageModel& image, RegionType& reg1, RegionType& reg2) {

			tjunctions.resize(0);

			if (reg1.label() == 0) return tjunctions;
			if (reg2.label() == 0) return tjunctions;

			typename RegionType::neighbor_iterator n = reg1.neighbors_find(&reg2); // to get the edges
			AllContours& edges12 = n.link_data()->neighbor_coords();

			typename RegionType::neighbor_iterator n3 = reg1.neighbors_begin();
			typename RegionType::neighbor_iterator n33 = reg2.neighbors_begin();

			typename RegionType::neighbor_iterator end3 = reg1.neighbors_end();
			typename RegionType::neighbor_iterator end33 = reg2.neighbors_end();

			// search for common neighbors
			while (n3 != end3 && n33 != end33) {
				if (*n3 == 0) {++n3; continue;} // we don't want the outer border
				if (*n33 == 0) {++n33; continue;} // we don't want the outer border

				if ((*n3)->label() == 0) {++n3; continue;} // we don't want the outer border
				if ((*n33)->label() == 0) {++n33; continue;} // we don't want the outer border

				if (*n33 < *n3 || (*n33)->label() == reg2.label()) ++n33; else
					if (*n3 < *n33 || (*n3)->label() == reg1.label()) ++n3; else {

						//We have a common neighbor - find all T-junctions

						// find T-junctions
						AllContours& edges13 = n3.link_data()->neighbor_coords();
						AllContours& edges23 = n33.link_data()->neighbor_coords();

						// variables that indicates if the contact point is at the front (0) or at the back (1) of the stored edge list
						CoordType cp12,cp13,cp23; // possible contact point
						bool contact = false;

						for (typename AllContours::iterator e12 = edges12.begin(); e12 != edges12.end(); e12++) {
							CoordType f12 = e12->front();
							CoordType l12 = e12->back();

							for (typename AllContours::iterator e13 = edges13.begin(); e13 != edges13.end(); e13++) {
								contact = false;
								CoordType f13 = e13->front();
								CoordType l13 = e13->back();

								for (typename AllContours::iterator e23 = edges23.begin(); e23 != edges23.end(); e23++) {
									CoordType f23 = e23->front();
									CoordType l23 = e23->back();
									CoordType tp; // tjunction point  {

									if (is_contact_point(f13,f12) && is_contact_point(f13,f23) && is_contact_point(f23,f12)) {
										tp = tjunction_point(f12,f13,f23);
										TJunction tj = get_tjunction_confidence(bpt,image,reg1,reg2,*(*n3),tp,*e12,*e13,*e23, 0,0,0);
										if (tj.confidence() > 0) tjunctions.push_back(tj);
									}
									if (is_contact_point(f13,f12) && is_contact_point(f13,l23) && is_contact_point(l23,f12)) {
										tp = tjunction_point(f12,f13,l23);
										TJunction tj = get_tjunction_confidence(bpt,image,reg1,reg2,*(*n3),tp,*e12,*e13,*e23, 0,0,1);
										if (tj.confidence() > 0) tjunctions.push_back(tj);
									}
									if (is_contact_point(l13,f12) && is_contact_point(l13,f23) && is_contact_point(f23,f12)) {
										tp = tjunction_point(f12,l13,f23);
										TJunction tj = get_tjunction_confidence(bpt,image,reg1,reg2,*(*n3),tp,*e12,*e13,*e23, 0,1,0);
										if (tj.confidence() > 0) tjunctions.push_back(tj);
									}
									if (is_contact_point(l13,f12) && is_contact_point(l13,l23) && is_contact_point(l23,f12)) {
										tp = tjunction_point(f12,l13,l23);
										TJunction tj = get_tjunction_confidence(bpt,image,reg1,reg2,*(*n3),tp,*e12,*e13,*e23, 0,1,1);
										if (tj.confidence() > 0) tjunctions.push_back(tj);
									}
									if (is_contact_point(f13,l12) && is_contact_point(f13,f23) && is_contact_point(f23,l12)) {
										tp = tjunction_point(l12,f13,f23);
										TJunction tj = get_tjunction_confidence(bpt,image,reg1,reg2,*(*n3),tp,*e12,*e13,*e23, 1,0,0);
										if (tj.confidence() > 0) tjunctions.push_back(tj);
									}
									if (is_contact_point(f13,l12) && is_contact_point(f13,l23) && is_contact_point(l23,l12)) {
										tp = tjunction_point(l12,f13,l23);
										TJunction tj = get_tjunction_confidence(bpt,image,reg1,reg2,*(*n3),tp,*e12,*e13,*e23, 1,0,1);
										if (tj.confidence() > 0) tjunctions.push_back(tj);
									}
									if (is_contact_point(l13,l12) && is_contact_point(l13,f23) && is_contact_point(f23,l12)) {
										tp = tjunction_point(l12,l13,f23);
										TJunction tj = get_tjunction_confidence(bpt,image,reg1,reg2,*(*n3),tp,*e12,*e13,*e23, 1,1,0);
										if (tj.confidence() > 0) tjunctions.push_back(tj);
									}
									if (is_contact_point(l13,l12) && is_contact_point(l13,l23) && is_contact_point(l23,l12)) {
										tp = tjunction_point(l12,l13,l23);
										TJunction tj = get_tjunction_confidence(bpt,image,reg1,reg2,*(*n3),tp,*e12,*e13,*e23, 1,1,1);
										if (tj.confidence() > 0) tjunctions.push_back(tj);
									}

								}
							}
						}

						////////////////////

						++n3;
						++n33;
					}
				// Search for t-junctions
			}

			return tjunctions;
		}

	private:

		//! \cond SKIP_DOC
		bool is_contact_point(CoordType a, CoordType b) {
			int32 ax = a[0];
			int32 ay = a[1];
			int32 bx = b[0];
			int32 by = b[1];
			//float64 eps = 1e-3;

			if (std::abs(by-ay)==1 && std::abs(bx-ax) == 1) return true; // this is a corner

			if (ax % 2 == 1) { // check for horizontal contact points
				if (std::abs(bx-ax) == 2 && by == ay) return true;
				return false;
			}
			else { // check for vertical contact points
				if (std::abs(by-ay) == 2 && bx == ax) return true;
				return false;
			}
			return false;
		}

		CoordType tjunction_point(CoordType c1, CoordType c2, CoordType c3) {
			CoordType p;
			if (c1[0] == c2[0]) {
				p[0] = c1[0];
				p[1] = c3[1];
			} else if (c1[0] == c3[0]) {
				p[0] = c1[0];
				p[1] = c2[1];
			} else if (c3[0] == c2[0]) {
				p[0] = c2[0];
				p[1] = c1[1];
			} else if (c1[1] == c2[1]) {
				p[1] = c1[1];
				p[0] = c3[0];
			} else if (c1[1] == c3[1]) {
				p[1] = c1[1];
				p[0] = c2[0];
			} else if (c3[1] == c2[1]) {
				p[1] = c2[1];
				p[0] = c1[0];
			}
			return p;
		}

		bool is_interior(const ImagePartition<>& partition, uint32 id1, uint32 id2, uint32 id3, uint32 x, uint32 y, uint32 sx, uint32 sy, uint32 nei) {
			bool pos = true;
			int dir[8][2] = {{-1,0},{1,0},{0,1},{0,-1},{-1,-1},{1,-1},{1,1},{-1,1}};

			if (partition[x][y] != id1 && partition[x][y] != id2 && partition[x][y] != id3) return false;
			for (uint32 j = 0; j < nei; j++) {
				int nx = (int)x + dir[j][0];
				int ny = (int)y + dir[j][1];
				if (nx > 0 && (uint32)nx < sx && ny > 0 && (uint32)ny < sy) {
					if (partition[nx][ny] != partition[x][y]) pos = false;
					if (partition[nx][ny] != partition[x][y]) pos = false;
					if (partition[nx][ny] != partition[x][y]) pos = false;
				}
			}
			return pos;
		}

		TJunction get_tjunction_confidence(BPT& bpt, ImageModel& image, RegionType& reg1, RegionType& reg2, RegionType& reg3, CoordType tp, ContourType &e12, ContourType &e13, ContourType &e23, uint32 c12, uint32 c13, uint32 c23) {

			TJunction lm;

			ColorConfidence 	lambda; lambda.conf = 0;
			CurvatureConfidence kappa =  0;
			AngleConfidence 	theta; theta.conf = 0;

			lambda = color_confidence(bpt, image, reg1,reg2,reg3,tp);
			if (lambda.conf > 1e-3)
			{
				theta = angle_confidence(reg1,reg2,reg3,tp,e12,e13,e23, c12, c13, c23);
				if (lambda.conf*theta.conf > 1e-6)
					kappa = curvature_confidence(bpt,reg1,reg2,reg3,tp,e12,e13,e23, c12, c13, c23);
				else theta.conf = 0;
			} else lambda.conf = 0;

			lm.angle = theta;
			lm.color = lambda;
			lm.curvature = kappa;
			lm.id = (_tjunction_id++);
			lm.regions.insert(reg1.label()); lm.regions.insert(reg2.label()); lm.regions.insert(reg3.label());
			lm.coords[0] = tp[0]; lm.coords[1] = tp[1];

			return lm;
		}

		ColorConfidence color_confidence(BPT& bpt, ImageModel &img, RegionType& reg1, RegionType& reg2, RegionType& reg3, CoordType &tp) {
			ColorConfidence cs;
			memset(&cs,0x0,sizeof(cs));

			cs.id1 = reg1.label();
			cs.id2 = reg2.label();
			cs.id3 = reg3.label();

			float64 area1 = calc_descriptor(new descriptors::Area(), img, reg1);
			float64 area2 = calc_descriptor(new descriptors::Area(), img, reg2);
			float64 area3 = calc_descriptor(new descriptors::Area(), img, reg3);

			float64 th = std::max(_pars.min_area_proportion*img.size_x()*img.size_y(),_pars.min_area_threshold);

			if (area1 < th || area2 < th || area3 < th) return cs;

			const ImagePartition<>& partition = bpt.roots_partition();

			float64 cp[2] = { 0.5 * tp[0]-0.5, 0.5 * tp[1]-0.5};
			int64 radius = _pars.window_size;
			int32 mnx = std::max((long long int)0,(int)cp[0]-radius);
			int32 mxx = std::min((long long int)img.size_x(), (int)cp[0]+radius+1);
			int32 mny = std::max((long long int)0,(int)cp[1]-radius);
			int32 mxy = std::min((long long int)img.size_y(), (int)cp[1]+radius+1);

			if (mxx == (int64) img.size_x()) return cs;
			if (mxy == (int64) img.size_y()) return cs;
			if (mnx == 0) return cs;
			if (mny == 0) return cs;

			bool valid = true;

			std::vector<math::Vector> points1,points2,points3;

			//std::cout << cp[0] << "," << cp[1] <<  " " << mnx << " " << mxx << " " << mny << " " << mxy << " - ";

			uint32 outliers = 0;
			for	(int32 i = mnx; i < mxx; i++) {
				for (int32 k = mny; k < mxy; k++) {
					if ((i-cp[0])*(i-cp[0]) + (k-cp[1])*(k-cp[1]) > radius*radius) continue;

					math::Vector v(3);
					for (uint32 l = 0; l < 3; l++) v(l) = img(l)[i][k];

					if (partition[i][k] == reg1.label()) {points1.push_back(v);} else
					if (partition[i][k] == reg2.label()) {points2.push_back(v);} else
					if (partition[i][k] == reg3.label()) {points3.push_back(v);} else outliers++;
				}
			}

			if (points1.size() < _pars.minimum_points || points2.size() < _pars.minimum_points || points3.size() < _pars.minimum_points) valid = false;
			if (outliers >= _pars.outlier_coefficient*std::min(points1.size(),std::min(points2.size(),points3.size()))) valid = false;

			//std::cout << points1.size() << " " << points2.size() << " " << points3.size() << " " << valid << std::endl;

			if (valid) {
				uint32 num_clusters = 3;
				math::statistics::KMeansParameters pars;
				math::statistics::KMeans<> kmeans(pars);

				math::statistics::Signature<> s1,s2,s3;

				kmeans.calculate(points1,num_clusters);
				s1.features = kmeans.centers();
				s1.weights = kmeans.weights();

				kmeans.calculate(points2,num_clusters);
				s2.features = kmeans.centers();
				s2.weights = kmeans.weights();

				kmeans.calculate(points3,num_clusters);
				s3.features = kmeans.centers();
				s3.weights = kmeans.weights();

				typedef math::statistics::PerceptualDistance<> DistanceType;
				DistanceType distance(3,1.0/(14.0*14.0));

				math::optimization::EMD<DistanceType> emd(distance);
				float64 d12 = emd.calculate(s1,s2);
				float64 d13 = emd.calculate(s1,s3);
				float64 d23 = emd.calculate(s2,s3);

				float64 dmax = std::max(std::max(d12,d13),d23);
				float64 dmin = std::min(std::min(d12,d13),d23);

				cs.n1 = points1.size();
				cs.n2 = points2.size();
				cs.n3 = points3.size();
				cs.conf = 2*dmax*dmin/(dmax+dmin);

				//std::cout << cp[0] << "," << cp[1] << " - " << cs.conf << std::endl;
			}
			return cs;
		}

		template <typename Iterator>
		float64 angle_of_edge(Iterator start, Iterator end, CoordType tp, uint32 edge_num) {
			float64 l = _pars.angle_lambda;
			float64 lacum = 0;
			float64 tx=0, ty=0;
			float64 dist = 0;
			Iterator p = start;
			Iterator p2;
			Iterator ap = start;
			float64 rx = (uint32)((*p)[0]*0.5-0.5);
			float64 ry = (uint32)((*p)[1]*0.5-0.5);

			p++;
			uint32 n = 0;
			float64 DD = _pars.window_size*_pars.window_size*2;
			float64 dd = _pars.internal_radius; // internal radius

			while (p!=end && l > 0.1 && dist < DD) {
				float64 ttx = ((float64)(*p)[0] - (float64)(*ap)[0]);
				float64 tty = ((float64)(*p)[1] - (float64)(*ap)[1]);

				float64 rrx = (uint32)((*p)[0]*0.5-0.5);
				float64 rry = (uint32)((*p)[1]*0.5-0.5);

				dist = (rx - rrx)*(rx -rrx) + (ry - rry)*(ry - rry);
				ap++;
				p++;
				if (std::sqrt(dist) < dd) continue;

				tx += l * ttx;
				ty += l * tty;
				lacum += l;
				n++;

				l*=_pars.angle_lambda;
			}

			if (tx + ty == 0) return -1;
			return (atan2(ty,tx) < 0) ? 2*M_PI + atan2(ty,tx) : atan2(ty,tx);
		}

		float64 angle_of_curve(ContourType e, CoordType tp, uint32 start_point, uint32 edge_num) {
			float64 angle;
			if (start_point == 0) {
				angle = angle_of_edge(e.begin(), e.end(), tp, edge_num);}
			else
				angle = angle_of_edge(e.rbegin(), e.rend(), tp, edge_num);
			return angle;
		}

		AngleConfidence angle_confidence(RegionType& reg1, RegionType& reg2, RegionType& reg3, CoordType tp, ContourType e12, ContourType e13, ContourType e23, uint32 c12, uint32 c13, uint32 c23) {
			// Angle Estimation
			AngleConfidence a;

			float64 angle1, angle2, angle3; // angles corresponding to each of the regions

			float64 v12 = angle_of_curve(e12, tp, c12,0);
			float64 v13 = angle_of_curve(e13, tp, c13,1);
			float64 v23 = angle_of_curve(e23, tp, c23,2);

			bool error = false;
			if (v12 < 0) error = true;
			if (v13 < 0) error = true;
			if (v23 < 0) error = true;

			angle1 = std::max(v12,v13) - std::min(v12,v13); if (v23 > std::min(v12,v13) && v23 < std::max(v12,v13)) angle1 = 2*M_PI - angle1;
			angle2 = std::max(v12,v23) - std::min(v12,v23); if (v13 > std::min(v12,v23) && v13 < std::max(v12,v23)) angle2 = 2*M_PI - angle2;
			angle3 = std::max(v13,v23) - std::min(v13,v23); if (v12 > std::min(v13,v23) && v12 < std::max(v13,v23)) angle3 = 2*M_PI - angle3;

			// Confidence
			std::pair<float64,uint32> p;

			float64 maxangle = std::max(std::max(angle1,angle2), angle3);
			float64 minangle = std::min(std::min(angle1,angle2), angle3);

			float64 arg1 = fabs(maxangle - M_PI);
			float64 arg2 = fabs(minangle - M_PI/2);

			//Normal distribution

			//Provar Rayleigh
			if (!error) {
				float64 pB = std::exp(-arg1/std::sqrt(_pars.angle_big_sigma));
				float64 pb = std::exp(-arg2/std::sqrt(_pars.angle_small_sigma));
				p.first = 2*pB*pb/(pB+pb);
			}

			//Which region seems at the top?
			if (angle1 > angle2 && angle1 > angle3) p.second = reg1.label();
			if (angle2 > angle1 && angle2 > angle3) p.second = reg2.label();
			if (angle3 > angle1 && angle3 > angle2) p.second = reg3.label();

			a.angle_pos1 = v12;
			a.angle_pos2 = v13;
			a.angle_pos3 = v23;
			a.angle1 = angle1;
			a.angle2 = angle2;
			a.angle3 = angle3;
			a.largest = p.second;

			if (p.second == 0) error = true;

			a.conf = (error) ? 0 : p.first;

			return a;
		}

		template<typename Iterator>
		float64 compute_curv(MultiArray<float64,2>& window, ContourType& e, Iterator begin, Iterator end, uint32 sx, uint32 sy, uint32 mxl, uint32 mxr, uint32 myt, uint32 myb, uint32 mnx, uint32 mny) {
			float64 curv = 0;
			uint32 n = 0;
			for (Iterator p = ++begin; p != end; p++) { // discard the T-junction point for curvature computation
				float64 x = (*p)[0]*0.5-0.5 - mnx;
				float64 y = (*p)[1]*0.5-0.5 - mny;

				if (x >= mxl && x <= sx-1-mxr && y >= myt && y <= sy-1-myb) {
					// Estimate the derivatives
					math::sampling::InterpolationType interpolation = math::sampling::LINEAR_INTERPOLATION;
					float64 ux = 0.5*(interpolate_value(window,x+0.5,y,interpolation) - interpolate_value(window,x-0.5,y,interpolation));
					float64 uy = 0.5*(interpolate_value(window,x,y+0.5,interpolation) - interpolate_value(window,x,y-0.5,interpolation));
					float64 uxx = 0.25*(interpolate_value(window,x-1,y,interpolation) + interpolate_value(window,x+1,y,interpolation)) - 0.5*interpolate_value(window,x,y,interpolation);
					float64 uyy = 0.25*(interpolate_value(window,x,y-1,interpolation) + interpolate_value(window,x,y+1,interpolation)) - 0.5*interpolate_value(window,x,y,interpolation);
					float64 uxy = 0.25*(interpolate_value(window,x-0.5,y-0.5,interpolation) + interpolate_value(window,x+0.5,y+0.5,interpolation) - interpolate_value(window,x-0.5,y+0.5,interpolation) - interpolate_value(window,x+0.5,y-0.5,interpolation));
					float64 f = uxx*uy*uy - 2*uxy*ux*uy + uyy *ux*ux;
					if (ux != 0 || uy != 0) f /= pow(ux*ux+uy*uy,1.5); else	f = 0;
					curv += fabs(f);
					n++;
				} else break;
			}
			if (n == 0) return 0;
			return curv/n;
		}

		template<typename Iterator>
		void mark_edge(MultiArray<float64,2>& window, ContourType& e, Iterator begin, Iterator end, uint32 sx, uint32 sy, uint32 mxl, uint32 mxr, uint32 myt, uint32 myb, uint32 mnx, uint32 mny, std::vector<std::pair<int64,int64> >& v1, std::vector<std::pair<int64,int64> >& v0) {

			typedef std::pair<uint64,int64> PI;

			for (Iterator p = begin; p != end; p++) {
				float64 x = (*p)[0]*0.5-0.5 - mnx;
				float64 y = (*p)[1]*0.5-0.5 - mny;
				uint32 xi = (int)x,yi = (int)y;

				if (x >= std::max(0,(int)(mxl-1)) && x <= sx-mxr && y >= std::max(0,(int)(myt-1)) && y <= sy-myb) {
					if ((int)x != x) {
						if (window[xi][yi] == 1) {if (xi+1 < window.dims(0)){window[xi+1][yi] = 0; v0.push_back(PI(xi+1,yi)); } v1.push_back(PI(xi,yi));  } else
						{window[xi][yi] = 0; if (yi+1 < window.dims(1)) v1.push_back(PI(xi+1,yi)); v0.push_back(PI(xi,yi)); }
					} else {
						if (window[xi][yi] == 1) {if (yi+1 < window.dims(1)) {window[xi][yi+1] = 0; v0.push_back(PI(xi,yi+1)); } v1.push_back(PI(xi,yi)); } else
						{window[xi][yi] = 0; if (yi+1 < window.dims(1)) v1.push_back(PI(xi,yi+1)); v0.push_back(PI(xi,yi)); }
					}
				} else break;
			}
		}

		void fill_holes(MultiArray<float64,2>& window, std::vector<std::pair<int64,int64> >& v1, std::vector<std::pair<int64,int64> >& v0) {

			int dir[4][2] = {{1,0}, {-1,0}, {0,1}, {0,-1}};

			for (uint32 i= 0; i < v1.size(); i++) {
				std::pair<uint64,int64> p = v1[i];
				for (uint32 k = 0; k < 4; k++) {
					uint32 nx = p.first  + dir[k][0];
					uint32 ny = p.second + dir[k][1];
					if (nx >= 0 && nx < window.dims(0) && ny >= 0 && ny < window.dims(1))
						if (window[nx][ny] == -1) window[nx][ny] = 1;
				}
			}
			for (uint32 i= 0; i < v0.size(); i++) {
				std::pair<uint64,int64> p = v0[i];
				for (uint32 k = 0; k < 4; k++) {
					uint32 nx = p.first  + dir[k][0];
					uint32 ny = p.second + dir[k][1];
					if (nx >= 0 && nx < window.dims(0) && ny >= 0 && ny < window.dims(1))
						if (window[nx][ny] == -1) window[nx][ny] = 0;
				}
			}

		}

		float64 mean_curvature(RegionType& region, CoordType& tp, ContourType& e1, ContourType& e2, uint32 cp1, uint32 cp2, BPT& bpt) {

			const ImagePartition<>& partition = bpt.roots_partition();

			uint32 ssx = partition.size_x();
			uint32 ssy = partition.size_y();

			float64 cp[2] = { 0.5 * tp[0] - 0.5, 0.5 * tp[1] - 0.5};
			uint32 mnx = std::max((long long int)0,(int)cp[0]-_pars.window_size-_pars.margin+1);
			uint32 mxx = std::min((long long int)ssx, (int)cp[0]+_pars.window_size+_pars.margin+1);
			uint32 mny = std::max((long long int)0,(int)cp[1]-_pars.window_size-_pars.margin+1);
			uint32 mxy = std::min((long long int)ssy, (int)cp[1]+_pars.window_size+_pars.margin+1);

			// Compute the _pars.margins inside the window (the window can be cropped in the borders)
			uint32 mxl = std::max((long long int)0,std::min(_pars.margin,(int)cp[0]-_pars.window_size-_pars.margin+1));
			uint32 mxr = std::max((long long int)0,std::min(_pars.margin,(int)ssx + _pars.margin - ((int)cp[0]+_pars.window_size+_pars.margin+1)));
			uint32 myt = std::max((long long int)0,std::min(_pars.margin,(int)cp[1]-_pars.window_size-_pars.margin+1));
			uint32 myb = std::max((long long int)0,std::min(_pars.margin,(int)ssy + _pars.margin - ((int)cp[1]+_pars.window_size+_pars.margin+1)));

			uint32 sx = mxx - mnx;
			uint32 sy = mxy - mny;

			MultiArray<float64,2> window(sx,sy);

			uint32 px=0,py=0;

			for (uint32 i = 0, x = mnx; i < sx; i++,x++) {
				for (uint32 k = 0, y = mny; k < sy; k++,y++) {
					if (partition[x][y] == region.label()) {window[i][k] = 1; px = i; py = k;} else window[i][k] = -1;
				}
			}

			std::vector<std::pair<int64,int64> > v1,v0;

			// Label correctly the points around the edge

			if (cp1 == 0) mark_edge(window, e1, e1.begin(), e1.end(), sx, sy, mxl, mxr, myt, myb, mnx, mny,v1,v0);
			else mark_edge(window, e1, e1.rbegin(), e1.rend(), sx, sy, mxl, mxr, myt, myb, mnx, mny,v1,v0);

			if (cp2 == 0) mark_edge(window,e2, e2.begin(), e2.end(), sx, sy, mxl, mxr, myt, myb, mnx, mny,v1,v0);
			else mark_edge(window,e2, e2.rbegin(), e2.rend(), sx, sy, mxl, mxr, myt, myb, mnx, mny,v1,v0);

			fill_holes(window,v1,v0);

			// Calculate the curvature for the edge points
			float64 curv = 0;
			if (cp1 == 0) curv += compute_curv(window,e1, e1.begin(), e1.end(), sx, sy, mxl, mxr, myt, myb, mnx, mny);
			else curv += compute_curv(window,e1, e1.rbegin(), e1.rend(), sx, sy, mxl, mxr, myt, myb, mnx, mny);

			if (cp2 == 0) curv += compute_curv(window,e2, e2.begin(), e2.end(), sx, sy, mxl, mxr, myt, myb, mnx, mny);
			else curv += compute_curv(window,e2, e2.rbegin(), e2.rend(), sx, sy, mxl, mxr, myt, myb, mnx, mny);
			return curv;
		}

		float64 curvature_confidence(BPT& bpt, RegionType& reg1, RegionType& reg2, RegionType& reg3, CoordType tp, ContourType &e12, ContourType &e13, ContourType &e23, uint32 c12, uint32 c13, uint32 c23) {
			float64 c1 = mean_curvature(reg1, tp, e12, e13, c12, c13, bpt);
			float64 c2 = mean_curvature(reg2, tp, e12, e23, c12, c23, bpt);
			float64 c3 = mean_curvature(reg3, tp, e23, e13, c23, c13, bpt);

			/*Log all data*/
			float64 mxc = std::max(c1,std::max(c2,c3));
			float64 mnc = std::min(c1,std::min(c2,c3));

			mxc = std::exp(-mxc*mxc / _pars.curvature_sigma);
			mnc = std::exp(-mnc*mnc / _pars.curvature_sigma);

			return 2*mxc*mnc / (mxc + mnc);
		}

	private:

		std::vector<TJunction> tjunctions;

		uint64 _tjunction_id;
		TJunctionDetectorParameters _pars;

	};
	//! \endcond SKIP_DOC

	}
}


#endif /* TJUNCTIONS_HPP_ */
