// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------

//
// - NAME of your tool
//   - This is mandatory
//   - Avoid the character '-', use always '_' 
// - GROUP where your tool belong (tools/GROUP directory)
//   - This is optional
//   - Comment the second definition to not group your tool
//
#define IMAGEPLUS_TOOL_CONFIG_NAME  bpt_creation
#define IMAGEPLUS_TOOL_CONFIG_GROUP bpt

//
// Include tool_config.hpp header 
//
// Note that it is mandatory to FIRST define the name (and group)
// of your tool, and LATER on include this header.
//
#include <imageplus/toolbox/tool_config.hpp>


//
// ImagePlus headers
//
#include <imageplus/bpt/creation.hpp>
#include <imageplus/bpt/analysis/merging_orders.hpp>
#include <imageplus/io/readimage.hpp>
#include <imageplus/io/writeimage.hpp>
#include <imageplus/io/readwritepartition.hpp>
#include <imageplus/math/numeric/interpolation.hpp>
#include <imageplus/segmentation/label_flatzone.hpp>
#include <imageplus/core/imagecielab.hpp>
#include <imageplus/core/convert_colorspace.hpp>

//#include <imageplus/descriptors/geometry/.hpp>

#include <boost/filesystem.hpp>


//
// Namespaces
//
using namespace std;
using namespace imageplus;
using namespace bpt;
using namespace segmentation;



IMAGEPLUS_TOOL_CONFIG_BRIEF()
    
    "An example of how to develop your BPT.\n";

IMAGEPLUS_TOOL_CONFIG_DESCRIPTION()

    "This tool allows the user to create a BPT from an image. It computes an initial partition (accuracy partition) " +
    "with N_partition regions using the WEDM criterion. Then calculates the search partition using the AMC criterion. " +
    "The tree is then calculated from the search partition to the whole image using the NWMC criterion. " +
    "(See Vilaplana et al. 'Binary Partition Trees for Object Detection', IEEE Trans. on Image Processing 17(11). Nov 2008. for further details)\n\n";


IMAGEPLUS_TOOL_CONFIG_PARAMETERS()

    // Your Options:
    int32 N_partition;
    string search_part;
    
    string bpt_extension;

    int32 N_regions_accuracy;
    string acc_part;

    float64 contour_alpha;
    float64 outscale_alpha;
    
    int32 num_regions_partition_means;
    
    string thumbnail_dir;
    uint64 thumbnail_width;
    uint64 thumbnail_height;
    
    uint32 coordX1;
    uint32 coordY1;
    uint32 coordX2;
    uint32 coordY2;
    
    string file_type;
    
    string verbose_file;
    uint32 flatzone;

    
    // Your Arguments
    string filename_image;
    string results_dir;
    
    uint32 color_range;
    uint32 channel_weights;
    
    uint32 statistical;
    uint32 criterion_type;
    uint32 bhat;
    uint32 ash;
    string merging_orders_file;

IMAGEPLUS_TOOL_CONFIG_DEFAULT_VALUES()

    N_partition = 300;
    N_regions_accuracy = 0;
    contour_alpha = 0.15;
    outscale_alpha = 0;
    num_regions_partition_means = 0;
    thumbnail_dir = "-";
    thumbnail_width = 100;
    thumbnail_height = 100;
    
    bpt_extension = "xml";
    
    verbose_file = "";
    
    coordX1 = 0;
    coordY1 = 0;
    coordX2 = 0;
    coordY2 = 0;
    acc_part = "";
    search_part = "";
    file_type = "";
    
    color_range = 1;
    channel_weights = 1;
    
    statistical = 1;
    criterion_type = 0;
    bhat = 0;
    ash = 0;
    
    flatzone = 1;
    merging_orders_file = "";
    
IMAGEPLUS_TOOL_CONFIG_OPTIONS()

    //
    // Here you have to define your OPTIONS, with a description 
    // and an optional abreviature
    //
    IMAGEPLUS_TOOL_CONFIG_OPTION_ABV ( N_partition, "Number of regions in the search partition", 'N' );
    IMAGEPLUS_TOOL_CONFIG_OPTION(search_part, "File to read the search partition: N_partition and N_regions_accuracy have no effect if it is given");

    IMAGEPLUS_TOOL_CONFIG_OPTION     ( N_regions_accuracy, "Number of regions in the accuracy partition. If 0: search = accuracy, if 1: accuracy = flatzone");
    IMAGEPLUS_TOOL_CONFIG_OPTION(acc_part, "File to read the accuracy partition (only if no search partition is given)");
    
    IMAGEPLUS_TOOL_CONFIG_OPTION_ABV ( contour_alpha      , "Alpha value in the Contour criterion (1 - No contour)", 'a' );
    IMAGEPLUS_TOOL_CONFIG_OPTION ( outscale_alpha      , "Alpha value in the Outscale criterion (0- No outscale)");

    IMAGEPLUS_TOOL_CONFIG_OPTION_ABV ( num_regions_partition_means , "Number of regions in the partition represented by the mean" +
                                                                     "of the regions (if 0, the search partition is written. if negative, +"
                                                                     "nothing is written)", 'P' );
     
    IMAGEPLUS_TOOL_CONFIG_OPTION(color_range, "Whether the histogram range are 0-255 (0) or the input color range (1). Only for statistical");
    IMAGEPLUS_TOOL_CONFIG_OPTION(channel_weights, "Whether the differences are weighted w.r.t. the color ranges");
    
    IMAGEPLUS_TOOL_CONFIG_OPTION(statistical, "Statistical (1) or Color homogeneity (0)");
    IMAGEPLUS_TOOL_CONFIG_OPTION(criterion_type, "If Statistical: Markov model (1) or IID model (0). If Color: WEDM (0) or WSDM (1)");
    IMAGEPLUS_TOOL_CONFIG_OPTION(bhat, "Bhattacharyya (1) or Kullback_Leibler (0). Only for statistical");
    IMAGEPLUS_TOOL_CONFIG_OPTION(ash, "ASH (1) or no ASH (0). Only for statistical");
    
    IMAGEPLUS_TOOL_CONFIG_OPTION_ABV(verbose_file, "File to write the data in verbose mode", 'v');
    IMAGEPLUS_TOOL_CONFIG_OPTION(flatzone, "Start with flatzone with tolerance");

    IMAGEPLUS_TOOL_CONFIG_OPTION_ABV ( thumbnail_dir, "Directory where the image thumbnail will be stored (if this"+
                                                          "option is not given, the thumbnail is not generated", 't' );
    IMAGEPLUS_TOOL_CONFIG_OPTION_ABV ( thumbnail_width, "Width of the thumbnail", 'w' );
    IMAGEPLUS_TOOL_CONFIG_OPTION_ABV ( thumbnail_height, "Height of the thumbnail", 'h' );
    IMAGEPLUS_TOOL_CONFIG_OPTION(coordX1, "X coordinate of the first extremum of the bounding box");
    IMAGEPLUS_TOOL_CONFIG_OPTION(coordY1, "Y coordinate of the first extremum of the bounding box");
    IMAGEPLUS_TOOL_CONFIG_OPTION(coordX2, "X coordinate of the second extremum of the bounding box");
    IMAGEPLUS_TOOL_CONFIG_OPTION(coordY2, "Y coordinate of the second extremum of the bounding box");
    IMAGEPLUS_TOOL_CONFIG_OPTION(file_type, "Extension of the image file to be read, used when the file does not have one");

    IMAGEPLUS_TOOL_CONFIG_OPTION(bpt_extension, "Extension of the BPT file to be written (xml or txt)");

    IMAGEPLUS_TOOL_CONFIG_OPTION(merging_orders_file, "txt file to write the merging orders");

IMAGEPLUS_TOOL_CONFIG_FLAGS()

    //
    // Here you have to define your FLAGS, with a description 
    // and an optional abreviature
    //


IMAGEPLUS_TOOL_CONFIG_ARGUMENTS()

    //
    // Here you have to define your ARGUMENTS with a description. 
    // You should put them in the DESIRED ORDER in the command-line
    //
    // Note that an argument that is a vector should be the last and no more
    // argument can be added later. Think: is impossible to parser arguments 
    // afters an unknown size vector!
    // If you need more than one vector, use "options" instead of arguments.
    //
    IMAGEPLUS_TOOL_CONFIG_ARGUMENT ( filename_image  , "Input image filename"                     );
    IMAGEPLUS_TOOL_CONFIG_ARGUMENT ( results_dir     , "Directory where results will be stored"   );


IMAGEPLUS_TOOL_CONFIG_READ_PARAMETERS()

    //
    // Here you have to read all your parameters
    //
    // DO NOT FORGET THIS STEP!!
    //
    IMAGEPLUS_TOOL_CONFIG_READ( verbose_file    );
    IMAGEPLUS_TOOL_CONFIG_READ( N_partition     );
    IMAGEPLUS_TOOL_CONFIG_READ( N_regions_accuracy);
    IMAGEPLUS_TOOL_CONFIG_READ( contour_alpha   );
    IMAGEPLUS_TOOL_CONFIG_READ( outscale_alpha  );
    IMAGEPLUS_TOOL_CONFIG_READ( num_regions_partition_means);
    IMAGEPLUS_TOOL_CONFIG_READ( filename_image  );
    IMAGEPLUS_TOOL_CONFIG_READ( results_dir     );
    IMAGEPLUS_TOOL_CONFIG_READ( thumbnail_dir   );
    IMAGEPLUS_TOOL_CONFIG_READ( thumbnail_width );
    IMAGEPLUS_TOOL_CONFIG_READ( thumbnail_height);
    IMAGEPLUS_TOOL_CONFIG_READ( coordX1         );
    IMAGEPLUS_TOOL_CONFIG_READ( coordY1         );
    IMAGEPLUS_TOOL_CONFIG_READ( coordX2         );
    IMAGEPLUS_TOOL_CONFIG_READ( coordY2         );
    IMAGEPLUS_TOOL_CONFIG_READ( file_type       );
    IMAGEPLUS_TOOL_CONFIG_READ( search_part     );
    IMAGEPLUS_TOOL_CONFIG_READ( acc_part        );
    
    IMAGEPLUS_TOOL_CONFIG_READ( color_range     );
    IMAGEPLUS_TOOL_CONFIG_READ( channel_weights );
    IMAGEPLUS_TOOL_CONFIG_READ( statistical     );
    IMAGEPLUS_TOOL_CONFIG_READ( criterion_type  );
    IMAGEPLUS_TOOL_CONFIG_READ( bhat            );
    IMAGEPLUS_TOOL_CONFIG_READ( ash             );
    
    IMAGEPLUS_TOOL_CONFIG_READ( flatzone        );

    IMAGEPLUS_TOOL_CONFIG_READ( bpt_extension   );

    IMAGEPLUS_TOOL_CONFIG_READ( merging_orders_file  );

    
//
// This is the "main" function of your tool.
//
// You can access to all your parameters (options, flags, and arguments)
// with the "cfg" object (see the code.)
//
// Run the exemple with "--help" to see your configuration.
//
IMAGEPLUS_TOOL_CONFIG_MAIN()
{   
    try
    {
        clock_t start = clock();
        clock_t global_start = start;

        // Create paths 
        boost::filesystem::path filename_image( cfg.filename_image );
        filename_image = boost::filesystem::system_complete(filename_image);
        
        boost::filesystem::path results_dir( cfg.results_dir );
        results_dir = boost::filesystem::system_complete(results_dir);
        
        string base = boost::filesystem::basename(filename_image);
        
        boost::filesystem::path temp(base + "-bpt." + cfg.bpt_extension);
        boost::filesystem::path filename_bpt(results_dir / temp );
        
        boost::filesystem::path filename_searchPart;
        if(cfg.search_part!="")
        {
            filename_searchPart = boost::filesystem::path(cfg.search_part);
        }
        else
        {
            temp = base + "-searchPart.prl";
            filename_searchPart = boost::filesystem::path( results_dir / temp );
        }

        temp = base + "-meansPart.jpg";
        boost::filesystem::path filename_meansPart( results_dir / temp );
        
        
        // Images to work with
        typedef uint8 pix_depth_type;
        typedef ImageCIELab<pix_depth_type> InputType;
        typedef RegionContour<Coord2D<int64> > RegionType;
        typedef Partition<RegionType> partition_type;
        
        InputType cielab_image;
        ImageRGB<pix_depth_type> rgb_image;
        
        
        //Read input image
        if(cfg.file_type=="")
        {
            io::ReadImage readImage(filename_image.file_string());
            readImage >> rgb_image;
        }
        else
        {
            io::ImageFormat image_format;
            if( cfg.file_type == "jpg" || cfg.file_type == "jpeg" )
            {
                image_format = io::JPEG;
            }
            else if( cfg.file_type == "png" )
            {
                image_format = io::PNG;
            }
            else if (cfg.file_type == "tiff" || cfg.file_type == "tif")
            {
                image_format = io::TIFF;
            }
        #ifdef USE_IMAGEMAGICK
            else if( cfg.file_type == "bmp" )
            {
                image_format = io::BMP;
            }
        #endif
            else
                throw(ImagePlusError("Unsupported file_type: " + cfg.file_type));
            
            io::ReadImage readImage(filename_image.file_string(), image_format);
            readImage >> rgb_image;
        }

        
        io::WriteImage writeImage;
        boost::filesystem::path thumbnail_dir( cfg.thumbnail_dir );
        boost::filesystem::path filename_thumbnail("-");
        
        // Create the thumbnail if asked
        if(cfg.thumbnail_dir!="-")
        {
            //Compute thumbnail dimensions not to distort it 
            boost::array<float64    ,2> org_size;
            boost::array<std::size_t,2> new_size;
            org_size = rgb_image.sizes();
            float64 factor = std::min((float64)cfg.thumbnail_width /org_size[0],
                                      (float64)cfg.thumbnail_height/org_size[1]);
            new_size = factor*org_size;
                
            //Generate thumbnail and write it
            //ImageRGB<pix_depth_type> thumbnail(math::numeric::resize(rgb_image, factor, factor, math::numeric::MEDIAN));
            ImageRGB<pix_depth_type> thumbnail(math::numeric::resize(rgb_image, new_size));
            
            temp = base + "-small.jpg";
            thumbnail_dir = boost::filesystem::system_complete(thumbnail_dir);
            filename_thumbnail = thumbnail_dir / temp;
            writeImage.open(filename_thumbnail.file_string());
            writeImage << thumbnail;
        }

        // Crop just the area of interest
        ImageRGB<pix_depth_type> rgb_image_reduced;
        if(cfg.coordX1!=0 || cfg.coordY1!=0 || cfg.coordX2!=0 || cfg.coordY2!=0)
        {
            if(cfg.coordX1==cfg.coordX2 || cfg.coordY1==cfg.coordY2)
                throw(ImagePlusError("Bounding box not defined properly"));

            rgb_image_reduced.resize(std::abs((int32)(cfg.coordX1-cfg.coordX2))+1,std::abs((int32)(cfg.coordY1-cfg.coordY2))+1);

            Coord2D<> c1(cfg.coordX1, cfg.coordY1);
            Coord2D<> c2(cfg.coordX2, cfg.coordY2);
            BBox2D bb(c1,c2);
            copy_paste_view(rgb_image(0), bb, rgb_image_reduced(0), Coord2D<>(0,0));
            copy_paste_view(rgb_image(1), bb, rgb_image_reduced(1), Coord2D<>(0,0));
            copy_paste_view(rgb_image(2), bb, rgb_image_reduced(2), Coord2D<>(0,0));
        }
        else
            rgb_image_reduced = rgb_image;

        
        // Convert to cielab
        cielab_image = to_cielab(rgb_image_reduced);
        
        std::size_t s_x = cielab_image.size_x();
        std::size_t s_y = cielab_image.size_y();
        
        // Compute maximum and minimum for each channel
        std::vector<uint8> curr_min(3,255);
        std::vector<uint8> curr_max(3,0);
        for (std::size_t jj=0; jj<s_y; jj++)
        {
            for (std::size_t ii=0; ii<s_x; ii++)
            {
                curr_max[0] = std::max(curr_max[0], cielab_image(0)[ii][jj]);
                curr_max[1] = std::max(curr_max[1], cielab_image(1)[ii][jj]);
                curr_max[2] = std::max(curr_max[2], cielab_image(2)[ii][jj]);
                
                curr_min[0] = std::min(curr_min[0], cielab_image(0)[ii][jj]);
                curr_min[1] = std::min(curr_min[1], cielab_image(1)[ii][jj]);
                curr_min[2] = std::min(curr_min[2], cielab_image(2)[ii][jj]);
            }
        }
        
        // Compute channel weights (inverse of range)
        std::vector<float64> weights(3);
        if(curr_max[0]!=curr_min[0])
            weights[0] = 1./((float64)curr_max[0]-(float64)curr_min[0]);
        else
            weights[0] = 0.;
        if(curr_max[1]!=curr_min[1])
            weights[1] = 1./((float64)curr_max[1]-(float64)curr_min[1]);
        else
            weights[1] = 0.;
        if(curr_max[2]!=curr_min[2])
            weights[2] = 1./((float64)curr_max[2]-(float64)curr_min[2]);
        else
            weights[2] = 0.;

        std::vector<uint8> range_min(3,0);
        std::vector<uint8> range_max(3,255);
        if(cfg.color_range!=0)
        {
            range_min = curr_min;
            range_max = curr_max;
        }
            
        std::vector<float64> channel_weights(3,1.);
        if(cfg.channel_weights!=0)
        {
            channel_weights = weights;
        }
        
        // Verbose mode writes times and some data to file
        std::ofstream myfile;
        clock_t tmp=clock();
        if(cfg.verbose_file!="")
        {
            tmp = clock();
            myfile.open((cfg.verbose_file).c_str(), ios::out | ios::app);
            myfile << ((float64)(tmp-start))/CLOCKS_PER_SEC << "\t";
            start = tmp;
        }
        
        // Compute or read search partition
        ImagePartition<> search_part(s_x,s_y);
        uint64 N_regions_leaves;
        if(cfg.search_part=="")  // ----> Compute search partition
        {
            // Compute or read accuracy partition
            ImagePartition<> accuracy_part(s_x,s_y);
            uint64 N_regions_accuracy;
            if(cfg.acc_part=="")
            {
                // Compute flatzone with tolerance
                ImagePartition<> base_part(s_x, s_y);
                uint32 n_reg_flatzone;
                if (cfg.flatzone!=0)
                {
                    const FlatZoneHoleFilling& flatzone = calc_descriptor(new FlatZoneHoleFilling(5,1000), cielab_image);
                    n_reg_flatzone = flatzone.num_regions();
                    relabel(flatzone, base_part);
                }
                else
                {
                    const FlatZone& flatzone = calc_descriptor(new FlatZone(), cielab_image);
                    n_reg_flatzone = flatzone.num_regions();
                    relabel(flatzone, base_part);
                }
                
                if(cfg.verbose_file!="")
                {
                    tmp = clock();
                    myfile << ((float64)(tmp-start))/CLOCKS_PER_SEC << "\t" << n_reg_flatzone << "\t";
                    start = tmp;
                }
                
                
                if (cfg.N_regions_accuracy==1)  // ------> Accuracy partition is flatzone partition
                {
                    N_regions_accuracy = n_reg_flatzone;
                    accuracy_part = base_part;
                }
                else    // ------> Compute accuracy partition
                {
                    if (cfg.N_regions_accuracy==0)  // ------> Accuracy partition is search partition
                    {
                        N_regions_accuracy = std::min(n_reg_flatzone, (uint32)cfg.N_partition);                            
                    }
                    else
                    {
                        N_regions_accuracy = std::min(n_reg_flatzone, (uint32)cfg.N_regions_accuracy);
                    }
                    
                
                    if(cfg.verbose_file!="")
                    {
                        myfile <<  N_regions_accuracy << "\t";
                    }
                    
                    BPTModels<InputType, RegionType> model_set_accuracy(new ColorHomogeneity<InputType, RegionType, WEDM>(weights));
            
                    partition_type bpt_accuracy(base_part);
                    create_bpt(bpt_accuracy, cielab_image, model_set_accuracy, N_regions_accuracy);
                    
                    // Create accuracy_part
                    partition_type::roots_iterator roots_begin = bpt_accuracy.begin();
                    partition_type::roots_iterator roots_end   = bpt_accuracy.end();
                    create_image_partition(roots_begin, roots_end, accuracy_part);
                    relabel(accuracy_part, accuracy_part);

                    if(cfg.verbose_file!="")
                    {
                        tmp = clock();
                        myfile << ((float64)(tmp-start))/CLOCKS_PER_SEC << "\t";
                        start = tmp;
                    }
                }
            }
            else  // ------> Read pre-computed accuracy partition
            {
                io::ReadImage ri(cfg.acc_part);
                ri >> accuracy_part;
                N_regions_accuracy = num_regions(accuracy_part.colors_begin(), accuracy_part.colors_end());
            }

            N_regions_leaves = std::min(N_regions_accuracy, (uint64)cfg.N_partition);

            BPTModels<InputType, RegionType> model_set(new ColorHomogeneity<InputType, RegionType, WEDM>(weights));
            // BPTModels<InputType, RegionType> model_set(new StatisticalIID<InputType, RegionType>(range_min, range_max, KULLBACK_LEIBLER, WEIGHTED, 5, 1));
            // BPTModels<InputType, RegionType> model_set(new StatisticalIID<InputType, RegionType>(range_min, range_max, BHATTACHARYYA, WEIGHTED, 5, 1));
            // BPTModels<InputType, RegionType> model_set(new StatisticalMarkov<InputType, RegionType>(range_min, range_max, BHATTACHARYYA, WEIGHTED, 5, 1));
            // BPTModels<InputType, RegionType> model_set(new StatisticalMarkov<InputType, RegionType>(range_min, range_max, KULLBACK_LEIBLER, WEIGHTED, 5, 1));

            partition_type bpt_search(accuracy_part);
            create_bpt(bpt_search, cielab_image, model_set, N_regions_leaves);
            
            // Create search_part
            search_part = bpt_search.roots_partition();
            relabel(search_part,search_part);

            if(cfg.verbose_file!="")
            {
                tmp = clock();
                myfile << ((float64)(tmp-start))/CLOCKS_PER_SEC << "\t";
                start = tmp;
            }
        }
        else // -----> Read pre-computed search partition
        {
            io::ReadImage ri(cfg.search_part);
            ri >> search_part;
            N_regions_leaves = num_regions(search_part.colors_begin(), search_part.colors_end());
        }

        // Create the BPT model
        BPTModels<InputType, RegionType> model_set_2;
        
        if(cfg.statistical!=0)
        {
            // Normalize weights
            if(channel_weights[0] + channel_weights[1] + channel_weights[2] != 0)
            {
                float64 K = 3./(channel_weights[0] + channel_weights[1] + channel_weights[2]);
                channel_weights[0] = K*channel_weights[0];
                channel_weights[1] = K*channel_weights[1];
                channel_weights[2] = K*channel_weights[2];
            }   
            
            uint32 num_bins = 5;
            uint32 window_size = 1;
            if(cfg.ash!=0)
            {
                num_bins = 50;
                window_size = 5;                
            }
            
            WeightedTypes weighted_type = WEIGHTED;
            if(cfg.outscale_alpha!=0)
            {
                weighted_type = UNWEIGHTED;
            }            
            
            StatisticalCriterion criterion = KULLBACK_LEIBLER;
            if(cfg.bhat!=0)
            {
                criterion = BHATTACHARYYA;
            }
            
            if(cfg.criterion_type==0)
            {
                model_set_2.add_model(new ColorStatisticalIID<InputType, RegionType>(criterion, weighted_type, num_bins, window_size, channel_weights));
            }
            else
            {
                model_set_2.add_model(new ColorStatisticalMarkov<InputType, RegionType>(criterion, weighted_type, num_bins, window_size, channel_weights));
            }
        }
        else
        {
            if(cfg.channel_weights==0)
            {
                // Normalize weights
                channel_weights[0] = channel_weights[0]/255.;
                channel_weights[1] = channel_weights[1]/255.;
                channel_weights[2] = channel_weights[2]/255.;
            }
            
            if(cfg.criterion_type==0)
            {
                model_set_2.add_model(new ColorHomogeneity<InputType, RegionType, WEDM>(channel_weights));
            }
            else
            {
                model_set_2.add_model(new ColorHomogeneity<InputType, RegionType, WSDM>(channel_weights));
            }
        }
        
        if(cfg.outscale_alpha!=0)
        {
            model_set_2.add_model(new OutScale<InputType, RegionType>(cfg.outscale_alpha));
        }
        
        if(cfg.contour_alpha!=0 && cfg.contour_alpha!=1)
        {
            model_set_2.add_model(new Contour<InputType, RegionType>(), (1-cfg.contour_alpha)/cfg.contour_alpha);    
        }
        

        // Create the BPT
        partition_type bpt_out(search_part);
        create_bpt(bpt_out, cielab_image, model_set_2);
        
        if (cfg.merging_orders_file!="")
        {
            std::vector<float64> merging_orders(N_regions_leaves);
            calculate_merging_orders(bpt_out, cielab_image, model_set_2, merging_orders);

            std::ofstream out_file;
            out_file.open( cfg.merging_orders_file.c_str(), std::ios::out);

            for(std::size_t ii = 0; ii<N_regions_leaves; ++ii)
            {
                out_file << merging_orders[ii] << std::endl;
            }
            out_file.close();
        }


        // Write the results
        std::vector<std::string> uri_names;
        std::vector<std::string> uri_values;
        uri_names.push_back("ImageFile");
        uri_values.push_back(filename_image.file_string());
        if(cfg.thumbnail_dir!="-")
        {
            uri_names.push_back("ThumbnailFile");
            uri_values.push_back(filename_thumbnail.file_string());
        }
        uri_names.push_back("PartitionSearchFile");
        uri_values.push_back(filename_searchPart.file_string());
        
        if(cfg.search_part!="")
        {
            io::ReadWritePartition write_bpt(filename_bpt.file_string(), uri_names, uri_values, io::CHECK_IMAGE_PART);
            write_bpt.write(bpt_out);
        }
        else
        {
            io::ReadWritePartition write_bpt(filename_bpt.file_string(), uri_names, uri_values, io::WRITE_IMAGE_PART);
            write_bpt.write(bpt_out);
        }


//        ImagePartition<> leaves_part_global(rgb_image.size_x(), rgb_image.size_y());
//        leaves_part_global = 0;
//        copy_paste(bpt_out.leaves_partition()(0), leaves_part_global(0), Coord2D<>(cfg.coordX1, cfg.coordY1));
//        writeImage.open(filename_searchPart.file_string());
//        writeImage << leaves_part_global;
        
        if(cfg.num_regions_partition_means>0)
        {
            ImagePartition<> means_partition(s_x,s_y);
            if(cfg.num_regions_partition_means<(int32)N_regions_leaves)
            {
                create_image_partition(bpt_out, cfg.num_regions_partition_means, means_partition);
            }
            mean_of_regions(rgb_image, means_partition, rgb_image);

            writeImage.open(filename_meansPart.file_string());
            writeImage << rgb_image;
        }
        else if(cfg.num_regions_partition_means==0)
        {
            mean_of_regions(rgb_image, search_part, rgb_image);
                        
            writeImage.open(filename_meansPart.file_string());
            writeImage << rgb_image;
        }
           
        if(cfg.verbose_file!="")
        {
            myfile << N_regions_leaves << "\t"<< ((float64)(clock()-global_start))/CLOCKS_PER_SEC << "\n";
        }
        
        myfile.close();
        return 0;
        
    }
    catch(BacktracedImagePlusException e)
    {
        std::cerr << e.what() << std::endl;
        exit(1);
    }
    catch(std::exception e)
    {
        std::cerr << e.what() << std::endl;
        exit(1);
    }
}


//
// This last line is mandatory!
//
IMAGEPLUS_TOOL_CONFIG_END()
