// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------

//!
//!  \file volume.hpp
//!
//!  Interface for Volume class, base class of all volumes in ImagePlus
//!

#ifndef IMAGEPLUS_CORE_VOLUME_HPP
#define IMAGEPLUS_CORE_VOLUME_HPP


#include <imageplus/core/config.hpp>
#include <imageplus/core/imageplus_types.hpp>
#include <imageplus/core/imavol.hpp>

// For coords access
#include <imageplus/core/coord3d.hpp>
// For geometric shapes access
#include <imageplus/core/geometric_shape.hpp>
// For coords arithmetic
#include <imageplus/core/array_arithmetic.hpp>


namespace imageplus
{

    //!
    //! \brief base class to all volumes
    //!
    //! \author Javier Ruiz Hidalgo <j.ruiz@upc.edu>
    //! \author Josep Ramon Morros <morros@gps.tsc.upc.edu>
    //! \author Albert Gil Moreno <agil@gps.tsc.upc.edu>
    //!
    //! \date 10-1-2008
    //!
    //! You should not instantiate this class (better use VolumeGray, VolumeRGB, etc.)
    //! unless you want to implement functions that work equally for all volumes
    //!
    //! Template T is the type of the data \n
    //! Template N is the number of channels in the volume \n
    //!
    //! The declaration should be:
    //! \code
    //!    Volume<uint8,3> a(4,4,4);
    //! \endcode
    //!
    //! This creates a volume of uint8 values with 3 channels with size 4x4x4.
    //!
    //! The access of a voxel is done as the ImaVol class:
    //! \code
    //!    a(GRAY_CHANNEL)[1][3][2] = 0 // Access to pixel (x=1,y=3,z=2) in the GRAY_CHANNEL
    //! \endcode
    //!
    //! See file multiarray.hpp to a more detail explanation on access
    //!
    //! Also you can access using 3D coordinates:
    //! \code
    //!    Coord3D<>  c(1,3,2);
    //!    a(GRAY_CHANNEL, c) = 0 // Access to pixel (x=1,y=3,z=2) in the GRAY_CHANNEL
    //! \endcode
    //!
    template<typename T, std::size_t N>
    class Volume : public ImaVol <T,N,3>
    {
        public:

            //!
            //! \brief Default constructor
            //!
            Volume();

            //!
            //! \brief Constructor for 3 dimensions
            //!
            //! \param[in] sizeX : X size of the image
            //! \param[in] sizeY : Y size of the image
            //! \param[in] sizeZ : Z size of the image
            //!
            Volume(uint64 sizeX, uint64 sizeY, uint64 sizeZ);

            //!
            //! \brief Copy constructor for ImaVol (also valid for Volume)
            //!
            //! \param[in] copy : Creates a copy (including values) of this imavol
            //!
            Volume( const ImaVol<T,N,3>& copy );
            
#ifdef MSVC            
            //!
            //! \brief Copy constructor for ImaVol (also valid for Volume)
            //!
            //! \param[in] copy : Creates a copy (including values) of this imavol
            //!
            Volume( const Volume& copy )
            		//: ImaVol<T,N,3>( copy.dims() )
            {
            	*this = copy;
            }
#endif


            //!
            //! \brief Constructor with a vector of dimentions
            //!
            //! \param[in] dims: Vector of vectors with the dimension of each channel
            //!
            explicit 
            Volume(const std::vector< std::vector<uint64> >& dims);

            //!
            //! \brief Assignment operator for ImaVol, also valid for Volume 
            //!
            //! \param[in] copy : Creates a copy (size,channels and data) of this imavol
            //!
            //! \return Reference to (this) so a = b = c; works.
            //!
            const ImaVol<T,N,3>& operator=( const ImaVol<T,N,3>& copy );

            //!
            //! \brief Assigment operator for values (fills the entire volume)
            //!
            //! \param[in] val : Value to fill all voxels
            //!
            //! \return Reference to value to a = b = 1; works
            //!
            const T& operator=(const T& val);
            
            //!
            //! \brief Channel access operator
            //!
            //! \param[in] channel : Channel number to access. Please, use channels defined in namespace imageplus: GRAY_CHANNEL, RED_CHANNEL...
            //!
            //! \return Reference to the channel
            //!
            //! \todo this operator is inherited from ImaVol, is necessary to overload it?
            //!
            //MultiArray<T,3>& operator()(uint64 channel);

            //!
            //! \brief Constant channel access operator
            //!
            //! \param[in] channel : Channel number to access. Please, use channels defined in namespace imageplus: GRAY_CHANNEL, RED_CHANNEL...
            //!
            //! \return Constant reference to the channel
            //!
            //! \todo this operator is inherited from ImaVol, is necessary to overload it?
            //!
            //const MultiArray<T,3>& operator()(uint64 channel) const;
            
//            //!
//            //! \brief Access operator by coords (assumed coordinate origin in (0,0,0))
//            //!
//            //! \param[in] channel : Channel number to access. Please, use channels defined in namespace imageplus: GRAY_CHANNEL, RED_CHANNEL...
//            //! \param[in] coord: Voxel coordinte to access 
//            //!
//            //! \return Reference to the voxel value
//            //!
//            //! \todo manage same coords in channels with different resolutions
//            //!
//            T& operator()(uint64 channel, const Coord3D<> & coord);
//            
//            //!
//            //! \brief Constant access operator by coords (assumed coordinate origin in (0,0,0))
//            //!
//            //! \param[in] channel : Channel number to access. Please, use channels defined in namespace imageplus: GRAY_CHANNEL, RED_CHANNEL...
//            //! \param[in] coord: Voxel coordinte to access 
//            //!
//            //! \return Constant reference to the voxel value
//            //!
//            //! \todo manage same coords in channels with different resolutions
//            //!
//            const T& operator()(uint64 channel, const Coord3D<> & coord) const;
//            
//            //!
//            //! \brief Access operator by coords with different axis origin
//            //!
//            //! \param[in] channel : Channel number to access. Please, use channels defined in namespace imageplus: GRAY_CHANNEL, RED_CHANNEL...
//            //! \param[in] coord: Voxel coordinte to access 
//            //! \param[in] origin: Axis origin
//            //!
//            //! \return Reference to the voxel value
//            //!
//            //! \todo manage same coords in channels with different resolutions
//            //!
//            T& operator()(uint64 channel, const Coord3D<> & coord, const Coord3D<> & origin);
//            
//            //!
//            //! \brief Constant access operator by coords with different axis origin
//            //!
//            //! \param[in] channel : Channel number to access. Please, use channels defined in namespace imageplus: GRAY_CHANNEL, RED_CHANNEL...
//            //! \param[in] coord: Voxel coordinte to access
//            //! \param[in] origin: Axis origin
//            //!
//            //! \return Constant reference to the voxel value
//            //!
//            //! \todo manage same coords in channels with different resolutions
//            //!
//            const T& operator()(uint64 channel, const Coord3D<> & coord, const Coord3D<> & origin) const;
//            
//            //!
//            //! \brief To get the values of a GeometricShape 
//            //!
//            //! \param[in] channel : Channel number to access. Please, use channels defined in namespace imageplus: GRAY_CHANNEL, RED_CHANNEL...
//            //! \param[in] shape: GeometricShape to get 
//            //!
//            //! \return Vector with all the values of the GeometricShape coordinates (values, NOT references)
//            //!
//            MultiArray<T,1> operator()(uint64 channel, const GeometricShape<int64,3> & shape) const;
    };
    
    
    //
    // Inline methods implementation
    //
    
    template <typename T, std::size_t N>
    IMAGEPLUS_INLINE
    Volume<T,N>::Volume()
            : ImaVol<T,N,3>()
    {
    }

    template <typename T, std::size_t N>
    IMAGEPLUS_INLINE
    Volume<T,N>::Volume(uint64 sizeX, uint64 sizeY, uint64 sizeZ)
            : ImaVol<T,N,3>(sizeX,sizeY,sizeZ)
    {
    }

    template <typename T, std::size_t N>
    IMAGEPLUS_INLINE
    Volume<T,N>::Volume( const ImaVol<T,N,3>& copy )
            : ImaVol<T,N,3>(copy)
    {
    }

    template <typename T, std::size_t N>
    IMAGEPLUS_INLINE
    Volume<T,N>::Volume(const std::vector< std::vector<uint64> >& dims)
            : ImaVol<T,N,3>(dims)
    {
    }

    template <typename T, std::size_t N>
    IMAGEPLUS_INLINE
    const ImaVol<T,N,3>& Volume<T,N>::operator=( const ImaVol<T,N,3>& copy )
    {
        return ImaVol<T,N,3>::operator=( copy );
    }

    template <typename T, std::size_t N>
    IMAGEPLUS_INLINE
    const T& Volume<T,N>::operator=(const T& val)
    {
        return ImaVol<T,N,3>::operator=( val );
    }

    /*
    template <typename T, std::size_t N>
    IMAGEPLUS_INLINE
    MultiArray<T,3>& Volume<T,N>::operator()(uint64 channel)
    {
        return ImaVol<T,N,3>::operator()(channel);
    }

    template <typename T, std::size_t N>
    IMAGEPLUS_INLINE
    const MultiArray<T,3>& Volume<T,N>::operator()(uint64 channel) const
    {
        return ImaVol<T,N,3>::operator()(channel);
    }

    template <typename T, std::size_t N>
    IMAGEPLUS_INLINE
    T& Volume<T,N>::operator()(uint64 channel, const Coord3D<> & coord)
    {
        ASSERT(coord.x() >= 0 && coord.y() >= 0 && coord.z() >= 0, "Volume access by negative coords")
        ASSERT( static_cast<size_type>(coord.x()) < this->size_x() && \
                static_cast<size_type>(coord.y()) < this->size_y() && \
                static_cast<size_type>(coord.z()) < this->size_z(), "Volume acces by coords out of range")
        ASSERT( (*this)(channel).dims(0) == this->size_x() && \
                (*this)(channel).dims(1) == this->size_y() && \
                (*this)(channel).dims(2) == this->size_z(), "Access by coords to a Volume with different channel resolution not supported")
        
        return (*this)(channel)(coord);
    }

    template <typename T, std::size_t N>
    IMAGEPLUS_INLINE
    const T& Volume<T,N>::operator()(uint64 channel, const Coord3D<> & coord) const
    {
        ASSERT(coord.x() >= 0 && coord.y() >= 0 && coord.z() >= 0, "Volume access by negative coords")
        ASSERT( static_cast<size_type>(coord.x()) < this->size_x() && \
                static_cast<size_type>(coord.y()) < this->size_y() && \
                static_cast<size_type>(coord.z()) < this->size_z(), "Volume acces by coords out of range")
        ASSERT( (*this)(channel).dims(0) == this->size_x() && \
                (*this)(channel).dims(1) == this->size_y() && \
                (*this)(channel).dims(2) == this->size_z(), "Access by coords to a Volume with different channel resolution not supported")
        
        return (*this)(channel)(coord);
    }

    template <typename T, std::size_t N>
    IMAGEPLUS_INLINE
    T& Volume<T,N>::operator()(uint64 channel, const Coord3D<> & coord, const Coord3D<> & origin)
    {
        return (*this)(channel)( coord+origin);
    }

    template <typename T, std::size_t N>
    IMAGEPLUS_INLINE
    const T& Volume<T,N>::operator()(uint64 channel, const Coord3D<> & coord, const Coord3D<> & origin) const
    {
        return (*this)(channel)( coord+origin);
    }
    
    template<typename T, std::size_t N>
    IMAGEPLUS_INLINE
    MultiArray<T,1> Volume<T,N>::operator()(uint64 channel, const GeometricShape<int64,3> & shape) const
    {
        size_type size = shape.size();
        MultiArray<T, 1> shape_values(size);
        
        T *d = shape_values.data();
        GeometricShape<int64,3>::const_iterator c = shape.begin();
        
        // TODO (AGIL): 
        //   Use std::vector::data() when it becames part of the C++ Standard (STL). 
        //   Now it is the active isssue number 464 of the standard and it's in WP status (Working Paper).  
        //   For more information see:
        //   The C++ Standards Committee:             http://www.open-std.org/jtc1/sc22/wg21/
        //   C++ Standard Library Active Issues List: http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html
        //   Active Issue 464:                        http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#464
        //
        //const Coord *c = shape.data();
        
        for( size_type i=0; i < size; i++)
        {
            *d++ = (*this)(channel, *c++);
        }
        
        return shape_values;
    }
    */
}


#endif
