// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------

/*!
 * \file coord.hpp
 */

#ifndef IMAGEPLUS_CORE_COORD_HPP
#define IMAGEPLUS_CORE_COORD_HPP

#include <boost/array.hpp>

#include <imageplus/cmath.hpp>
#include <imageplus/core/exceptions.hpp>
#include <imageplus/core/imageplus_types.hpp>
#include <imageplus/core/multiarray.hpp>
#include <imageplus/core/point.hpp>

/*
 * AGIL: TR1 header commented to avoid linking problems.
 *       See http://www.boost.org/libs/math/doc/sf_and_dist/html/math_toolkit/extern_c/tr1.html
 */
//#include <boost/math/tr1.hpp>
#include <boost/math/special_functions/round.hpp>
#include <boost/math/special_functions/trunc.hpp>

namespace imageplus
{
    /*!
     * The different modes to convert a decimal value (floating point) to an integer
     *
     * See <a href="http://www.boost.org/libs/math/doc/sf_and_dist/html/math_toolkit/utils/rounding.html">
     * Rounding Truncation and Integer Conversion of Boost.Math </a> for further details.
     */
    enum RoundMode
    {
        ROUND, //! The nearest integer                      (e.g. 3.75 -> 4, -1.2 -> -1)
               //! Halfway cases are rounded away from zero (e.g. 3.5  -> 4, -1.5 -> -2)
        TRUNC, //! Just remove decimals                     (e.g. 3.75 -> 3, -1.2 -> -1)
        FLOOR, //! The nearest not greater integer          (e.g. 3.75 -> 3, -1.2 -> -2)
        CEIL   //! The nearest not less integer             (e.g. 3.75 -> 4, -1.2 -> -1)
    };


    /*!
     * Class to represent coordinates of a N-dimensional discrete space.
     *
     * Basically a Coord is used to represent a pixel (N=2) or voxel (N=3) position in an Image or Volume.\n
     * To represent points in a continuous (or real) space use the Point class instead.
     *
     * This class inherits from <a href="http://www.boost.org/doc/html/array.html">boost::array</a>, so check the
     * <a href="http://www.boost.org/doc/html/array.html">boost::array documentation</a> for a complete reference
     * of the available methods.
     *
     * \tparam T : Type of the data (must be an integer type)
     * \tparam D : Number of dimensions (2 for Image coordinates, 3 for Volume coordinates, etc)
     *
     * You can also use Coord2D or Coord3D as a kind of "template typedef" from Coord with specific D=2 and D=3
     * respectively.
     *
     * \see Coord2D, Coord3D, Point
     *
     * \todo Check that T is an integer type
     *
     * \author 2008-02 - Josep Ramon Morros <ramon.morros@upc.edu> - Creation
     * \author 2011-06 - Albert Gil Moreno <albert.gil@upc.edu>    - Review
     */
    template < typename T, std::size_t D >
    class Coord : public boost::array<T,D>
    {
    protected:
        typedef boost::array<T,D> Base;          //!< the base array class

    public:
    	typedef      T           data_type;      //!< The data_type of the coordinate
    	static const std::size_t dimensions = D; //!< The dimension of the Coord space
    	
        /*!
         * Default constructor.
         * All values are initialized to 0.
         */
        Coord()
        {
            (*this).assign(T(0));
        }
        
        /*!
         * Copy constructor
         *
         * \param[in] copy : Coord to copy from
         */
        Coord(const Coord& copy)
        :   Base( (const Base&)copy )
        {}

        /*!
         * Copy constructor from a 1D MultiArray, with an implicit conversion of the data type (TC)
         *
         * Sometimes we have a coordinate stored in a MultiArray,
         * this constructor allows a conversion.
         *
         * \tparam TC : the MultiArray data type
         *
         * \param[in] ma_coord : a 1D MultiArray with coordinates
         *
         * \todo is this function really necessary? Coord now depends on MultiArray!
         */
        template<typename TC>
        Coord( const  MultiArray<TC,1> & ma_coord )
        {
            ASSERT(ma_coord.dims(0) == dimensions, "Cannot create a Coord from a MultiArray with dimension = "
                                                    << ma_coord.dims(0)
                                                    << " when the Coord has dimension = "
                                                    << dimensions);

            std::copy(ma_coord.begin(),ma_coord.end(), this->begin());
        }

        /*!
         * Copy constructor from the base class array using a RoundMode.
         *
         * Note that we can use this constructor as a copy constructor from a Coord<TC,D> or a Point<D>.
         *
         * \tparam TC : the type of the copy object, it will be transformed to T with the RoundMode
         *
         * \param[in] copy : the array (Coord<TC,> or Point<D>) to copy the Coord from
         * \param[in] mode : the RoundMode used to compute the Coord
         */
        template<typename TC>
        Coord ( const boost::array<TC, dimensions>& copy, RoundMode mode )
        {
            set(copy, mode);
        }

        /*!
         * Copy constructor from the base class array with implicit type cast (ROUND).
         *
         * Note that we can use this constructor as a copy constructor from a Coord<TC,D>.
         * It is not recommended to use with Points.
         *
         * It call the set(array,mode) function with mode=ROUND.
         *
         * \tparam TC : the type of the copy object, it will be transformed to T with ROUND
         *
         * \param[in] copy : the array (Coord<TC,>) to copy the Coord from
         */
        template<typename TC>
        Coord ( const boost::array<TC, dimensions>& copy )
        {
            set(copy, ROUND);
        }

        /*!
         * Specific constructor from a constant value (also for 1D Coord).
         *
         * All dimensions will have the same value.
         *
         * Please note that this constructor is also useful for 1D Coord.
         *
         * \param[in] v : the value of all dimensions
         */
        Coord (T v)
        {
            (*this).assign(v);
        }

        /*!
         * Specific constructor for 2D Coord, just for convenience
         *
         * \param[in] x : the value of the first dimension
         * \param[in] y : the value of the second dimension
         */
        Coord (T x, T y)
        {
            ASSERT(dimensions == 2, "Cannot create a Coord with 2 arguments when dimension = " << dimensions);
            
            (*this)[0] = x;
            (*this)[1] = y;
         }

        /*!
         * Specific constructor for 3D Coord, just for convenience
         *
         * \param[in] x : the value of the first dimension
         * \param[in] y : the value of the second dimension
         * \param[in] z : the value of the third dimension
         */
        Coord (T x, T y, T z)
        {
            ASSERT(dimensions == 3, "Cannot create a Coord with 3 arguments when dimension =" << dimensions);

            (*this)[0] = x;
            (*this)[1] = y;
            (*this)[2] = z;
        }

        /*!
         * Assignment operator from another Coord with implicit cast
         *
         * \tparam TC : the data type of the copy Coord (an implicit cast will be done)
         * 
         * \param[in] copy : the Coord to copy from
         *
         * \returns this, just to concatenate
         */
        template<typename TC>
        const Coord& operator= (const boost::array<TC, dimensions>& copy)
        {
            Base::operator=(copy);
            return *this;
        }

        /*!
         * Set/Assignment from an base array (or Coord<TC,D> or Point<D>) using a RoundMode.
         *
         * \tparam TC : the type of the copy object, it will be transformed to T with the RoundMode
         *
         * \param[in] copy : base array (Coord<TC,D> or Point<D>) to copy from
         * \param[in] mode : the RoundMode used to set the Coord
         */
        template<typename TC>
        void set(const boost::array<TC,dimensions>& copy, RoundMode mode = ROUND)
        {
            if( typeid(TC) == typeid(float32) ||
                typeid(TC) == typeid(float64) )
            {
                switch( mode )
                {
                    case ROUND: for(std::size_t ii=0; ii<D; ++ii) (*this)[ii] = boost::math/*::tr1*/::round(copy[ii]); break;
                    case TRUNC: for(std::size_t ii=0; ii<D; ++ii) (*this)[ii] = boost::math/*::tr1*/::trunc(copy[ii]); break;
                    case FLOOR: for(std::size_t ii=0; ii<D; ++ii) (*this)[ii] = std::floor                 (copy[ii]); break;
                    case CEIL : for(std::size_t ii=0; ii<D; ++ii) (*this)[ii] = std::ceil                  (copy[ii]); break;
                }
            }
            else
            {
                Base::operator=(copy);
            }
        }

        /*!
         * Set/Assignment from values (1D)
         *
         * \param[in] x : first dimension
         */
        void set(T x)
        {
            ASSERT(dimensions == 1, "Cannot set a Coord with (x) with dimension = " << dimensions);
            (*this)[0] = x;
        }

        /*!
         * Set/Assignment from values (2D)
         *
         * \param[in] x : first dimension
         * \param[in] y : second dimension
         */
        void set(T x, T y)
        {
            ASSERT(dimensions == 2, "Cannot set a Coord with (x,y) with dimension = " << dimensions);

            (*this)[0] = x;
            (*this)[1] = y;
        }

        /*!
         * Set/Assignment from values (3D)
         *
         * \param[in] x : first dimension
         * \param[in] y : second dimension
         * \param[in] z : third dimension
         */
        void set(T x, T y, T z)
        {
            ASSERT(dimensions == 3, "Cannot set a Coord with (x,y,z) with dimension = " << dimensions);

            (*this)[0] = x;
            (*this)[1] = y;
            (*this)[2] = z;
        }

        /*!
         * \returns the dimensions of the Coord: 2, 3 or n
         */
        size_type dims() const
        {
            return dimensions;
        }

        /*!
         * \returns the coordinate of the first dimension (const access)
         */
        const T& x() const
        {
            return (*this)[0];
        }

        /*!
         * \returns the coordinate of the first dimension
         */
        T& x()
        {
            return (*this)[0];
        }

        /*!
         * \returns the coordinate of the second dimension (const access)
         */
        const T& y() const
        {
            ASSERT(dimensions >= 2, "Cannot access to the y coordinate with S=" << dimensions);
            return (*this)[1];
        }

        /*!
         * \returns the coordinate of the second dimension
         */
        T& y()
        {
            ASSERT(dimensions >= 2, "Cannot access to the y coordinate with S=" << dimensions);
            return (*this)[1];
        }

        /*!
         * \returns the coordinate of the third dimension (const access)
         */
        const T& z() const
        {
            ASSERT(dimensions >= 3, "Cannot access to the z coordinate with S=" << dimensions);
            return (*this)[2];
        }

        /*!
         * \returns the coordinate of the third dimension
         */
        T& z()
        {
            ASSERT(dimensions >= 3, "Cannot access to the z coordinate with S=" << dimensions);
            return (*this)[2];
        }
    };
}

#endif //IMAGEPLUS_CORE_COORD_HPP
