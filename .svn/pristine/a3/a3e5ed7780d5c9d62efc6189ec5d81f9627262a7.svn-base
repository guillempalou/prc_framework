// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------

//!
//!  \file image.hpp
//!
//!  Interface for Image class, base class of all images in ImagePlus
//!

#ifndef IMAGEPLUS_CORE_IMAGE_HPP
#define IMAGEPLUS_CORE_IMAGE_HPP


#include <imageplus/core/config.hpp>
#include <imageplus/core/imageplus_types.hpp>
#include <imageplus/core/imavol.hpp>

// For coords access
#include <imageplus/core/coord.hpp>
// For geometric shapes access
#include <imageplus/core/geometric_shape.hpp>
// For coords arithmetic
#include <imageplus/core/array_arithmetic.hpp>


namespace imageplus
{

    //!
    //! \brief base class to all images
    //!
    //! \author Javier Ruiz Hidalgo <j.ruiz@upc.edu>
    //! \author Josep Ramon Morros <morros@gps.tsc.upc.edu>
    //! \author Albert Gil Moreno <agil@gps.tsc.upc.edu>
    //!
    //! \date 10-1-2008
    //!
    //! You should not instantiate this class (better use ImageGray, ImageRGB, etc.)
    //! unless you want to implement functions that work equally for all images
    //!
    //! Template T is the type of the data \n
    //! Template N is the number of channels in the image \n
    //!
    //! The declaration should be:
    //! \code
    //!    Image<uint8,3> a(4,4);
    //! \endcode
    //!
    //! This creates an image of uint8 values with 3 channels with size 4x4.
    //!
    //! The access of a pixel is done as the ImaVol class:
    //! \code
    //!    a(GRAY_CHANNEL)[1][3] = 0 // Access to pixel (x=1,y=3) in the GRAY_CHANNEL
    //! \endcode
    //!
    //! See file multiarray.hpp to a more detail explanation on access
    //!
    //! Also you can access using 2D coordinates:
    //! \code
    //!    Coord2D c(1,3);
    //!    a(GRAY_CHANNEL, c) = 0 // Access to pixel (x=1,y=3) in the GRAY_CHANNEL
    //! \endcode
    //!
    template<typename T, std::size_t N>
    class Image : public ImaVol <T,N,2>
    {
        public:

            //!
            //! \brief Default constructor
            //!
            Image();

            //!
            //! \brief Constructor for 2 dimensions
            //!
            //! \param[in] width  : X size of the image
            //! \param[in] height : Y size of the image
            //!
            Image(uint64 width, uint64 height);

            //!
            //! \brief Copy constructor for ImaVol (also valid for Image)
            //!
            //! \param[in] copy : Creates a copy (including values) of this imavol
            //!
            Image(const ImaVol<T,N,2>& copy);

#ifdef MSVC
            //!
            //! \brief Copy constructor for ImaVol (also valid for Image)
            //!
            //! \param[in] copy : Creates a copy (including values) of this imavol
            //!
            Image(const Image& copy)
            		//: ImaVol<T,N,2>(copy.dims())
            {
            	*this = copy;
            }
#endif


            //!
            //! \brief Constructor with a vector of dimentions
            //!
            //! \param[in] dims: Vector of vectors with the dimension of each channel
            //!
            explicit 
            Image(const std::vector< std::vector<uint64> >& dims);
            
            //!
            //! \brief Assignment operator for ImaVols (also useful for Images)
            //!
            //! \param[in] copy : Creates a copy (size,channels and data) of this Image
            //!
            //! \return Reference to (this) so a = b = c; works.
            //!
            const ImaVol<T,N,2>& operator=( const ImaVol<T,N,2>& copy );

            //!
            //! \brief Assigment operator for values (fills the entire image)
            //!
            //! \param[in] val : Value to fill all pixel
            //!
            //! \return Reference to value to a = b = 1; works
            //!
            const T& operator=( const T& val );
    };
    
    
    //
    // Inline methods implementation
    //
    
    template<typename T, std::size_t N>
    IMAGEPLUS_INLINE
    Image<T,N>::Image()
            : ImaVol<T,N,2>()
    {
    }

    template<typename T, std::size_t N>
    IMAGEPLUS_INLINE
    Image<T,N>::Image(uint64 width, uint64 height)
            : ImaVol<T,N,2>(width,height)
    {
    }

    template<typename T, std::size_t N>
    IMAGEPLUS_INLINE
    Image<T,N>::Image(const ImaVol<T,N,2>& copy)
            : ImaVol<T,N,2>(copy)
    {
    }

    template<typename T, std::size_t N>
    IMAGEPLUS_INLINE
    Image<T,N>::Image(const std::vector< std::vector<uint64> >& dims)
            : ImaVol<T,N,2>(dims)
    {
    }

    template<typename T, std::size_t N>
    IMAGEPLUS_INLINE
    const ImaVol<T,N,2>& Image<T,N>::operator=( const ImaVol<T,N,2>& copy )
    {
        return ImaVol<T,N,2>::operator=( copy );
    }

    template<typename T, std::size_t N>
    IMAGEPLUS_INLINE
    const T& Image<T,N>::operator=( const T& val )
    {
        return ImaVol<T,N,2>::operator=( val );
    }
}





#endif
