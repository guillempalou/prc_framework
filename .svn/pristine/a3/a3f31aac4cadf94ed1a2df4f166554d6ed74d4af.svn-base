// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------

//!
//!  \file array_arithmetic.hpp
//!

#ifndef IMAGEPLUS_CORE_ARRAY_ARITHMETIC_HPP
#define IMAGEPLUS_CORE_ARRAY_ARITHMETIC_HPP

#include <boost/array.hpp>

#include <imageplus/core/config.hpp>
#include <imageplus/core/exceptions.hpp>
#include <imageplus/core/point.hpp>

#include <iostream> // for array output

namespace imageplus
{
    /*!
     * Absolute value (or modulus) for all the elements of an array
     *
     * \tparam T : the data type of the array
     * \tparam N : the arraya size
     *
     * \param[in] array : the array to compute the absolute value
     *
     * \returns an array with the absolute value of the input array
     *
     * \author 2011-07 - Albert Gil - Creation
     */
    template<typename T, std::size_t N>
    boost::array<T,N> abs(const boost::array<T,N>& array)
    {
        boost::array<T,N> out;
        for(std::size_t ii=0; ii<array.size(); ++ii)
        {
            if(array[ii] < 0.0) out[ii] = -array[ii];
            else                out[ii] =  array[ii];
        }

        return out;
    }

    /*!
     * Equal-To operator (==) for basic arrays, with implicit type conversion from T2 to T1.
     *
     * \tparam T1 : the data type of the first array
     * \tparam T2 : the data type of the second array; will be converted to T1
     * \tparam N  : the arrays size
     *
     * \param[in] a1 : the first array to compare (data type = T1)
     * \param[in] a2 : the second array to compare (data type = T2)
     *
     * \returns true if all elements are equal, false otherwise
     *
     * \note The implicit data type conversion is done by the std::equal algorithm.
     *
     * \note The <a href="http://www.boost.org/doc/html/array.html">boost::array</a> class has an "equal-to"
     *       operator, but without a data type conversion. So this operator has been added just for convenience.
     *
     * \author 2011-06 - Albert Gil - Creation
     */
    template<class T1, class T2, std::size_t N>
    bool operator== (const boost::array<T1,N>& a1, const boost::array<T2,N>& a2)
    {
        return std::equal(a1.begin(), a1.end(), a2.begin());
    }

    /*!
     * Not-Equal-To operator (!=) for basic arrays, with implicit type conversion from T2 to T1.
     *
     * \tparam T1 : the data type of the first array
     * \tparam T2 : the data type of the second array; will be converted to T1
     * \tparam N  : the arrays size
     *
     * \param[in] a1 : the first array to compare (data type = T1)
     * \param[in] a2 : the second array to compare (data type = T2)
     *
     * \returns false if all elements are equal, true otherwise
     *
     * \note The <a href="http://www.boost.org/doc/html/array.html">boost::array</a> class has an "not-equal"
     *       operator, but without a data type conversion. So this operator has been added just for convenience.
     *
     * \author 2011-06 - Albert Gil - Creation
     */
    template<class T1, class T2, std::size_t N>
    bool operator!= (const boost::array<T1,N>& a1, const boost::array<T2,N>& a2)
    {
        return !(a1==a2);
    }

    /*!
     * Equal-To operator (==) between arrays and MultiArray (1D), with implicit type conversion from T2 to T1.
     *
     * \tparam T1 : the data type of the Array
     * \tparam T2 : the data type of the MultiArray; will be converted to T1
     * \tparam N  : the array size
     *
     * \param[in] a1 : the Array to compare (data type = T1)
     * \param[in] a2 : the MultiArray to compare (data type = T2)
     *
     * \returns true if all elements are equal, false otherwise
     *
     * \note The implicit conversion is done by the std::equal algorithm.
     *
     * \note This function has been added for coherence due we can create a Coord or Point from a MultiArray,
     *       so, we should be able to compare them.
     *
     * \author 2011-06 - Albert Gil - Creation
     */
    template<class T1, class T2, std::size_t N>
    bool operator== (const boost::array<T1,N>& a1, const MultiArray<T2,1>& a2)
    {
        if(a2.num_elements() != N ) return false;

        return std::equal(a1.begin(), a1.end(), a2.begin());
    }

    /*!
     * Not-Equal-To operator (!=) between an Array and a MultiArray (1D), with implicit type conversion from T2 to T1.
     *
     * \tparam T1 : the data type of the Array
     * \tparam T2 : the data type of the MultiArray; will be converted to T1
     * \tparam N  : the array size
     *
     * \param[in] a1 : the Array to compare (data type = T1)
     * \param[in] a2 : the MultiArray to compare (data type = T2)
     *
     * \returns false if all elements are equal, true otherwise
     *
     * \note This function has been added for coherence due we can create a Coord or Point from a MultiArray,
     *       so, we should be able to compare them.
     *
     * \note The <a href="http://www.boost.org/doc/html/array.html">boost::array</a> class has an "not-equal"
     *       operator, but without a data type conversion. So this operator has been added just for convenience.
     *
     * \author 2011-06 - Albert Gil - Creation
     */
    template<class T1, class T2, std::size_t N>
    bool operator!= (const boost::array<T1,N>& a1, const MultiArray<T2,1>& a2)
    {
        return !(a1==a2);
    }

    /*!
     * Addition-Assignment operator (+=) for two arrays, with implicit data type conversion from T2 to T1
     *
     * \tparam T1 : the data type of the first array
     * \tparam T2 : the data type of the second array; will be converted to T1
     * \tparam S  : the size of both arrays
     *
     * \param[in,out] a1 : first array, where the addition will be saved
     * \param[in]     a2 : second array, will be added to a1
     *
     * \returns the addition a1+a2
     *
     * \author 2011-04 - Josep Ramon Morros <ramon.morros@upc.edu> - Creation
     * \author 2011-06 - Albert Gil - Template T2 added
     */
    template<typename T1, typename T2, std::size_t S>
    const boost::array<T1,S>& operator+=( boost::array<T1,S>& a1, const boost::array<T2,S>& a2);

    /*!
     * Addition operator (+) for two arrays, with implicit data type conversion from T2 to T1
     *
     * \tparam T1 : the data type of the first array
     * \tparam T2 : the data type of the second array; will be converted to T1
     * \tparam S  : the size of both arrays
     *
     * \param[in] a1 : first array operand
     * \param[in] a2 : second array operand
     *
     * \returns the addition a1+a2
     *
     * \author 2008-01 - Marcel Alcoverro - Creation
     * \author 2011-06 - Albert Gil       - Template T2 added
     */
    template<typename T1, typename T2, std::size_t S>
    boost::array<T1,S> operator+( const boost::array<T1,S>& a1, const boost::array<T2,S>& a2);

    /*!
     * Addition-Assignment operator (+=) for an array and a scalar, without data type conversion.
     *
     * \tparam T : the data type of the array and the scalar
     * \tparam S : the size of the array
     *
     * \param[in,out] array  : the array, where the addition will be saved
     * \param[in]     scalar : the scalar, will be added to array
     *
     * \returns the array after adding the scalar to each element
     *
     * \author 2011-04 - Josep Ramon Morros <ramon.morros@upc.edu> - Creation
     */
    template<typename T, std::size_t S>
    const boost::array<T,S>& operator+=( boost::array<T,S>& array, T scalar);

    /*!
     * Addition operator (+) between an array and a scalar, without data type conversion
     *
     * \tparam T : the data type of the array and the scalar
     * \tparam S : the size of the array
     *
     * \param[in] array  : the array of the addition
     * \param[in] scalar : the scalar of the addition
     *
     * \returns an array where each member contains values of the initial array plus the scalar
     *
     * \author 2008-01 - Marcel Alcoverro - Creation
     */
    template<typename T, std::size_t S>
    boost::array<T,S> operator+( const boost::array<T,S>& array, T scalar );

    /*!
     * Addition operator (+) between a scalar and an array, without data type conversion
     *
     * \tparam T : the data type of the array and the scalar
     * \tparam S : the size of the array
     *
     * \param[in] array  : the array of the addition
     * \param[in] scalar : the scalar of the addition
     *
     * \returns an array where each member contains values of the initial array plus the scalar
     *
     * \author 2008-01 - Marcel Alcoverro - Creation
     */
    template<typename T, std::size_t S>
    boost::array<T,S> operator+( T scalar, const boost::array<T,S>& array);

    /*!
     * Subtraction-Assignment operator (-=) for two arrays, with implicit data type conversion from T2 to T1
     *
     * \tparam T1 : the data type of the first array
     * \tparam T2 : the data type of the second array; will be converted to T1
     * \tparam S  : the size of both arrays
     *
     * \param[in,out] a1 : first array, where the subtraction will be saved
     * \param[in]     a2 : second array, will be subtracted to a1
     *
     * \returns the subtraction a1-a2
     *
     * \author 2011-04 - Josep Ramon Morros <ramon.morros@upc.edu> - Creation
     * \author 2011-06 - Albert Gil - Template T2 added
     */
    template<typename T1, typename T2, std::size_t S>
    const boost::array<T1,S>& operator-=( boost::array<T1,S>& a1, const boost::array<T2,S>& a2);

    /*!
     * Subtraction operator (-) for two arrays, with implicit data type conversion from T2 to T1
     *
     * \tparam T1 : the data type of the first array
     * \tparam T2 : the data type of the second array; will be converted to T1
     * \tparam S  : the size of both arrays
     *
     * \param[in] a1 : first array operand
     * \param[in] a2 : second array operand
     *
     * \returns the subtraction a1-a2
     *
     * \author 2008-01 - Marcel Alcoverro - Creation
     * \author 2011-06 - Albert Gil       - Template T2 added
     */
    template<typename T1, typename T2, std::size_t S>
    boost::array<T1,S> operator-( const boost::array<T1,S>& a1, const boost::array<T2,S>& a2);

    /*!
     * Subtraction-Assignment operator (-=) for an array and a scalar, without data type conversion.
     *
     * \tparam T : the data type of the array and the scalar
     * \tparam S : the size of the array
     *
     * \param[in,out] array  : the array, where the subtraction will be saved
     * \param[in]     scalar : the scalar, will be subtracted to array
     *
     * \returns the array after subtracting the scalar to each element
     *
     * \author 2011-04 - Josep Ramon Morros <ramon.morros@upc.edu> - Creation
     */
    template<typename T, std::size_t S>
    const boost::array<T,S>& operator-=( boost::array<T,S>& array, T scalar);

    /*!
     * Subtraction operator (-) between an array and a scalar, without data type conversion
     *
     * \tparam T : the data type of the array and the scalar
     * \tparam S : the size of the array
     *
     * \param[in] array  : the array of the subtraction; first operand
     * \param[in] scalar : the scalar of the subtraction; second operand
     *
     * \returns an array where each member contains values of the initial array minus the scalar
     *
     * \author 2008-01 - Marcel Alcoverro - Creation
     */
    template<typename T, std::size_t S>
    boost::array<T,S> operator-( const boost::array<T,S>& array, T scalar );
    
    /*!
     * Subtraction operator (-) between a scalar and an array, without data type conversion
     *
     * \tparam T : the data type of the array and the scalar
     * \tparam S : the size of the array
     *
     * \param[in] scalar : the scalar of the subtraction; first operand
     * \param[in] array  : the array of the subtraction; second operand
     *
     * \returns an array where each member contains the scalar minus the array values
     *
     * \author 2008-01 - Marcel Alcoverro - Creation
     */
    template<typename T, std::size_t S>
    boost::array<T,S> operator-( T scalar, const boost::array<T,S>& array );

    /*!
     * Multiplication-Assignment operator (*=) for two arrays, with implicit data type conversion from T2 to T1
     *
     * \tparam T1 : the data type of the first array
     * \tparam T2 : the data type of the second array; will be converted to T1
     * \tparam S  : the size of both arrays
     *
     * \param[in,out] a1 : first array operand, where the multiplication will be saved
     * \param[in]     a2 : second array operand
     *
     * \returns the element by element multiplication a1*a2 (also saved in a1)
     *
     * \author 2011-04 - Josep Ramon Morros <ramon.morros@upc.edu> - Creation
     * \author 2011-06 - Albert Gil - Template T2 added
     */
    template<typename T1, typename T2, std::size_t S>
    const boost::array<T1,S>& operator*=( boost::array<T1,S>& a1, const boost::array<T2,S>& a2);

    /*!
     * Multiplication operator (*) for two arrays, with implicit data type conversion from T2 to T1
     *
     * \tparam T1 : the data type of the first array
     * \tparam T2 : the data type of the second array; will be converted to T1
     * \tparam S  : the size of both arrays
     *
     * \param[in] a1 : first array operand
     * \param[in] a2 : second array operand
     *
     * \returns the element by element multiplication a1*a2
     *
     * \author 2008-01 - Marcel Alcoverro - Creation
     * \author 2011-06 - Albert Gil       - Template T2 added
     */
    template<typename T1, typename T2, std::size_t S>
    boost::array<T1,S> operator*( const boost::array<T1,S>& a1, const boost::array<T2,S>& a2 );

    /*!
     * Multiplication operator (*) to apply a mask and an array
     *
     * \tparam T2 : the data type of the second array and the output
     * \tparam S  : the size of both arrays
     *
     * \param[in] a1 : first array operand, the mask
     * \param[in] a2 : second array operand
     *
     * \returns the multiplication a2*a1, so the mask applied to a2.
     *
     * \note This specialization was necessary because the generic operator* with two templates <T1,T2>
     *       fails when T1 is boolean, just because T1 is also the returned type. In this specialization
     *       the returned type is T2.
     *
     * \author 2011-06 - Albert Gil - Creation, to once T2 added to the generic operator*
     */
    template<typename T2, std::size_t S>
    boost::array<T2,S> operator*( const boost::array<bool,S>& a1, const boost::array<T2,S>& a2 );

    //!
    //! \brief Overloading of operator *= for a array and a scalar
    //!
    //! \tparam T : the type of the data
    //! \tparam S : Size of the array 
    //!
    //! \param[in] input1 : First operand (array)
    //! \param[in] val    : Second operand (scalar)
    //!
    //! \return Product of the input operands (array)
    //!
    //! \author Josep Ramon Morros <ramon.morros@upc.edu>
    //!
    //! \date 08-4-2011
    //!
    template<typename T, std::size_t S>
    const boost::array<T,S>& operator*=( boost::array<T,S>& input1, T val);

    //!
    //! \brief Overloading of operator * for a imageplus array and a scalar
    //!
    //! \tparam T : Type of the scalar, the input and the output multiarrays 
    //! \tparam S : Size of the array 
    //!
    //! \param[in] input1 : First operand (array)
    //! \param[in] val    : Second operand (scalar)
    //!
    //! \return Product between the input operands (array)
    //!
    //! \author Marcel Alcoverro <marcel@gps.tsc.upc.edu>
    //! \date 18-1-2008
    //!
    template<typename T, std::size_t S>
    boost::array<T,S> operator*( const boost::array<T,S>& input1, T val );

    //!
    //! \brief Overloading of operator * for a scalar and a imageplus array
    //!
    //! \tparam T : Type of the scalar, the input and the output multiarrays 
    //! \tparam S : Size of the array 
    //!
    //! \param[in] val    : First operand (array)
    //! \param[in] input1 : Second operand (scalar)
    //!
    //! \return Product between the input operands (array)
    //!
    //! \author Marcel Alcoverro <marcel@gps.tsc.upc.edu>
    //! \date 18-1-2008
    //!
    template<typename T, std::size_t S>
    boost::array<T,S> operator*( T val, const boost::array<T,S>& input1);

    /*!
     * Division-Assignment operator (/=) for two arrays, with implicit data type conversion from T2 to T1
     *
     * \tparam T1 : the data type of the first array
     * \tparam T2 : the data type of the second array; will be converted to T1
     * \tparam S  : the size of both arrays
     *
     * \param[in,out] a1 : first array operand, where the division will be saved
     * \param[in]     a2 : second array operand
     *
     * \returns the element by element division of a1/a2 (it is also saved in a1)
     *
     * \author 2011-04 - Josep Ramon Morros <ramon.morros@upc.edu> - Creation
     * \author 2011-06 - Albert Gil - Template T2 added
     */
    template<typename T1, typename T2, std::size_t S>
    const boost::array<T1,S>& operator/=( boost::array<T1,S>& a1, const boost::array<T2,S>& a2);

    /*!
     * Division operator (/) for two arrays, with implicit data type conversion from T2 to T1
     *
     * \tparam T1 : the data type of the first array
     * \tparam T2 : the data type of the second array; will be converted to T1
     * \tparam S  : the size of both arrays
     *
     * \param[in] a1 : first array operand
     * \param[in] a2 : second array operand
     *
     * \returns the element by element division  a1/a2
     *
     * \author 2008-01 - Marcel Alcoverro - Creation
     * \author 2011-06 - Albert Gil       - Template T2 added
     */
    template<typename T1, typename T2, std::size_t S>
    boost::array<T1,S> operator/( const boost::array<T1,S>& a1, const boost::array<T2,S>& a2 );
    
    //!
    //! \brief Overloading of operator /= for a array and a scalar
    //!
    //! \tparam T : the type of the data
    //! \tparam S : Size of the array 
    //!
    //! \param[in] input1 : First operand (array)
    //! \param[in] val    : Second operand (scalar)
    //!
    //! \return Quotient of the input operands (array)
    //!
    //! \author Josep Ramon Morros <ramon.morros@upc.edu>
    //!
    //! \date 08-4-2011
    //!
    template<typename T, std::size_t S>
    const boost::array<T,S>& operator/=(boost::array<T,S>& input1, T val);

    //!
    //! \brief Overloading of operator / bettween an array and a scalar
    //!
    //! \tparam T  : Type of the data 
    //! \tparam S  : Size of the array 
    //! \tparam TS : Type of the scalar 
    //!
    //! \param[in] input1 : First operand (array)
    //! \param[in] val : Second operand (scalar)
    //!
    //! \return Quocient of the input operands (array)
    //!
    //! \author Albert Gil <agil@gps.tsc.upc.edu>
    //! \date 4-6-2009
    //!
    template<typename T, std::size_t S>
    boost::array<T,S> operator/( const boost::array<T,S>& input1, T val );

    //!
    //! \brief Overloading of operator * for a generic array and a bool array
    //!
    //! \tparam T : Type of the data 
    //! \tparam S : Size of the array 
    //!
    //! \param[in] input1 : First operand (array<bool,D>)
    //! \param[in] input2 : Second operand (array<T,D>)
    //!
    //! \return Element product of the input operands (array)
    //!
    //! \author Marcel Alcoverro <marcel@gps.tsc.upc.edu>
    //! \date 12-2-2008
    //!
//    template<typename T, std::size_t S>
//    boost::array<T,S> operator*( const boost::array<bool,S>& input2 , const boost::array<T,S>& input1 );

    //!
    //! \brief Overloading of operator * for a generic array and a bool array
    //!
    //! \tparam T : Type of the data 
    //! \tparam S : Size of the array 
    //!
    //! \param[in] input1 : First operand (array<T,D>)
    //! \param[in] input2 : Second operand (array<bool,D>)
    //!
    //! \return Element product of the input operands (array)
    //!
    //! \author Marcel Alcoverro <marcel@gps.tsc.upc.edu>
    //! \date 12-2-2008
    //!
//    template<typename T, std::size_t S>
//    boost::array<T,S> operator*( const boost::array<T,S>& input1, const boost::array<bool,S>& input2 );
    
    //!
    //! \brief sum function for two imageplus multiarrays
    //!
    //! \tparam T : Type of the data 
    //! \tparam S : Size of the array 
    //!
    //! \param[in]  input1 : First operand (array)
    //! \param[in]  input2 : Second operand (array)
    //! \param[out] output : sum of the input operands (array)
    //!
    //! \author Marcel Alcoverro <marcel@gps.tsc.upc.edu>
    //! \date 14-5-2008
    //!
    template<typename T, std::size_t S>
    void sum( const boost::array<T,S>& input1, const boost::array<T,S>& input2, boost::array<T,S>& output );

    //!
    //! \brief sum function for a imageplus array and a scalar
    //!
    //! \tparam T : Type of the data 
    //! \tparam S : Size of the array 
    //!
    //! \param[in]  input1 : First operand (array)
    //! \param[in]  val : Second operand (scalar)
    //! \param[out] output :  sum of the input operands (array)
    //!
    //! \author Marcel Alcoverro <marcel@gps.tsc.upc.edu>
    //! \date 14-5-2008
    //!
    template<typename T, std::size_t S>
    void sum( const boost::array<T,S>& input1, T val, boost::array<T,S>& output );
    
    //!
    //! \brief sum function for  a scalar and a imageplus array
    //!
    //! \tparam T : Type of the data 
    //! \tparam S : Size of the array 
    //!
    //! \param[in] val : Second operand (scalar)
    //! \param[in] input1 : First operand (array)
    //! \param[out] output : sum of the input operands (array)
    //!
    //! \author Marcel Alcoverro <marcel@gps.tsc.upc.edu>
    //! \date 14-5-2008
    //!
    template<typename T, std::size_t S>
    void sum( T val,const boost::array<T,S>& input1, boost::array<T,S>& output );

    //!
    //! \brief substraction function for  two imageplus multiarrays
    //!
    //! \tparam T : Type of the data 
    //! \tparam S : Size of the array 
    //!
    //! \param[in]  input1 : First operand (array)
    //! \param[in]  input2 : Second operand (array)
    //! \param[out] output : Difference between the input operands (array)
    //!
    //! \author Marcel Alcoverro <marcel@gps.tsc.upc.edu>
    //! \date 14-5-2008
    //!
    template<typename T, std::size_t S>
    void substract( const boost::array<T,S>& input1, const boost::array<T,S>& input2, boost::array<T,S>& output);

    //!
    //! \brief substraction function for a imageplus array and a scalar
    //!
    //! \tparam T : Type of the data 
    //! \tparam S : Size of the array 
    //!
    //! \param[in]  input1 : First operand (array)
    //! \param[in]  val : Second scalar (array)
    //! \param[out] output : Difference between the input operands (array)
    //!
    //! \author Marcel Alcoverro <marcel@gps.tsc.upc.edu>
    //! \date 14-5-2008
    //!
    template<typename T, std::size_t S>
    void substract( const boost::array<T,S>& input1, T val, boost::array<T,S>& output);
    
    //!
    //! \brief substraction function for a imageplus scalar and a array
    //!
    //! \tparam T : Type of the data 
    //! \tparam S : Size of the array 
    //!
    //! \param[in]  val : First operand (scalar)
    //! \param[in]  input1 : Second operand (array)
    //! \param[out] output : Difference between the input operands (array)
    //!
    //! \author Marcel Alcoverro <marcel@gps.tsc.upc.edu>
    //! \date 14-5-2008
    //!
    template<typename T, std::size_t S>
    void substract(  T val,const boost::array<T,S>& input1, boost::array<T,S>& output);

    /*!
     * Multiplication for two arrays, with implicit data type conversion from T2 to T1 and finally to T3
     * Multiplication is done element by element.
     *
     * \tparam T1 : the data type of the first array; will be converted to T3
     * \tparam T2 : the data type of the second array; will be converted to T3
     * \tparam T1 : the data type of the output array
     * \tparam S  : the size of both arrays
     *
     * \param[in]   a1 : first array operand
     * \param[in]   a2 : second array operand
     * \param[out] out : the multiplication element by element of a1*a2
     *
     * \author 2008-01 - Marcel Alcoverro - Creation
     * \author 2011-06 - Albert Gil       - Template T2 added
     */
    template<typename T1, typename T2, typename T3, std::size_t S>
    void product( const boost::array<T1,S>& a1, const boost::array<T2,S>& a2, boost::array<T3,S>& out );

    /*!
     * Multiplication to apply a mask to an array, with also an implicit conversion from T2 to T3
     * Multiplication is done element by element.
     *
     * \tparam T2 : the data type of the second array; will be converted to T3
     * \tparam S  : the size of all arrays
     *
     * \param[in]  mask : the mask array
     * \param[in] array : the array to apply the mask
     * \param[out]  out : the application of the mask element by element to the array
     *
     * \note This specialization was necessary because the generic product function with three templates <T1,T2,T3>
     *       fails when T1 is boolean, just because T2 is converted to T1 (bool) in the product and finally converted
     *       to the returned type (T3). In this specialization we convert bool (T1) to T2.
     *
     * \author 2011-06 - Albert Gil - Creation, because T2,T3 added to the generic product function
     */
    template<typename T2, typename T3, std::size_t S>
    void product( const boost::array<bool,S>& mask, const boost::array<T2,S>& array, boost::array<T3,S>& out );

    //!
    //! \brief product function for a imageplus array and a scalar
    //!
    //! \tparam T : Type of the data 
    //! \tparam S : Size of the array 
    //!
    //! \param[in]  input1 : First operand (array)
    //! \param[in]  val : Second operand (scalar)
    //! \param[out] output :  product of the input operands (array)
    //! 
    //! \author Marcel Alcoverro <marcel@gps.tsc.upc.edu>
    //! \date 14-5-2008
    //!
    template<typename T, std::size_t S>
    void product( const boost::array<T,S>& input1, T val, boost::array<T,S>& output );
    
    //!
    //! \brief product function for  a scalar and a imageplus array
    //!
    //! \tparam T : Type of the data 
    //! \tparam S : Size of the array 
    //!
    //! \param[in]  val : first operand (scalar)
    //! \param[in]  input1 : second operand (array)
    //! \param[out] output : product of the input operands (array)
    //!
    //! \author Marcel Alcoverro <marcel@gps.tsc.upc.edu>
    //! \date 14-5-2008
    //!
    template<typename T, std::size_t S>
    void product( T val,const boost::array<T,S>& input1, boost::array<T,S>& output );

    //!
    //! \brief division function for two imageplus multiarrays
    //!
    //! \tparam T : Type of the data 
    //! \tparam S : Size of the array 
    //!
    //! \param[in]  input1 : First operand (array)
    //! \param[in]  input2 : Second operand (array)
    //! \param[out] output : division of the input operands (array)
    //!
    //! \author Marcel Alcoverro <marcel@gps.tsc.upc.edu>
    //! \date 14-5-2008
    //!
    template<typename T, std::size_t S>
    void division( const boost::array<T,S>& input1, const boost::array<T,S>& input2, boost::array<T,S>& output );

    //!
    //! \brief division function for a imageplus array and a scalar
    //!
    //! \tparam T : Type of the data 
    //! \tparam S : Size of the array 
    //! \tparam TS : Type of the scalar 
    //!
    //! \param[in] input1  : First operand (array)
    //! \param[in] val     : Second operand (scalar)
    //! \param[out] output :  division of the input operands (array)
    //!
    //! \author Marcel Alcoverro <marcel@gps.tsc.upc.edu>
    //! \date 14-5-2008
    //!
    template<typename T, std::size_t S, typename TS>
    void division( const boost::array<T,S>& input1, TS val, boost::array<T,S>& output );
    
    //!
    //! \brief product function for  a scalar and a imageplus array
    //!
    //! \tparam T : Type of the data 
    //! \tparam S : Size of the array 
    //!
    //! \param[in] val : first operand (scalar)
    //! \param[in] input1 : second operand (array)
    //! \param[in] output : division of the input operands (array)
    //!
    //! \author Marcel Alcoverro <marcel@gps.tsc.upc.edu>
    //! \date 14-5-2008
    //!
    template<typename T, std::size_t S>
    void division( T val,const boost::array<T,S>& input1, boost::array<T,S>& output );
} // namespace imageplus


//
//  Implementation
// 
namespace imageplus
{
    template<typename T1, typename T2, std::size_t S>
    const boost::array<T1,S>& operator+=( boost::array<T1,S>& input1, const boost::array<T2,S>& input2 )
    {
        std::transform(input1.begin(),
                       input1.end(),
                       input2.begin(),
                       input1.begin(),
                       std::plus<T1>());

        return input1;
    }

    template<typename T1, typename T2, std::size_t S>
    boost::array<T1,S> operator+( const boost::array<T1,S>& input1, const boost::array<T2,S>& input2 )
    {
        boost::array<T1,S> out  = input1;
        return             out += input2;
    }

    template<typename T, std::size_t S>
    const boost::array<T,S>& operator+=( boost::array<T,S>& input1, T val )
    {
        std::transform(input1.begin(),
                       input1.end(),
                       input1.begin(),
                       std::bind2nd(std::plus<T>(),val));

        return input1;
    }

    template<typename T, std::size_t S>
    boost::array<T,S> operator+( const boost::array<T,S>& input1, T val )
    {
        boost::array<T,S> out  = input1;
        return            out += val;
    }

    template<typename T, std::size_t S>
    boost::array<T,S> operator+( T val, const boost::array<T,S>& input1 )
    {
        boost::array<T,S> out  = input1;
        return            out += val;
    }

    template<typename T1, typename T2, std::size_t S>
    const boost::array<T1,S>& operator-=( boost::array<T1,S>& input1, const boost::array<T2,S>& input2 )
    {
        std::transform(input1.begin(),
                       input1.end(),
                       input2.begin(),
                       input1.begin(),
                       std::minus<T1>());

        return input1;
    }

    template<typename T1, typename T2, std::size_t S>
    boost::array<T1,S> operator-( const boost::array<T1,S>& input1, const boost::array<T2,S>& input2 )
    {
        boost::array<T1,S> out  = input1;
        return             out -= input2;
    }

    template<typename T, std::size_t S>
    const boost::array<T,S>& operator-=( boost::array<T,S>& input1, T val )
    {
        std::transform(input1.begin(),
                       input1.end(),
                       input1.begin(),
                       std::bind2nd(std::minus<T>(),val));

        return input1;
    }

    template<typename T, std::size_t S>
    boost::array<T,S> operator-( const boost::array<T,S>& input1, T val )
    {
        boost::array<T,S> out  = input1;
        return            out -= val;
    }

    template<typename T, std::size_t S>
    boost::array<T,S> operator-( T val, const boost::array<T,S>& input1 )
    {
        boost::array<T,S> out;
        out.assign(val);
        return out -= input1;
    }

    template<typename T1, typename T2, std::size_t S>
    const boost::array<T1,S>& operator*=( boost::array<T1,S>& input1, const boost::array<T2,S>& input2 )
    {
        std::transform(input1.begin(),
                       input1.end(),
                       input2.begin(),
                       input1.begin(),
                       std::multiplies<T1>());

        return input1;
    }

    template<typename T1, typename T2, std::size_t S>
    boost::array<T1,S> operator*( const boost::array<T1,S>& input1, const boost::array<T2,S>& input2 )
    {
        boost::array<T1,S> out  = input1;
        return             out *= input2;
    }

    template<typename T2, std::size_t S>
    boost::array<T2,S> operator*( const boost::array<bool,S>& input1, const boost::array<T2,S>& input2 )
    {
        boost::array<T2,S> out  = input2;
        return             out *= input1;
    }

    template<typename T, std::size_t S>
    const boost::array<T,S>& operator*=( boost::array<T,S>& input1, T val )
    {
        std::transform(input1.begin(),
                       input1.end(),
                       input1.begin(),
                       std::bind2nd(std::multiplies<T>(),val));

        return input1;
    }

    template<typename T, std::size_t S>
    boost::array<T,S> operator*( const boost::array<T,S>& input1, T val )
    {
        boost::array<T,S> out  = input1;
        return            out *= val;
    }

    template<typename T, std::size_t S>
    boost::array<T,S> operator*( T val, const boost::array<T,S>& input1 )
    {
        boost::array<T,S> out  = input1;
        return            out *= val;
    }

    template<typename T1, typename T2, std::size_t S>
    const boost::array<T1,S>& operator/=( boost::array<T1,S>& input1, const boost::array<T2,S>& input2 )
    {
        std::transform(input1.begin(),
                       input1.end(),
                       input2.begin(),
                       input1.begin(),
                       std::divides<T1>());

        return input1;
    }
    
    template<typename T1, typename T2, std::size_t S>
    boost::array<T1,S> operator/( const boost::array<T1,S>& input1, const boost::array<T2,S>& input2 )
    {
        boost::array<T1,S> out  = input1;
        return             out /= input2;
    }

    template<typename T, std::size_t S>
    const boost::array<T,S>& operator/=(boost::array<T,S>& input1, T val)
    {
        std::transform(input1.begin(),
                       input1.end(),
                       input1.begin(),
                       std::bind2nd(std::divides<T>(),val));

        return input1;
    }

    template<typename T, std::size_t S>
    boost::array<T,S> operator/( const boost::array<T,S>& input1, T val )
    {
        boost::array<T,S> out  = input1;
        return            out /= val;
    }

    template<typename T, std::size_t S>
    void sum( const boost::array<T,S>& input1, const boost::array<T,S>& input2, boost::array<T,S>& output )
    {
        std::transform(input1.begin(),
                       input1.end(),
                       input2.begin(),
                       output.begin(),
                       std::plus<T>());
    }
    
    template<typename T, std::size_t S>
    void sum( const boost::array<T,S>& input1, T val, boost::array<T,S>& output )
    {
        std::transform(input1.begin(),
                       input1.end(),
                       output.begin(),
                       std::bind2nd(std::plus<T>(),val));
    }

    template<typename T, std::size_t S>
    void sum( T val,const boost::array<T,S>& input1, boost::array<T,S>& output )
    {
        std::transform(input1.begin(),
                       input1.end(),
                       output.begin(),
                       std::bind2nd(std::plus<T>(),val));        
    }
    
    template<typename T, std::size_t S>
    void substract( const boost::array<T,S>& input1, const boost::array<T,S>& input2, boost::array<T,S>& output)
    {
        std::transform(input1.begin(),
                       input1.end(),
                       input2.begin(),
                       output.begin(),
                       std::minus<T>());
    }
    
    template<typename T, std::size_t S>
    void substract( const boost::array<T,S>& input1, T val, boost::array<T,S>& output)
    {
        std::transform(input1.begin(),
                       input1.end(),
                       output.begin(),
                       std::bind2nd(std::minus<T>(),val));
    }
    
    template<typename T, std::size_t S>
    void substract(  T val,const boost::array<T,S>& input1, boost::array<T,S>& output)
    {
        output.assign(val);

        std::transform(output.begin(),
                       output.end(),
                       input1.begin(),
                       output.begin(),
                       std::minus<T>());
    }
        
    template<typename T1, typename T2, typename T3, std::size_t S>
    void product( const boost::array<T1,S>& input1, const boost::array<T2,S>& input2, boost::array<T3,S>& output )
    {
        std::transform(input1.begin(),
                       input1.end(),
                       input2.begin(),
                       output.begin(),
                       std::multiplies<T1>());
    }
    template<typename T2, typename T3, std::size_t S>
    void product( const boost::array<bool,S>& a1, const boost::array<T2,S>& a2, boost::array<T3,S>& out )
    {
        return product(a2,a1,out);
    }

    
    template<typename T, std::size_t S>
    void product( const boost::array<T,S>& input1, T val, boost::array<T,S>& output )
    {
        std::transform(input1.begin(),
                       input1.end(),
                       output.begin(),
                       std::bind2nd(std::multiplies<T>(),val));
    }
    
    template<typename T, std::size_t S>
    void product( T val,const boost::array<T,S>& input1, boost::array<T,S>& output )
    {
        std::transform(input1.begin(),
                       input1.end(),
                       output.begin(),
                       std::bind2nd(std::multiplies<T>(),val));
    }
    
    template<typename T, std::size_t S>
    void division( const boost::array<T,S>& input1, const boost::array<T,S>& input2, boost::array<T,S>& output )
    {
        std::transform(input1.begin(),
                       input1.end(),
                       input2.begin(),
                       output.begin(),
                       std::divides<T>());
    }
    
    template<typename T, std::size_t S, typename TS>
    void division( const boost::array<T,S>& input1, TS val, boost::array<T,S>& output )
    {
        std::transform(input1.begin(),
                       input1.end(),
                       output.begin(),
                       std::bind2nd(std::divides<T>(),val));
    }

    template<typename T, std::size_t S>
    void division( T val,const boost::array<T,S>& input1, boost::array<T,S>& output )
    {
        output.assign(val);
        std::transform(output.begin(),
                       output.end(),
                       input1.begin(),
                       output.begin(),
                       std::divides<T>());
    }
}

#endif //IMAGEPLUS_CORE_ARRAY_ARITHMETIC_HPP
