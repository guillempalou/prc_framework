/// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------

/*!
 * \file context_gpu.hpp
 *
 * Interface for OpenCL and OpenGL Contexts and for the GL Shading Language.
 *
 * File structure:
 *
 * - USE_OPENGL: OpenGL Config
 *   - MSVC config
 *   - not MSVC config
 *     - OffscreenGL
 *   - Shaders Config (msvc?)
 *
 * - USE_OPENCL: OpenCL Config
 */

#ifndef IMAGEPLUS_CONTEXT_GPU_HPP
#define IMAGEPLUS_CONTEXT_GPU_HPP


#include <cstring>
#include <string>


/*
 * \defgroup stringcode Code Strings
 *
 * Macros to create strings from code.\n
 * They are very useful for OpenCL Kernels and OpenGL Shaders
 *
 * \todo create an usage example?
 */

/*!
 * Converts code to string. Useful for GPU functions
 *
 * \ingroup stringcode
 */
#define __string_from_code(...) #__VA_ARGS__"\n"

/*!
 * Converts code to string and adds original code. Useful for GPU-CPU shared structures
 *
 * \ingroup stringcode
 */
#define __string_and_code(...) #__VA_ARGS__"\n"; __VA_ARGS__



#ifdef USE_OPENGL

#include <imageplus/core/imageplus_types.hpp>
#include <imageplus/core/exceptions.hpp>

/*!
 * \todo This is necessary for some cerr traces... we should use another logging system!
 */
#include <iostream>
#include <stdio.h> //deprecated fopen etc.



/******************************************
 *        OpenGL Configurations
 ******************************************/


/*
 * OpenGL and OpenGL Extensions configuration.
 * Different setup for MSVC.
 */
#ifdef MSVC

#include <GL/glew.h> //needed for the extensions
#include <GL/wglew.h> //needed for the extensions

#include <GL/glut.h>  // Header file for the GLUT Library
#include <GL/glu.h>
#include <GL/gl.h>

#include <GL/glext.h>

//Remove the glew definition, as it has been reported that this call crashes in several windows drivers
#ifdef glLoadTransposeMatrixf
#undef glLoadTransposeMatrixf
#endif

//!
//! \brief Check GL extensions needed by Imageplus and MSVC
//!

inline
void check_msvc_extensions()
{
    std::cout << "Checking Extensions... " << std::endl;
#ifdef GL_ARB_transpose_matrix
    std::cout << "ARB_transpose IS defined " << std::endl;
#endif
    if ( glewIsSupported("GL_VERSION_1_3") )
    {
        std::cout << "GL 1.3 supported" << std::endl;
    }
    if ( glewIsSupported("GL_ARB_shading_language_100") )
    {
        std::cout << "Shading Language supported" << std::endl;
    }
}


namespace imageplus
{
	/*
	 * \brief Alternative definition of glLoadTransposeMatrixf
	 *
	 * Windows does not support newer versions of OpenGL, so we have to retrieve the function pointer
	 *
	 * \param[in] m : GL 4x4 Matrix
	 */
    void glLoadTransposeMatrixf ( GLfloat * m);
}

inline
void imageplus::glLoadTransposeMatrixf ( GLfloat * m)
{
    PFNGLLOADTRANSPOSEMATRIXFPROC LoadTransposeMatrixf = (PFNGLLOADTRANSPOSEMATRIXFPROC) wglGetProcAddress("glLoadTransposeMatrixf");
    (*LoadTransposeMatrixf)(m);

//    //Manual Transpose
//    GLfloat *t;
//    t= new GLfloat[16];
//    std::size_t row, col;
//    for (std::size_t i=0; i < 4; ++i )
//    {
//      for (std::size_t j=i; j < 4; ++j )
//      {
//          *(t+i*4+j)=*(m+j*4+i);
//          *(t+j*4+i)=*(m+i*4+j);
//      }
//    }
//    glLoadMatrixf ((const GLfloat*)t);
//    delete[] t;
}

#else // not MSVC

/*!
 * \todo is there a better way to control the GL Extensions?
 */
#ifndef GL_GLEXT_PROTOTYPES
#define GL_GLEXT_PROTOTYPES
#endif

#include <GL/glut.h>  // Header file for the GLUT Library
#include <GL/glu.h>   // Header file for the GLU Library
#include <GL/gl.h>    // Header file for the GL Library

#include <GL/glx.h>
namespace imageplus
{
    //!
    //! Class to create and manage an offscreen OpenGl context
    //! and its associated RGBA, stencil and depth buffers
    //!
    //! \todo Only an X11 implementation is currently available
    //! \todo This class is implemented in the header to avoid conflicts
    //!       between the X11 library and OpenMesh.
    //!       See the undef commands below the class.
    //!
    //! \author Jordi Salvador <jordi.salvador@upc.edu>
    //! \date   31-03-2010
    //!
    class OffscreenGL
    {
    public:
        //!
        //! \brief Constructor
        //! \param[in] width : width in pixels of the render buffers
        //! \param[in] height : height in pixels of the render buffers
        //!
        OffscreenGL( const uint16 width, const uint16 height )
        {
            //Open a connection to the X server
            init_display();

            //Request a suitable framebuffer configuration
            static int fbAttribs[]=
            {
                GLX_DRAWABLE_TYPE, GLX_PBUFFER_BIT,
                GLX_RENDER_TYPE,   GLX_RGBA_BIT,
                GLX_RED_SIZE,      1, //largest available will be taken when '1' requested
                GLX_GREEN_SIZE,    1,
                GLX_BLUE_SIZE,     1,
                GLX_ALPHA_SIZE,    1,
                GLX_DEPTH_SIZE,    1,
                GLX_STENCIL_SIZE,  1,
                None
            };
            int n;
            GLXFBConfig * cfg=glXChooseFBConfig( _dpy, DefaultScreen( _dpy ), fbAttribs, &n );
            if( n == 0 )
                throw ImagePlusError( "ERROR( OffscreenGL ) : Unable to find a suitable framebuffer configuration. Try using 'VirtualGL'" );

            //Create a GLX context for OpenGL rendering
            _context=glXCreateNewContext( _dpy, cfg[0], GLX_RGBA_TYPE, NULL, True );
            if( glXIsDirect( _dpy, _context ) != True )
                std::cerr<<"WARNING( OffscreenGL ) : Direct rendering not available. Rendering through the X server"<<std::endl;

            //Create a GLX Pbuffer to associate it with the frame buffer configuration
            static int pbAttribs[]=
            {
                GLX_PBUFFER_WIDTH,      width,
                GLX_PBUFFER_HEIGHT,     height,
                GLX_PRESERVED_CONTENTS, True,
                None
            };
            _pbuffer=glXCreatePbuffer( _dpy, cfg[0], pbAttribs );

            //Free fbconfig list
            XFree( cfg );

            make_active();
        }

        //!
        //! \brief Destructor
        //!
        ~OffscreenGL()
        {
            glXDestroyPbuffer( _dpy, _pbuffer );
            glXDestroyContext( _dpy, _context );
            delete_display();
        }

        //!
        //! \brief Sets this GL context as active in multi-context scenarios
        //!
        void make_active()
        {
            //Bind the GLX context to the Pbuffer
            glXMakeContextCurrent( _dpy, _pbuffer, _pbuffer, _context );
        }

    private:
        //! GLX Pixel buffer
        GLXPbuffer _pbuffer;
        //! GLX Context
        GLXContext _context;
        //! Number of instances
        static int16 _ninst;
        //! Display, xserver connection
        static Display * _dpy;
        //! Creates xserver connection if necessary
        static void init_display()
        {
            if( _ninst == 0 )
                _dpy=XOpenDisplay( NULL );
            if( _dpy == NULL )
                throw ImagePlusError( "ERROR( OffscreenGL ) : Unable to open a connection to the X server" );
            ++_ninst;
        }

        //! Deletes xserver connection if possible
        static void delete_display()
        {
            if( _ninst == 1 )
                XCloseDisplay( _dpy );
            --_ninst;
        }
    };

    /*
     * We should undef some bad defines of X11 lib (they have conflicts with OpenMesh and PCL and Eigen)
     */
    #ifdef Bool
    #undef Bool
    #endif
    #ifdef True
    #undef True
    #endif
    #ifdef False
    #undef False
    #endif
    #ifdef None
    #undef None
    #endif
    #ifdef Status
    #undef Status
    #endif
	#ifdef Success // Used in PCL
	#undef Success
	#endif


} // imageplus
#endif // MSVC


namespace imageplus
{
    /*
     * Unused or deprecated configuration?
     */

    //#include <GL/glext.h> // Header file for the GL Extensions
    //#ifdef GL_VERSION_1_3
    //#undef GL_VERSION_1_3
    //#endif
    //
    //#ifndef FGAPI
    //    #include <GL/freeglut.h> //Something more is needed
    //#endif
    //#include <GL/freeglut_ext.h> // mainly used for mouses' wheel


    /********************************************
     *           OpenGL Shaders
     ********************************************/

    /*!
     * \returns a string containing the text in
     *          a vertex/fragment shader source file.
     *
     *  \param[in] file_path : Input file path containing the source code
     */
    static
    char* shader_load_source(const char *file_path)
    {
        const size_t blockSize = 512;
        FILE *fp;
        char buf[blockSize];
        char *source = NULL;
        size_t tmp, sourceLength = 0;

        /* open file */
        fp = fopen(file_path, "r");
        if(!fp) {
            fprintf(stderr, "shader_load_source(): Unable to open %s for reading\n", file_path);
            return NULL;
        }

        /* read the entire file into a string */
        while((tmp = fread(buf, 1, blockSize, fp)) > 0) {
            char *newSource = (char *)malloc(sourceLength + tmp + 1);
            if(!newSource) {
                fprintf(stderr, "shader_load_source(): malloc failed\n");
                if(source)
                    free(source);
                return NULL;
            }

            if(source)
            {
                std::memcpy(newSource, source, sourceLength);
                free(source);
            }
            std::memcpy(newSource + sourceLength, buf, tmp);

            source = newSource;
            sourceLength += tmp;
        }

        /* close the file and null terminate the string */
        fclose(fp);
        if(source)
            source[sourceLength] = '\0';

        return source;
    }

    /*!
     * \brief Returns a shader object containing a shader
     *  compiled from the given GLSL shader file.
     *
     * \param[in] type : Shader type
     * \param[in] file_path : Input file with the source code
     *
     * \return 0 in case of error
     */
    static
    GLuint shader_compile_from_file(GLenum type, const char *file_path)
    {
        char *source;
        GLuint shader;
        GLint length, result;

        /* get shader source */
        source = shader_load_source(file_path);
        if(!source)
            return 0;

        /* create shader object, set the source, and compile */
        shader = glCreateShader(type);
        length = std::strlen(source);
        glShaderSource(shader, 1, (const char **)&source, &length);
        glCompileShader(shader);
        free(source);

        /* make sure the compilation was successful */
        glGetShaderiv(shader, GL_COMPILE_STATUS, &result);
        if(result == GL_FALSE)
        {
            char *log;

            /* get the shader info log */
            glGetShaderiv(shader, GL_INFO_LOG_LENGTH, &length);
            log = (char *)malloc(length);
            glGetShaderInfoLog(shader, length, &result, log);

            /* print an error message and the info log */
            fprintf(stderr, "shader_compile_from_file(): Unable to compile %s: %s\n", file_path, log);
            free(log);

            glDeleteShader(shader);
            return 0;
        }

        return shader;
    }

    /*!
     * \brief Returns a shader object containing a shader
     *  compiled from the given GLSL shader file.
     *
     * \param[in] type : Shader type
     * \param[in] shader_src : Shader source code in string
     *
     *  \return 0 in case of error
     */
    static
    GLuint shader_compile_from_string(GLenum type, const std::string & shader_src)
    {

        GLuint shader;
        GLint length, result;

        /* create shader object, set the source, and compile */
        shader = glCreateShader(type);
        length = shader_src.size();
        const char* src=shader_src.c_str();
        glShaderSource(shader, 1, &src, &length);
        glCompileShader(shader);


        /* make sure the compilation was successful */
        glGetShaderiv(shader, GL_COMPILE_STATUS, &result);
        if(result == GL_FALSE)
        {
            char *log;

            /* get the shader info log */
            glGetShaderiv(shader, GL_INFO_LOG_LENGTH, &length);
            log = (char *)malloc(length);
            glGetShaderInfoLog(shader, length, &result, log);

            /* print an error message and the info log */
            fprintf(stderr, "shader_compile_from_string(): Unable to compile %s: %s\n", shader_src.c_str(), log);
            free(log);

            glDeleteShader(shader);
            return 0;
        }

        return shader;
    }

    /*!
     * \brief Compiles and attaches a shader of the
     * given type to the given program object.
     *
     *  \param[in] program : Program identifier
     *  \param[in] type : Shader type (GL_VERTEX_SHADER or GL_FRAGMENT_SHADER)
     *  \param[in] file_path : name of the file containing the shader code
     *
     *  \todo why is not static as the previous ones?
     */
    inline
    void shader_attach_from_file(GLuint program, GLenum type, const char *file_path)
    {
        /* compile the shader */
        GLuint shader = shader_compile_from_file(type, file_path);
        if(shader != 0)
        {
            /* attach the shader to the program */
            glAttachShader(program, shader);

            /* delete the shader - it won't actually be
             * destroyed until the program that it's attached
             * to has been destroyed */
            glDeleteShader(shader);
        }
    }

    /*!
     * \brief Compiles and attaches a shader of the
     * given type to the given program object.
     *
     *  \param[in] program : Program identifier
     *  \param[in] type : Shader type (GL_VERTEX_SHADER or GL_FRAGMENT_SHADER)
     *  \param[in] shader_src : string containing the source code of the shader
     */
    inline
    void shader_attach_from_string(GLuint program, GLenum type, const std::string & shader_src )
    {
        /* compile the shader */
        GLuint shader = shader_compile_from_string(type, shader_src);
        if(shader != 0)
        {
            /* attach the shader to the program */
            glAttachShader(program, shader);

            /* delete the shader - it won't actually be
             * destroyed until the program that it's attached
             * to has been destroyed */
            glDeleteShader(shader);
        }
    }
} //imageplus

#endif //USE_OPENGL


#ifdef USE_OPENCL

/******************************************
 *        OpenCL Configurations
 ******************************************/

#define __CL_ENABLE_EXCEPTIONS
//#include <cl.hpp>
#include <CL/cl.hpp>


#include <list>
#include <imageplus/core/coord3d.hpp>

/*
 * \brief Converts constant to string. Useful for define constant in host code
 */
#define __opencl_constant(x) opencl_constant_impl( #x, x )

inline
std::string opencl_constant_impl( const char * name, const int value )
{
    char buffer[500];
    sprintf( buffer, "#define %s %d\n", name, value );
    return std::string( buffer );
}

namespace imageplus
{
	/* FunctionGPU: object to create a kernel: function declared in a program and executed on an OpenCL device */
	typedef cl::KernelFunctor FunctionGPU;
	/* LocalSpaceGPU: Local address wrapper*/
	typedef cl::LocalSpaceArg LocalSpaceGPU;
	/* BufferGPU: Memory buffer interface*/
	typedef cl::Buffer BufferGPU;
	/* ImageGPU: Image interface for 2D images*/
	typedef cl::Image2D ImageGPU;
	/* VolumeGPU: Image interface for 3D images*/
	typedef cl::Image3D VolumeGPU;
	/* CodeGPU: string with OpenCL code*/
	typedef std::string CodeGPU;

#ifdef USE_OPENGL
	/* Generic shared GL object, instances below: */
	typedef cl::Memory 			ObjectGL;
	/* OpenGL-OpenCL shared buffer */
	typedef cl::BufferGL		BufferGPU_GL;
	/* OpenGL-OpenCL shared RenderBuffer */
	typedef cl::BufferRenderGL	BufferRenderGPU_GL;
	/* OpenGL-OpenCL shared 2D texture */
	typedef cl::Image2DGL 		ImageGPU_GL;
	/* OpenGL-OpenCL shared 3D texture */
	typedef cl::Image3DGL 		VolumeGPU_GL;
#endif
	
	/*
	 * \brief Standard types for CPU-GPU interaction, useful for shared structures
	 *  Automatically added
	 *  motivation: cl_char4 is the type defined in host program (CPU)
	 *              in device code (GPU) is defined char4 (vector with 4 chars)
	 *              use cl_ prefix is recommended to avoid confusion
	 */
    const CodeGPU cl_src_basic_types=__string_from_code(
    		
        typedef char   cl_char;
        typedef char2  cl_char2;
        typedef char4  cl_char4;
        typedef char8  cl_char8;
        typedef char16 cl_char16;
        
        typedef uchar   cl_uchar;
        typedef uchar2  cl_uchar2;
        typedef uchar4  cl_uchar4;
        typedef uchar8  cl_uchar8;
        typedef uchar16 cl_uchar16;
        
        typedef short   cl_short;
        typedef short2  cl_short2;
        typedef short4  cl_short4;
        typedef short8  cl_short8;
        typedef short16 cl_short16;
        
        typedef ushort   cl_ushort;
        typedef ushort2  cl_ushort2;
        typedef ushort4  cl_ushort4;
        typedef ushort8  cl_ushort8;
        typedef ushort16 cl_ushort16;
        
        typedef int   cl_int;
        typedef int2  cl_int2;
        typedef int4  cl_int4;
        typedef int8  cl_int8;
        typedef int16 cl_int16;
        
        typedef uint   cl_uint;
        typedef uint2  cl_uint2;
        typedef uint4  cl_uint4;
        typedef uint8  cl_uint8;
        typedef uint16 cl_uint16;
        
        typedef long   cl_long;
        typedef long2  cl_long2;
        typedef long4  cl_long4;
        typedef long8  cl_long8;
        typedef long16 cl_long16;
        
        typedef ulong   cl_ulong;
        typedef ulong2  cl_ulong2;
        typedef ulong4  cl_ulong4;
        typedef ulong8  cl_ulong8;
        typedef ulong16 cl_ulong16;
        
        typedef float   cl_float;
        typedef float2  cl_float2;
        typedef float4  cl_float4;
        typedef float8  cl_float8;
        typedef float16 cl_float16;
    );
    
    /*
     * \brief Some utilities to opencl code
     * /Automatically added
     *
     *   buffer_access   Returns a standard linear position for a work item in up to 3-dimensional space:z*sx*sy+y*sx+x
     *
     *   not_valid_thread_   Check if the current work-item is valid. Should be the first instruction in each kernel
	 *     motivation: if global_group isn't divisible by local_group some work-items musn't execute code
     */
    const CodeGPU cl_src_thread_access=__string_from_code(

        cl_ulong buffer_access_3d( cl_uint4 dims, cl_uint4 id )
        {
            return (id.z*dims.y+id.y)*dims.x+id.x;
        }
              
        cl_ulong buffer_access_2d( cl_uint2 dims, cl_uint2 id )
        {
            return id.y*dims.x+id.x;
        }
 
        cl_int not_valid_thread_3d (cl_uint4 dims)
        {
        	cl_uint4 ret=(cl_uint4)(get_global_id(0),get_global_id(1),get_global_id(2),0);
        	if ( ret.x<dims.x && ret.y<dims.y && ret.z<dims.z )
        		return 0;
        	
        	return 1;
        }
        
        cl_int not_valid_thread_2d (cl_uint2 dims) 
        {
        	cl_uint2 ret=(cl_uint2)(get_global_id(0),get_global_id(1));
        	if ( ret.x<dims.x && ret.y<dims.y )                            //no accepta ret < dims!!!!!!!!!!!!!!!
        		return 0;

        	return 1;
        }
        
        cl_int not_valid_thread_1d (cl_uint dims)
        {
        	cl_uint ret=get_global_id(0);
        	if ( ret < dims )
        		return 0; //thread valid!

        	return 1; //thread no valid
        }
    );
    
    //It is not recognized by our GPUs, resulting in a warning from the compiler!
    const CodeGPU cl_src_addressable_byte( "#pragma OPENCL EXTENSION cl_khr_byte_addressable_store : enable\n" );
    
    //For shared OpenCL-OpenGL contexts
    //It is not recognized by our GPUs, resulting in a warning from the compiler!
    const CodeGPU cl_src_shared_context( "#pragma OPENCL EXTENSION cl_khr_gl_sharing : enable\n" );
    
    /*
     * \brief class to create OpenCL interface
     */
    class ContextGPU
    {
    public:

        /*
         * \brief constructor
         * \param[in] source: OpenCL code, should be created with __string_from_code / __sting_and_code / __opencl_constant
         * \param[in] glshare: OpenCL-OpenGL interaction. True if required
         */
    	ContextGPU(){};
        ContextGPU( const CodeGPU & source, bool glshare=false )
        {
        	try
        	{

	            std::vector<cl::Device> devices;
	            {
	                std::vector<cl::Platform> platforms;
	                cl::Platform::get( &platforms );
	                
	                if( platforms.size() > 1 )
	                    std::cout<<platforms.size()<<" available platforms"<<std::endl;
	                
	                uint32 curr_platform=0;
	                while( devices.size() == 0 && curr_platform < platforms.size() )
	                    platforms[curr_platform++].getDevices( CL_DEVICE_TYPE_GPU, &devices );
//	                std::cout<<devices.size()<<" detected devices"<<std::endl;
	                if(devices.size() > 1) devices.pop_back(); // HACK: not possible to create a shared context with gpu and 2 devices
//	                std::cout<<devices.size()<<" detected devices"<<std::endl;
	            }
	            
	            if( !glshare )
	                _context=cl::Context( devices ); 
	            else
	            {
#ifdef USE_OPENGL
#ifndef MSVC
	                cl_context_properties shared_props[]=
	                {
	                        CL_GL_CONTEXT_KHR, (cl_context_properties)glXGetCurrentContext(),
	                        CL_GLX_DISPLAY_KHR, (cl_context_properties)glXGetCurrentDisplay(),
	                        0
	                };
#else //MSVC
//                    cl_context_properties shared_props[]=
//                    {
//                        CL_GL_CONTEXT_KHR, (cl_context_properties)wglGetCurrentContext(),
//                        CL_WGL_HDC_KHR, (cl_context_properties)wglGetCurrentDC(),
//                        0
//                    };
	                throw ImagePlusError( "ERROR( ContextGPU ) : No Windows implementation" );
#endif //ifndef MSVC
	                _context=cl::Context( devices, shared_props );
#else  // !USE_OPENGL
	                throw ImagePlusError( "ERROR( ContextGPU ) : OpenGL required for shared context" );
#endif //ifdef USE_OPENGL
	            }
            
	            CodeGPU csource=cl_src_basic_types+cl_src_thread_access+source;
	            
	            _program=cl::Program( _context, cl::Program::Sources( 1, std::make_pair( csource.c_str(), csource.length() ) ) );
	            try
	            {
	                _program.build( devices );
	            }
	            catch( cl::Error e )
	            {
	                for( uint16 d=0; d < devices.size(); ++d )
	                    std::cerr<<"ERROR (OpenCL build, device "<<d<<"):"<<std::endl<<_program.getBuildInfo<CL_PROGRAM_BUILD_LOG>( devices[d] )<<std::endl;
	                throw e;
	            }
	            cl::UnloadCompiler();
	            
	            _queues.push_back( cl::CommandQueue( _context, devices[0] ) );
	            _queue_access.push_back( &_queues.back() );
	            _device=0;
        	}
         	catch( cl::Error err )
         	{
         		std::cerr<<"ERROR: "<<err.what()<<"("<<err.err()<<")"<<std::endl;
         		throw err;
         	}
        }
        
        /*
         * \brief add new device in the ContextGPU
         */
        bool add_device()
        {
        	try
        	{
	            uint16 num_devices=_queues.size();
	            std::vector<cl::Device> devices=_context.getInfo<CL_CONTEXT_DEVICES>();
	            if( devices.size() > num_devices )
	            {
	                _queues.push_back( cl::CommandQueue( _context, devices[num_devices] ) );
	                _queue_access.push_back( &_queues.back() );
	                return true;
	            }
	            else
	                return false;
	    	}
	     	catch( cl::Error err )
	     	{
	     		std::cerr<<"ERROR: "<<err.what()<<"("<<err.err()<<")"<<std::endl;
	     		throw err;
	     	}
        }
        
        /*
         * \brief choose the current device
         */
        void set_device( const uint16 device )
        {
            if( device < _queues.size() )
                _device=device;
            else
                std::cerr<<"WARNING: Ignoring wrong device ID "<<device<<std::endl;
        }

        /*
         * \brief create new FunctionGPU, kernels with work-items organized in 1 dimension
         * \param[in] function: string with the kernel code
         * \param[in] image_dims: global dimension
         * \param[in] local_dims: local dimension
         */
        FunctionGPU function( const std::string & function, cl_uint & image_dims, cl_uint & local_dims )
        {
            try
            {
            	
	        	cl_uint global_dims;
	        	global_dims=image_dims;
	        	
	        	if(global_dims%local_dims != 0)
	        		global_dims+=(local_dims-global_dims%local_dims);

        	
                _kernels.push_back( cl::Kernel( _program, function.c_str() ) );
                return _kernels.back().bind( *_queue_access[_device], cl::NDRange(global_dims), cl::NDRange(local_dims) );
            }
            catch( cl::Error e )
            {
                std::cerr<<"ERROR (ContextGPU::function): Creating kernel \""<<function<<"\" ("<<e.err()<<")"<<std::endl;
                throw e;
            }
        }
        
        /*
         * \brief create new FunctionGPU, kernels with work-items organized in 2 dimensions
         * \param[in] function: string with the kernel code
         * \param[in] image_dims: global dimensions
         * \param[in] local_dims: local dimensions
         */
        FunctionGPU function( const std::string & function, cl_uint2 & image_dims, cl_uint2 & local_dims )
        {
            try
            {
            	
	        	cl_uint2 global_dims;
	        	global_dims=image_dims;
	        	
	        	if(global_dims.x%local_dims.x != 0)
	        		global_dims.x+=(local_dims.x-global_dims.x%local_dims.x);
	        	
	        	if(global_dims.y%local_dims.y != 0)
	        		global_dims.y+=(local_dims.y-global_dims.y%local_dims.y);
        	
                _kernels.push_back( cl::Kernel( _program, function.c_str() ) );
                return _kernels.back().bind( *_queue_access[_device], cl::NDRange(global_dims.x , global_dims.y ), cl::NDRange( local_dims.x , local_dims.y ) );
            }
            catch( cl::Error e )
            {
                std::cerr<<"ERROR (ContextGPU::function): Creating kernel \""<<function<<"\" ("<<e.err()<<")"<<std::endl;
                throw e;
            }
        }
        
        /*
         * \brief create new FunctionGPU, kernels with work-items organized in 3 dimensions
         * \param[in] function: string with the kernel code
         * \param[in] image_dims: global dimensions
         * \param[in] local_dims: local dimensions
         */
        FunctionGPU function( const std::string & function, cl_uint3 & image_dims, cl_uint3 & local_dims )
        {
            try
            {
            	
	        	cl_uint3 global_dims;
	        	global_dims=image_dims;
	        	
	        	if(global_dims.x%local_dims.x != 0)
	        		global_dims.x+=(local_dims.x-global_dims.x%local_dims.x);
	        	
	        	if(global_dims.y%local_dims.y != 0)
	        		global_dims.y+=(local_dims.y-global_dims.y%local_dims.y);
	        	
	        	if(global_dims.z%local_dims.z != 0)
	        		global_dims.z+=(local_dims.z-global_dims.z%local_dims.z);
        	
                _kernels.push_back( cl::Kernel( _program, function.c_str() ) );
                return _kernels.back().bind( *_queue_access[_device], cl::NDRange(global_dims.x , global_dims.y , global_dims.z ), cl::NDRange( local_dims.x , local_dims.y , local_dims.z ) );
            }
            catch( cl::Error e )
            {
                std::cerr<<"ERROR (ContextGPU::function): Creating kernel \""<<function<<"\" ("<<e.err()<<")"<<std::endl;
                throw e;
            }
        }
        
        /*
         * \brief create new BufferGPU
         * \param[in] size: size in bytes of the buffer memory to be allocated
         * \param[in] flags: usage information and allocate type, by default read and write are allowed inside a kernel
         */
        BufferGPU create_buffer( const uint64 size, const cl_mem_flags flags=CL_MEM_READ_WRITE )
        {
        	try
        	{
        		return cl::Buffer( _context, flags, size );
	    	}
	     	catch( cl::Error err )
	     	{
	     		std::cerr<<"ERROR: "<<err.what()<<"("<<err.err()<<")"<<std::endl;
	     		throw err;
	     	}
        }
        
        /*
         * \brief create new ImageGPU
         * \param[in] width: image width
         * \param[in] height: image height
         * \param[in] flags: usage information and allocate type, by default read and write are allowed inside a kernel
         * \param[in] order: number of channels and the channel layout, by default RGBA
         * \param[in] type: size of the channel data type, by default CL_UNSIGNED_INT8
         */
        ImageGPU create_image( const uint64 width, const uint64 height, const cl_mem_flags flags=CL_MEM_READ_WRITE, const cl_channel_order order=CL_RGBA, const cl_channel_type type=CL_UNSIGNED_INT8 )
        {
        	try
        	{
        		return cl::Image2D( _context, flags, cl::ImageFormat( order, type ), width, height, 0 );
	    	}
	     	catch( cl::Error err )
	     	{
	     		std::cerr<<"ERROR: "<<err.what()<<"("<<err.err()<<")"<<std::endl;
	     		throw err;
	     	}
        }
        
        /*
         * \brief create new VolumeGPU
         * \param[in] width: image width
         * \param[in] height: image height
         * \param[in] depth: image depth
         * \param[in] flags: usage information and allocate type, by default read and write are allowed inside a kernel
         * \param[in] order: number of channels and the channel layout, by default RGBA
         * \param[in] type: size of the channel data type, by default CL_UNSIGNED_INT8
         */
        VolumeGPU create_volume( const uint64 width, const uint64 height, const uint64 depth, const cl_mem_flags flags=CL_MEM_READ_WRITE, const cl_channel_order order=CL_RGBA, const cl_channel_type type=CL_UNSIGNED_INT8 )
        {
        	try
        	{
        		return cl::Image3D( _context, flags, cl::ImageFormat( order, type ), width, height, depth, 0, 0 );
	    	}
	     	catch( cl::Error err )
	     	{
	     		std::cerr<<"ERROR: "<<err.what()<<"("<<err.err()<<")"<<std::endl;
	     		throw err;
	     	}
        }
        
#ifdef USE_OPENGL
        /*
         * \brief create BufferGPU_GL from a valid GL buffer object
         * \param[in] bufobj: ame of a GL buffer object
         * \param[in] flags: usage information and allocate type, by default read and write are allowed inside a kernel
         */
        BufferGPU_GL create_buffer_gl( const GLuint bufobj, const cl_mem_flags flags=CL_MEM_READ_WRITE )
        {
        	try
        	{
        		return cl::BufferGL( _context, flags, bufobj );
	    	}
	     	catch( cl::Error err )
	     	{
	     		std::cerr<<"ERROR: "<<err.what()<<"("<<err.err()<<")"<<std::endl;
	     		throw err;
	     	}
        }

        /*
         * \brief create BufferRenderGPU_GL from an OpenGL renderbuffer object.
         * \param[in] bufobj: name of a GL renderbuffer object
         * \param[in] flags: usage information and allocate type, by default read and write are allowed inside a kernel
         */
        BufferRenderGPU_GL create_buffer_render_gl( const GLuint bufobj, const cl_mem_flags flags=CL_MEM_READ_WRITE )
        {
        	try
        	{
        		return cl::BufferRenderGL( _context, flags, bufobj );
	    	}
	     	catch( cl::Error err )
	     	{
	     		std::cerr<<"ERROR: "<<err.what()<<"("<<err.err()<<")"<<std::endl;
	     		throw err;
	     	}
        }

        /*
         * \brief  creates an OpenCL 2D image object from an OpenGL 2D texture object
         * \param[in] texobj: texobj is the name of a GL 2D, cubemap or rectangle texture object
         * \param[in] flags: usage information and allocate type, by default read and write are allowed inside a kernel
         * \param[in] target: define the image type of texture
         * \param[in] miplevel: mipmap level to be used
         */
        ImageGPU_GL create_image_gl( const GLuint texobj, const cl_mem_flags flags=CL_MEM_READ_WRITE, const GLenum target=GL_TEXTURE_2D, const GLint miplevel=0 )
        {
            try
            {
            	return cl::Image2DGL( _context, flags, target, miplevel, texobj );
	    	}
	     	catch( cl::Error err )
	     	{
	     		std::cerr<<"ERROR: "<<err.what()<<"("<<err.err()<<")"<<std::endl;
	     		throw err;
	     	}
        }

        /*
         * \brief  creates an OpenCL 3D image object from an OpenGL 3D texture object
         * \param[in] texobj: texobj is the name of a 3D texture object
         * \param[in] flags: usage information and allocate type, by default read and write are allowed inside a kernel
         * \param[in] target: define the image type of texture
         * \param[in] miplevel: mipmap level to be used
         */
        VolumeGPU_GL create_volume_gl( const GLuint texobj, const cl_mem_flags flags=CL_MEM_READ_WRITE, const GLenum target=GL_TEXTURE_3D, const GLint miplevel=0 )
        {
        	try
        	{
        		return cl::Image3DGL( _context, flags, target, miplevel, texobj );
	    	}
	     	catch( cl::Error err )
	     	{
	     		std::cerr<<"ERROR: "<<err.what()<<"("<<err.err()<<")"<<std::endl;
	     		throw err;
	     	}
        }
#endif // USE_OPENGL

        /*
         * \brief  write to a BufferGPU object from host memory
         * \param[in] buf: valid BufferGPU object
         * \param[in] src: pointer to buffer in host memory where data is to be written to
         * \param[in] size: size in bytes of data being written. By default, all the bytes in buf are used
         * \param[in] offset: offset in bytes in the buffer object to write to
         */
        void write_buffer( const BufferGPU & buf, const void * src, const uint64 size=0, const uint64 offset=0 )
        {
        	try
        	{
        		uint64 realsize=size;
	        	if( realsize == 0 )
	        		realsize=buf.getInfo<CL_MEM_SIZE>();
	        	_queue_access[_device]->enqueueWriteBuffer( buf, CL_TRUE, offset, realsize, const_cast<void *>( src ) );
	    	}
	     	catch( cl::Error err )
	     	{
	     		std::cerr<<"ERROR: "<<err.what()<<"("<<err.err()<<")"<<std::endl;
	     		throw err;
	     	}
        }
        
        /*
         * \brief  write to a ImageGPU object from host memory
         * \param[in] image: valid ImageGPU object
         * \param[in] data: pointer to buffer in host memory where data is to be written to
         * \param[in] size: height and width of the image. By default, all the image is used
         * \param[in] offset: offset in each dimension
         */
        void write_image( const ImageGPU & image, const void * data, const imageplus::Coord3D<> & size=imageplus::Coord3D<>(0,0,1), const imageplus::Coord3D<> & offset=imageplus::Coord3D<>(0,0,0) )
        {
        	try
        	{
	        	cl::size_t<3> realsize; realsize[0]=size[0]; realsize[1]=size[1]; realsize[2]=size[2];
	        	cl::size_t<3> realoffset; realoffset[0]=offset[0]; realoffset[1]=offset[1]; realoffset[2]=offset[2];
	        	if( realsize[0] == 0 )
	        	{
	        		realsize[0]=image.getImageInfo<CL_IMAGE_WIDTH>();
	        		realsize[1]=image.getImageInfo<CL_IMAGE_HEIGHT>();
	        	}
	        	_queue_access[_device]->enqueueWriteImage( image, CL_TRUE, realoffset, realsize, 0, 0, const_cast<void *>( data ) );
	    	}
	     	catch( cl::Error err )
	     	{
	     		std::cerr<<"ERROR: "<<err.what()<<"("<<err.err()<<")"<<std::endl;
	     		throw err;
	     	}
        }
        
        /*
         * \brief  write to a VolumeGPU object from host memory
         * \param[in] volume: valid VolumeGPU object
         * \param[in] data: pointer to buffer in host memory where data is to be written to
         * \param[in] size: height, width and depth of the volume. By default, all the volume is used
         * \param[in] offset: offset in each dimension
         */
        void write_volume( const VolumeGPU & volume, const void * data, const Coord3D<> & size=Coord3D<>(0,0,0), const Coord3D<> & offset=Coord3D<>(0,0,0) )
        {
        	try
        	{
	        	cl::size_t<3> realsize; realsize[0]=size[0]; realsize[1]=size[1]; realsize[2]=size[2];
	        	cl::size_t<3> realoffset; realoffset[0]=offset[0]; realoffset[1]=offset[1]; realoffset[2]=offset[2];
	        	if( realsize[0] == 0 )
	        	{
	        		realsize[0]=volume.getImageInfo<CL_IMAGE_WIDTH>();
	        		realsize[1]=volume.getImageInfo<CL_IMAGE_HEIGHT>();
	        		realsize[2]=volume.getImageInfo<CL_IMAGE_DEPTH>();
	        	}
	        	_queue_access[_device]->enqueueWriteImage( volume, CL_TRUE, realoffset, realsize, 0, 0, const_cast<void *>( data ) );
	    	}
	     	catch( cl::Error err )
	     	{
	     		std::cerr<<"ERROR: "<<err.what()<<"("<<err.err()<<")"<<std::endl;
	     		throw err;
	     	}
        }
        
        /*
         * \brief  read from a BufferGPU object to host memory
         * \param[in] buf: valid BufferGPU object
         * \param[in] dst: pointer to buffer in host memory where data is to be read from
         * \param[in] size: size in bytes of data being read. By default, all the bytes in buf are used
         * \param[in] offset: offset in bytes in the buffer object to read from
         */
        void read_buffer( const BufferGPU & buf, void * dst, const uint64 size=0, const uint64 offset=0 )
        {
        	try
        	{
	        	uint64 realsize=size;
	        	if( realsize == 0 )
	        		realsize=buf.getInfo<CL_MEM_SIZE>();
	            _queue_access[_device]->enqueueReadBuffer( buf, CL_TRUE, offset, realsize, dst );
	    	}
	     	catch( cl::Error err )
	     	{
	     		std::cerr<<"ERROR: "<<err.what()<<"("<<err.err()<<")"<<std::endl;
	     		throw err;
	     	}
        }

        /*
         * \brief  read from a ImageGPU object to host memory
         * \param[in] buf: valid ImageGPU object
         * \param[in] data: pointer to buffer in host memory where data is to be read from
         * \param[in] size: height and width of the image. By default, all the image is used
         * \param[in] offset: offset in each dimension
         */
        void read_image( const ImageGPU & image, void * data, const Coord3D<> & size=Coord3D<>(0,0,1), const Coord3D<> & offset=Coord3D<>(0,0,0) )
        {
        	try
        	{
	        	cl::size_t<3> realsize; realsize[0]=size[0]; realsize[1]=size[1]; realsize[2]=size[2];
	        	cl::size_t<3> realoffset; realoffset[0]=offset[0]; realoffset[1]=offset[1]; realoffset[2]=offset[2];
	        	if( realsize[0] == 0 )
	        	{
	        		realsize[0]=image.getImageInfo<CL_IMAGE_WIDTH>();
	        		realsize[1]=image.getImageInfo<CL_IMAGE_HEIGHT>();
	        	}
	        	_queue_access[_device]->enqueueReadImage( image, CL_TRUE, realoffset, realsize, 0, 0, data );
	    	}
	     	catch( cl::Error err )
	     	{
	     		std::cerr<<"ERROR: "<<err.what()<<"("<<err.err()<<")"<<std::endl;
	     		throw err;
	     	}
        }
        
        /*
         * \brief  read from a VolumeGPU object to host memory
         * \param[in] buf: valid VolumeGPU object
         * \param[in] data: pointer to buffer in host memory where data is to be read from
         * \param[in] size: height, width and depth of the volume. By default, all the image is used
         * \param[in] offset: offset in each dimension
         */
        void read_volume( const VolumeGPU & volume, void * data, const Coord3D<> & size=Coord3D<>(0,0,0), const Coord3D<> & offset=Coord3D<>(0,0,0) )
        {
        	try
        	{
	        	cl::size_t<3> realsize; realsize[0]=size[0]; realsize[1]=size[1]; realsize[2]=size[2];
	        	cl::size_t<3> realoffset; realoffset[0]=offset[0]; realoffset[1]=offset[1]; realoffset[2]=offset[2];
	        	if( realsize[0] == 0 )
	        	{
	        		realsize[0]=volume.getImageInfo<CL_IMAGE_WIDTH>();
	        		realsize[1]=volume.getImageInfo<CL_IMAGE_HEIGHT>();
	        		realsize[2]=volume.getImageInfo<CL_IMAGE_DEPTH>();
	        	}
	        
	        	_queue_access[_device]->enqueueReadImage( volume, CL_TRUE, realoffset, realsize, 0, 0, data );
	    	}
	     	catch( cl::Error err )
	     	{
	     		std::cerr<<"ERROR: "<<err.what()<<"("<<err.err()<<")"<<std::endl;
	     		throw err;
	     	}
        }
        
#ifdef USE_OPENGL
        /*
		* \brief  Acquire OpenCL memory objects that have been created from OpenGL objects
		* \param[in] objects: A pointer to a list of CL memory objects that correspond to GL objects
		*/
        void acquire_gl_objects( const std::vector<ObjectGL> & objects )
        {
        	try
        	{
	            glFinish(); //slow!!!
	            cl::Event evt;
	            _queue_access[_device]->enqueueAcquireGLObjects( &objects, NULL, &evt );
	            evt.wait();
	    	}
	     	catch( cl::Error err )
	     	{
	     		std::cerr<<"ERROR: "<<err.what()<<"("<<err.err()<<")"<<std::endl;
	     		throw err;
	     	}
        }
        
        /*
		* \brief  Release OpenCL memory objects that have been created from OpenGL objects
		* \param[in] objects: A pointer to a list of CL memory objects that correspond to GL objects
		*/
        void release_gl_objects( const std::vector<ObjectGL> & objects )
        {
        	try
        	{
	            cl::Event evt;
	            _queue_access[_device]->enqueueReleaseGLObjects( &objects, NULL, &evt );
	            evt.wait();
	    	}
	     	catch( cl::Error err )
	     	{
	     		std::cerr<<"ERROR: "<<err.what()<<"("<<err.err()<<")"<<std::endl;
	     		throw err;
	     	}
        }
#endif
        
        inline LocalSpaceGPU local( const size_t size ) { return cl::__local( size ); }
        inline const cl::Context & context() const { return _context; }
        inline const cl::Program & program() const { return _program; }
        inline const cl::CommandQueue & command_queue() const { return *_queue_access[_device]; }
        
    private:
        /* environment within which the kernels execute and the domain in which synchronization and memory management is defined */
        cl::Context _context;
        /* set of kernels, auxiliary functions called by the kernel functions and constant data */
        cl::Program _program;
        /* object that holds commands that will be executed on a specific device */
        std::list<cl::CommandQueue> _queues;
        /* list of CommandQueue in the current context */
        std::vector<cl::CommandQueue * > _queue_access;
        /* index of the current CommandQueue */
        uint16 _device;
        /*  list of kernels */
        std::list<cl::Kernel> _kernels;
    };

} // namespace imageplus

#endif //USE_OPENCL


#endif //IMAGEPLUS_CONTEXT_GPU_HPP
