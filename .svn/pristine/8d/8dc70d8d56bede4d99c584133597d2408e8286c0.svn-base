// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------

//!
//!  \file homogeneous.hpp
//!

#ifndef IMAGEPLUS_MATH_GEOMETRY_HOMOGENEOUS_HPP_
#define IMAGEPLUS_MATH_GEOMETRY_HOMOGENEOUS_HPP_

#include <imageplus/core.hpp> 

namespace imageplus
{
    namespace math
    {
        namespace geometry
        {
            //!
            //! \brief Product Matrix*Vector in homogeneous coordinates.   
            //!
            //! \param[in]  m_in  : input matrix
            //! \param[in]  v_in  : input vector
            //! \param[out] v_out : output vector
            //!
            //! \author Marcel Alcoverro <marcel@gps.tsc.upc.edu>
            //! \date   21-12-2009
            //!
            template<typename T> 
            void hmvprod( const MultiArray<T,2> & m_in, const MultiArray<T,1> & v_in , MultiArray<T,1> & v_out  )
            {
                const T* mp = m_in.data();
                for(std::size_t i = 0; i < 4 ; ++i)
                {
                    v_out[i] = mp[0]*v_in[0] + mp[1]*v_in[1] + mp[2]*v_in[2] + mp[3]*v_in[3];
                    mp = mp + 4;
                }  
            }
            
	        //!
	        //! \brief Product Matrix*Matrix in homogeneous coordinates.   
	        //!
	        //! \param[in]  m_in1  : input matrix
	        //! \param[in]  m_in2  : input matrix
	        //! \param[out] m_out : output matrix
	        //!
	        //! \author Marcel Alcoverro <marcel@gps.tsc.upc.edu>
	        //! \date   17-03-2010
	        //!
	        template<typename T> 
	        void hmprod( const MultiArray<T,2> & m_in1, const MultiArray<T,2> & m_in2 , MultiArray<T,2> & m_out  )
	        {
	            const T* mp1 = m_in1.data();
	            for(std::size_t j = 0; j < 4 ; ++j)
	            {
	            	const T* mp2 = m_in2.data();
		            for(std::size_t i = 0; i < 4 ; ++i)
		            {
		            	m_out[i][j] = mp1[0]*mp2[0] + mp1[1]*mp2[4] + mp1[2]*mp2[8] + mp1[3]*mp2[12];		            	
		            	mp2 = mp2 + 1;
		            }  
		            mp1 = mp1 + 4;
	            }
	        }
            
            //!
            //! \brief Conversion from homogeneous coordinates (MultiArray) to euclidean cordinates (Point3D)    
            //!
            //! \param[in]  m_in  : input vector
            //! \param[out] p_out : output vector
            //!
            //! \author Marcel Alcoverro <marcel@gps.tsc.upc.edu>
            //! \date   21-12-2009
            //!
            inline 
            void hm2p(const MultiArray<float64,1> & m_in, Point3D & p_out  )
            {
                std::copy(m_in.data(), m_in.data()+3, p_out.data());
            }

            //!
            //! \brief Conversion from euclidean cordinates (Point3D)  to homogeneous coordinates (MultiArray)    
            //!
            //! \param[in]  p_in  : input vector 
            //! \param[out] m_out : output vector
            //!
            //! \author Marcel Alcoverro <marcel@gps.tsc.upc.edu>
            //! \date   21-12-2009
            //!
            inline 
            void hp2m( const Point3D & p_in, MultiArray<float64,1> & m_out  )
            {
                std::copy(p_in.data(), p_in.data()+3, m_out.data());
                m_out[3] = 1;
            }

            //!
            //! \brief Create a translation matrix in homogeneous coordinates    
            //!
            //! \param[in] vec : translation vector 
            //!
            //! \return translation matrix
            //!
            //! \author Marcel Alcoverro <marcel@gps.tsc.upc.edu>
            //! \date   21-12-2009
            //!
            MultiArray<float64,2> translation_matrix (const Point3D &vec);
        
            //!
            //! \brief Create a scale matrix in homogeneous coordinates    
            //!
            //! \param[in] vec : scale factors in x , y, z directions
            //!
            //! \return scale matrix
            //!
            //! \author Marcel Alcoverro <marcel@gps.tsc.upc.edu>
            //! \date   21-12-2009
            //!
            MultiArray<float64,2> scale_matrix (const Point3D &vec);
        }
    }
}

#endif /*IMAGEPLUS_MATH_GEOMETRY_HOMOGENEOUS_HPP_*/
