#include <imageplus/compress/rle.hpp>

using namespace imageplus;
using namespace imageplus::compress;


Rle::Rle()
{
}

Rle::~Rle()
{
}

void Rle::write_rep(uint8 *out, uint64 *outpos, uint8 marker, uint8 symbol, uint64 count)
{
    uint64 i, idx;

    idx = *outpos;
    if ( count <= 3 )
    {
        if ( symbol == marker )
        {
            out[ idx ++ ] = marker;
            out[ idx ++ ] = count-1;
        }
        else
        {
            for ( i = 0; i < count; ++ i )
            {
                out[ idx ++ ] = symbol;
            }
        }
    }
    else
    {
        out[ idx ++ ] = marker;
        -- count;
        if ( count >= 128 )
        {
            out[ idx ++ ] = (count >> 8) | 0x80;
        }
        out[ idx ++ ] = count & 0xff;
        out[ idx ++ ] = symbol;
    }
    *outpos = idx;
}

void Rle::write_non_rep( uint8 *out, uint64 *outpos, uint8 marker, uint8 symbol )
{
    uint64 idx;

    idx = *outpos;
    if ( symbol == marker )
    {
        out[ idx ++ ] = marker;
        out[ idx ++ ] = 0;
    }
    else
    {
        out[ idx ++ ] = symbol;
    }
    *outpos = idx;
}


uint64 Rle::compress( const uint8 *in, uint8 *out, uint64 insize )
{
    uint8 byte1, byte2, marker;
    uint64  inpos, outpos, count, i, histogram[ 256 ];

    /* Do we have anything to compress? */
    if ( insize < 1 )
    {
        return 0;
    }

    /* Create histogram */
    for ( i = 0; i < 256; ++ i )
    {
        histogram[ i ] = 0;
    }
    for ( i = 0; i < insize; ++ i )
    {
        ++ histogram[ in[ i ] ];
    }

    /* Find the least common byte, and use it as the repetition marker */
    marker = 0;
    for ( i = 1; i < 256; ++ i )
    {
        if ( histogram[ i ] < histogram[ marker ] )
        {
            marker = i;
        }
    }

    /* Remember the repetition marker for the decoder */
    out[ 0 ] = marker;
    outpos = 1;

    /* Start of compression */
    byte1 = in[ 0 ];
    inpos = 1;
    count = 1;

    /* Are there at least two bytes? */
    if ( insize >= 2 )
    {
        byte2 = in[ inpos ++ ];
        count = 2;

        /* Main compression loop */
        do
        {
            if ( byte1 == byte2 )
            {
                /* Do we meet only a sequence of identical bytes? */
                while ( (inpos < insize) && (byte1 == byte2) &&
                        (count < 32768) )
                {
                    byte2 = in[ inpos ++ ];
                    ++ count;
                }
                if ( byte1 == byte2 )
                {
                    write_rep( out, &outpos, marker, byte1, count );
                    if ( inpos < insize )
                    {
                        byte1 = in[ inpos ++ ];
                        count = 1;
                    }
                    else
                    {
                        count = 0;
                    }
                }
                else
                {
                    write_rep( out, &outpos, marker, byte1, count-1 );
                    byte1 = byte2;
                    count = 1;
                }
            }
            else
            {
                /* No, then don't handle the last byte */
                write_non_rep( out, &outpos, marker, byte1 );
                byte1 = byte2;
                count = 1;
            }
            if ( inpos < insize )
            {
                byte2 = in[ inpos ++ ];
                count = 2;
            }
        }
        while ( (inpos < insize) || (count >= 2) );
    }

    /* One byte left? */
    if ( count == 1 )
    {
        write_non_rep( out, &outpos, marker, byte1 );
    }

    return outpos;
}


void Rle::uncompress(const uint8 *in, uint8 *out,uint64 insize)
{
    uint8 marker, symbol;
    uint64  i, inpos, outpos, count;

    /* Do we have anything to compress? */
    if ( insize < 1 )
    {
        return;
    }

    /* Get marker symbol from input stream */
    inpos = 0;
    marker = in[ inpos ++ ];

    /* Main decompression loop */
    outpos = 0;
    do
    {
        symbol = in[ inpos ++ ];
        if ( symbol == marker )
        {
            /* We had a marker byte */
            count = in[ inpos ++ ];
            if ( count <= 2 )
            {
                /* Counts 0, 1 and 2 are used for marker byte repetition
                   only */
                for ( i = 0; i <= count; ++ i )
                {
                    out[ outpos ++ ] = marker;
                }
            }
            else
            {
                if ( count & 0x80 )
                {
                    count = ((count & 0x7f) << 8) + in[ inpos ++ ];
                }
                symbol = in[ inpos ++ ];
                for ( i = 0; i <= count; ++ i )
                {
                    out[ outpos ++ ] = symbol;
                }
            }
        }
        else
        {
            /* No marker, plain copy */
            out[ outpos ++ ] = symbol;
        }
    }
    while ( inpos < insize );
}
