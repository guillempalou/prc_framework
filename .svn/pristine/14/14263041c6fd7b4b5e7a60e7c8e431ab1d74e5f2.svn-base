// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------


/*!
 * \file captureip.hpp
 * 
 * Interface for CaptureIP class
 */

#ifdef USE_SMARTFLOW

#ifndef IMAGEPLUS_IO_CAPTURE_IP_HPP
#define IMAGEPLUS_IO_CAPTURE_IP_HPP



/*
 * Definitions needed by proscilica drivers: _LINUX, _x64
 * If they were undefined, we keep them undefined.
 * 
 * NOTE: It doesn't work properly for i386 arch!
 */

#ifndef _LINUX
#define _LINUX
#define IMAGEPLUS_DEFINED_LINUX
#endif
#ifndef _x64
#define _x64
#define IMAGEPLUS_DEFINED_x64
#endif
#include <smartroom/video/prosilica/PvApi.h>
#ifdef IMAGEPLUS_DEFINED_LINUX
#undef _LINUX
#endif
#ifdef IMAGEPLUS_DEFINED_x64
#undef _x64
#endif

#include <string>

#include <boost/smart_ptr.hpp>
#include <boost/filesystem.hpp>

#include <imageplus/core.hpp>

/*
 * For the inet_addr method
 */
#include <arpa/inet.h>

namespace bf = boost::filesystem;

namespace imageplus
{
    namespace io
    {
		//! Number of buffers that can be mapped
        const uint16 NB_BUFFER=8;
        //! Number of frames in the buffer
        const uint16 FRAMESCOUNT=8;
        
        /*!
         * 
         * \brief Class to capture frames from an IP camera (using Prosilica drivers)
         * 
         * This class follows the same rules as the ReadSequence class but captures frames
         * from an IP device.
         * 
         * \author Albert Gil Moreno <albert.gil@upc.edu>
         * \author Marc Vila
         * 
         * \date 2010-11-2
         */
        class CaptureIP
        {
        private:
            /*!
             * \brief Copy contructor not allowed to avoid multi-adquisition
             * 
             * \param[in] cpy : object to copy from
             */
        	CaptureIP(const CaptureIP& cpy);

        public:
            
            /*!
             * \brief Constructor by IP
             * 
             * \param[in]     ipstr : A string representing the IP of the device
             * \param[in]     width : Requested width of the capture window
             * \param[in]    height : Requested height of the capture window
             * \param[in]       fps : Frame rate
             */
            CaptureIP ( std::string ipstr,
                        uint32      width  = 1360,
                        uint32      height = 1024,
                        uint32      fps    =   20 );

            /*!
             * Destructor
             */
            ~CaptureIP(void);
                
            /*!
             * Start capture
             */
            void start();

            /*!
             * Stop capture
             */
            void stop();

            /*!
             * \brief Stream extraction operator
             * 
             * Gets a new frame ans saves it to an ImageRGB.
             * A conversion from the Bayer pattern to RGB used.
             * 
             * \sa convert_bayer 
             * 
             * \param[in] rgb : The ImageRGB to save the new captured frame
             * 
             * \return itself to be able to concatenate extractions
             */
            CaptureIP& operator>>( ImageRGB<uint8>& rgb );
            
            /*!
             * \brief Stream extraction operator
             * 
             * Gets a new frame ans saves it to a Bayer buffer (MultiArray).
             * 
             * \param[in] bay : The Bayer buffer to save the new captured frame
             * 
             * \return itself to be able to concatenate extractions
             */ 
            CaptureIP& operator>>( MultiArray<uint8,2>& bay );
            
            /*!
             * \brief Stream extraction operator
             * 
             * This method do not capture any new frame, just "extract" the timestamp 
             * of the last captured frame. 
             *  
             * \param[in] ts : The Timestamp object to save the extracted value
             * 
             * \return itself to be able to concatenate extractions
             */ 
            CaptureIP& operator>>( Timestamp& ts );
	
        private:
            	
        	/*!
        	 * Function to just get the next frame.
        	 * 
        	 * It should be used for all operator>> methods (except the timestamp one
        	 */
        	void get_new_frame();
        	
        	/*!
        	 * Function to capture the Timestamp from the device
        	 */
        	void get_timestamp();
        	
        	/*!
        	 * Auxiliar method to get a string from a tPvErr (Prosilica drivers).\n
        	 * Just for logging.
        	 * 
        	 * \param[in] err : the error to be converted to a string
        	 * 
        	 * \return a string representing the error
        	 */
        	std::string err2string( tPvErr err );
        	
            bool            _first;                //!< to avoid timestamp validation in the first frame
            tPvHandle       _cam_handle;           //!< to manage the camera device
            tPvFrame        _frames[FRAMESCOUNT];  //!< frames buffer  

            uint32          _width;                //!< capture width
            uint32          _height;               //!< capture height
            uint32          _fps;                  //!< capture frame rate

            uint32          _curr;                 //!< current frame in use of the buffer 

            std::vector< MultiArray<uint8,2> > _vec_bayer; //!< buffer to really save the images captured
            Timestamp _ts_curr_clk /*!< clock timestamps */, _ts_prev_clk; //!< clock timestamps
            Timestamp _ts_curr_cam /*!< camera imestamps */, _ts_prev_cam; //!< camera imestamps
        };
    } // namespace io
} //namespace imageplus

#endif // HEADER
#endif // USE_SMARTFLOW
