// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------

//!
//!  \file poprtablefloat.cpp
//!
//!  Implementation of classes for writing floats in a portable manner
//!

#include <imageplus/io/portablefloat.hpp>

using namespace imageplus;
using namespace imageplus::io;


PortableFloat::PortableFloat()
{
    int16 DummySign;
    register uint32 i;
    
    _Pow256[0]        = 256.0;
    _OneOverPow256[0] = 0.00390625;
    for (i = 1;
         ( (i < LD_MAX_EXP256) && (_Pow256 [i - 1] <= std::numeric_limits<float64>::max() / _Pow256 [i - 1]) );
         i++) {
        _Pow256[i]        = (_Pow256[i-1]) * (_Pow256[i-1]);
        _OneOverPow256[i] = (_OneOverPow256[i-1]) * (_OneOverPow256[i-1]);
    }
    _MaxPow256Index = i - 1;
    _Norm256Float64(std::numeric_limits<float64>::max(), &DummySign, &_MaxMantissa, &_MaxExp);
}


uint64 PortableFloat::encode(float64 Real, 
                             uint8 *Buf)
{

    int16 Sign;
    float64 Mantissa;
    int32 Exp;
    register uint32 CodedExp;
    register uint32 Len, MantissaLen;
    
    _Norm256Float64 (Real, &Sign, &Mantissa, &Exp);
    if (Exp >= -64 && Exp <= 63) {
        CodedExp = (uint32) (Exp + 64);
        Buf [1]  = (uint8) CodedExp;
        Len      = 2;
    } else {
        CodedExp = (uint32) (Exp + MAX_EXP256);
        Buf [1]  = ((uint8) ((uint32) (CodedExp) / 256)) + 0200;
        Buf [2]  = ((uint8)CodedExp);
        Len      = 3;
    }

    for (MantissaLen = 0;
         MantissaLen < sizeof (float64) && Mantissa != 0.0;
         MantissaLen++) {
        Buf [Len] = (uint8) Mantissa;
        Mantissa  = (Mantissa - (float64) Buf [Len]) * 256.0;
        Len++;
    }

    Buf [0] = (uint8) ((Sign >= 0) ? Len : Len + 0200);
    
    return Len;

}

float64 PortableFloat::decode(uint8 *Buf) throw (ImagePlusError)
{
    float64 Real;
    int16 Sign;
    float64 Mantissa;
    register int32 Exp;
    register uint32 CodedExp;
    register uint32 Len, MantissaLen;
    register uint32 i;

    if (Buf [0] < 0200) {
        Sign = 1;
        Len  = (uint32) Buf [0];
    } else {
        Sign = -1;
        Len  = (uint32) Buf [0] - 0200;
    }

    if (Buf [1] < 0200) {
        CodedExp    = (uint32) Buf [1];
        Exp         = (int32) CodedExp - 64;
        MantissaLen = Len - 2;
    } else {
        CodedExp    = ((uint32) Buf [1] - 0200) * 256 + (uint32) Buf [2];
        Exp         = (int32) CodedExp - MAX_EXP256;
        MantissaLen = Len - 3;
    }

    Mantissa = 0.0;
    for (i = 0; i < MantissaLen; i++) {
        Mantissa = (Mantissa * 0.00390625) + (float64) Buf [Len - i - 1];
    }
    
    Real = (Sign >= 0) ? Mantissa : -Mantissa;
    if (Exp >= 0) {
        if (Exp > _MaxExp || (Exp == _MaxExp && Mantissa > _MaxMantissa)) {                 
            // the value causes an overflow on this machine
            //Real  = (Sign >= 0) ? HUGE_VAL : -HUGE_VAL;
            //errno = ERANGE;
            throw ImagePlusError("The float value read causes an overflow on this machine");
        } else {
            for (i = 0; Exp != 0; i++) {
                if (_floatodd(Exp)) {
                    Real *= _Pow256 [i];
                }
                Exp /= 2;
            }
        }
    } else {
        Exp = -Exp;
        for (i = 0; i <= _MaxPow256Index && Exp != 0; i++) {
            if (_floatodd(Exp)) {
                Real *= _OneOverPow256 [i];
            }
            Exp /= 2;
        }
        if (Exp != 0 || Real == 0.0) {
            // the value causes an underflow on this machine
            //Real  = 0.0;
            //errno = ERANGE;
            throw ImagePlusError("The float value read causes an underflow on this machine");
        }
    }
    
    return (Real);

}


void PortableFloat::_Norm256Float64 (float64 Real,
                                     int16 *SignOut,
                                     float64 *MantissaOut,
                                     int32 *ExpOut)
{
    register short Sign;
    register double Mantissa;
    register int Exp;
    
    if (Real == 0.0) {
        Sign     = 0;
        Mantissa = 0.0;
        Exp      = 0;
    } else {
        Sign     = (Real >= 0.0) ? 1 : -1;
        Mantissa = (((Real) < 0) ? -(Real) : (Real));
        if (Mantissa >= 1.0 && Mantissa < 256.0) {
            Exp = 0;
        } else {
            register unsigned int Pow2,i;
            
            if (Mantissa >= 256.0) {
                for (i = 0, Pow2 = 1;
                     ( (i < _MaxPow256Index) && (Mantissa >= _Pow256 [i + 1]) );
                     i++, Pow2 *= 2);
                Mantissa /= _Pow256 [i];
                Exp       = (int) Pow2;
            } else {
                for (i = 0, Pow2 = 1;
                     ( (i <= _MaxPow256Index) && (Mantissa <= _OneOverPow256 [i]) );
                     i++, Pow2 *= 2);
                if (i <= _MaxPow256Index) {
                    Mantissa *= _Pow256 [i];
                } else {
                    Mantissa *= _Pow256 [i - 1];
                    Mantissa *= _Pow256 [i - 1];
                }
                Exp = -(int) Pow2;
            }


            while (i > 0 && Mantissa >= 256.0) {

                do {
                    i--, Pow2 /= 2;
                } while (i > 0 && Mantissa < _Pow256 [i]);

                Mantissa /= _Pow256 [i];
                Exp      += (int) Pow2;
            }

        }

    }

    *SignOut     = Sign;
    *MantissaOut = Mantissa;
    *ExpOut      = Exp;
}


