/*
 * video_relative_depth.cpp
 *
 *  Created on: Dec 17, 2012
 *      Author: gpalou
 */

#include <imageplus/core/image_signal.hpp>
#include <imageplus/core/video_signal.hpp>
#include <imageplus/core/colorspace_converter.hpp>

#include <imageplus/segmentation/partition/partition.hpp>
#include <imageplus/segmentation/partition/hierarchical_region_partition.hpp>
#include <imageplus/segmentation/visualization/false_color.hpp>

#include <imageplus/bpt/pruning/merging_sequence_pruner.hpp>
#include <imageplus/bpt/pruning/min_area_pruner.hpp>

#include <imageplus/video_segmentation/trajectory_bpt/trajectory.hpp>
#include <imageplus/video_segmentation/trajectory_bpt/motion_color_distance.hpp>

#include <boost/filesystem.hpp>
#include <iomanip>
#include <iostream>

using namespace imageplus;

#define uint64 imageplus::uint64
#define int64 imageplus::int64

typedef VideoSignal<float64,3> 																		VideoType;
typedef VideoType::ImageType																		FrameType;

typedef FrameType::coord_type																		coord2d;
typedef VideoType::coord_type																		coord3d;
typedef VideoType::value_type																		rgb_type;

typedef HierarchicalRegion<coord3d>																	Region3D;
typedef video_segmentation::Trajectory<VideoType>													TrajectoryType;
typedef segmentation::HierarchicalRegionPartition<TrajectoryType>									BPT;
typedef BPT::PartitionType																			PartitionType;

int main(int argc, char *argv[]) {
	std::string path 		= argv[1];
	std::string segm_path 	= argv[2];
	std::string result_path = argv[3];
	std::vector<uint64> list_of_segmentations;

	for (int64 i = 4; i < argc; i++) {
		std::string a = argv[i];
		std::cout << a << " ";
		std::istringstream is(a);
		uint64 n;
		is >> n;
		list_of_segmentations.push_back(n);
	}
	std::cout << std::endl;

	std::string video_path = path + "/frames";
	std::string partition_path = segm_path + "/leaves.sgm";
	std::string mergings_path  = segm_path + "/mergings.txt";

	// create the necessary paths
	//std::cout << "creating path " << result_path << std::endl;
	boost::filesystem::path result_path_p(result_path);
	boost::filesystem::create_directory(result_path_p);

	std::cout << "Reading tree" << std::endl;
	BPT bpt;
	bpt.load_from_files(partition_path, mergings_path);
	coord3d sizes = bpt.leaves_partition().sizes();

	uint64 Nframes = sizes(2);

	VideoType video(sizes);

	std::cout << "Reading video with " << Nframes << " frames " << std::endl;
	for (uint64 k = 0; k < Nframes; k++) {
		std::ostringstream os;
		os << video_path << "/frame" << std::setw(3) << std::setfill('0') << k << ".png";
		//std::cout << "reading " << os.str() << std::endl;
		video.read_frame(os.str(),k); // read frame k and put it to the position k of the current block
	}

	std::cout << "Creating segmentations " << std::endl;
	BPT::PartitionType partition(video.sizes());
	for (uint64 i = 0; i < list_of_segmentations.size(); i++) {
		bpt::MergingSequencePruner<BPT, VideoType> merging_sequence_pruner(list_of_segmentations[i],false);
		merging_sequence_pruner.prune_bpt(bpt,video);
		std::set<uint64> regs = merging_sequence_pruner.regions(); //optical_flow_pruner.regions();

		for (std::set<uint64>::iterator r = regs.begin(); r != regs.end(); ++r) {
			for (BPT::RegionType::iterator p = bpt(*r).begin(); p != bpt(*r).end(); ++p) {
				partition(*p)(0) = *r;
			}
		}

		VideoType segmentation = segmentation::to_false_color<VideoType>(partition);

		//output the segmentation
		std::ostringstream os;
		os << list_of_segmentations[i];
		boost::filesystem::path result_path_p(result_path + "/" + os.str());
		boost::filesystem::create_directory(result_path_p);

		partition.write_partition(result_path + "/" + os.str() + "/partition.sgm");

		for (uint64 k = 0; k < Nframes; k++) {
			std::ostringstream os;
			os << result_path << "/" << list_of_segmentations[i] << "/" << std::setw(5) << std::setfill('0') << k << ".png";
			FrameType frame = segmentation.frame(k);
			frame.write(os.str());
		}
	}
}
