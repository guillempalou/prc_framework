// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------

//!
//!  \file minim.cpp
//!
//!  Minima and mosaic image creation
//!


#include <imageplus/math/morphology/minim.hpp>
#include "morphology/image_access.hpp"

using namespace imageplus;
using namespace imageplus::math::morphology;


#define pastplato(ai) \
                          if (((*ai) == ta0 ) && (*((ai) + ab_offset) ==  -1 ))        \
                          { *((ai) + ab_offset) = 0 ;                   \
                              *eq = ((ai) + ab_offset) ;                \
                              eq++ ; if(eq >= nxte) eq = nxt;}

#define testpast(ai)  \
                          if ( ta0 > *(ai) ) res = 0 ; \
                          else if (ta0 == *(ai) ) {             \
                              if ( *((ai) + ab_offset) ==  0 ) res = 0 ; \
                              else voisin = true ;}

#define testneig(dir)  \
                nei = neigh8(b,d,(dir));  \
                if ( *nei == -1) { *nei = 0 ;   \
                    *eq = nei ; eq++ ; if(eq >= nxte) eq = nxt;}

#define tfuture(ai)  \
                if ( *(ai) > ta0 ) nb++ ;  \
                if ( *(ai) < ta0 ) flag = true ;

#define proplab(dir)  \
                nei = neigh8(b,d,(dir));  \
                if ( *nei == -1) { *nei = label ;   \
                    *eq = nei ; eq++ ; if(eq >= nxte) eq = nxt;}


template<typename T>
MultiArray<T,2> imageplus::math::morphology::minlab8 (const MultiArray<T,2>& in, const MultiArray<T,2>& lab)
{
    T res,ta0,*a0,*a1,*a2,*a3,*a4,*a5,*a6,*a7,*a8;  
    T *b0,*end, *d;

    int64 ab_offset;
    T **nxt,**nxte;
    T **bq,**eq;
    T **deb,**lit,**ecrit,**fin ;
    T label ;
    T *nei ;
    char nb;
    bool flag, voisin;

    const T bigval = std::numeric_limits<T>::max();

    compatible (in,lab);
    notsame (in,lab);

    
    MultiArray<T,2> a;
    MultiArray<T,2> b;


    padding (in, static_cast<size_type>(1), static_cast<T>(0), a);
    padding (lab, static_cast<size_type>(1), static_cast<T>(bigval), b);

    deb = lit = ecrit = new T*[a.num_elements()];
    fin = deb + a.num_elements() - 1;

    nxt  = bq = eq = new T*[4*(a.dims(0)+a.dims(1))];
    nxte = nxt + 4 * (a.dims(0) + a.dims(1)) - 1;


    end = a.data() + a.dims(0) * (a.dims(1) - 1);
    b0  = b.data() + b.dims(0) + 1;
    a0  = a.data() + a.dims(0) + 1;
    a1  = a0 + 1;
    a2  = a0 + 1 - a.dims(0);
    a3  = a0 - a.dims(0);
    a4  = a0 - a.dims(0) - 1;
    a5  = a0 - 1;
    a6  = a0 - 1 + a.dims(0);
    a7  = a0 + a.dims(0);
    a8  = a0 + a.dims(0) + 1;

    ab_offset = b.data() - a.data();

    while(a0 < end)
    {
        if(*a0 == bigval)
        {
            a0 += 2; a1 += 2; a2 += 2; a3 += 2;
            a4 += 2; a5 += 2; a6 += 2; a7 += 2;
            a8 += 2; b0 += 2;
        } 
        else  
        {
            res = -1 ;
            flag = false ; voisin = false ;
            ta0 = *a0;
            testpast(a2) ;
            testpast(a3) ;
            testpast(a4) ;
            testpast(a5) ;
            *b0 = res ;

            if (res == -1 )
            {
                nb = 0 ; 

                tfuture(a1) ;
                tfuture(a6) ;
                tfuture(a7) ;
                tfuture(a8) ;

                if ( nb == 4 )
                {
                    *ecrit = b0 ; ecrit++ ;
                }
            }
            if ((flag == true) || (res == 0 && voisin == true))
                /* the current point does not belong to
                   a regional minimum ; the plateau it belongs to has
                   to be reset to the value 0 */
            {
                *b0 = 0 ;
                /* search for the past neighbors of the same
                   plateau */
                pastplato(a2) ;
                pastplato(a3) ;
                pastplato(a4) ;
                pastplato(a5) ;

                while(bq != eq)
                {
                    d = *bq ;

                    testneig(1) ;
                    testneig(2) ;
                    testneig(3) ;
                    testneig(4) ;
                    testneig(5) ;
                    testneig(6) ;
                    testneig(7) ;
                    testneig(8) ;

                    bq++; if(bq >= nxte) bq = nxt;
                }

            }
            a0++; a1++; a2++; a3++; a4++; a5++;
            a6++; a7++; a8++; b0++;
        }
    }        
           
    label = 0 ;
    while(lit != ecrit)
    {
        d = *lit ;
        if (*d == -1)
        {
            label++ ;
            *d = label ;
            *eq = d ; eq++; if(eq >= nxte) eq = nxt;

            while(bq != eq)
            {
                d = *bq ;
                proplab(1) ;
                proplab(2) ;
                proplab(3) ;
                proplab(4) ;
                proplab(5) ;
                proplab(6) ;
                proplab(7) ;
                proplab(8) ;

                bq++; if(bq >= nxte) bq = nxt;
            }

        }

        lit++; if(lit >= fin) lit = deb;
    }
    delete [] nxt;
    delete [] deb;

    return (remove_padding(b,1));
}




namespace imageplus
{
    namespace math
    {
        namespace morphology
        {
            // Do not instantiate uint8 or int8 because bigval and smlval fall in the range of image values
            template MultiArray<int64,2> minlab8(const MultiArray<int64,2>& , const MultiArray<int64,2>& );
            template MultiArray<int16,2> minlab8(const MultiArray<int16,2>& in, const MultiArray<int16,2>& lab );
        } 
    }
}

