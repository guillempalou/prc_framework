// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------

//!
//!  \file readwriteontology.cpp
//!
//!  Implementation of classes for reading and writing Ontologies to/from disk
//!

#include <list>
#include <string>

#include <boost/filesystem.hpp>
#include <boost/foreach.hpp>
#include <boost/lexical_cast.hpp>

#include <imageplus/semantic/readwriteontology.hpp>

#include <imageplus/io/pugixml/pugixml.hpp>
#include <imageplus/io/pugixml/foreach.hpp>

using namespace imageplus;
using namespace imageplus::semantic;

imageplus::semantic::ReadWriteOntology::ReadWriteOntology(const std::string& filename) throw (ImagePlusError)
{
	open(filename);
}

void imageplus::semantic::ReadWriteOntology::open(const std::string& filename) throw (ImagePlusError)
{
	_filename = filename;
	if (_filename.find("file:") == 0)
	{
		 // FIXME IT'S AN URI! ("file:/path/to/file.xml" -> "/path/to/file.xml")
		_filename.erase(0, 5);
	}

    boost::filesystem::path file_path(_filename);
    boost::filesystem::path filename_branch(file_path.branch_path());
    if (!boost::filesystem::exists(filename_branch) && filename_branch.string()!="")
        throw ImagePlusError( "ReadWriteOntology: Directory " + filename_branch.string() + " not found." );
}

void imageplus::semantic::ReadWriteOntology::read(Ontology& ontology) const throw (ImagePlusError)
{
	pugi::xml_document doc;
	pugi::xml_parse_result result = doc.load_file(_filename.c_str());

	if (! result)
	{
		std::stringstream error;
		error << "XML [" << _filename << "] parsed with errors." << std::endl;
		error << "XML Error description: " << result.description() << std::endl;
		error << "XML Error offset: " << result.offset << std::endl;
		throw ImagePlusError(error.str());
	}

	if (! doc.child("Mpeg7"))
		throw ImagePlusError("XML reading: 'Mpeg7' node not found");

	// Ontology file loaded => save ontology file URI
	ontology.set_file_uri(_filename);

	// semantics node
	pugi::xml_node semantics_node = doc.child("Mpeg7").child("Description").child("Semantics");

	// ontology name
	std::string ont_name = semantics_node.attribute("id").value();
	ontology.set_name(ont_name);

	// semantic classes
	BOOST_FOREACH(pugi::xml_node semantic_base_node, semantics_node)
	{
		// id
		uint32 id;
		try {
			std::string id_text = semantic_base_node.attribute("id").value();
			id_text.erase(0, 5);						// "Class1" => "1"
			id = boost::lexical_cast<uint32>(id_text);  // "1" => (int) 1
		} catch (boost::bad_lexical_cast const &) {
			throw ImagePlusError("An error occurred while reading the XML: found a semantic class with an unparseable id.");
		}

		// name
		std::string sc_name = semantic_base_node.child("Label").child_value("Name");

		ontology.add_semantic_class(id, sc_name);
	}
}

void imageplus::semantic::ReadWriteOntology::operator>>(Ontology& ontology) const throw (ImagePlusError)
{
	read(ontology);
}

bool imageplus::semantic::ReadWriteOntology::write(Ontology& ontology) const throw (ImagePlusError)
{
	pugi::xml_document doc;

	// Mpeg7
	pugi::xml_node mpeg7_node = doc.append_child("Mpeg7");
	mpeg7_node.append_attribute("xmlns") = "urn:mpeg:mpeg7:schema:2001";
	mpeg7_node.append_attribute("xmlns:xsi") = "http://www.w3.org/2001/XMLSchema-instance";

	// `-> Description
	pugi::xml_node desc_node = mpeg7_node.append_child("Description");
	desc_node.append_attribute("xsi:type") = "urn:SemanticDescriptionType";
	desc_node.append_attribute("xmlns:urn") = "urn:mpeg:mpeg7:schema:2001";

	//  `-> Semantics (ontology)
	pugi::xml_node semantics_node = desc_node.append_child("Semantics");
	semantics_node.append_attribute("id") = ontology.get_name().c_str();

	//   `-> SemanticBase -> Label -> Name (for each semantic class)
	BOOST_FOREACH(int semantic_class_id, ontology)
	{
		pugi::xml_node semantic_base_node = semantics_node.append_child("SemanticBase");
		semantic_base_node.append_attribute("xsi:type") = "urn:ObjectType";

		// semantic class id
		std::string class_id = "Class" + boost::lexical_cast<std::string>(semantic_class_id);
		semantic_base_node.append_attribute("id") = class_id.c_str();

		// semantic class name
		std::string semantic_class_name = ontology.get_semantic_class_name(semantic_class_id);
		pugi::xml_node name_node = semantic_base_node.append_child("Label").append_child("Name");
		name_node.append_child(pugi::node_pcdata).set_value(semantic_class_name.c_str());
	}

	// save document to file
	return doc.save_file(_filename.c_str(), "  ", pugi::format_default, pugi::encoding_utf8);
}

bool imageplus::semantic::ReadWriteOntology::operator<<(Ontology& ontology) const throw (ImagePlusError)
{
	return write(ontology);
}
