// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------

//!
//!  \file multiarray_ostream.hpp
//!
//!  Interface and implementation for writing MultiArrays into streams for debugging purposes
//!

#ifndef IMAGEPLUS_CORE_MULTIARRAY_OSTREAM_HPP
#define IMAGEPLUS_CORE_MULTIARRAY_OSTREAM_HPP

#include <iostream>
#include <iomanip>

#include <imageplus/core/multiarray.hpp>

namespace imageplus
{
    /*!
     * \brief Prints a 1 dimensional multiarray  for debugging purposes
     *
     * \param[out] os : stream to output multiarray
     * \param[in]   m : 1D MultiArray to write to stream
     *
     * \return the os to be able to concatenate
     *
     * \author Javier Ruiz Hidalgo <j.ruiz@upc.edu>
     * \date   10-1-2008
     */
    template<typename T>
    std::ostream& operator<<(std::ostream& os, const MultiArray<T,1>& m)
    {
        os << "    ";
        for (int64 i=m.index_bases()[0]; i<(int64)m.dims(0)+m.index_bases()[0]; i++)
        {
            os.width(3);
            if (sizeof(T) == 1)
                os << int(static_cast<unsigned char>(m[i])) << "  ";
            else
                os << m[i] << "  ";
        }
        os << std::endl;

        return os;
    }

    //!
    //! \brief Prints a boost:array for debugging purposes
    //!
    //! \tparam T : data type of boost::array
    //! \tparam S : size of the boost::array
    //!
    //! \param[out] os : stream to output multiarray
    //! \param[in]   m : boost::array to write to stream
    //!
    //! \return the os to be able to concatenate
    //!
    //! \author Albert Gil Moreno <albert.gil@upc.edu>
    //! \date   10-1-2008
    //!
    template<typename T, std::size_t S>
    std::ostream& operator<<(std::ostream& os, const boost::array<T,S>& m)
    {
        os << "    ";
        for (uint64 i=0; i<m.size(); i++)
        {
            os.width(3);
            if (sizeof(T) == 1)
                os << int(static_cast<unsigned char>(m[i])) << "  ";
            else
                os << m[i] << "  ";
        }

        return os;
    }

    //!
    //! \brief Prints a 2 dimensional multiarray for debugging purposes
    //!
    //! \param[out] os : stream to output multiarray
    //! \param[in]   m : 2D MultiArray to write to stream
    //!
    //! \return the os to be able to concatenate
    //!
    //! \author Javier Ruiz Hidalgo <j.ruiz@upc.edu>
    //! \date   10-1-2008
    //!
    template<typename T>
    std::ostream& operator<<(std::ostream& os, const MultiArray<T,2>& m)
    {
        for (int64 y=m.index_bases()[1]; y < (int64)m.dims(1)+m.index_bases()[1]; y++)
        {
            os << "    ";
            for (int64 x=m.index_bases()[0]; x < (int64)m.dims(0)+m.index_bases()[0]; x++)
            {
                os.width(3);
                if (sizeof(T) == 1)
                    os << int(static_cast<unsigned char>(m[x][y])) << "  ";
                else
                    os << m[x][y] << "  ";
            }
            os << std::endl;
        }

        return os;
    }

    //!
    //! \brief Prints a 3 dimensional multiarray for debugging purposes
    //!
    //! \tparam T : data type of the MultiArray
    //!
    //! \param[out] os : stream to output multiarray
    //! \param[in]   m : 2D MultiArray to write to stream
    //!
    //! \return the os to be able to concatenate
    //!
    //! \author Albert Gil Moreno <albert.gil@upc.edu>
    //! \date   10-1-2008
    //!
    template<typename T>
    std::ostream& operator<<(std::ostream& os, const MultiArray<T,3>& m)
    {
    	
        for (int64 z=m.index_bases()[2]; z < (int64)m.dims(2)+m.index_bases()[2]; z++)
        {
            os << "z = " << z << ": " << std::endl;
            for (int64 y=m.index_bases()[1]; y < (int64)m.dims(1)+m.index_bases()[1]; y++)
            {
                os << "    ";
                for (int64 x=m.index_bases()[0]; x < (int64)m.dims(0)+m.index_bases()[0]; x++)
                {
                    os.width(3);
                    if (sizeof(T) == 1)
                        os << int(static_cast<unsigned char>(m[x][y][z])) << "  ";
                    else
                        os << m[x][y][z] << "  ";
                }
                os << std::endl;
            }
        }

        return os;
    }
}

#endif
