// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------

/*!
 * \file volume.test
 * 
 * \todo: Test case for assignements (operator=)
 * \todo: Test case for volume operations
 */


#include <imageplus/core/volume.hpp>

// To test image operators
#include <imageplus/core/imavol_arithmetic.hpp>


BOOST_AUTO_TEST_SUITE ( suite_Volume );

using namespace imageplus;

typedef boost::mpl::list<uint8,int64,float64> VolumeTypes;

/*!
 * \cond TestFixture
 */
template <typename T>
struct VolumeFixture {
    
    VolumeFixture() :
        size(15),
        iv1(size,size+1,size+2),
        iv3(size,size+1,size+2),
        v1(size,size+1,size+2),
        v3(size,size+1,size+2)
    {       
    }
    
    ~VolumeFixture() 
    {   
    }

    uint8 size;
    ImaVol<T,1,3> iv1;
    ImaVol<T,3,3> iv3;
    Volume<T,1> v1;
    Volume<T,3> v3;
};

/*!
 * \endcond TestFixture
 */

BOOST_AUTO_TEST_CASE_TEMPLATE( test_Volume, T, VolumeTypes )
{   
    // TODO: Check values
    // Default constructors
    Volume<T,1> vd1;
    BOOST_CHECK( vd1.size_x() == size_type(0) );
    BOOST_CHECK( vd1.size_y() == size_type(0) );
    BOOST_CHECK( vd1.size_z() == size_type(0) );
    
    Volume<T,3> vd3;
    BOOST_CHECK( vd3.size_x() == size_type(0) );
    BOOST_CHECK( vd3.size_y() == size_type(0) );
    BOOST_CHECK( vd3.size_z() == size_type(0) );
    
    // TODO: This constructor does not work!!
    Volume<T,1> v0;
    BOOST_CHECK( v0.size_x() == size_type(0) );
    BOOST_CHECK( v0.size_y() == size_type(0) );
    BOOST_CHECK( v0.size_z() == size_type(0) );
    
    // Parameters constructors
    Volume<T,1> vp1(10,20,30);
    BOOST_CHECK( vp1.size_x() == size_type(10) );
    BOOST_CHECK( vp1.size_y() == size_type(20) );
    BOOST_CHECK( vp1.size_z() == size_type(30) );
    
    Volume<T,3> vp3(11,21,31);
    BOOST_CHECK( vp3.size_x() == size_type(11) );
    BOOST_CHECK( vp3.size_y() == size_type(21) );
    BOOST_CHECK( vp3.size_z() == size_type(31) );
    
    // Copy constructors
    ImaVol<T,1,3> iv1(12,22,32);
    Volume<T,1> vi1(iv1);
    BOOST_CHECK( vi1.size_x() == size_type(12) );
    BOOST_CHECK( vi1.size_y() == size_type(22) );
    BOOST_CHECK( vi1.size_z() == size_type(32) );
    
    ImaVol<T,3,3> iv3(13,23,33);
    Volume<T,3> vi3(iv3);
    BOOST_CHECK( vi3.size_x() == size_type(13) );
    BOOST_CHECK( vi3.size_y() == size_type(23) );
    BOOST_CHECK( vi3.size_z() == size_type(33) );
    
    Volume<T,1> vv1(vi1);
    BOOST_CHECK( vv1.size_x() == size_type(12) );
    BOOST_CHECK( vv1.size_y() == size_type(22) );
    BOOST_CHECK( vv1.size_z() == size_type(32) );
    
    Volume<T,3> vv3(vi3);
    BOOST_CHECK( vv3.size_x() == size_type(13) );
    BOOST_CHECK( vv3.size_y() == size_type(23) );
    BOOST_CHECK( vv3.size_z() == size_type(33) );
    
    // From dimensions vector
    std::vector<uint64> vec1;
    vec1.push_back(10);
    vec1.push_back(21);
    vec1.push_back(32);
    
    std::vector< std::vector<uint64> > vec1b;
    vec1b.push_back(vec1);
    
    Volume<T,1> vvec1(vec1b);
    BOOST_CHECK( vvec1.size_x() == size_type(10) );
    BOOST_CHECK( vvec1.size_y() == size_type(21) );
    BOOST_CHECK( vvec1.size_z() == size_type(32) );
    
    vec1b.push_back(vec1);
    vec1b.push_back(vec1);
    
    Volume<T,3> vvec3(vec1b);
    BOOST_CHECK( vvec3.size_x() == size_type(10) );
    BOOST_CHECK( vvec3.size_y() == size_type(21) );
    BOOST_CHECK( vvec3.size_z() == size_type(32) );
}



BOOST_AUTO_TEST_CASE_TEMPLATE( test_Volume_Resize, T, VolumeTypes )
{   
    
    VolumeFixture<T> f;
    
    BOOST_CHECK_EQUAL( f.v1.size_x(), size_type(15) );
    BOOST_CHECK_EQUAL( f.v1.size_y(), size_type(16) );
    BOOST_CHECK_EQUAL( f.v1.size_z(), size_type(17) );
    
    BOOST_CHECK_EQUAL( f.v3.size_x(), size_type(15) );
    BOOST_CHECK_EQUAL( f.v3.size_y(), size_type(16) );
    BOOST_CHECK_EQUAL( f.v3.size_z(), size_type(17) );
    
    
    // Resize for Volume with (width, height, depth)
    f.v1.resize(10,20,30);
    f.v3.resize(10,20,30);

    BOOST_CHECK_EQUAL( f.v1.size_x(), size_type(10) );
    BOOST_CHECK_EQUAL( f.v1.size_y(), size_type(20) );
    BOOST_CHECK_EQUAL( f.v1.size_z(), size_type(30) );
    
    BOOST_CHECK_EQUAL( f.v3.size_x(), size_type(10) );
    BOOST_CHECK_EQUAL( f.v3.size_y(), size_type(20) );
    BOOST_CHECK_EQUAL( f.v3.size_z(), size_type(30) );

    
    // Resize for Volume with vector and diferent dimensions for each channel (in the case of 3 channels)
    std::vector< std::vector<size_type> > dims;
    std::vector<uint64> temp_dims;
    temp_dims.push_back(11);
    temp_dims.push_back(21);
    temp_dims.push_back(31);
    dims.push_back(temp_dims);

    f.v1.resize(dims);
    
    BOOST_CHECK_EQUAL( f.v1.size_x(), size_type(11) );
    BOOST_CHECK_EQUAL( f.v1.size_y(), size_type(21) );
    BOOST_CHECK_EQUAL( f.v1.size_z(), size_type(31) );
    
    temp_dims.resize(0);
    temp_dims.push_back(5);
    temp_dims.push_back(10);
    temp_dims.push_back(20);
    dims.push_back(temp_dims);
    dims.push_back(temp_dims);    

    f.v3.resize(dims);

    
    BOOST_CHECK_EQUAL( f.v3.size_x(), size_type(11) );
    BOOST_CHECK_EQUAL( f.v3.size_y(), size_type(21) );
    BOOST_CHECK_EQUAL( f.v3.size_z(), size_type(31) );
    BOOST_CHECK_EQUAL( f.v3.dims().at(1).at(0),  size_type(5) );
    BOOST_CHECK_EQUAL( f.v3.dims().at(1).at(1),  size_type(10) );
    BOOST_CHECK_EQUAL( f.v3.dims().at(1).at(2),  size_type(20) );
    BOOST_CHECK_EQUAL( f.v3.dims().at(2).at(0),  size_type(5) );
    BOOST_CHECK_EQUAL( f.v3.dims().at(2).at(1),  size_type(10) );
    BOOST_CHECK_EQUAL( f.v3.dims().at(2).at(2),  size_type(20) );
}


BOOST_AUTO_TEST_CASE_TEMPLATE( test_Volume_access, T, VolumeTypes )
{
    VolumeFixture<T> f;
    
    // Volume access: 1 channel
    for(uint32 i = 0 ; i< f.v1.size_x(); i++)
    {
        for(uint32 j = 0 ; j < f.v1.size_y(); j++)
        {
            for(uint32 k = 0 ; k < f.v1.size_z(); k++)
            {
                f.v1(0)[i][j][k] = T(i);
                BOOST_CHECK( f.v1(0)[i][j][k] == T(i) );
            }
        }
    }
    
    // Voxel access: 3 channel
    for(uint32 c = 0 ; c < f.v3.dims().size(); c++)
    {
        for(uint32 i = 0 ; i< f.v3.size_x(); i++)
        {
            for(uint32 j = 0 ; j < f.v3.size_y(); j++)
            {
                for(uint32 k = 0 ; k < f.v3.size_z(); k++)
                {
                    f.v3(c)[i][j][k] = T(i);
                    BOOST_CHECK( f.v3(c)[i][j][k] == T(i) );
                }
            }
        }
    }

    // Channel access: 1 channel
    f.v1(0) = T(5);
    for(uint32 i = 0 ; i< f.v1.size_x(); i++)
    {
        for(uint32 j = 0 ; j < f.v1.size_y(); j++)
        {
            for(uint32 k = 0 ; k < f.v1.size_z(); k++)
            {
                BOOST_CHECK( f.v1(0)[i][j][k] == T(5) );
            }
        }
    }
    
    // Channel access: 3 channel
    for(uint32 c = 0 ; c < f.v3.dims().size(); c++)
    {
        f.v3(c) = T(c);
        for(uint32 i = 0 ; i< f.v3.size_x(); i++)
        {
            for(uint32 j = 0 ; j < f.v3.size_y(); j++)
            {
                for(uint32 k = 0 ; k < f.v3.size_z(); k++)
                {
                    BOOST_CHECK( f.v3(c)[i][j][k] == T(c) );
                }
            }
        }
    }
    
    // Voxel access by coords: 1 channel
    f.v1 = T(5);
    Coord3D<>  coord(2,3,1);
    Coord3D<>  origin(1,1,2);
    
    f.v1(0)(coord) = T(3);
    BOOST_CHECK( f.v1(0)(coord)         == T(3) );
    BOOST_CHECK( f.v1(0)[2][3][1]      == T(3) );
    
//    f.v1(0,coord, origin) = T(1);
//    BOOST_CHECK( f.v1(0,coord, origin) == T(1) );
//    BOOST_CHECK( f.v1(0)[3][4][3]      == T(1) );
    
    
    // Voxel access by coords: 3 channel
    f.v3 = T(5);
    for(uint8 channel=0; channel < 3; channel++)
    {
        f.v3(channel)(coord) = T(7);
        BOOST_CHECK( f.v3(channel)(coord)        == T(7) );
        BOOST_CHECK( f.v3(channel)[2][3][1]      == T(7) );
        
//        f.v3(channel,coord, origin) = T(9);
//        BOOST_CHECK( f.v3(channel,coord, origin) == T(9) );
//        BOOST_CHECK( f.v3(channel)[3][4][3]      == T(9) );
    }
    
    // Constant voxel access by coords
    const Volume<T,1> cv(10,20,30);
    const T t = cv(0)(coord);
    BOOST_CHECK( t == T(0) );
}


BOOST_AUTO_TEST_SUITE_END ();
