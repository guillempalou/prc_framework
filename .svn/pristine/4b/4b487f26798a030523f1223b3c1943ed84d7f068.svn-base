/*
 * quadratic_cost.hpp
 *
 *  Created on: Dec 18, 2012
 *      Author: gpalou
 */

#ifndef QUADRATIC_COST_HPP_
#define QUADRATIC_COST_HPP_

#include <imageplus/bpt/energy_minimization/optimal_pruner.hpp>
#include <imageplus/math/algebra/robust_regression.hpp>
#include <imageplus/descriptors/geometry/area.hpp>

namespace imageplus {
	namespace bpt {

	template <class BPT, class ImageModel>
	class QuadraticCost : public RegionCost<BPT, ImageModel> {

		typedef RegionCost<BPT, ImageModel> BaseClassType;

	public:

		QuadraticCost(descriptors::DescriptorManager& manager, uint64 max_label, float64 lambda = 0.001) : BaseClassType(manager, max_label, lambda) {
		}

		float64 region_cost(BPT& bpt, ImageModel& img, uint64 id) {
			float64 e = fit_model(bpt,img,*r);
			return e; // does not include lambda (the pruner does it instead)
		}

		float64 fit_model(BPT& bpt, ImageModel& img, uint64 id) {

			descriptors::Area::type N = BaseClassType::_manager->calc_descriptor<descriptors::Area>(img, bpt(id));

			typedef math::algebra::RobustRegression<math::numeric::L1Robust> RobustRegression; // We fit 8 parameters, hence the dimension is 8

			uint64 p = 0;
			math::Matrix A = math::Matrix::Zero(2*N,8);
			math::Vector b = math::Vector::Zero(2*N);

			for (typename BPT::RegionType::iterator c = bpt(id).begin(); c != bpt(id).end(); ++c, p+=2) {
				uint32 x = (*c)(0);
				uint32 y = (*c)(1);

				// Each point contributes to 2 equations
				b(p)  = img(x,y)(0);
				b(p+1) = img(x,y)(1);

				A(p,0) = 1; A(p,1) = x; A(p,2) = y; A(p,6) = x*x; A(p,7) = x*y;
				A(p+1,3) = 1; A(p+1,4) = x; A(p+1,5) = y; A(p+1,6) = x*y; A(p+1,7) = y*y;
			}

			//
			// Fitting:
			//
			// vx = a0 + a1 * x + a2 * y + a6 * x^2 +   a7 * x * y
			// vy = a3 + a4 * x + a5 * y + a6 * x * y + a7 * y * y
			//
			//
			math::numeric::L1Robust f;
			RobustRegression rr;
			rr.fit(A,b);

			math::Vector a = rr.solution();

			float64 e = 0;
			// Compute the error
			for (typename BPT::RegionType::iterator c = bpt(id).begin(); c != bpt(id).end(); ++c, p+=2) {
				uint32 x = (*c)(0);
				uint32 y = (*c)(1);

				float64 u = a(0) + a(1)*x + a(2)*y + a(6)*x*x + a(7)*x*y;
				float64 v = a(3) + a(4)*x + a(5)*y + a(6)*x*y + a(7)*y*y;

				float64 dx = img(x,y)(0)-u;
				float64 dy = img(x,y)(1)-v;
				e += std::sqrt(dx*dx+dy*dy);
			}
			return e;
		}
	};

	}
}

#endif /* QUADRATIC_COST_HPP_ */
