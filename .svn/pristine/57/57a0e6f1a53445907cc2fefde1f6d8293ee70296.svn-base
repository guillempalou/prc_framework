// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------

/*!
 * \file region_contour.hpp
 */

#ifndef IMAGEPLUS_CORE_REGION_CONTOUR_HPP
#define IMAGEPLUS_CORE_REGION_CONTOUR_HPP

#include <vector>
#include <set>

#include <imageplus/core/config.hpp>
#include <imageplus/core/imageplus_types.hpp>
#include <imageplus/core/geometric_region.hpp>   
#include <imageplus/core/region_traits.hpp>   
#include <imageplus/core/region_links.hpp>

#include <boost/enable_shared_from_this.hpp>


namespace imageplus
{
    /*!
     * \brief Default class for the LinkDataType
     *
     * \author Guillem Palou <guillem.palou@upc.edu>
     */
    class LinkDataTypeDefault
    {
    public:
        typedef uint32 ElementType;     //!< Element type to store the data
    };

    /*!
     * \brief Class to handle regions (vector of coordinates) with descriptors
     *
     * It can take advantage of a BPT to compute the descriptors recursively.
     *
     * \author Jordi Pont Tuset - 05-05-2009
     *
     * \todo Store the coordinates in sweeping order: Instead of a vector, use a sorted queue
     */
    template<class CoordModel, class LinkDataModel = LinkDataTypeDefault, typename IdentifierType=uint32>
    class RegionContour : public GeometricRegion<CoordModel>,
                          public collaborative_descriptors_traits,
                          public tree_traits<RegionContour<CoordModel,LinkDataModel,IdentifierType> >,
                          public neighbor_link_traits<RegionContour<CoordModel, LinkDataModel, IdentifierType>, neighbor_ordered_contour_link<RegionContour<CoordModel, LinkDataModel, IdentifierType>, LinkDataModel> >
    {
    public:
        //! Coordinates Type
        typedef CoordModel CoordType;
        //! Structure to hold the link data (optional)
        typedef LinkDataModel LinkDataType;
        //! Pointer type of the region
        typedef RegionContour* RegionPointer;
        //! Type of Gerometric region (father)
        typedef GeometricRegion<CoordModel> GeomRegType;
        //! type of links we have between regions
        typedef neighbor_link_traits<RegionContour<CoordModel, LinkDataModel, IdentifierType>, neighbor_ordered_contour_link<RegionContour<CoordModel, LinkDataModel, IdentifierType>, LinkDataModel> > BaseClass;
        //! Container Type that holds the list of common contours
        typedef typename neighbor_ordered_contour_link<RegionContour<CoordModel, LinkDataModel, IdentifierType>, LinkDataModel>::AllContours contour_container;
        //! Container Type that hold the list of coordinates
        typedef typename neighbor_ordered_contour_link<RegionContour<CoordModel, LinkDataModel, IdentifierType>, LinkDataModel>::ContourType coords_container;
        //! iterator of the region coordinates
        typedef RegionIteratorBase<RegionContour, typename GeomRegType::position_iterator> position_iterator;
        //! const iterator of the region coordinates
        typedef RegionIteratorBase<const RegionContour, typename GeomRegType::const_position_iterator> const_position_iterator;
        
        /*!
         * \brief Copy Constructor
         * \param[in] copy : region to be copied
         */
        RegionContour(const RegionContour& copy)
        :   GeomRegType(copy),
            tree_traits<RegionContour<CoordModel, LinkDataType, IdentifierType> >(copy),
            BaseClass(copy),
            _label(copy.label())
        {}
        
        /*!
         * Constructor by children
         *
         * \param[in] child1 : Pointer to one of the child regions that formed it via a merging process
         * \param[in] child2 : Pointer to the other child
         * \param[in] label  : Label of the region in the base partition of the Partition (by def. NOT_ASSGNED)
         *
         * \todo can be totally replaced by the below one
         */
        RegionContour( RegionPointer  child1 = RegionPointer(),
                       RegionPointer  child2 = RegionPointer(),
                       IdentifierType label  = not_assigned<IdentifierType>())
        :   GeomRegType(),
            _label(label)
        {
            _init(child1, child2);
        }
        
        /*!
         * Constructor by children and global descriptors
         *
         * \param[in] global_vd : Pointer to the collaborative descriptors (CollaborativeDescriptors) of the global image
         * \param[in] child1    : Pointer to one of the child regions that formed it via a merging process
         * \param[in] child2    : Pointer to the other child
         * \param[in] label     : Label of the region in the base partition of the Partition (by def. NOT_ASSGNED)
         */
        RegionContour( CollaborativeDescriptors* global_vd,
                       RegionPointer             child1    = RegionPointer(),
                       RegionPointer             child2    = RegionPointer(),
                       IdentifierType            label     = not_assigned<IdentifierType>() )
        :   GeomRegType(),
            collaborative_descriptors_traits(global_vd),
            _label(label)
        {
            _init(child1, child2);
        }
        
        /*!
         * Constructor receiving the first coordinate of the region and a reference to the partition
         * where it belongs (optional), and the collaborative descriptors.
         *
         * \param[in] global_vd      : Pointer to the collaborative descriptors (CollaborativeDescriptors)
         *                             of the global image
         * \param[in] first_position : First position (coordinate) of the region
         * \param[in] label          : Label of the region in the base partition of the Partition
         *                             (by def. NOT_ASSGNED)
         */
        RegionContour( CollaborativeDescriptors* global_vd,
                       CoordModel                first_position,
                       IdentifierType            label          = not_assigned<IdentifierType>() )
        :   GeomRegType(),
            collaborative_descriptors_traits(global_vd),
            _label(label)
        {
            this->push_back(first_position);
        }
        
        /*!
         * Constructor receiving the first coordinate of the region and a reference to the partition
         * where it belongs (optional).
         *
         * \param[in] first_position : First position (coordinate) of the region
         * \param[in] label          : Label of the region in the base partition of the Partition
         *                             (by def. NOT_ASSGNED)
         */
        RegionContour( CoordModel first_position, IdentifierType label=not_assigned<IdentifierType>() )
        :   GeomRegType(),
            _label(label)
        {
            this->push_back(first_position);
        }
        
        /*!
         * Constructor receiving the first coordinate of the region and a reference to the partition
         * where it belongs (optional).
         *
         * \param[in] label   : Label of the region in the base partition of the Partition (by def. NOT_ASSGNED)
         */
        RegionContour(IdentifierType label)
        :   GeomRegType(),
            _label(label)
        {}
        
        /*! \brief Pointer operator overload
         *
         * \returns this
         *
         * \todo is this really necessary?
        RegionPointer operator&()
        {
            return this;
        }*/
        
        /*!
         * \brief function to update the link traits when performing region operations
         *
         * \param[in] curr_part : current partition from which we will update
         */
        template<class PartitionModel>
        void update_traits(PartitionModel& curr_part)
        {
            tree_traits<RegionContour<CoordModel, LinkDataType, IdentifierType> >::update_traits(curr_part);
            BaseClass::update_traits(curr_part);
        }
    public:   
        
        /*!
         * \returns the label of the region in the context of a Partition
         */
        IdentifierType label() const
        {
            return _label;
        }
        
        /*!
         * \returns true because the region can have children
         */
        bool is_composite() const
        {
            return true;
        }
        
        /*!
         * \brief Function to iterate along the region coordinates. The coordinates may be given in any order
         * \return iterator to the beginning of the coordinates
         */
        position_iterator begin()
        {
            return position_iterator(this);
        }

        /*!
         * \brief Function to iterate along the region coordinates. The coordinates may be given in any order
         * \return iterator to the end of the coordinates
         */
        position_iterator end()
        {
            return position_iterator(this,true);
        }

        /*!
         * \brief Function to iterate along the region coordinates. The coordinates may be given in any order
         * \return const iterator to the beginning of the coordinates
         */
        const_position_iterator begin() const
        {
            return const_position_iterator(this);
        }

        /*!
         * \brief Function to iterate along the region coordinates. The coordinates may be given in any order
         * \return iterator to the end of the coordinates
         */
        const_position_iterator end() const
        {
            return const_position_iterator(this,true);
        }

    protected:
        
        /*!
         * Sets the label
         *
         * \param[in] label : label of the region in the context of a Partition
         */
        void label(IdentifierType label)
        {
            _label = label;
        }
        
        /*!
         * Initializes the class
         *
         * \param[in] child1 : Pointer to one of the child regions that formed it via a merging process
         * \param[in] child2 : Pointer to the other child
         */
        void _init(RegionPointer child1, RegionPointer child2)
        {
            std::size_t size1 = 0;
            if(child1!=0)
            {
                this->_children.push_back(child1);
                size1 = child1->size();
                this->resize(size1);
                std::copy(child1->position_begin(), child1->position_end(), GeomRegType::begin());

                if (child1->parts().size() != 0) child1->clear(); // we only maintain a copy of the coordinates at the roots
            }

            if(child2!=0)
            {
                this->_children.push_back(child2);
                this->resize(size1+child2->size());
                std::copy(child2->position_begin(), child2->position_end(), GeomRegType::begin()+size1);

                if (child2->parts().size() != 0) child2->clear(); // we only maintain a copy of the coordinates at the roots
            }
        }

    protected:
        
        //! Region identifier
        IdentifierType _label;
        
        /*! 
         * \cond SKIP_DOC 
         * 
         * Friends 
         */
        template<class RegionModel>
        friend class Partition;
        
        template<class PM>
        friend void prune(typename PM::RegionType&, PM&);
        
        template<class PartitionModel>
        friend void merge_regions(typename PartitionModel::RegionType&, typename PartitionModel::RegionType&, typename PartitionModel::IdentifierType, PartitionModel&);
        
        template<class PM>
        friend void relabel(PM&);
        /*! 
         * \endcond SKIP_DOC 
         */
    };
}

#endif  // IMAGEPLUS_CORE_REGION_CONTOUR_HPP
