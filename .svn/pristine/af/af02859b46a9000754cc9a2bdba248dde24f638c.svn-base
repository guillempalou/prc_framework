// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------

//!
//!  \file geometric_shape.hpp
//!
//!  Base class for all geometric shapes
//!

#ifndef IMAGEPLUS_CORE_GEOMETRIC_SHAPE_HPP
#define IMAGEPLUS_CORE_GEOMETRIC_SHAPE_HPP

#include <vector>

#include <imageplus/core/config.hpp>
#include <imageplus/core/imageplus_types.hpp>
#include <imageplus/core/coord.hpp>
#include <imageplus/core/multiarray_arithmetic.hpp>


namespace imageplus
{
    //!
    //! \brief Base class for all geometric shapes
    //!
    //! \author Albert Gil Moreno <agil@gps.tsc.upc.edu>
    //!
    //! \date 08-5-2008
    //!
    //! A GeometricShape is nothing else than a list of coordinates of an arbitrary shape. Template T is coordinate type 
    //! Template D is dimension.
    //! You can apply a GeometricShape to an Image or a Volume and get the corresponding pixels or voxels values.
    //!
    //! \tparam T : Type of the data. It must be a signed integer type: int8, int16, int32 or int64
    //! \tparam D : Dimension of the shape (2D, 3D...). Note that a 2D shape can be only used in an Image, and a 3D only in a Volume
    //! \tparam ContainerBase : Optional parameter, by default Geometric Shapes are std::vectors, and you can add coords using the 
    //!                         "push_back" method, but tou can use a different container and methods if you wish.
    //!
    //! Note that a GeometricShape is (by default) a std::vector,so you can create your own shapes adding Coords with the push_back method.
    //!
    //! \code
    //! Image<uint8,1> im(10,10);
    //! GeometricShape<int16,2> shape;
    //! // add coords to shape...
    //! MultiArray<uint8,1> shape_values = im(0,shape);
    //!
    //! // to get an interator from a shape we need the "typename" keyword:
    //! typename GeometricShape<int16,2>::iterator iter = shape.begin();
    //! \endcode
    //!
    //! \todo not inherit from std::vector, but containing one? (look more information google)
    //!
    template<typename T,std::size_t D, class ContainerBase = std::vector<Coord<T,D> > >
    class GeometricShape : public  ContainerBase
    {
    public:
    
        
        const static std::size_t dimensions = D; /*!< Coords dimensions */
    
        typedef          Coord<T,D>                     CoordType;             /*!< Type of coordinate used */ // AGIL: deprectaed?
        //typedef          Coord<T,D>                     Coord;                 /*!< Type of coordinate used */
        typedef          ContainerBase                  ContainerType;         /*!< Type of container used  */
        
        typedef typename ContainerType::      iterator        position_iterator; //!< Region iterator
        typedef typename ContainerType::const_iterator  const_position_iterator; //!< Const region iterator
        

        //!
        //! \brief Constructor with the dimension of the Coords
        //!
        IMAGEPLUS_INLINE
        GeometricShape()
                : ContainerType(), _origin()
        {
        }
        
        //!
        //! \brief Constructor with the dimension of the Coords
        //!
        //! \param[in] initial_size : the suposed size (number of coords) of the GeometricShape
        //!
        IMAGEPLUS_INLINE
        GeometricShape( std::size_t initial_size)
                : ContainerType(initial_size), _origin()
        {
        }
        
        //!
        //! Copy operator from base class
        //!
        //! \param[in] copy: Object to be copied
        //!
        //! \return copy, to concatenate
        //!
        const ContainerBase& operator=(const ContainerBase& copy)
        {
            ContainerBase::operator=(copy);
            return copy;
        }
        
        //!
        //! \brief Change the axes origin of the GeometricShpe 
        //!
        //! This method change all the coordinates to refer them to the new_orgin
        //!
        //! \param[in] new_origin : the new axis origin
        //!
        void origin(const CoordType& new_origin)
        {   
            CoordType offset;
            
            if(_origin == CoordType())
            {
                offset = new_origin;
                
            }
            else
            {
                offset = new_origin - _origin;
            }
            
            _origin = new_origin;

            // Use the STL algorithm 'transform' with the function object 'plus()'
            std::transform( this->begin(),
                            this->end(),
                            this->begin(),
                            std::bind2nd(std::plus< CoordType >(),offset));
        }
        
        /*!
         * \brief Gets the same GeometricShape with the desired borders.
         * 
         * See the \ref iterators_example.cpp "iterators and colors example" to know how to use it.
         * 
         * \tparam PaddingType : This template allows us to use any type of container to represent the borders dimensions.
         *                       You can use boost::array, or std::vector...
         * 
         * \param[in] borders       : The borders dimensions
         * 
         * \return The same GeometricShape with borders added.
         */
        template <class PaddingType >
        GeometricShape with_borders(const PaddingType& borders) const
        {
            GeometricShape out(*this);
            
            out.origin(borders);
            
            return out;
        }

        
        //!
        //! \brief Change the axes origin of the GeometricShpe 
        //!
        //! This method change all the coordinates to refer them to the new_orgin
        //!
        //! \param[in] new_origin : the new axis origin
        //! \param[in] dims       : this parameter is ignored, is only present to model the RegionConcept
        //!
        template<class ExtentList>
        void origin(const CoordType& new_origin, const ExtentList& dims)
        {
            origin(new_origin);
        }

        
        //!
        //! \brief Change the axes origin of the GeometricShpe 
        //!
        //! This method change all the coordinates to refer them to the new_orgin
        //!
        //! \param[in] new_origin : the new axis origin
        //! \param[in] dims       : this parameter is ignored, is only present to model the RegionConcept
        //!
        template<class ExtentList>
        void origin(const DataIndex& new_origin, const ExtentList& dims)
        {
            CoordType new_origin_coord;
            
            uint64 mod_prev = new_origin();
            for(std::size_t d = 0; d < D; ++d)
            {
                uint64 tmp = mod_prev/dims[d];
                
                new_origin_coord[d] = mod_prev - tmp*dims[d];
                
                mod_prev = tmp;
            }
            
            origin(new_origin_coord);
        }
        
        //!
        //! \brief Constant access to the axis origin 
        //!
        //! \return constant reference to the axis origin coordinates of the shape
        //!
        IMAGEPLUS_INLINE
        const CoordType& origin() const
        {
            return _origin;
        }
        
        
    private:
        CoordType  _origin; //!< The coordinates origin
    };
}


#endif





#if 0
// AGIL: Here we have a preliminar version of non inheriting from vector... but I don't like it...

    template<typename T,std::size_t D>
    class GeometricShape 
    {
        public:
            
            typedef Coord<T,D> CoordType;
            typedef std::vector< Coord<T,D> > VectorType;
            
            typedef typename VectorType::const_iterator const_iterator;
            typedef typename VectorType::iterator       iterator;
            

            //!
            //! \brief Constructor with the dimension of the Coords
            //!
            //! 
            //!
            IMAGEPLUS_INLINE
            GeometricShape()
                    : _coords(), _origin()
            {
            }
            
            //!
            //! \brief Change the axes origin of the GeometricShpe 
            //!
            //! This method change all the coordinates to refer them to the new_orgin
            //!
            //! \param[in] new_origin : the new axis origin
            //!
            IMAGEPLUS_INLINE
            void origin(CoordType& new_origin)
            {   
                CoordType offset;
                
                if(_origin == CoordType())
                {
                    offset = new_origin;
                    
                }
                else
                {
                    offset = new_origin - _origin;
                }
                
                _origin = new_origin;

                // Use the STL algorithm 'transform' with the function object 'plus()'
                std::transform(_coords.begin(),
                               _coords.end(),
                               _coords.begin(),
                               std::bind2nd(std::plus< CoordType >(),offset));
            }
            
            //!
            //! \brief Constant access to the axis origin 
            //!
            //! \return constant reference to the axis origin coordinates of the shape
            //!
            IMAGEPLUS_INLINE
            const CoordType& origin() const
            {
                return _origin;
            }
            
            //!
            //! \brief The number od Coords 
            //!
            //! \return the number of coords
            //!
            IMAGEPLUS_INLINE
            size_t size() const
            {
                return _coords.size();
            }
            
            //!
            //! \brief The first element 
            //!
            //! \return the first element
            //!
            IMAGEPLUS_INLINE
            iterator begin()
            {
                return _coords.begin();
            }

            //!
            //! \brief The first element 
            //!
            //! \return the first element
            //!
            IMAGEPLUS_INLINE
            const_iterator begin() const
            {
                return _coords.begin();
            }

            //!
            //! \brief The one after the last 
            //!
            //! \return The one after the last
            //!
            IMAGEPLUS_INLINE
            iterator end()
            {
                return _coords.end();
            }

            //!
            //! \brief The one after the last 
            //!
            //! \return The one after the last
            //!
            IMAGEPLUS_INLINE
            const_iterator end() const
            {
                return _coords.end();
            }

            //!
            //! \brief add an element to the end of the shape 
            //!
            IMAGEPLUS_INLINE
            void push_back( const CoordType& val )
            {
                return _coords.push_back(val);
            }
            
            //!
            //! \brief Access operator 
            //!
            //! \return The coord in the index position
            //!
            IMAGEPLUS_INLINE
            CoordType& operator[]( size_t index )
            {
#ifdef NDEBUG
                return _coords[index];
#else
                return _coords.at(index);
#endif
            }
            
            //!
            //! \brief Access operator 
            //!
            //! \return The coord in the index position
            //!
            IMAGEPLUS_INLINE
            const CoordType& operator[]( size_t index ) const
            {
#ifdef NDEBUG
                return _coords[index];
#else
                return _coords.at(index);
#endif
            }
            
            //!
            //! \brief removes all coords from the vector 
            //!
            IMAGEPLUS_INLINE
            void clear() 
            {
                _coords.clear();
            }
            
        private:
            VectorType _coords; //!< All the coordinates of the shape
            CoordType  _origin; //!< The coordinates origin
            
    };
#endif
