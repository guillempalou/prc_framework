// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------

/*!
 * \file capture_v4l.cpp
 */

#ifdef USE_VIDEO4LINUX

#define IMAGEPLUS_TOOL_CONFIG_NAME  capture_v4l
#include <imageplus/toolbox/tool_config.hpp>

#include <fstream>
#include <csignal>

#include <boost/filesystem.hpp>

#include <imageplus/io/capturev4l2.hpp>
#include <imageplus/core/timestamp.hpp>
#include <imageplus/io/writesequence.hpp>

#ifdef USE_SMARTFLOW
#include <smartroom/video/recording/recording_client.hpp>
#endif


using namespace imageplus;
using namespace imageplus::io;
using namespace std;
using namespace boost::filesystem;


// Global variables
static volatile bool running = true;

// Function used for killing the clients with ctrol+c
static void kill_callback(int x)
{
    running = false;
};

static void set_kill_handler()
{
    // Needed to kill client
    struct sigaction sa;
    sa.sa_handler = kill_callback;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = SA_ONESHOT;
    sigaction(SIGINT,  &sa, 0);
    sigaction(SIGTERM, &sa, 0);
}

IMAGEPLUS_TOOL_CONFIG_BRIEF()

    "This client captures images from a camera and store them in the path given\n";

IMAGEPLUS_TOOL_CONFIG_DESCRIPTION()

    "This client captures images from a camera and store them in the path given \n" +
    "                                                                           \n" +
    "Timestamp is obtained from system time.                                    \n" +
    "Captures follow video4linux/hardware default frame rate. It is 25 fps      \n" +
    "The program uses Video4Linux to access the hardware.                       \n" +
    "You need read permission on the devices /dev/video*                        \n" +
    "You need write permission on the path where images will be stored          \n";

IMAGEPLUS_TOOL_CONFIG_PARAMETERS()

    // options
    string      device_name;
    std::size_t framerate;
    uint16      use_every_N_frames;
    string      calibration_file;
    std::size_t width;
    std::size_t height;
    uint8       first_frame;

    // flags

    // arguments
    string      out_files;

IMAGEPLUS_TOOL_CONFIG_DEFAULT_VALUES()

    device_name         = "/dev/video0";
    framerate           = 25;
    use_every_N_frames  = 1;
    calibration_file    = "no_file";
    width               = 768;
    height              = 576;
    first_frame         = 0;

IMAGEPLUS_TOOL_CONFIG_OPTIONS()

    IMAGEPLUS_TOOL_CONFIG_OPTION_ABV( device_name        , "device to connect"      , 'd' );
    IMAGEPLUS_TOOL_CONFIG_OPTION_ABV( framerate          , "image frame rate"       , 'f' );
    IMAGEPLUS_TOOL_CONFIG_OPTION_ABV( use_every_N_frames , "to discard some frames" , 'N' );
    IMAGEPLUS_TOOL_CONFIG_OPTION_ABV( calibration_file   , "the calibration file"   , 'c' );
    IMAGEPLUS_TOOL_CONFIG_OPTION_ABV( width              , "image width"            , 'w' );
    IMAGEPLUS_TOOL_CONFIG_OPTION_ABV( height             , "image height"           , 'h' );
    IMAGEPLUS_TOOL_CONFIG_OPTION_ABV( first_frame        , "first frame number"     , 'n' );

IMAGEPLUS_TOOL_CONFIG_FLAGS()

IMAGEPLUS_TOOL_CONFIG_ARGUMENTS()

    IMAGEPLUS_TOOL_CONFIG_ARGUMENT( out_files , "Filenames in a 'printf style' where to store the imeges" );

IMAGEPLUS_TOOL_CONFIG_READ_PARAMETERS()

    IMAGEPLUS_TOOL_CONFIG_READ( device_name         );
    IMAGEPLUS_TOOL_CONFIG_READ( framerate           );
    IMAGEPLUS_TOOL_CONFIG_READ( use_every_N_frames  );
    IMAGEPLUS_TOOL_CONFIG_READ( calibration_file    );
    IMAGEPLUS_TOOL_CONFIG_READ( width               );
    IMAGEPLUS_TOOL_CONFIG_READ( height              );
    IMAGEPLUS_TOOL_CONFIG_READ( first_frame         );
    IMAGEPLUS_TOOL_CONFIG_READ( out_files           );

IMAGEPLUS_TOOL_CONFIG_MAIN()
{
#ifdef USE_SMARTFLOW
    Recording_client::initClient();
#endif

    /*
     * Initialize the WriteSequence and seq.index file
     */
    WriteSequence   wseq( cfg.out_files, cfg.first_frame );
    path root_directory( cfg.out_files );
    root_directory = root_directory.remove_leaf();

    // Initialize recording file names
    string seq_index_filename = root_directory.string() + "seq.index";

    // Opening seq.index file
    ofstream seq_index_file( seq_index_filename.c_str(), ofstream::trunc );
    if( !seq_index_file.is_open() ) cout << "Error openning file " << seq_index_filename << " to write" << endl;

    cout << "Writing to " << root_directory << endl;

    /*
     * Initializing the capture
     */
    ImageRGB<uint8> rgb ( cfg.width, cfg.height );
    CaptureV4L2     cap ( cfg.device_name, cfg.width, cfg.height, cfg.framerate, V4L2_PIX_FMT_RGB32 );
    cap.start();

    /*
     * Setting up the running loop
     */
    set_kill_handler(); // set the Ctrl+C handler

    Timestamp ts_prev = clock_ts();
    Timestamp ts_dist = (1.0/cfg.framerate)*cfg.use_every_N_frames;

    uint32 log_number    = 0;
    uint32 log_rate      = 10 * cfg.framerate; // Log information every 10 seconds
    uint64 current_frame = cfg.first_frame;

    /*
     * Running loop
     */
    while( running )
    {
    try
    {
        /*
         * Capturing the image
         */
        cap >> rgb;

        /*
         * Capturing the timestamp
         */
        Timestamp ts = clock_ts();

        /*
         * Writing the image
         */
        wseq << rgb;

        /*
         * Writing the timestamp
         */
        seq_index_file <<                                                ts
                       << "\t" << std::setfill(' ') << std::setw(6)   << current_frame
                       << "\t" << std::setfill(' ') << std::setw(6)   << 0
                       << std::endl; //just for backward compatibility

        /*
         * Checking the timestamp
         */
        Timestamp ts_expected = ts_prev + ts_dist;
        if( !are_similars(ts, ts_expected, ts_dist/2 ) )
        {
            std::cout << "Drop frame detected: " << ts - ts_expected << " - Frame: " << current_frame << std::endl;
        }

        /*
         * Log
         */
        if( ++log_number == log_rate )
        {
            cout << "Saved image number " << current_frame << " (ts = " << ts << " )" << endl;
            log_number=0;
        }

        /*
         * Updating running loop variables
         */
        ts_prev = ts;
        ++current_frame;
    }
    catch( ImagePlusError& e )
    {
        std::cout << "Error capturing frame " << current_frame << ": " <<  e.what() << std::endl;
    }
    }

    /*
     * End client
     */
    seq_index_file.close();
    cap.stop();
    return (0);
}

IMAGEPLUS_TOOL_CONFIG_END()

#else // USE_VIDEO4LINUX

#include <iostream>

int main(int argc, char* argv[])
{
    std::cout << "Please, to run this tool you should build it with the flags USE_VIDEO4LINUX." << std::endl;
}
#endif // USE_VIDEO4LINUX
