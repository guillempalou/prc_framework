// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------

//!
//!  \file cholesky.test
//!

#include <iostream>
#include <imageplus/math/numeric/cholesky.hpp>
#include <imageplus/math/numeric/products.hpp>
#include <imageplus/math/numeric/matrices.hpp>
#include <imageplus/math/numeric/transformations.hpp>

BOOST_AUTO_TEST_SUITE ( CholeskySuite );

using namespace imageplus;
using namespace imageplus::math::numeric;


BOOST_AUTO_TEST_CASE( Cholesky_test )
{
    uint64 size = 4;
    
    MultiArray<float64,2> A(size,size);

    A[0][0] = 1;
    A[1][0] = 1;
    A[2][0] = 1;
    A[3][0] = 1;
    A[0][1] = 1;
    A[1][1] = 2;
    A[2][1] = 3;
    A[3][1] = 4;
    A[0][2] = 1;
    A[1][2] = 3;
    A[2][2] = 6;
    A[3][2] = 10;
    A[0][3] = 1;
    A[1][3] = 4;
    A[2][3] = 10;
    A[3][3] = 20;
    
    //std::cout << A << std::endl;
    
    cholesky_factorization(A);
    
    BOOST_CHECK_EQUAL(A[3][3],1.0);
    BOOST_CHECK_EQUAL(A[2][3],3.0);
    BOOST_CHECK_EQUAL(A[1][3],3.0);
    BOOST_CHECK_EQUAL(A[0][3],1.0);
    BOOST_CHECK_EQUAL(A[2][2],1.0);
    BOOST_CHECK_EQUAL(A[1][2],2.0);
    BOOST_CHECK_EQUAL(A[0][2],1.0);
    
    //std::cout << A << std::endl;
    
}

BOOST_AUTO_TEST_CASE( Cholesky_test_2 )
{
    uint64 size = 4;
    int32 val;
    MultiArray<float64,2> A(size,size);
    MultiArray<float64,2> B(size,size);

    A[0][0] = 1;
    A[1][0] = 1;
    A[2][0] = 1;
    A[3][0] = 1;
    A[0][1] = 1;
    A[1][1] = 2;
    A[2][1] = 3;
    A[3][1] = 4;
    A[0][2] = 1;
    A[1][2] = 3;
    A[2][2] = 6;
    A[3][2] = 10;
    A[0][3] = 1;
    A[1][3] = 4;
    A[2][3] = 10;
    A[3][3] = 20;
    
    //std::cout << A << std::endl;
    B=A;
    A=cholesky_factorization(A, val);
    
    BOOST_CHECK_EQUAL(A[3][3],1.0);
    BOOST_CHECK_EQUAL(A[2][3],3.0);
    BOOST_CHECK_EQUAL(A[1][3],3.0);
    BOOST_CHECK_EQUAL(A[0][3],1.0);
    BOOST_CHECK_EQUAL(A[2][2],1.0);
    BOOST_CHECK_EQUAL(A[1][2],2.0);
    BOOST_CHECK_EQUAL(A[0][2],1.0);
    
    BOOST_CHECK_EQUAL(B, prod(A, trans(A)));
    //std::cout << A << std::endl;
    
}

BOOST_AUTO_TEST_CASE (Cholesky_invert)
{
	uint64 size = 4;
    
    MultiArray<float64,2> A(size,size);
    MultiArray<float64,2> IA(size,size);
	MultiArray<float64,2> I(size,size);
	
    A[0][0] = 1;
    A[1][0] = 1;
    A[2][0] = 1;
    A[3][0] = 1;
    A[0][1] = 1;
    A[1][1] = 2;
    A[2][1] = 3;
    A[3][1] = 4;
    A[0][2] = 1;
    A[1][2] = 3;
    A[2][2] = 6;
    A[3][2] = 10;
    A[0][3] = 1;
    A[1][3] = 4;
    A[2][3] = 10;
    A[3][3] = 20;
    
    IA=A;
    
    cholesky_factorization(A);
    cholesky_invert(A);
    A=prod(A,IA);
    I = identity_matrix<float64>(size);
    BOOST_CHECK_EQUAL(A,I);
}
BOOST_AUTO_TEST_CASE( Cholesky_solve )
{

    MultiArray<float64,2> A(4,4);
    MultiArray<float64,1> indep(4);
	//int32 value;
    //Data
    A[0][0] = 1;
    A[1][0] = 1;
    A[2][0] = 1;
    A[3][0] = 1;
    A[0][1] = 1;
    A[1][1] = 2;
    A[2][1] = 3;
    A[3][1] = 4;
    A[0][2] = 1;
    A[1][2] = 3;
    A[2][2] = 6;
    A[3][2] = 10;
    A[0][3] = 1;
    A[1][3] = 4;
    A[2][3] = 10;
    A[3][3] = 20;
    //Independent term
    indep[0]=10; indep[1]=33;
    indep[2]=80; indep[3]=159;
    
   
    //Evaluation of solution
    if (!cholesky_factorization(A))
    {
    	std::cout << "Matrix is not positive definite" << std::endl;
    }
    
   	for (uint64 y=0; y < 3; ++y)
   		for(uint64 x=y+1; x < 4; ++x)
   		  	 A[x][y]=0;
   		  	 
    
    cholesky_solve(A,indep);
    
    BOOST_CHECK_EQUAL(indep[0], 3);
    BOOST_CHECK_EQUAL(indep[1], -1);
    BOOST_CHECK_EQUAL(indep[2], 0);
    BOOST_CHECK_EQUAL(indep[3], 8);
}
BOOST_AUTO_TEST_SUITE_END();


