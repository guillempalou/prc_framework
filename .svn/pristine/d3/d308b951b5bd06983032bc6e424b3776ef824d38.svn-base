// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------


/*!
 * \example iterators_example.cpp
 *
 * This is an example of how to use the ImaVol class, with iterators and colors.
 */

#include <iostream>
#include <imageplus/core.hpp>
#include <imageplus/core/imavolmask.hpp>
#include <imageplus/core/rectangles.hpp>

#include <imageplus/core/imavol_arithmetic.hpp>

#include <imageplus/core/array_arithmetic.hpp>

#include <imageplus/math/statistics/histogram.hpp>

#include <algorithm>


using namespace imageplus;
using namespace imageplus::math::statistics; // for histogram
using namespace std;


// These definitions are only for convenience
typedef GeometricShape<uint32, 2> GShape2D;
typedef GeometricShape<uint32, 3> GShape3D;



//
// Overloaded STL-Like functions 
//
// Implementations are at the end of the example.
//


//
// print_colors: Simply prints out each color of the ImaVol. 
//               Each line of the output represents one color. 
//
//               Note that these functions receive const inputs. 
//
template<          class ImaVolType >
void print_colors( const ImaVolType& iv );

template<          class ImaVolType,     class RegionType >
void print_colors( const ImaVolType& iv, const RegionType& region );

template<          class DataIterator >
void print_colors( const DataIterator& first, 
				   const DataIterator& last );


//
// print_neighbours: Simply prints out each color of the ImaVol. 
//                   Each line of the output represents one color. 
//
//                   Note that these functions receive const inputs. 
//
template<        class Iterator, class NeighbourType >
void print_neighbours( Iterator first,
                       Iterator last,  NeighbourType neighbours );

template<              class ImaVolType, class NeighbourType >
void print_neighbours( const ImaVolType& iv,   NeighbourType neighbours );

template<              class ImaVolType,     class RegionType,   class NeighbourType >
void print_neighbours( const ImaVolType& iv, const RegionType& region, NeighbourType neighbours );


//
// accumulate_filter: A filter that sums the neighbour colors and apply the result to the element  
//
template<         class InIterator, class OutIterator, class NeighbourType >
void accumulate_filter( InIterator first,
                        InIterator last,  OutIterator out,   NeighbourType neighbours );

template<               class ImaVolType, class NeighbourType >
void accumulate_filter( const ImaVolType& in,
                              ImaVolType& out,  NeighbourType neighbours );

template<               class ImaVolType,      class RegionType,   class NeighbourType >
void accumulate_filter( const ImaVolType& in, 
                              ImaVolType& out, const RegionType& region, NeighbourType neighbours );

//
// global_mean_filter: This filter computes the global mean color, and adds it to all elements of the region
//
template<          class InIterator, class OutIterator>
void global_mean_filter( InIterator first,
                         InIterator last,  OutIterator out );

template<                class ImaVolType >
void global_mean_filter( const ImaVolType& in,
                               ImaVolType& out );

template<                class ImaVolType,      class RegionType >
void global_mean_filter( const ImaVolType& in, 
                               ImaVolType& out, const RegionType& region );


//
// set_color: Assign a given color to all elements (pixel/voxel) 
//            in the given ImaVol
//
//            Note that the type Color should correspond with 
//            the type of the ImaVol, or the DataIterator
//
template< class ImaVolType >
void set_color( ImaVolType& iv, 
	   typename ImaVolType::Color color);

template< class ImaVolType,     class RegionType >
void set_color( ImaVolType& iv, const RegionType& region, 
	   typename ImaVolType::Color color);

template< class DataIterator >
void set_color( DataIterator first, 
				DataIterator last,
	   typename DataIterator::Color color);
       


//
// Initialized data will loop for all channels and 
// all elements and will assign a correlative number.
//
template<      class ImaVolType >
void init_test_data( ImaVolType& in );



int main (int argc, char* argv[])
{
#if 1
    std::cout << "****** REGION ITERATOR AND COLORS TEST ******" << std::endl;

    
    ////////// Input ImaVols and Colors ///////////
    ImageRGB<uint32>   rgb(3,4);
    ImageGray<uint32>  gry(3,4);
    Volume<uint32,1>   vol(3,4,2);    

    init_test_data( gry );
    init_test_data( rgb );
    init_test_data( vol );
    

    std::cout << "GRY: " << std::endl;
    std::cout <<  gry    << std::endl;

    std::cout << "RGB: " << std::endl;
    std::cout <<  rgb    << std::endl;

    std::cout << "VOL: " << std::endl;
    std::cout <<  vol    << std::endl;



    /*
     * Colors
     * 
     * Note that you can NOT get color_views objects.
     * If you uncomment the folowing lines the code will not compile
     * ("color_view is protected" error)
     * 
     * This is beacuse a view contains pointers, and sould be always initialized.
     * To avoid confusion between colors and color_views, we can only have color variables, not color_views.
     * 
     * ImageRGB<uint32>::color_view  rgb_view;   // If color_view was not protected, these lines will compile,
     * rgb_view[0] = 0;                          // but you will get a run-time error here! A Segmentation Fault error!
     * 
     */

    ImageGray<uint32>::Color  gry_color;
    ImageRGB<uint32> ::Color  rgb_color;
    Volume<uint32,1> ::Color  vol_color;

    Coord2D<>  c2d(0,0);
    Coord3D<>  c3d(0,0,0);
    
    std::cout << "GRY ACCESS BY COORDS BEF:    " << gry(c2d) <<std::endl;
    std::cout << "RGB ACCESS BY COORDS BEF:    " << rgb(c2d) <<std::endl;
    std::cout << "VOL ACCESS BY COORDS BEF:    " << vol(c3d) <<std::endl;
    
    gry_color = gry(c2d);
    rgb_color = rgb(c2d);
    vol_color = vol(c3d);
    
    gry(c2d) = gry(c2d) + gry_color;
    rgb(c2d) = rgb(c2d) + rgb_color;
    vol(c3d) = vol(c3d) + vol_color;
    
    std::cout << "GRY ACCESS BY COORDS AFT I:  " << gry(c2d) <<std::endl;
    std::cout << "RGB ACCESS BY COORDS AFT I:  " << rgb(c2d) <<std::endl;
    std::cout << "VOL ACCESS BY COORDS AFT I:  " << vol(c3d) <<std::endl;
    
    gry(c2d)[0] = 1;
    rgb(c2d)[0] = 1;
    rgb(c2d)[1] = 13;
    rgb(c2d)[2] = 25;
    vol(c3d)[0] = 1;

    std::cout << "GRY ACCESS BY COORDS AFT II: " << gry(c2d) <<std::endl;
    std::cout << "RGB ACCESS BY COORDS AFT II: " << rgb(c2d) <<std::endl;
    std::cout << "VOL ACCESS BY COORDS AFT II: " << vol(c3d) <<std::endl;

    
    /*
     * Iterators
     * 
     */
    for(ImageGray<uint32>::iterator<> it = gry.colors_begin(); it != gry.colors_end(); ++it)
    {
        gry_color = (*it).value();
        std::cout << "GRY - ITERATOR: " << (*it).value() <<std::endl;
    }
    
    for(ImageRGB<uint32>::iterator<>  it = rgb.colors_begin(); it != rgb.colors_end(); ++it)
    {
        rgb_color = (*it).value();
        std::cout << "RGB - ITERATOR: " << (*it).value() <<std::endl;
    }
    
    for(Volume<uint32,1>::iterator<>  it = vol.colors_begin(); it != vol.colors_end(); ++it)
    {
        vol_color = (*it).value();
        std::cout << "VOL - ITERATOR: " << (*it).value() <<std::endl;
    }

    

    /*
     * REGIONS
     * 
     * All three "Regions" objects will define the same region: coords (1,1) and (0,2)
     * 
     * Well, gs3d is a 3D region...
     * 
     */
   
    ImageMask  imask(3,4);
    VolumeMask vmask(3,4,1);
    GShape2D   gs2d(2);
    GShape3D   gs3d(2);
    
    imask[1][1] = true;
    imask[0][2] = true;
    
    vmask[1][1][0] = true;
    vmask[0][2][0] = true;  
    
    gs2d[0]=GShape2D::CoordType(1,1);
    gs2d[1]=GShape2D::CoordType(0,2);
    
    gs3d[0]=GShape3D::CoordType(1,1,0);
    gs3d[1]=GShape3D::CoordType(0,2,0);
    
    
    /*
     * We can also iterate using ANY kind of Region
     * 
     * With Masks:
     * 
     */
    for(ImageGray<uint32>::iterator< ImageMask > it = gry.colors_begin( imask ); it != gry.colors_end( imask ); ++it)
    {
        gry_color = (*it).value();
        std::cout << "GRY - ITERATOR - MASK:   " << (*it).value() <<std::endl;
    }
    
    for(ImageRGB<uint32>::iterator< ImageMask >  it = rgb.colors_begin( imask ); it != rgb.colors_end( imask ); ++it)
    {
        rgb_color = (*it).value();
        std::cout << "RGB - ITERATOR - MASK:   " << (*it).value() <<std::endl;
    }
    
    for(Volume<uint32,1>::iterator< VolumeMask >  it = vol.colors_begin( vmask ); it != vol.colors_end( vmask ); ++it)
    {
        vol_color = (*it).value();
        std::cout << "VOL - ITERATOR - MASK:   " << (*it).value() <<std::endl;
    }
    
    
    /*
     * And Geometric Shapes:
     * 
     */
    for(ImageGray<uint32>::iterator< GShape2D > it = gry.colors_begin( gs2d ); it != gry.colors_end( gs2d ); ++it)
    {
        gry_color = (*it).value();
        std::cout << "GRY - ITERATOR - GSHAPE: " << (*it).value() <<std::endl;
    }
    
    for(ImageRGB<uint32>::iterator< GShape2D >  it = rgb.colors_begin( gs2d ); it != rgb.colors_end( gs2d ); ++it)
    {
        rgb_color = (*it).value();
        std::cout << "RGB - ITERATOR - GSHAPE: " << (*it).value() <<std::endl;
    }
    
    for(Volume<uint32,1>::iterator< GShape3D >  it = vol.colors_begin( gs3d ); it != vol.colors_end( gs3d ); ++it)
    {
        vol_color = (*it).value();
        std::cout << "VOL - ITERATOR - GSHAPE: " << (*it).value() <<std::endl;
    }


    
    /*
     * Calling our own STL-Like Functions with Regions
     *  
     */

    //
    // First we will print ALL colors of all ImaVols with our print_colors() functions.
    //
    // Note that this is a CONST function
    //
    // Directly:
    //
    std::cout << "GRY - ALL I - BEF: " << std::endl;
    print_colors( gry );

    std::cout << "RGB - ALL I - BEF: " << std::endl;
    print_colors( rgb );
    
    std::cout << "VOL - ALL I - BEF: " << std::endl;
    print_colors( vol );

    //
    // The same, but using iterators:
    //
    std::cout << "GRY - ALL II - BEF: " << std::endl;
    print_colors(gry.colors_begin(), gry.colors_end());

    std::cout << "RGB - ALL II - BEF: " << std::endl;
    print_colors(rgb.colors_begin(), rgb.colors_end());
    
    std::cout << "VOL - ALL II - BEF: " << std::endl;
    print_colors(vol.colors_begin(), vol.colors_end());
    

    //
    // Now we are going to print only a desired region.
    //
    // Note that it doesn't matter how a region is stored, 
    // by a mask, or by a shape: 
    //
    std::cout << "GRY - MASK I  - BEF.:  "  << std::endl;
    print_colors( gry, imask );
    
    std::cout << "RGB - MASK I  - BEF.:  "  << std::endl;
    print_colors( rgb, imask );
    
    std::cout << "VOL - MASK I  - BEF.:  "  << std::endl;
    print_colors( vol, vmask );  // note that we need a 3D region to access to a volume!

    
    std::cout << "GRY - GSHAPE I - BEF.:  "  << std::endl;
    print_colors( gry, gs2d ); 

    std::cout << "RGB - GSHAPE I - BEF.:  "  << std::endl;
    print_colors( rgb, gs2d );
    
    std::cout << "VOL - GSHAPE I - BEF.:  "  << std::endl;
    print_colors( vol, gs3d );   // note that we need a 3D region to access to a volume!

    //
    // The same, but with iterators:
    //
    std::cout << "GRY - MASK II - BEF.:  "  << std::endl;
    print_colors( gry.colors_begin(imask), 
                  gry.colors_end  (imask) ); 
    
    std::cout << "RGB - MASK II  - BEF.:  "  << std::endl;
    print_colors( rgb.colors_begin( imask ), 
                  rgb.colors_end  ( imask ) );
    
    std::cout << "VOL - MASK II  - BEF.:  "  << std::endl;
    print_colors( vol.colors_begin( vmask ), 
                  vol.colors_end  ( vmask ) );
    
    std::cout << "GRY - GSHAPE II - BEF.:  "  << std::endl;
    print_colors( gry.colors_begin(gs2d ), gry.colors_end(gs2d) ); 
    
    std::cout << "RGB - GSHAPE II  - BEF.:  "  << std::endl;
    print_colors( rgb.colors_begin( gs2d ), rgb.colors_end( gs2d ));
    
    std::cout << "VOL - GSHAPE II  - BEF.:  "  << std::endl;
    print_colors( vol.colors_begin( gs3d ), vol.colors_end( gs3d ));

    
 
    //
    // Now we are going to change the values of a region of our ImaVols
    //

    // First we initialize the colors
    gry_color = 0;
    rgb_color = 0;
    vol_color = 0;
    
    // And now call the STL-Like function
    set_color( gry, gs2d, gry_color);
    set_color( rgb, gs2d, rgb_color);
    set_color( vol, gs3d, vol_color);
    
    
    // And print the results to watch them
    std::cout << "GRY - GSHAPE   - AFT.:  "  << std::endl;
    print_colors( gry, gs2d );
    
    std::cout << "RGB - GSHAPE   - AFT.:  "  << std::endl;
    print_colors( rgb, gs2d );
    
    std::cout << "VOL - GSHAPE   - AFT.:  "  << std::endl;
    print_colors( vol, gs3d );


    //
    // Now the same but using iterators
    //
    gry_color = 55;
    rgb_color = 55;
    vol_color = 55;

    set_color( gry.colors_begin( gs2d ), gry.colors_end( gs2d ), gry_color);
    set_color( rgb.colors_begin( gs2d ), rgb.colors_end( gs2d ), rgb_color);
    set_color( vol.colors_begin( gs3d ), vol.colors_end( gs3d ), vol_color);
    
    std::cout << "GRY - GSHAPE - AFT. II:  "  << std::endl;
    print_colors( gry, gs2d );

    std::cout << "RGB - GSHAPE - AFT. II:  "  << std::endl;
    print_colors( rgb, gs2d );

    std::cout << "VOL - GSHAPE - AFT. II:  "  << std::endl;
    print_colors( vol, gs3d );
    

    /*
     * NEW HISTOGRAMS WITH ITERATORS AND REGIONS: 
     * 
     * A real example of STL-Like with Regions function
     * 
     */
    Histogram< ImageGray<uint32> > hgry(0, 100, 9);
    Histogram< ImageRGB<uint32> >  hrgb(0, 100, 3);
    Histogram< Volume<uint32,1> >  hvol(0, 100, 9);

    //
    // Complete histograms:
    //
    hgry.calculate(gry.colors_begin(), gry.colors_end());
    hrgb.calculate(rgb.colors_begin(), rgb.colors_end());
    hvol.calculate(vol.colors_begin(), vol.colors_end());
    
	std::cout << "GRY - HISTOGRAM:  " << std::endl;
	std::cout << hgry << std::endl;
    
	std::cout << "RGB - HISTOGRAM:  " << std::endl;
	std::cout << hrgb << std::endl;
    
	std::cout << "VOL - HISTOGRAM:  " << std::endl;
	std::cout << hvol << std::endl;


	//
	// Histograms in only a Region
	//
	// With GShapes:
	//
    hgry.calculate(gry.colors_begin(gs2d), gry.colors_end(gs2d));
    hrgb.calculate(rgb.colors_begin(gs2d), rgb.colors_end(gs2d));
    hvol.calculate(vol.colors_begin(gs3d), vol.colors_end(gs3d));
    
    std::cout << "GRY - HISTOGRAM - GSHAPE:  " << std::endl;
    std::cout << hgry << std::endl;
    
    std::cout << "RGB - HISTOGRAM - GSHAPE:  " << std::endl;
    std::cout << hrgb << std::endl;

    std::cout << "VOL - HISTOGRAM - GSHAPE:  " << std::endl;
    std::cout << hvol << std::endl;

	//
	// With Masks:
	//
    hgry.calculate(gry.colors_begin(imask), gry.colors_end(imask));
    hrgb.calculate(rgb.colors_begin(imask), rgb.colors_end(imask));
    hvol.calculate(vol.colors_begin(vmask), vol.colors_end(vmask));
    
    std::cout << "GRY - HISTOGRAM - MASK:  " << std::endl;
    std::cout << hgry << std::endl;
    
    std::cout << "RGB - HISTOGRAM - MASK:  " << std::endl;
    std::cout << hrgb << std::endl;

    std::cout << "VOL - HISTOGRAM - MASK:  " << std::endl;
    std::cout << hvol << std::endl;
    
       
    
    /*
     * NEIGHBOURS AND BORDERS
     * 
     * 
     */
    init_test_data( gry );
    init_test_data( rgb );
    init_test_data( vol );

    
    boost::array<std::size_t, 2> borders2d = {{1,2}};
    boost::array<std::size_t, 3> borders3d = {{1,2,1}};
    
    gry_color = 0;
    rgb_color = 0;
    vol_color = 0;
    
    Border<ImageGray<uint32> >& _gry_ = calc_descriptor(new Border<ImageGray<uint32> >(borders2d,gry_color), gry);
    Border<ImageRGB<uint32> >&  _rgb_ = calc_descriptor(new Border<ImageRGB<uint32> >(borders2d,rgb_color), rgb);
    Border<Volume<uint32,1> >&  _vol_ = calc_descriptor(new Border<Volume<uint32,1> >(borders3d,vol_color), vol);
    
    std::cout << "GRY - BORDERS" << std::endl;
    std::cout << _gry_ << std::endl;
    
    std::cout << "RGB - BORDERS" << std::endl;
    std::cout << _rgb_ << std::endl;
    
    std::cout << "VOL - BORDERS" << std::endl;
    std::cout << _vol_ << std::endl;


    /*
     * STL-Like algorithms will skip the borders!
     */
    std::cout << "GRY - BORDERS:"  << std::endl;
    print_colors( _gry_ );
    
    std::cout << "RGB - BORDERS: "  << std::endl;
    print_colors( _rgb_ );
    
    std::cout << "VOL - BORDERS: "  << std::endl;
    print_colors( _vol_ );


    std::cout << "GRY - BORDERS - MASK:  "  << std::endl;
    print_colors( _gry_, imask );
    
    std::cout << "RGB - BORDERS - MASK:  "  << std::endl;
    print_colors( _rgb_, imask );

    std::cout << "VOL - BORDERS - MASK:  "  << std::endl;
    print_colors( _vol_, vmask );
    
    
    std::cout << "GRY - BORDERS - GSHAPE: "  << std::endl;
    print_colors( _gry_, gs2d );
   
    std::cout << "RGB - BORDERS - GSHAPE:  "  << std::endl;
    print_colors( _rgb_, gs2d );

    std::cout << "VOL - BORDERS - GSHAPE:  "  << std::endl;
    print_colors( _vol_, gs3d );


  
    
    /// Neighbours///
    
    //
    // Note the neighbours are regions cenetered in origin.
    // When we iterate on them, we will cenetrer the neighbourhood in
    // the current position
    //
    Neighborhood2D ngb2d(4);
    ngb2d[0]=Neighborhood2D::CoordType( 0,-1 );
    ngb2d[1]=Neighborhood2D::CoordType(-1, 0 );  
    ngb2d[2]=Neighborhood2D::CoordType( 1, 0 );
    ngb2d[3]=Neighborhood2D::CoordType( 0, 1 );
    
    Neighborhood3D ngb3d(6);
    ngb3d[0]=Neighborhood3D::CoordType( 0,-1, 0 );
    ngb3d[1]=Neighborhood3D::CoordType(-1, 0, 0 ); 
    ngb3d[2]=Neighborhood3D::CoordType( 1, 0, 0 );
    ngb3d[3]=Neighborhood3D::CoordType( 0, 1, 0 );
    ngb3d[4]=Neighborhood3D::CoordType( 0, 0, 1 );
    ngb3d[5]=Neighborhood3D::CoordType( 0, 0,-1 );

    
    /*
     * Neighbours Iterators
     * 
     */
    for(Border<ImageGray<uint32> >::iterator<> it = _gry_.colors_begin(); it != _gry_.colors_end(); ++it)
    {
        std::cout << "GRY - ITERATOR:             " << (*it).value() <<std::endl;
        for(Border<ImageGray<uint32> >::iterator<>::pixel_type::neighbor_iterator nit = (*it).local_begin(ngb2d); nit != (*it).local_end(ngb2d); ++nit)
        {
            std::cout << "GRY - ITERATOR - NEIGHBOUR: " << (*nit).value() <<std::endl;
        }
    }
    
    for(Border<ImageRGB<uint32> >::iterator<>  it = _rgb_.colors_begin(); it != _rgb_.colors_end(); ++it)
    {
        std::cout << "RGB - ITERATOR:             " << (*it).value() <<std::endl;
        for(Border<ImageRGB<uint32> >::iterator<>::pixel_type::neighbor_iterator nit = (*it).local_begin(ngb2d); nit != (*it).local_end(ngb2d); ++nit)
        {
            std::cout << "RGB - ITERATOR - NEIGHBOUR: " << (*nit).value() <<std::endl;
        }
    }
    
    for(Border<Volume<uint32,1> >::iterator<>  it = _vol_.colors_begin(); it != _vol_.colors_end(); ++it)
    {
        std::cout << "VOL - ITERATOR:             " << (*it).value() <<std::endl;
        for(Border<Volume<uint32,1> >::iterator<>::pixel_type::neighbor_iterator nit = (*it).local_begin(ngb3d); nit != (*it).local_end(ngb3d); ++nit)
        {
            std::cout << "VOL - ITERATOR - NEIGHBOUR: " << (*nit).value() <<std::endl;
        }
    }


    /*
     * STl-Like functions that works for iterators
     * 
     */
    std::cout << "GRY - NEIGHBOURS" << std::endl;
    print_neighbours(_gry_, ngb2d);
    
    std::cout << "RGB - NEIGHBOURS" << std::endl;
    print_neighbours(_rgb_, ngb2d);
    
    std::cout << "VOL - NEIGHBOURS" << std::endl;
    print_neighbours(_vol_, ngb3d);
    
    
    std::cout << "GRY - NEIGHBOURS - MASK" << std::endl;
    print_neighbours(_gry_, imask, ngb2d);
    
    std::cout << "RGB - NEIGHBOURS - MASK " << std::endl;
    print_neighbours(_rgb_, imask, ngb2d);
    
    std::cout << "VOL - NEIGHBOURS - MASK" << std::endl;
    print_neighbours(_vol_, vmask, ngb3d);
    
    
    std::cout << "GRY - NEIGHBOURS - GSHAPE" << std::endl;
    print_neighbours(_gry_, gs2d, ngb2d);
    
    std::cout << "RGB - NEIGHBOURS - GSPAHE " << std::endl;
    print_neighbours(_rgb_, gs2d, ngb2d);
    
    std::cout << "VOL - NEIGHBOURS - GSHAPE" << std::endl;
    print_neighbours(_vol_, gs3d, ngb3d);
    
    
    std::cout << "GRY - FILTER - BEF" << std::endl;
    std::cout << gry << std::endl;

    accumulate_filter( _gry_.colors_begin(),
                       _gry_.colors_end(),
                        gry.colors_begin(),
                        ngb2d);
    
    std::cout << "GRY - FILTER - AFT" << std::endl;
    std::cout << gry << std::endl;
    
    init_test_data(gry);
    
    std::cout << "GRY - FILTER - MASK - BEF" << std::endl;
    std::cout << gry << std::endl;

    accumulate_filter( _gry_.colors_begin( imask ),
                       _gry_.colors_end  ( imask ),
                        gry. colors_begin( imask ),
                        ngb2d);
    
    std::cout << "GRY - FILTER - MASK - AFT" << std::endl;
    std::cout << gry << std::endl;
    
    init_test_data(gry);
    
    std::cout << "GRY - FILTER - GSHAPE - BEF" << std::endl;
    std::cout << gry << std::endl;

    accumulate_filter( _gry_.colors_begin( gs2d ),
                       _gry_.colors_end  ( gs2d ),
                        gry. colors_begin( gs2d ),
                        ngb2d);
    
    std::cout << "GRY - FILTER - GSHAPE - AFT" << std::endl;
    std::cout << gry << std::endl;
    

    
    global_mean_filter( _gry_.colors_begin( gs2d ),
                        _gry_.colors_end  ( gs2d ),
                         gry. colors_begin( gs2d ) );
    
    std::cout << "GRY - GLOBAL - GSHAPE" << std::endl;
    std::cout << gry << std::endl;


    global_mean_filter( _gry_.colors_begin( imask ),
                        _gry_.colors_end  ( imask ),
                         gry. colors_begin( imask ) );
    
    std::cout << "GRY - GLOBAL - MASK" << std::endl;
    std::cout << gry << std::endl;

#endif
} // end main





//
// STL-Like function implementations
//
// Note that only one of the overloaded functions implements it,
// the others only are wrapers to call the main function.
//
// And also note that the one that MUST implement the algoritm is
// the one that works with DataIterators.
// This is because is the only one that all others can call.
//
template<          class DataIterator >
void print_colors( const DataIterator& begin, 
				   const DataIterator& end)
{
	for( DataIterator it = begin; it != end; ++it)
	{
		std::cout << (*it).value() << std::endl;
	}
}

template< class DataIterator >
void set_color( DataIterator begin, 
				DataIterator end,
	   typename DataIterator::Color color)
{
	for( DataIterator it = begin; it != end; ++it)
	{
		(*it).value() = color;
	}
}


//
// All overloaded funciotns
//
template<          class ImaVolType >
void print_colors( const ImaVolType& iv )
{
	print_colors( iv.colors_begin(), iv.colors_end() );	
}

template<          class ImaVolType,     class RegionType >
void print_colors( const ImaVolType& iv, const RegionType& region )
{
	print_colors( iv.colors_begin( region ), 
			      iv.colors_end  ( region )  );	
}


template< class ImaVolType >
void set_color( ImaVolType& iv, 
	   typename ImaVolType::Color color)
{
	set_color( iv.colors_begin(), 
			   iv.colors_end(), 
			   color);
}

template<class ImaVolType, class RegionType >
void set_color( ImaVolType& iv, const RegionType& region,
				typename ImaVolType::Color color)
{
	set_color( iv.colors_begin( region ), 
			   iv.colors_end  ( region ), 
			   color);
}



template<        class Iterator, class NeighbourType >
void print_neighbours( Iterator first,
                       Iterator last,  NeighbourType neighbors )
{
    typedef typename Iterator::pixel_type::neighbor_iterator neighbor_iterator;
    
    for ( Iterator it = first; it != last; ++it)
    {
        std::cout << "Current color: " << (*it).value() << std::endl;

        for ( neighbor_iterator nit  = (*it).local_begin(neighbors); nit != (*it).local_end(neighbors); ++nit)
        {
            std::cout << "Current neighbour color: " << (*nit).value() << std::endl;
        }
    }
}


template<              class ImaVolType, class NeighbourType >
void print_neighbours( const ImaVolType& iv,   NeighbourType neighbours )
{
    
    print_neighbours( iv.colors_begin(),
                      iv.colors_end(),
                      neighbours);
}

template<              class ImaVolType,     class RegionType,   class NeighbourType >
void print_neighbours( const ImaVolType& iv, const RegionType& region, NeighbourType neighbours )
{
    
    print_neighbours( iv.colors_begin( region ),
                      iv.colors_end  ( region ),
                      neighbours);
}


template<         class InIterator, class OutIterator, class NeighbourType >
void accumulate_filter( InIterator first,
                        InIterator last,  OutIterator out,   NeighbourType neighbours )
{
    for(InIterator it = first; it!=last; ++it)
    {
        (*out).value() = 0;
        
        for( typename InIterator::pixel_type::neighbor_iterator nit = (*it).local_begin(neighbours); nit != (*it).local_end(neighbours); ++nit)
        {
            (*out).value() = (*out).value() + (*nit).value();
        }
        ++out;
    }
        
}

template<               class ImaVolType, class NeighbourType >
void accumulate_filter( const ImaVolType& in,
                              ImaVolType& out,  NeighbourType neighbours )
{
    accumulate_filter( in.colors_begin(),
                       in.colors_end(),
                       out.colors_begin(),
                       neighbours);
}

template<               class ImaVolType,      class RegionType,   class NeighbourType >
void accumulate_filter( const ImaVolType& in, 
                              ImaVolType& out, const RegionType& region, NeighbourType neighbours )
{
    accumulate_filter( in.colors_begin ( region ),
                       in.colors_end   ( region ),
                       out.colors_begin( region ),
                       neighbours);
}


//
// global_mean_filter: This filter computes the global mean color, and adds it to all elements of the region
//
template<          class InIterator, class OutIterator>
void global_mean_filter( InIterator first,
                         InIterator last,  OutIterator out )
{
    //
    // Compute the global mean with the global iterators
    //
    typename OutIterator::Color              global_mean=0;
    typename OutIterator::Color::data_type   global_area=0;
    
    for( typename InIterator::pixel_type::global_iterator git = (*first).global_begin(); git != (*first).global_end(); ++git)
    {
        global_mean = global_mean + (*first).value();
        global_area++;
    }
    
    global_mean = global_mean / global_area;
    
    
    //
    // Apply the global mean to the region
    //
    for(InIterator it = first; it!=last; ++it)
    {
        (*out).value() = (*it).value() + global_mean;
        ++out;
    }
}

template<                class ImaVolType >
void global_mean_filter( const ImaVolType& in,
                               ImaVolType& out )
{
    global_mean_filter( in.colors_begin(), 
                        in.colors_end(), 
                        out.colors_begin() );
}

template<                class ImaVolType,      class RegionType >
void global_mean_filter( const ImaVolType& in, 
                               ImaVolType& out, const RegionType& region )
{
    global_mean_filter( in.colors_begin ( region ), 
                        in.colors_end   ( region ), 
                        out.colors_begin( region ) );
}


//
// Helper function (not overloaded...) 
//
template<      class ImaVolType >
void init_test_data( ImaVolType& in )
{
    typename ImaVolType::data_type  val = 0;

	for(std::size_t ch = 0; ch < in.num_channels(); ++ch )
	{
	    for(typename ImaVolType::template iterator<> it = in.colors_begin() ; it != in.colors_end(); ++it  )
	    {
    		(*it).value(ch) = ++val; // + in.num_elements_in_channel(ch)*ch;
    	}
    	//++val;
    }
}


