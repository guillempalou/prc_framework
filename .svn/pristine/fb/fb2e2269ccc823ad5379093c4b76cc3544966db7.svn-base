// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------

//
//  Detection of a tumult using particle filters.
//

#define IMAGEPLUS_TOOL_CONFIG_NAME  tumult_detector
//#define IMAGEPLUS_TOOL_CONFIG_GROUP examples

#include <imageplus/toolbox/tool_config.hpp>



/*
 * Tool include
 */
#include <tumult_detector.hpp>


IMAGEPLUS_TOOL_CONFIG_BRIEF()

    "Detection of tumults using particle filters.";

IMAGEPLUS_TOOL_CONFIG_DESCRIPTION()

    "Tool used to configure the main parameters of the tumult detection tool. \n" +
    "The input of this tool is a video sequence (MPEG).\n" +
    "The foreground is extracted using a simple one gaussian model (it is extremely " +
    "important to adjust correctly the fg extraction parameters, initial variance and standard deviation).\n" +
    "The tracking is done using particle filters, a specific Particle Filter Class has been created named Tumult Particle Filter.\n" +
    "An output file shows the results of the detection of tumults for the input sequence.\n" +
    "\n"+
    "In order to read MPEG files compile the tool with USE_FFMPEG flag. \n" +
    "\n"+
    "The MPEG sequences can be found in the following path: seq/projects/hesperia/aeropuerto/CPY-T4-01/Sequences/2006/Aug/01/01/ \n" +
    "Sequences correspond to the cfg files for the environments with the following correspondence:\n" +
    " CPY-T4-01/*/*/*/*/01/ -> Environment 3 \n" +
    " CPY-T4-01/*/*/*/*/02/ -> Environment 2 \n" +
    " CPY-T4-02/*/*/*/*/01/ -> Environment 1 \n" +
    " CPY-T4-02/*/*/*/*/02/ -> Environment 4 \n" +
    "Environments 1 and 4 have no tumults, read environment 2 and 3 to observe tumult detection.\n";

IMAGEPLUS_TOOL_CONFIG_PARAMETERS()

    // my options
    uint64  number_of_digits;        //!< Number of digits of the input/output sequence
    uint64  image_width;             //!< Width of the input and output image
    uint64  image_height;            //!< Height of the input and output image
    uint64  number_of_particles;     //!< Number of particles used for each particle filter
    uint64  number_of_filters;       //!< Maximum Number of particle filters used for tracking
    float64 variance;                //!< Variance used for the particle filters resampling
    float64 beta;                    //!< BETA parameter that varies the influence of Battacharyya's distance
    float64 ramp_error;              //!< RAMPERROR parameter that limits how far a PF can get from the ramp estimation (in average %)
    uint64  number_of_bins;          //!< NumberOfBins: Number of bins of the histogram of each particle and the PF
    float64 lambda_color;            //!< LAMDAC: To control the influence of the BattDist in the score
    float64 lambda_fg;               //!< LAMDAF: To control the influence of the FG pixels in the score
    float64 survival_rate_threshold; //!< SurivalRateThreshold: Threshold of the survival rate of the PF
    uint64  resolution_y;            //!< Y' Resolution ( E1 => 500 cm, E2 => 250 cm, E3 => 250 cm, E4 => 500 cm )
    uint64  resolution_speed;        //!< Speed Resolution of the Detection Grid ( E1 => 50 cm/s, E2 => 50 cm/s, E3 => 50 cm/s, E4 => 50 cm/s )
    uint64  detection_threshold;     //!< Thhreshold used for the detection of a tumult
    uint64  detection_histeresis;    //!< HISTERESIS threshold used to decide if a possible tumult condition is a real tumult

    // fg detection parameters
    uint64 training_frames; //!< Number of training frames used to initialize background
    uint64 init_variance;   //!< This parameter is used to calculate the THRESHOLD
    float64 std_dev_factor; //!< This parameter is used to calculate the THRESHOLD
    float64 ro;             //!< This parameter is used to actualize mean and variance models

    uint64 mode;            //!< This parameter determines the output images
                            //!< (0: draws FG images, 1: draws only Particle Filters, 2: draws Particles, 3: draws Particle filters and their path and 4: writes all previous ones)

    // my flags
    bool output_file;         //!< Option generate output file

    // my arguments
    string input_sequence;        //!< Name of the file to do the fg segmentation, tracking and tumult detection
    string environment_file_name; //!< File name where the environment info is stored

    // environment data
    struct TumultEnvironmentData environment; //!< Structure used to store the environment info

IMAGEPLUS_TOOL_CONFIG_DEFAULT_VALUES()

    // default values
    number_of_digits = 4;
    image_width = 640;
    image_height = 240;
    number_of_particles = 100;
    number_of_filters = 2000;
    variance = 3;
    beta = 5;
    ramp_error = 30;
    number_of_bins = 10;
    lambda_color = 0.5;
    lambda_fg = 0.5;
    survival_rate_threshold = 0.1;
    resolution_y = 250;
    resolution_speed = 50;
    detection_threshold = 3;
    detection_histeresis = 2;
    training_frames = 50;
    init_variance = 50;
    std_dev_factor = 2.5;
    ro = 0.01;

    mode = 4;

    output_file = false;

IMAGEPLUS_TOOL_CONFIG_OPTIONS()

    IMAGEPLUS_TOOL_CONFIG_OPTION_ABV( number_of_digits   , "Number of digits of the input/output sequence", 'd');
    IMAGEPLUS_TOOL_CONFIG_OPTION_ABV( image_width        , "Width of the input and output image", 'w');
    IMAGEPLUS_TOOL_CONFIG_OPTION_ABV( image_height       , "Height of the input and output image", 'h');
    IMAGEPLUS_TOOL_CONFIG_OPTION_ABV( number_of_particles, "Number of particles used in the particle filtar", 'P');
    IMAGEPLUS_TOOL_CONFIG_OPTION_ABV( number_of_filters  , "Maximum Number of particle filters used for tracking", 'N');
    IMAGEPLUS_TOOL_CONFIG_OPTION_ABV( variance           , "variance used in the propagate of the particles", 'v' );
    IMAGEPLUS_TOOL_CONFIG_OPTION_ABV( beta               , "beta used in weight calculation", 'b' );
    IMAGEPLUS_TOOL_CONFIG_OPTION_ABV( ramp_error         , "RAMPERROR parameter that limits how far a PF can get from the ramp estimation (in average %)", 'e');
    IMAGEPLUS_TOOL_CONFIG_OPTION_ABV( number_of_bins     , "NumberOfBins: Number of bins of the histogram of each particle and the PF ", 'n');
    IMAGEPLUS_TOOL_CONFIG_OPTION_ABV( lambda_color       , "LAMDAC: To control the influence of the BattDist in the score", 'c');
    IMAGEPLUS_TOOL_CONFIG_OPTION_ABV( lambda_fg          , "LAMDAF: To control the influence of the FG pixels in the score", 'f');

    IMAGEPLUS_TOOL_CONFIG_OPTION_ABV( survival_rate_threshold , "SurivalRateThreshold: Threshold of the survival rate of the PF", 's');
    IMAGEPLUS_TOOL_CONFIG_OPTION_ABV( resolution_y            , "Y' Resolution ( E1 => 500 cm, E2 => 250 cm, E3 => 250 cm, E4 => 500 cm )", 'Y');
    IMAGEPLUS_TOOL_CONFIG_OPTION_ABV( resolution_speed        , "Speed Resolution ( E1 => 50cm/s, E2 => 50 cm/s, E3 => 50 cm/s, E4 => 50 cm/s )", 'S');
    IMAGEPLUS_TOOL_CONFIG_OPTION_ABV( detection_threshold     , "Threshold used for the detection of a tumult", 't');
    IMAGEPLUS_TOOL_CONFIG_OPTION_ABV( detection_histeresis    , "HISTERESIS threshold used to decide if a possible tumult condition is a real tumult", 'h');

    IMAGEPLUS_TOOL_CONFIG_OPTION_ABV( training_frames , "Number of training frames used to initialize background", 't');
    IMAGEPLUS_TOOL_CONFIG_OPTION_ABV( init_variance   , "This parameter is used to calculate the THRESHOLD", 'V');
    IMAGEPLUS_TOOL_CONFIG_OPTION_ABV( std_dev_factor  , "This parameter is used to calculate the THRESHOLD", 'D');
    IMAGEPLUS_TOOL_CONFIG_OPTION_ABV( ro              , "This parameter is used to actualize mean and variance models", 'R');

    IMAGEPLUS_TOOL_CONFIG_OPTION_ABV( mode            , "This parameter determines the output images ( 0: draws FG images, 1: draws only Particle Filters, 2: draws Particles, 3: draws Particle filters and their path and 4: writes all previous ones)", 'm');

IMAGEPLUS_TOOL_CONFIG_FLAGS()

    IMAGEPLUS_TOOL_CONFIG_FLAG_ABV( output_file, "For generating an external file with the detection results", 'F' );

IMAGEPLUS_TOOL_CONFIG_ARGUMENTS()

    IMAGEPLUS_TOOL_CONFIG_ARGUMENT( input_sequence       , "Input sequence name" );
    IMAGEPLUS_TOOL_CONFIG_ARGUMENT( environment_file_name, "Environment file name" );

IMAGEPLUS_TOOL_CONFIG_READ_PARAMETERS()

    IMAGEPLUS_TOOL_CONFIG_READ( number_of_digits );
    IMAGEPLUS_TOOL_CONFIG_READ( image_width );
    IMAGEPLUS_TOOL_CONFIG_READ( image_height );
    IMAGEPLUS_TOOL_CONFIG_READ( number_of_particles );
    IMAGEPLUS_TOOL_CONFIG_READ( number_of_filters );
    IMAGEPLUS_TOOL_CONFIG_READ( variance );
    IMAGEPLUS_TOOL_CONFIG_READ( beta);
    IMAGEPLUS_TOOL_CONFIG_READ( ramp_error );
    IMAGEPLUS_TOOL_CONFIG_READ( number_of_bins );
    IMAGEPLUS_TOOL_CONFIG_READ( lambda_color );
    IMAGEPLUS_TOOL_CONFIG_READ( lambda_fg );
    IMAGEPLUS_TOOL_CONFIG_READ( survival_rate_threshold );
    IMAGEPLUS_TOOL_CONFIG_READ( resolution_y );
    IMAGEPLUS_TOOL_CONFIG_READ( resolution_speed );
    IMAGEPLUS_TOOL_CONFIG_READ( detection_threshold );
    IMAGEPLUS_TOOL_CONFIG_READ( detection_histeresis );
    IMAGEPLUS_TOOL_CONFIG_READ( training_frames );
    IMAGEPLUS_TOOL_CONFIG_READ( init_variance );
    IMAGEPLUS_TOOL_CONFIG_READ( std_dev_factor );
    IMAGEPLUS_TOOL_CONFIG_READ( ro );

    IMAGEPLUS_TOOL_CONFIG_READ( mode );

    IMAGEPLUS_TOOL_CONFIG_READ( output_file );

    IMAGEPLUS_TOOL_CONFIG_READ( input_sequence );
    IMAGEPLUS_TOOL_CONFIG_READ( environment_file_name );

IMAGEPLUS_TOOL_CONFIG_MAIN()
{
    TumultParticle::input_data_type     input_data;
    TumultParticle::init_data_type      initialization_data;
    bool                                tumult_detected = false;
    uint64                              current_frame = 0;
    int8                                frame_number[10];
    std::fstream                        f;              // Output file with results
    std::vector< TumultParticleFilter > tumult_filters; // Vector to store all Tumult particle filters
    uint64                              tumult_detection_histeresis = 0; // Number of frames of possible tumult condition to consider it as a tumult

    // Output information:
    std::cout << "Sequence file name: " << cfg.input_sequence << std::endl;
    if( cfg.output_file )
    {
        std::cout << "Writing output file." << std::endl;
    }
    f.open("Tumult_detection_results.txt", ios::out);

    // Reading data of the environment
    read_environment(cfg);

    // Initialize Input Data
    initialize_input_data( input_data, cfg );

    // Reading input sequence
    io::ReadSequence rseq1( cfg.input_sequence );
    io::ReadSequence rseq2( cfg.input_sequence );
    std::cout << "Sequence open... " << std::endl;
    rseq1 >> input_data.current_image;
    rseq2 >> input_data.fg_mask;
    input_data.fg_mask = 0;
    input_data.output_image = to_rgb( input_data.current_image );

    cfg.image_width = input_data.current_image.size_x();
    cfg.image_height = input_data.current_image.size_y();

    // Initialization Data
    initialization_data.variance = cfg.variance;
    initialization_data.beta = cfg.beta;

    sprintf( frame_number,"%06d", static_cast< int32 > ( current_frame ) );
    string input_file =  "seq/training";
    string input_extension = ".jpg";

    // Fg segmentation:
    //initialize the FrameModel with the PixelModels desired
    FrameModel< OneGaussianPM > frame_model_PM( cfg.image_width, cfg.image_height );
    float64 std_dev_factor_2 = cfg.std_dev_factor * cfg.std_dev_factor;
    frame_model_PM.set_pixel_models( OneGaussianPM( cfg.init_variance, cfg.ro, std_dev_factor_2 ) );
    //initialize the segmentation object
    Foreground2D foreground_2d( cfg.training_frames, cfg.image_width, cfg.image_height );
    imageplus::math::morphology::Opening<2> ope( 4, 1 );

    // Reading input sequence
    while ( !rseq1.eof() )
    {
        // For each frame (unless the initial one)
        if( current_frame != 0 )
        {
            rseq1 >> input_data.current_image;
            rseq2 >> input_data.output_image;
        }

        std::cout << "frame:" << frame_number << std::endl;

        if( current_frame < cfg.training_frames ) //    if training period
        {
            // FG Extraction training period
            foreground_2d.segmentation< OneGaussianPM, 3 >( frame_model_PM, input_data.current_image, input_data.fg_mask );

            input_data.fg_mask = ope.filter( input_data.fg_mask );
        }
        else // training period ended
        {
            // FG Extraction
            foreground_2d.segmentation< OneGaussianPM, 3 >( frame_model_PM, input_data.current_image, input_data.fg_mask );
            input_data.fg_mask = ope.filter( input_data.fg_mask );

            // CreateParticleFilters
            create_particle_filter( tumult_filters, input_data, initialization_data, cfg.number_of_particles, cfg.beta );

            // If there are filters
            if( tumult_filters.size() > 0 )
            {
                tracking( tumult_filters, input_data, initialization_data, cfg.survival_rate_threshold );   // Tracking  ); // Tracking
                std::cout << "...tracking." << std::endl;

                // DroppingPF
                dropping_pf( tumult_filters, input_data );
                std::cout << "...dropping." << std::endl;

                // Detection
                if( tumult_filters.size() > 0 ) // Dropping could destroy them all!!!
                {
                    tumult_detected = detecting_tumult( tumult_filters, cfg.resolution_speed, cfg.resolution_y, cfg.detection_threshold, cfg.detection_histeresis, tumult_detection_histeresis );
                    std::cout << "...detecting." << std::endl;
                }
            }
        }

        // Writing results (Output images)
        write_result_images( tumult_filters, input_data, current_frame, tumult_detected, cfg.mode ); // Draw ALL previous ones

        // Output file with detection
        if ( cfg.output_file )
        {
            write_output_data( f, tumult_filters, current_frame, tumult_detected, cfg );
        }

        current_frame++;
        sprintf( frame_number,"%06d", static_cast< int32 > ( current_frame ) );

        if( rseq1.endframe() == current_frame )
        {
            f.close();
        }
    }
}
IMAGEPLUS_TOOL_CONFIG_END()
