// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------
//!
//!  \file readvolume.cpp
//!
//!
#include <imageplus/io/readvolume.hpp>

#include <cstdio>

using namespace imageplus;
using namespace imageplus::io;

namespace ipcomp = imageplus::compress;

ReadVolume::ReadVolume():_filename("")
{

}

ReadVolume::ReadVolume( const std::string& filename ) :
        _filename( filename )
{
}

ReadVolume::~ReadVolume()
{
}
void ReadVolume::open(const std::string& filename)
{
    FILE *fp=fopen(filename.c_str(), "rb");
    if (fp==NULL) throw ImagePlusError( "ERROR(ReadVolume) : Cannot open  " + filename );
    else
    {
        fclose(fp);
        _filename=filename;
    }
}
template<typename T>
void ReadVolume::operator>>( VolumeRGB<T>& vol ) const
{
}


template<typename T>
void ReadVolume::operator>>( VolumeGray<T>& vol ) const
{
    //Data Union for type conversion
    union _dataToCompress
    {
        T *dataVoxelOriginal;
        uint8 *dataVoxelsInChars;
    } dataToCompress;

    uint32 CubesX, CubesY, CubesZ;
    
    // AGIL: 'VoxelSize is set but not used' warning
    //float64 VoxelSize;

    size_t return_size;

    FILE *fp=fopen(_filename.c_str(), "rb");
    if (fp!=NULL)
    {
        imageplus::uint32 r_size;

        // Read file header
        uint16 usInputVersion;
        return_size = fread(&usInputVersion,sizeof(uint16),1,fp);
        if (return_size != 1)
        {
            throw ImagePlusError( "ERROR(ReadVolume) : No version found " + _filename );
        }


        // Check file parameters
        //if(usInputVersion>FileVersion)
        //{
        //throw ImagePlusError( "ERROR(ReadSequence) : Could not open file " + datfile );
        //cout << "Error: File version (" << usInputVersion << ") not compatible with class version (" << FileVersion << ")." << endl;
        //exit(0);
        //}
        //Read Header from file
        file_header header;
        return_size = fread(&header,sizeof(file_header),1,fp);
        if (return_size != 1)
        {
            throw ImagePlusError( "ERROR(ReadVolume) : Inconsistent header size " + _filename );
        }

        // AGIL: 'VoxelSize is set but not used' warning
        //VoxelSize=header.voxel_size;

        CubesX=header.cubes_x;
        CubesY=header.cubes_y;
        CubesZ=header.cubes_z;
        //Consistency check: Size of Data Type
        if (header.data_size!=sizeof(T))
        {
            fclose(fp);
            throw ImagePlusError( "ERROR(ReadVolume) : Inconsistent Data Size " + _filename );
        }

        //Reallocation of the volume given file parameters
        vol=VolumeGray<T>(CubesX,CubesY,CubesZ);
        //Read sizeo of the total amount of data stored in the file
        return_size = fread(&r_size,sizeof(uint32),1,fp);
        if (return_size != 1)
        {
            throw ImagePlusError( "ERROR(ReadVolume) : No size of stored data found " + _filename );
        }


        //Allocate a data buffer
        uint8 *buffer = new uint8[r_size];
        //Pointer to data
        dataToCompress.dataVoxelOriginal=vol(0).data();
        //Read all Data as a single block
        return_size = fread (buffer,1,r_size,fp);
        if (return_size != r_size)
        {
            throw ImagePlusError( "ERROR(ReadVolume) : Error reading volume data " + _filename );
        }

        //Uncompress data
        ipcomp::Rle uncompressor;
        uncompressor.uncompress (buffer,dataToCompress.dataVoxelsInChars,r_size);
        //Free memory
        delete [] buffer;
        //delete [] header;
        //Close file
        fclose(fp);
    }
    else throw ImagePlusError( "ERROR(ReadVolume) : Cannot open  " + _filename );
}

//ReadVolume instantiations
namespace imageplus
{
    namespace io
    {

        template void ReadVolume::operator>><uint8>(VolumeGray<uint8>&) const;
        template void ReadVolume::operator>><uint8>(VolumeRGB<uint8>&) const;

        template void ReadVolume::operator>><int64>(VolumeGray<int64>&) const;
        template void ReadVolume::operator>><int64>(VolumeRGB<int64>&) const;

        template void ReadVolume::operator>><float64>(VolumeGray<float64>&) const;
        template void ReadVolume::operator>><float64>(VolumeRGB<float64>&) const;

    }
}

