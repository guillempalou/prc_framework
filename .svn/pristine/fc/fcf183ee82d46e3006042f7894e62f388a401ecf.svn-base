// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------

/*!
 * \file gaussian_distribution.hpp
 *
 * Gaussian distribution for N dimensional spaces.
 */

#ifndef IMAGEPLUS_MATH_STATISTICS_GAUSSIAN_DISTRIBUTIONL_HPP
#define IMAGEPLUS_MATH_STATISTICS_GAUSSIAN_DISTRIBUTIONL_HPP

#include <imageplus/core.hpp>
#include <boost/array.hpp>
#include <imageplus/core/imageplus_types.hpp>
#include <imageplus/math/numeric/transformations.hpp> 	//matrix inverse
#include <imageplus/math/numeric/products.hpp> 	//matrix multiplication
#include <imageplus/math/numeric/lu_decomposition.hpp> 	//matrix determinant
#include <imageplus/math/numeric/cholesky.hpp> 
#include <imageplus/math/statistics/random_generators.hpp>
#include <algorithm>



namespace imageplus
{
namespace math
{
namespace statistics
{

/*!
 * \brief Gaussian Distribution class for N dimensional spaces.
 *
 * \tparam N : Number of dimensions (3 for RGB or YUV image spaces)
 *
 * \author Jaume Gallego     <jgallego@gps.tsc.upc.edu>
 * \author Albert Gil Moreno <albert.gil@upc.edu> (review)
 *
 * \date   2008-07-29
 * \date   2011-03-05 (review)
 *
 * \todo Generic documentation and usage examples of the class should be added
 * \todo what about template T?
 * \todo Documentation of ALL members should be reviewed!!
 * \todo we should create typedef like "Mean" to be able to declare variable like GaussianDistribution::Mean m;
 *       this way, if we change the internal type (e.g. boost::array for std::vector) the users of the class won't change anything;
 *       and not only users, but also reviewers of anyone that modifies the class. In general the usage of typedefs helps
 *       and is the base of the generic programming
 * \todo Are "constructors", "resets" and "sets" redundant?
 */
template <typename T, std::size_t N>
class GaussianDistribution
#ifndef FIX_DOCUMENTATION
{
public:

    //! Model for Probability distributions
    static const int32 continuous=1;

    /*!
     * \brief Default constructor
     */
    GaussianDistribution();

    /*!
     * \brief Constructor
     *
     * \todo why "init_mean/var" and not simply "mean/var"?
     * \todo "init_mean" is used as the "init_mean of all channels?
     * \todo should the "diagonal_cov_matrix" be true/false by default?
     * \todo should we rename "diagonal_cov_matrix" as "is_diagonal"?
     * \todo should be T changed to "const T&"?
     *
     * \param[in] init_mean           : (???)
     * \param[in] init_var            : (???)
     * \param[in] diagonal_cov_matrix : 1--> Diagonal covariance matrix; 0--> Not diagonal covariance matrix
     */
    GaussianDistribution(T init_mean,  float64 init_var, bool diagonal_cov_matrix);

    /*!
     * \brief Constructor
     *
     * \param[in] mean_vector         : boost::array<float64,N>
     * \param[in] init_var            : float64
     * \param[in] diagonal_cov_matrix : boolean   1--> Diagonal covariance matrix; 0--> Not diagonal covariance matrix
     *
     * \todo use the typedef "Mean" instead of boost::array<T,N>
     */
    GaussianDistribution(const boost::array<T,N> & mean_vector, float64  init_var, bool diagonal_cov_matrix);

    /*!
     * \brief Constructor
     *
     * \param[in] mean_vector         : boost::array<float64,N>
     * \param[in] var_vector          : boost::array<float64,N>
     * \param[in] diagonal_cov_matrix : boolean   1--> Diagonal covariance matrix; 0--> Not diagonal covariance matrix
     */
    GaussianDistribution(const boost::array<T,N> & mean_vector, const boost::array<float64,N> & var_vector, bool diagonal_cov_matrix);

    /*!
     * \brief Constructor
     *
     * \param[in] init_data           : MultiArray<float64,1>. N cols (one for each dimension). 2 rows(mean, var).
     * \param[in] diagonal_cov_matrix : boolean   1--> Diagonal covariance matrix; 0--> Not diagonal covariance matrix
     */
    GaussianDistribution(const MultiArray<float64,2> & init_data, bool diagonal_cov_matrix);

    /*!
     * \brief Constructor
     *
     * \param[in] mean_vector         : boost::array<float64,N>
     * \param[in] covariance_matrix   : MultiArray<float64,2>
     * \param[in] diagonal_cov_matrix : boolean   1--> Diagonal covariance matrix; 0--> Not diagonal covariance matrix
     */
    GaussianDistribution(const boost::array<T,N> & mean_vector, const MultiArray<float64,2> & covariance_matrix, bool diagonal_cov_matrix);

    /*!
     * \brief Copy Constructor
     *
     * \param[in] cpy : GaussianDistribution<T,N>
     */
    GaussianDistribution(const GaussianDistribution<T,N> & cpy);

    /*!
     * \brief Assignment operator
     *
     * \param[in] cpy : the GaussianDistribution to copy from
     *
     * \todo should it return *this to allow g1=g2=g3? (it is the general rule)
     */
    void operator=(const GaussianDistribution<T,N> & cpy);

    /*!
     * \brief Reset gaussian values
     *
     * \param[in] new_mean : float64
     * \param[in] new_var  : float64
     */
    void reset(T new_mean, float64  new_var);

    /*!
     * \brief Reset gaussian values
     *
     * \param[in] new_mean_vector : boost::array<float64,N>
     * \param[in] new_var         : float64
     */
    void reset(const boost::array<T,N> & new_mean_vector, float64 new_var);

    /*!
     * \brief Reset gaussian values
     *
     * \param[in] mean_vector : boost::array<float64,N>
     * \param[in] var_vector  : boost::array<float64,N>
     */
    void reset(const boost::array<T,N> & new_mean_vector, const boost::array<float64,N> & new_var_vector);

    /*!
     * \brief Reset gaussian values
     *
     * \param[in] mean_vector           : boost::array<float64,N>
     * \param[in] new_covariance_matrix : MultiArray<float64,2>
     */
    void reset(const boost::array<T,N> & new_mean_vector, const MultiArray<float64,2> & new_covariance_matrix);

    /*!
     * \brief Destructor
     */
    ~GaussianDistribution();

    /*!
     * \brief Gaussian pdf.
     *
     * It examines if gaussian is diagonal or not, and calculates the probability according to
     * this factor.
     *
     * \param[in]  point : point in the space.
     *
     * \return the probability of the input point
     *
     * \todo: it should be const!!
     * \todo: it returns -1 if error?
     */
    float64 probability(const boost::array<T,N> & point); // const;

    /*!
     * \brief Generic Interface to get the probability (models the continuous PDF)
     *
     * \param[in] point : point in the space (as a MultiArray)
     *
     * \return the probability of the input point
     *
     * \todo it should be const!!
     */
    float64 probability(const MultiArray<T, 1> & point ) //const
    {
        if (point.dims(0)!=N)
        {
            throw ImagePlusError ("Gaussian Distribution: Dimensions are not consistent");
        }

        boost::array<T,N> copy;
        std::copy (point.begin(), point.end(), copy.begin());
        //std::cout << "Copied input point " << copy << std::endl;
        return this->operator()(copy);
        //return GaussianProbability(copy);
    }

    /*!
     * \brief Gets the probability.
     *
     * It examines if gaussian is diagonal or not, and calculates the probability according
     * to this factor.
     *
     * \param[in]  input_vector : multiArray<float64,N> , point in the space.
     * \param[in]   data_index  :   uint64, number of array file where the pixel data is safed. Files= different pixel. Columns= data of each pixel.
     *
     * \return probability : float64
     *
     * \todo it should be const!
     * \todo input_vector in the case is not a point, but a vector of points?
     * \todo is this method really necessary...? it seems to be an auxiliar/ad-hoc function...
     */
    float64 probability(const MultiArray<T,2> & input_vector, uint64 data_index);

    /*!
     * \brief Generic Interface to get the probability (models the continuous PDF)
     *
     * This operator is just a wrapper of the probability() method.
     *
     * \param[in] point : boost::array<float64,N> , point in the space.
     *
     * \return the probability of the input point
     *
     * \todo const_cast should be removed!!
     */
    float64 operator()(const boost::array<T, N> & point ) const
    {
        //Trick to avoid compilation error "Passing this as const discards qualifiers"
        GaussianDistribution < T, N > * ref=const_cast< GaussianDistribution < T, N>* > (this);
        //return ref->GaussianProbability( const_cast< boost::array<T,N> & > (input_vector) );
        return ref->probability( point );

        // If it is const, just:
        //return this->probability( point );
    }

    /*!
     * \brief Generic Interface to get the probability (models the continuous PDF)
     *
     * This operator is just a wrapper of the probability() method.
     *
     * \param[in] point : point in the space (as a MultiArray)
     *
     * \return the probability of the input point
     */
    float64 operator()(const MultiArray<T, 1> & input_vector ) const
    {
        if (input_vector.dims(0)!=N)
        {
            throw ImagePlusError ("Gaussian Distribution: Dimensions are not consistent");
        }

        boost::array<T,N> copy;
        std::copy (input_vector.begin(), input_vector.end(), copy.begin());
        //std::cout << "Copied input vector " << copy << std::endl;
        return this->operator()(copy);
        //return GaussianProbability(copy);
    }

    /*!
     * \brief Draw sample from Multivariate Gaussian
     *
     * \todo what is this function for??
     * \todo add a throws in the declaration
     */
    boost::array<T, N> emit() const
    {
        boost::array<float64, N> sample;

        MultiArray<float64, 2> A;
        MultiArray<float64, 1> Z((uint64)N);

        for (std::size_t i=0;i<N;i++)
        {
            Z[i] = rand_normal(0.0, 1.0);
        }

        A=(_covariance_matrix);
//	    		std::cout << A << std::endl;
//	    		std::cout << "Factorize" << std::endl;
        if (!imageplus::math::numeric::cholesky_factorization(A))
        {
            throw ImagePlusError ("Non-positive definite covariance matrix");
        }
        //Set the upper triangle to zero
		for (std::size_t i=0;i<N-1;i++)
		{
			for (std::size_t ii=i+1;ii<N;ii++)
    		{
    			A[ii][i]=0.0;
    		}
		}

        Z=imageplus::math::numeric::prod(A,Z);

        for (std::size_t i=0;i<N;i++)
        {
            sample[i]=static_cast<T>(_mean[i] + Z[i]);
        }

        return sample;
    }

    /*!
     * \brief Get the probability using the Cholesky factorization
     *
     * It examines if gaussian is diagonal or not and calculates the probability
     * according to this factor.
     *
     * \param[in]  point : point in the space
     *
     * \return probability : float64
     *
     * \todo it should be const!
     */
    float64 probability_cholesky(const boost::array<T,N> & point);

    /*!
     * \brief Gaussian pdf.
     *
     * It examines if gaussian is diagonal or not, and calculates the probability according
     * to this factor.
     *
     * \warning All parameteres must be already calculated : _alpha, _inverse_covariance_matrix, matrix_determinant ...
     *
     * \param[in]  input_vector : multiArray<float64,N> , point in the space.
     * \param[in]  data_index  :   uint64, number of array file where the pixel data is safed. Files= different pixel. Columns= data of each pixel.
     *
     * \return probability : float64
     *
     * \todo it should be const!
     * \todo probably this function should be internal/private
     * \todo Rows = "pixels" means "pixels" = "points"?
     */
    float64 probability_with_calculated_params(const MultiArray<T,2> & input_vector, uint64 data_index);

    /*!
     * \brief Gaussian pdf result for a given point of the space.
     *
     * \param[in] point : boost::array<float64,N> , point in the space.
     *
     * \return probability : float64
     *
     * \todo it should be const!
     * \todo difference with the standard "probability" method?
     */
    float64 probability_complete(const boost::array<T,N> & point);

    /*!
     * \brief Gaussian pdf result for a given point of the space.
     *
     * \param[in]  input_vector : multiArray<float64,N> , point in the space.
     * \param[in]    data_index  : uint64, number of array file where the pixel data is stored. Files= different pixel. Columns= data of each pixel.
     *
     * \return probability : float64
     *
     * \todo it should be const!
     * \todo difference with the standard "probability" method?
     */
    float64 probability_complete(const MultiArray<T,2> & input_vector, uint64 data_index);

    /*!
     * \brief Gaussian pdf result in the case all dimensions were decoupled (diagonal covariance matrix).
     *
     * \param[in] point : boost::array<float64,N> , point in the space.
     *
     * \return probability : float64
     *
     * \todo it should be const!
     * \todo it should be probably internal/private
     */
    float64 probability_diagonal_cov(const boost::array<T,N> & point);

    /*!
     * \brief Gaussian pdf result in the case all dimensions were decoupled (diagonal covariance matrix).
     *
     * \param[in] input_vector : multiArray<float64,N> , point in the space.
     * param[in]    data_index  :   uint64, number of array file where the pixel data is safed. Files= different pixel. Columns= data of each pixel.
     *
     * \return probability : float64
     *
     * \todo it should be const!
     * \todo it should be probably internal/private
     */
    float64 probability_diagonal_cov(const MultiArray<T,2> & input_vector, uint64 data_index);

    /*!
     * \brief Gaussian update of the determinant and inverse covariance matrix.
     *
     * \todo this method should be probably internal/private
     * \todo it is clear for the user when to use update and when reset? why we need both?
     */
    void update();

    /*!
     * \brief Gaussian mean values for each dimension
     *
     * \return mean : boost::array<float64,N>
     *
     * \todo this is an INCORRECT "set"!! it is equivalent to make _mean public!!
     * \todo it should be "void mean(const boost::array<T,N> & mean);"
     */
    boost::array<T,N> & mean();

    /*!
     * \brief Gaussian mean values for each dimension. Const acces
     *
     * \return mean : boost::array<float64,N>
     */
    const boost::array<T,N> & mean() const
    {
        return _mean;
    }

    /*!
     * \brief Gaussian variance values for each dimension
     *
     * \return var : boost::array<float64,N>
     *
     * \todo this is an INCORRECT "set"!! it is equivalent to make _var public!!
     * \todo it should be "void var(const boost::array<T,N> & var);"
     */
    boost::array<float64,N> & var();

    /*!
     * \brief Gaussian variance values for each dimension
     *
     * \return var : boost::array<float64,N>
     */
    const boost::array<float64,N> & var() const
    {
        return _var;
    }

    /*!
     * \brief Gaussian covariance matrix
     *
     * \return covariance_matrix : boost::multi_array<float64,2>
     *
     * \todo this is an INCORRECT "set"!! it is equivalent to make _covariance_matrix public!!
     */
    MultiArray<float64,2> & covariance_matrix()
    {
        return _covariance_matrix;
    }

    /*!
     * \brief Gaussian covariance matrix
     *
     * \return covariance_matrix : boost::multi_array<float64,2>
     */
    const MultiArray<float64,2> & covariance_matrix() const
    {
        return _covariance_matrix;
    }

    /*!
     * \brief Gaussian covariance matrix
     *
     * \return _inverse_covariance_matrix : boost::multi_array<float64,2>
     *
     * \todo this is an INCORRECT "set"!! it is equivalent to make _inverse_covariance_matrix public!!
     * \todo this method should be linked to "covariance_matrix" to check the correctness between matrices!!
     */
    MultiArray<float64,2> & inverse_covariance_matrix()
    {
        return _inverse_covariance_matrix;
    }

    /*!
     * \brief Gaussian covariance matrix
     *
     * \return _inverse_covariance_matrix : boost::multi_array<float64,2>
     */
    const MultiArray<float64,2> & inverse_covariance_matrix() const
    {
        return _inverse_covariance_matrix;
    }

    /*!
     * \brief Gaussian variance. Symplification: all dimensions have the same variance.
     *
     * \return total_var : float64
     *
     * \todo this is an INCORRECT "set"!! it is equivalent to make _total_var public!!
     */
    float64 & total_var();

    /*!
     * \brief Gaussian variance. Symplification: all dimensions have the same variance.
     *
     * \return total_var : float64
     */
    const float64 & total_var() const
    {
        return _total_var;
    }

    /*!
     * \brief Gaussian diagonal covariance matrix flag.
     *
     * \return true if diagonal covariance simplification, false if complete covariance matrix.
     *
     * \todo this is an INCORRECT "set"!! it is equivalent to make _diagonal public!!
     */
    bool & diagonal_covariance();

    /*!
     * \brief Gaussian diagonal covariance matrix flag.
     *
     * \return true if diagonal covariance simplification, false if complete covariance matrix.
     */
    const bool & diagonal_covariance() const
    {
        return _diagonal;
    }

    /*!
     * \brief (2*PI)^(N/2) factor
     *
     * \return _c1 : float64. (2*PI)^(N/2) factor
     *
     * \todo this is an INCORRECT "set"!! it is equivalent to make _c1 public!!
     * \todo why an external user needs access to this parameter?
     */
    float64 & c1()
    {
        return _c1;
    }

    /*!
     * \brief (2*PI)^(N/2) factor
     *
     * \return _c1 : float64. (2*PI)^(N/2) factor
     *
     * \todo why an external user needs access to this parameter?
     */
    const float64 & c1() const
    {
        return _c1;
    }

    /*!
     * \brief (2*PI)^(N/2) factor
     *
     * \return _c1 : float64. (2*PI)^(N/2) factor
     *
     * \todo this is an INCORRECT "set"!! it is equivalent to make _alpha public!!
     * \todo why an external user needs access to this parameter?
     */
    float64 & alpha()
    {
        return _alpha;
    }

    /*!
     * \brief (2*PI)^(N/2) factor
     *
     * \return _c1 : float64. (2*PI)^(N/2) factor
     *
     * \todo why an external user needs access to this parameter?
     */
    const float64 & alpha() const
    {
        return _alpha;
    }

    /*!
     * \brief his function print gaussian parameters
     *
     * \todo this method should be replaced by a operator<< !!
     */
    void print_gaussian_parameters(FILE *File);

    /*!
     * \brief This function prints the gaussian parameters.
     *
     * \todo why 2 print methods??
     */
    void print_info_screen();

protected:

    //! Array with gaussian mean
    boost::array<T,N> _mean;

    //! Array with gaussian variance for each dimension. Decoupled dimensions are supposed here.
    boost::array<float64,N> _var;

    //! Gaussian variance symplification. In the case that all dimensions had the same variance.
    float64 _total_var;		//in the case of equal variance in every dimension

    //! Covariance Matrix implemented with MultiArray
    MultiArray<float64, 2> _covariance_matrix;

    //!Inverse of covariance matrix
    MultiArray<float64,2> _inverse_covariance_matrix;

    //! This flag indicates if the covariance matrix is  diagonal. 1-->diagonal  0-->non diagonal
    bool _diagonal;

    //! c1 factor = (2*PI)^(N/2)
    float64 _c1;

    //! Covariance matrix determinant
    float64 _cov_matrix_det;

    //! alpha = c1 * sqrt(_cov_matrix_det)
    float64 _alpha;
};

/*!
 * \brief Output stream operator
 *
 * \todo is this the same of the "print_*" methods??
 */
template <typename T, std::size_t N>
std::ostream& operator<< (std::ostream& os, const GaussianDistribution<T,N>& g)
{
    os<< "====Gaussian_Distribution=====" << std::endl;

    os << "Mean" << std::endl;
    for (uint32 i=0; i<N; i++)
    {
        os << g.mean()[i] << " " ;

    }
    os << std::endl;

    os << "covariance_matrix"<< std::endl;
    os << g.covariance_matrix() << std::endl;


    return os;
}

/*!
 *
 * \todo add documentation
 */
template <typename T, std::size_t N, std::size_t M>
inline
void  GaussianDistribution_split_dims (GaussianDistribution<T,N> & Gauss_in,
                                       GaussianDistribution<T,M> & Gauss_out1,
                                       uint32                      position_split_dims )
{
    ASSERT( (N > M) ,
                      "GaussianDistribution_split_dims ERROR. Split dim position is bigger than GMM_in dimensions of gaussians!!!" );

    ASSERT( (N >= position_split_dims + M) ,
                 "GaussianDistribution_split_dims ERROR. Split dim position + GMM_out dimensions exceeds GMM_in dimensions of gaussians!!!" );

    // M < N!!
    for (uint32 out_index=0, i = position_split_dims; out_index < M; i++, out_index++)
    {
        Gauss_out1.mean()[out_index] = Gauss_in.mean()[i];
        Gauss_out1.var() [out_index] = Gauss_in.var() [i];

        for (uint32 out_index2 = 0, j = position_split_dims; out_index2 < M; j++, out_index2++)
        {
            Gauss_out1.covariance_matrix()         [out_index][out_index2]          = Gauss_in.covariance_matrix()[i][j];
            Gauss_out1.inverse_covariance_matrix() [out_index][out_index2]  = Gauss_in.inverse_covariance_matrix()[i][j];

        }
    }

    Gauss_out1.total_var() = Gauss_out1.var()[0];

    Gauss_out1.diagonal_covariance() = Gauss_in.diagonal_covariance();

    Gauss_out1.c1 () = pow(6.28318530717958,static_cast<int>(M/2)); // (2*pi)^N/2

    //! Covariance matrix determinant
//          Gauss_out1.cov_matrix_det() = ;
//
//             //! alpha = c1 * sqrt(_cov_matrix_det)
//             float64 Gauss_out1.alpha();
}

/*!
 *
 * \todo add documentation
 */
template <typename T, std::size_t N, std::size_t M, std::size_t P>
inline
void  GaussianDistribution_merge_dims (GaussianDistribution<T,N> & Gauss_in1,
                                       GaussianDistribution<T,M> & Gauss_in2,
                                       GaussianDistribution<T,P> & Gauss_out)
{
    ASSERT( (P == N+M) ,
            "GaussianDistribution_merge_dims ERROR. Gauss_out must have the same dimensions as Gauss_in1 + Gausss_in2 dims !!!" );

    Gauss_out.Reset(0,1);

    for (uint32 out_index=0, i = 0; i < N; i++, out_index++)
    {
        Gauss_out.mean()[out_index] = Gauss_in1.mean()[i];
        Gauss_out.var() [out_index] = Gauss_in1.var() [i];

        for (uint32 out_index2 = 0, j = 0; j < N; j++, out_index2++)
        {
            Gauss_out.covariance_matrix()         [out_index][out_index2]          = Gauss_in1.covariance_matrix()[i][j];
            Gauss_out.inverse_covariance_matrix() [out_index][out_index2]  = Gauss_in1.inverse_covariance_matrix()[i][j];

        }
    }

    for (uint32 out_index=N, i = 0; i < M; i++, out_index++)
    {
        Gauss_out.mean()[out_index] = Gauss_in2.mean()[i];
        Gauss_out.var() [out_index] = Gauss_in2.var() [i];

        for (uint32 out_index2 = N, j = 0; j < M; j++, out_index2++)
        {
            Gauss_out.covariance_matrix()         [out_index][out_index2]          = Gauss_in2.covariance_matrix()[i][j];
            Gauss_out.inverse_covariance_matrix() [out_index][out_index2]  = Gauss_in2.inverse_covariance_matrix()[i][j];
        }
    }

    Gauss_out.total_var() = Gauss_out.var()[0];

    if(Gauss_in1.diagonal_covariance() || Gauss_in2.diagonal_covariance())
    {
        Gauss_out.diagonal_covariance() = true;
    }
    else
    {
        Gauss_out.diagonal_covariance() = false;
    }

    Gauss_out.c1 () = pow(6.28318530717958,static_cast<int>(P/2)); // (2*pi)^N/2
}

/*!
 *
 * \todo add documentation
 * \todo why not to use operator== and operator!=
 */
template <typename T, std::size_t N>
inline
bool compare_gaussians(const GaussianDistribution<T,N> & gaussian1, const GaussianDistribution<T,N> & gaussian2)
{
    if ( gaussian1.total_var() != gaussian2.total_var() ) return false;

    for(uint32 i=0; i<N; i++)
    {
        if ( gaussian1.var()[i] != gaussian2.var()[i] )   return false;
        if ( gaussian1.mean()[i] != gaussian2.mean()[i] ) return false;

        for (uint32 j=0; j<N; j++)
        {
            if ( gaussian1.covariance_matrix()[i][j] != gaussian2.covariance_matrix()[i][j] )                 return false;
            if ( gaussian1.inverse_covariance_matrix()[i][j] != gaussian2.inverse_covariance_matrix()[i][j] ) return false;
        }
    }

    if ( gaussian1.c1() != gaussian2.c1() ) return false;

    return true;
}

} // statistics
} // math
} // imageplus


/*
 * Class Implementation
 */
namespace imageplus
{
namespace math
{
namespace statistics
{
    /*!
     * \todo in constructors, when possible, members should be initialized in the ":" section
     * \todo the following constructors are too similars... why not an internal "init"?
     */
    template <typename T,std::size_t N>
    GaussianDistribution<T,N>::GaussianDistribution()
    {
        _c1 = pow(2.0*M_PI,static_cast<int>(N/2));
    }

    template <typename T, std::size_t N>
    GaussianDistribution<T,N>::GaussianDistribution (T init_mean,  float64 init_var, bool diagonal_cov_matrix)
            : _covariance_matrix(uint64 (N),uint64 (N)),
              _inverse_covariance_matrix(uint64 (N),uint64 (N)),
              _diagonal(diagonal_cov_matrix)
    {
        float64 zero = 0;

        _mean.assign(init_mean);
        _var.assign(init_var);

        _covariance_matrix = zero;
        _inverse_covariance_matrix = zero;

        for (uint64 i=0; i<N; i++)
        {
            for(uint64 j=0; j<N; j++)
            {
                if (i==j)
                {
                    _covariance_matrix[i][j] = init_var;
                }
                else{
                    _covariance_matrix[i][j] = 0;
                }
            }
        }

        _total_var=init_var;
        _c1 = pow(6.28318530717958,static_cast<int>(N/2)); // (2*pi)^N/2

        update();
    }

    template <typename T, std::size_t N>
    GaussianDistribution<T,N>::GaussianDistribution(const boost::array<T,N> & mean_vector,  float64 init_var, bool diagonal_cov_matrix)
        : _covariance_matrix(uint64 (N),uint64 (N)),
          _inverse_covariance_matrix(uint64 (N),uint64 (N)),
          _diagonal(diagonal_cov_matrix)
    {
        float64 zero = 0;
        _mean = mean_vector;
        _var.assign(init_var);

        _total_var=init_var;

        _covariance_matrix = zero;
        _inverse_covariance_matrix = zero;

        for (uint64 i=0; i<N; i++)
        {
            for (uint64 j=0; j<N; j++)
            {
                if(i==j)
                {
                    _covariance_matrix[i][j] = init_var;
                }
                else
                {
                    _covariance_matrix[i][j]=0;
                }
            }
        }

        _c1 = pow(6.28318530717958,static_cast<int>(N/2)); // (2*pi)^N/2


        update();
    }

    template <typename T, std::size_t N>
    GaussianDistribution<T,N>::GaussianDistribution(const boost::array<T,N> & mean_vector, const boost::array<float64,N> & var_vector, bool diagonal_cov_matrix)
        : _covariance_matrix(uint64 (N),uint64 (N)),
          _inverse_covariance_matrix(uint64 (N),uint64 (N)),
          _diagonal(diagonal_cov_matrix)
    {
        float64 zero = 0;
        _mean = mean_vector;
        _var = var_vector;
        _total_var=var_vector[0];

        _covariance_matrix = zero;
        _inverse_covariance_matrix = zero;

        for (uint64 i=0; i<N; i++)
        {
            for (uint64 j=0; j<N; j++)
            {
                if(i==j)
                {
                    _covariance_matrix[i][j] = var_vector[i];
                }
                else{
                    _covariance_matrix[i][j]=0;
                }
            }
        }

        _c1 = pow(6.28318530717958,static_cast<int>(N/2)); // (2*pi)^N/2

        update();
    }

    template <typename T, std::size_t N>
    GaussianDistribution<T,N>::GaussianDistribution(const boost::array<T,N> & mean_vector, const MultiArray<float64,2> & covariance_matrix, bool diagonal_cov_matrix)
        : _covariance_matrix(uint64 (N),uint64 (N)),
          _inverse_covariance_matrix(uint64 (N),uint64 (N)),
          _diagonal(diagonal_cov_matrix)
    {

        float64 zero = 0;
        _mean = mean_vector;
//	    	_var = covariance_matrix[0][0];
        _total_var=covariance_matrix[0][0];

        _covariance_matrix = zero;
        _inverse_covariance_matrix = zero;

        if(_diagonal==true)
        {
            for (uint64 i=0; i<N; i++)
            {
                for(uint64 j=0; j<N; j++)
                {
                    if (i==j)
                    {
                        _covariance_matrix[i][j] = covariance_matrix[i][j];
                        _var[i] = covariance_matrix[i][j];
                    }
                    else
                    {
                        _covariance_matrix[i][j] = 0;
                    }
                }
            }
        }
        else
        {
            for (uint64 i=0; i<N; i++)
            {
                for (uint64 j=0; j<N; j++)
                {
                    _covariance_matrix[i][j] = covariance_matrix[i][j];

                    if (i==j)
                    {
                        _var[i] = covariance_matrix[i][j];
                    }
                }
            }

        }


        _c1 = pow(6.28318530717958,static_cast<int>(N/2)); // (2*pi)^N/2

        update();
    }

    template <typename T, std::size_t N>
    GaussianDistribution<T,N>::GaussianDistribution(const MultiArray<float64,2> & initial_data, bool diagonal_cov_matrix)
        : _covariance_matrix(uint64 (N),uint64 (N)),
          _inverse_covariance_matrix(uint64 (N),uint64 (N)),
          _diagonal(diagonal_cov_matrix)
    {
        uint64 numdims = uint64 (N);

        /*
         * TODO: prtinf should not be used in modules:
         * - use TRACE for debugging
         * - or ImagePlusError for errors
         */
        if (initial_data.dims(0)!= N)
        {
            printf("Error in GaussianDistribution constructor. Initial data Multiarray doesn't have the same size x as gaussian dimensions");
        }
        for (uint32 i = 0; i < numdims; i++)
        {
            _mean[i] = initial_data[0][i];	//mean is located in the first file
            _var[i]  = initial_data[1][i];	//variance is placed in the second file

        }

        float64 zero = 0;

        _total_var=_var[0];

        _covariance_matrix = zero;
        _inverse_covariance_matrix = zero;

        for (uint64 i=0; i<N; i++)
        {
            for(uint64 j=0; j<N; j++)
            {
                if (i==j)
                {
                    _covariance_matrix[i][j] = _var[i];
//						_inverse_covariance_matrix[i][j] = float64(1.0/_var[i]);
                }
                else{
                    _covariance_matrix[i][j] = 0;
                }
            }
        }

        _c1 = pow(6.28318530717958,static_cast<int>(N/2)); // (2*pi)^N/2

        update();
    }

    template <typename T, std::size_t N>
    GaussianDistribution<T,N>::GaussianDistribution(const GaussianDistribution<T,N> & initial_gaussian)
        : _covariance_matrix(uint64 (N),uint64 (N)),
          _inverse_covariance_matrix(uint64 (N),uint64 (N))
    {
        _mean = initial_gaussian._mean;
        _var = initial_gaussian._var;
        _total_var=initial_gaussian._total_var;

        _diagonal = initial_gaussian._diagonal;

        _covariance_matrix = initial_gaussian._covariance_matrix;

        _inverse_covariance_matrix = initial_gaussian._inverse_covariance_matrix;

        _c1 = pow(6.28318530717958,static_cast<int>(N/2)); // (2*pi)^N/2

        _alpha = initial_gaussian._alpha;
        _cov_matrix_det = initial_gaussian._cov_matrix_det;
    }

    template <typename T, std::size_t N>
    void GaussianDistribution<T,N>::operator=(const GaussianDistribution<T,N> & initial_gaussian)
    {
        this->_mean	      =	initial_gaussian._mean;
        this->_var	      =	initial_gaussian._var;
        this-> _total_var = initial_gaussian._total_var;

        this->_covariance_matrix         = initial_gaussian._covariance_matrix;
        this->_inverse_covariance_matrix = initial_gaussian._inverse_covariance_matrix;

        this->_diagonal = initial_gaussian._diagonal;
        this-> _c1      = initial_gaussian._c1;

        this->_alpha          = initial_gaussian._alpha;
        this->_cov_matrix_det = initial_gaussian._cov_matrix_det;
    }

    template <typename T, std::size_t N>
    void GaussianDistribution<T,N>::reset(T new_mean, float64 new_var)
    {
        float64 zero = 0;
        _mean.assign(new_mean);
        _var.assign(new_var);

        _total_var=new_var;

        _covariance_matrix = zero;
        _inverse_covariance_matrix = zero;

        for (uint32 i=0; i<N; i++)
        {
            _covariance_matrix[i][i] = new_var;
        }

        _c1 = pow(6.28318530717958,static_cast<int>(N/2)); // (2*pi)^N/2

        update();
    }

    template <typename T, std::size_t N>
    void GaussianDistribution<T,N>::reset(const boost::array<T,N> & new_mean_vector, float64 new_var)
    {
        float64 zero = 0;
        _mean = new_mean_vector;
        _var.assign(new_var);

        _total_var=new_var;

        _covariance_matrix = zero;
        _inverse_covariance_matrix = zero;

        for (uint32 i=0; i<N; i++)
        {
            _covariance_matrix[i][i] = new_var;
        }

        _c1 = pow(6.28318530717958,static_cast<int>(N/2)); // (2*pi)^N/2

        update();
    }

    template <typename T, std::size_t N>
    void GaussianDistribution<T,N>::reset(const boost::array<T,N> & new_mean_vector, const boost::array<float64,N> & new_var_vector)
    {
        float64 zero = 0;

        _mean = new_mean_vector;
        _var = new_var_vector;

        _total_var=new_var_vector[0];

        _covariance_matrix = zero;
        _inverse_covariance_matrix = zero;

        for (uint32 i=0; i<N; i++)
        {
            _covariance_matrix[i][i] = new_var_vector[i];
        }

        _c1 = pow(6.28318530717958,static_cast<int>(N/2)); // (2*pi)^N/2

        update();
    }

    template <typename T, std::size_t N>
    void GaussianDistribution<T,N>::reset(const boost::array<T,N> & new_mean_vector, const MultiArray<float64,2> & new_covariance_matrix)
    {
        float64 zero = 0;

        _mean = new_mean_vector;

        for (uint32 i=0; i<N; i++){
            _var[i] = new_covariance_matrix[i][i];
        }


        _total_var=new_covariance_matrix[0][0];

        _covariance_matrix = zero;
        _inverse_covariance_matrix = zero;

        /*
         * \todo Why not using ASSERT?
         */
        //ASSERT (!((new_covariance_matrix.dims(0)=!N) || (new_covariance_matrix.dims(1)=!N)), Error in Gaussian distribution Reset function);
        if ((new_covariance_matrix.dims(0)!=N) || (new_covariance_matrix.dims(1)!=N))
        {
            throw ImagePlusError("Error in GaussianDistribution reset. MultiArray input covariance_matrix dimension error." );
        }

        _covariance_matrix=new_covariance_matrix;


        _c1 = pow(6.28318530717958,static_cast<int>(N/2)); // (2*pi)^N/2

        update();
    }

    template <typename T, std::size_t N>
    GaussianDistribution<T,N>::~GaussianDistribution(){}

    template <typename T, std::size_t N>
    float64 GaussianDistribution<T,N>::probability_cholesky(const boost::array<T,N> & input_vector)
    {
        float64 v, b, det,Probability;
        //         float64 c1 = pow(6.28318530717958,N/2); // (2*pi)^1.5

        float64 ex   =  0.0;
        float64 zero =  0;

        float64 matrix_determinant;

        boost::array<float64,N> vector_aux;
        boost::array<float64,N> vector_aux2;

        bool flag_error = false;

        //             MultiArray<float64,2> inverse_covariance;

       // _inverse_covariance_matrix = _covariance_matrix;

        if (!_diagonal)
        {

            /*
             * TODO: cout NOT allowed in modules!!
             */
            if (math::numeric::invert_matrix_cholesky ( _covariance_matrix,  _inverse_covariance_matrix ) < 0)
//	        	_inverse_covariance_matrix=_covariance_matrix;
//	        	if (!math::numeric::cholesky_factorization(_inverse_covariance_matrix))
            {
                std::cout << "ERROR in Cholesky matrix inversion. gaussian_distribution.hpp" <<std::endl;
                std::cout << _covariance_matrix << std::endl;
            }
//	        	else
//	        	{
//	        		math::numeric::cholesky_invert (_inverse_covariance_matrix) ;
//	        	}

            _cov_matrix_det = math::numeric::lu_det(_covariance_matrix);


            _alpha = 1.0 / (_c1 * std::sqrt(_cov_matrix_det));


            v=0;

            float64 aux=0, z=0;
            uint32 i, j;

            for (i=0, z = 0.0; i < N; i++)
            {
                for (j = 0, aux = 0.0; j <= i; j++)
                {
                    v += _covariance_matrix[i][j] * (input_vector[j] - _mean[j]);
                }
                z += v * v;
            }
            v = _alpha * exp(-0.5 * z);
            return v;
        }
        else
        {
            return -1;
        }
    }

    template <typename T, std::size_t N>
    float64 GaussianDistribution<T,N>::probability(const boost::array<T,N> & input_vector) //const
    {
        if (_diagonal==true)
        {
            //std::cout << "DIAGONAL!!" << std::endl;
            return probability_diagonal_cov(input_vector);
        }
        else
        {
            float64 prob=probability_complete(input_vector);
            return prob;
        }

        return -1.0;
    }

    template <typename T, std::size_t N>
    float64 GaussianDistribution<T,N>::probability(const MultiArray<T,2> & input_vector, uint64 data_index)
    {

        if(_diagonal==true)
        {
            return probability_diagonal_cov(input_vector, data_index);
        }
        else
        {
            float64 prob=probability_complete(input_vector, data_index);
            return prob;
        }

        return -1.0;
    }

    template <typename T, std::size_t N>
    float64 GaussianDistribution<T,N>::probability_with_calculated_params(const MultiArray<T,2> & input_vector, uint64 data_index)
    {
        float64 v,  b ;

        float64 ex=0.0;
        float64 aux1, aux2, aux3;

        if(_diagonal==true)
        {
            for (uint32 i=0; i<N; ++i)
            {
                _inverse_covariance_matrix[i][i] = float64(1.0/_covariance_matrix[i][i]);
                aux1=input_vector[data_index][i];
                aux2= _mean[i];
                aux3= _var[i];
                ex += (input_vector[data_index][i]-_mean[i])*(input_vector[data_index][i]-_mean[i])*_inverse_covariance_matrix[i][i];
            }

            b = -0.5 * ex;

            v = _alpha * exp(b);
        }
        else
        {
            v=0.0;

            float64 z=0;
            uint32 i, j;

            for (i=0, z = 0.0; i < N; i++)
            {
                for (j = 0, v = 0.0; j <= i; j++)
                {
                    v += _inverse_covariance_matrix[i][j] * (input_vector[data_index][j] - _mean[j]);
                }
                z += v * v;
            }
            v = _alpha * exp(-0.5 * z);
        }
        return v;
    }

    template <typename T, std::size_t N>
    float64 GaussianDistribution<T,N>::probability_complete(const boost::array<T,N> & input_vector)
    {
        /*
         * TODO: cout NOT allowed in modules, only in tools!
         * TODO: remove commented code?
         */
        if (math::numeric::invert_matrix_cholesky ( _covariance_matrix,  _inverse_covariance_matrix ) < 0)
        {
            std::cout << "ERROR in Cholesky matrix inversion (1). gaussian_distribution.hpp" <<std::endl;
            std::cout << _covariance_matrix << std::endl;
            int32 spd;
            _inverse_covariance_matrix=math::numeric::cholesky_factorization(_covariance_matrix, spd);
            if (!spd )
            {
                std::cout << "Cholesky factorization is not possible!" << std::endl;
            }
        }
//	    	_inverse_covariance_matrix=_covariance_matrix;
//	    	if (!math::numeric::cholesky_factorization(_inverse_covariance_matrix))
//        	{
//                std::cout << "ERROR in Cholesky matrix inversion. gaussian_distribution.hpp" <<std::endl;
//            }
//        	else
//        	{
//        		math::numeric::cholesky_invert (_inverse_covariance_matrix) ;
//        	}

        _cov_matrix_det = math::numeric::lu_det(_covariance_matrix);

        _alpha = 1.0 / (_c1 * std::sqrt(_cov_matrix_det));

        float64 v=0.0;

        float64 z=0;

        uint32 i, j;


        //Inversion with inverse factorized matrix
        for (i=0, z = 0.0; i < N; i++)
        {
            for (j = 0, v = 0.0; j <= i; j++)
            {
                v += _inverse_covariance_matrix[i][j] * (input_vector[j] - _mean[j]);
            }
            z += v * v;
        }

        //Re-implementation (much slower)
//	        static MultiArray<float64, 1> tmp((uint64)N);
//	        tmp=input_vector-_mean;
//	        v=imageplus::math::numeric::scalar_prod(tmp, imageplus::math::numeric::prod(_inverse_covariance_matrix, tmp));

        v = _alpha * exp(-0.5 * z);

//	        if ( v > 1.0 )
//	        {
//	        	std::cout << " Gauss probability error "  << v << " " << z << " " <<  exp(-0.5*z) << " " << _alpha << std::endl;
//	        	std::cout << " Det: " << _cov_matrix_det << std::endl;
//	        }

        return v;
    }

    template <typename T, std::size_t N>
    float64 GaussianDistribution<T,N>::probability_complete(const MultiArray<T,2> & input_vector, uint64 data_index)
    {
        /*
         * TODO: cout NOT allowed in modules, only in tools!
         * TODO: remove commented code?
         */
        if (math::numeric::invert_matrix_cholesky ( _covariance_matrix,  _inverse_covariance_matrix ) < 0)
        {
            std::cout << "ERROR in Cholesky matrix inversion (2). gaussian_distribution.hpp" <<std::endl;
            std::cout << _covariance_matrix << std::endl;
        }
        //_inverse_covariance_matrix=_covariance_matrix;
//	    	if (!math::numeric::cholesky_factorization(_inverse_covariance_matrix))
//        	{
//                std::cout << "ERROR in Cholesky matrix inversion. gaussian_distribution.hpp" <<std::endl;
//            }
//        	else
//        	{
//        		math::numeric::cholesky_invert (_inverse_covariance_matrix) ;
//        	}

        _cov_matrix_det = math::numeric::lu_det(_covariance_matrix);

        _alpha = 1.0 / (_c1 * std::sqrt(_cov_matrix_det));

        float64 v=0.0;

        float64 z=0;
        uint32 i, j;

        for (i=0, z = 0.0; i < N; i++)
        {
            for (j = 0, v = 0.0; j <= i; j++)
            {
                v += _inverse_covariance_matrix[i][j] * (input_vector[data_index][j] - _mean[j]);
            }
            z += v * v;
        }
        v = _alpha * exp(-0.5 * z);

        return v;
    }

    template <typename T, std::size_t N>
    float64 GaussianDistribution<T,N>::probability_diagonal_cov(const boost::array<T,N> & input_vector)
    {
        /*
         * TODO: clean commented code?
         */
        float64   b, Probability;
        //   	       float64 c1 = 15.74960994572242; // (2*pi)^1.5
        float64 ex=0.0;
        _cov_matrix_det=1;

        // calc the coefficient

        float64 zero = 0;

        _alpha = 1.0;

        _inverse_covariance_matrix=zero;

        for (uint32 i=0; i<N; ++i)
        {
            _inverse_covariance_matrix[i][i] = float64(1.0/_covariance_matrix[i][i]);
            //   	    	   for (uint32 j=1; j<N; ++j){
            ex += (input_vector[i]-_mean[i])*(input_vector[i]-_mean[i])*_inverse_covariance_matrix[i][i];
            _cov_matrix_det = _cov_matrix_det *_covariance_matrix[i][i];
            //   	    	   }
        }

        _alpha = 1.0 / (_c1 * std::sqrt(_cov_matrix_det));
        //   	       ex = ex / _total_var;

        // exponent calculation
        b = -0.5 * ex;

        Probability = _alpha * exp(b);

//	        Probability = v;


        return Probability;
    }

    template <typename T, std::size_t N>
    float64 GaussianDistribution<T,N>::probability_diagonal_cov(const MultiArray<T,2> & input_vector, uint64 data_index)
    {
        /*
         * TODO: clean commented code?
         */
        //MultiArray<T,2> input_vector [num_pixel= data_index][pixel data= diemnsion of the gaussian];

        float64 b, Probability;
        //   	       float64 c1 = 15.74960994572242; // (2*pi)^1.5
        float64 ex=0.0;
        float64 aux1, aux2, aux3;
        _cov_matrix_det=1;

        // calc the coefficient

        float64 zero = 0;

        _alpha = 1.0;

        _inverse_covariance_matrix = zero;
        for (uint32 i=0; i<N; ++i)
        {
            //   	    	   for (uint32 j=1; j<N; ++j){
            _inverse_covariance_matrix[i][i] = float64(1.0/_covariance_matrix[i][i]);
            aux1=input_vector[data_index][i];
            aux2= _mean[i];
            aux3= _var[i];
            ex += (input_vector[data_index][i]-_mean[i])*(input_vector[data_index][i]-_mean[i])*_inverse_covariance_matrix[i][i];
            _cov_matrix_det = _cov_matrix_det *_covariance_matrix[i][i];
            //   	    	   }
        }

        _alpha = 1.0 / (_c1 * std::sqrt(_cov_matrix_det));

        // exponent calculation
        b = -0.5 * ex;

        Probability = _alpha * exp(b);

        return Probability;
    }

    template <typename T, std::size_t N>
    void GaussianDistribution<T,N>::update()
    {
    	//TODO: Find an appropriate regularization method. Must be inside or outside update?
        for (uint32 hh = 0; hh < N; hh++)
        {
           _covariance_matrix [hh][hh] += 0.00001; //This term may be big
        }
        /*
         * TODO: couts not allowed in modules: use TRACE or ImagePlusError
         * TODO: clean commented code?
         */
        if (math::numeric::invert_matrix_cholesky ( _covariance_matrix,  _inverse_covariance_matrix ) < 0)
        {
            std::cout << "ERROR in Cholesky matrix inversion (update). gaussian_distribution.hpp" <<std::endl;
            std::cout << _covariance_matrix << std::endl;
        }
//	        _inverse_covariance_matrix=_covariance_matrix;
//	    	if (!math::numeric::cholesky_factorization(_inverse_covariance_matrix))
//        	{
//                std::cout << "ERROR in Cholesky matrix inversion. gaussian_distribution.hpp" <<std::endl;
//            }
//        	else
//        	{
//        		math::numeric::cholesky_invert (_inverse_covariance_matrix) ;
//        	}

        _cov_matrix_det = math::numeric::lu_det(_covariance_matrix);

        _alpha = (1.0 / (_c1 * std::sqrt(_cov_matrix_det)));

        //	        _inverse_covariance_matrix = math::numeric::invert_matrix ( math::numeric::trans(_covariance_matrix) );
    }

    template <typename T, std::size_t N>
    boost::array<T,N> & GaussianDistribution<T,N> :: mean()
    {
        return (_mean);
    }

    template <typename T, std::size_t N>
    boost::array<float64,N> & GaussianDistribution<T,N> :: var()
    {
        return (_var);
    }

    template <typename T, std::size_t N>
    float64 & GaussianDistribution<T,N> :: total_var()
    {
        return ( _total_var);
    }

    template <typename T, std::size_t N>
    bool & GaussianDistribution<T,N> :: diagonal_covariance()
    {
        return ( _diagonal);
    }

    template <typename T, std::size_t N>
    inline void  GaussianDistribution<T,N>::print_gaussian_parameters(FILE *File)
    {
        fprintf(File,"\n \t mean values\n");
        for (uint32 i =0; i<N; i++)
        {
            fprintf(File,"\t	mean[%d]= %f", i, _mean[i]);

        }

        fprintf(File,"\n \t variance matrix:");
        for (uint32 i =0; i<N; i++)
        {
            fprintf(File,"\n");
            for (uint32 j =0; j<N; j++){
                    fprintf(File,"\t var= %f", _var[i]);
            }
        }
    }

    template <typename T, std::size_t N>
    inline void  GaussianDistribution<T,N>::print_info_screen()
    {
        std::cout<<"GaussianDistribution Values********************************************* " << std::endl;

        std::cout<<"Number of dimensions = "<< N << std::endl;

        std::cout<<"Mean values"<<std::endl;
        for (uint32 i =0; i<N; i++){
            std::cout<<"mean["<< i << "] = "<< _mean[i] << std::endl;

        }

        std::cout<<"Diagonal variance values"<<std::endl;
        for (uint32 i =0; i<N; i++){
            std::cout<<"variance["<< i << "] = "<< _var[i] << std::endl;

        }

        std::cout<<"Diagonal = "<< _diagonal <<std::endl;
        std::cout<<"Total_var = "<< _total_var <<std::endl;

        std::cout<<"covariance_matrix"<< std::endl;
        std::cout<<_covariance_matrix ;

        std::cout<<"Inverse_covariance_matrix"<< std::endl;
        std::cout<<_inverse_covariance_matrix;

        std::cout<<"(2*PI)^("<< N <<"/2) = "<<  _c1 << std::endl;

        std::cout<<"covariance matrix determinant = " <<  _cov_matrix_det << std::endl;

        std::cout<<"alpha = 1/((2*PI)^("<< N <<"/2) * (sqrt(|cov_matrix|))) = " << _alpha << std::endl;
    }
} //statistics
}//math
}//imageplus

#endif //FIX_DOCUMENTATION
#endif //IMAGEPLUS_MATH_STATISTICS_GAUSSIAN_DISTRIBUTIONL_HPP
