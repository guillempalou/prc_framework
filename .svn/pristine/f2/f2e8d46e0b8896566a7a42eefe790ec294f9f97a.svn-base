// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------

//!
//!  \file writemultiarray.cpp
//!
//!  Implementation of classes for writing multiarrays to disk
//!

#include <typeinfo>
#include <bitset>

#include <boost/smart_ptr.hpp>

#include <imageplus/compress/rle.hpp>

#include <imageplus/io/writemultiarray.hpp>
#include <imageplus/io/writebitstream.hpp>
#include <imageplus/io/portablefloat.hpp>


using namespace imageplus;
using namespace imageplus::io;

WriteMultiArray::WriteMultiArray( const std::string& filename, CompressType c)
{
    open(filename,c);
}

WriteMultiArray::WriteMultiArray()
{
}

void WriteMultiArray::open( const std::string& filename, CompressType c)
{
    _filename = filename;
    _compress = c;
}

WriteMultiArray::~WriteMultiArray()
{
}


void WriteMultiArray::_append_multiarray_header(std::vector<uint64> dims,
                                                DataType dt,
                                                std::ofstream& fp)
{
    // write datatype
    uint8 c = (uint8)dt;
    fp.write((char*)&c,sizeof(c));

    // write number of dimensions
    uint64 d = dims.size();
    fp.write((char*)&d,sizeof(uint64));

    // write size of each dimension
    for (uint32 i = 0; i < dims.size(); i++)
    {
        d = dims[i];
        fp.write((char*)&d,sizeof(uint64));
    }
}


template<int D>
void WriteMultiArray::_append_multiarray(const MultiArray<uint8,D>& m,
                                         std::ofstream& fp)
{
    _append_multiarray_header(m.dims(),UINT8,fp);

    // compress data
    switch (_compress)
    {
        case BYTE_RUNLENGTH:
        {
            // The number 1.00390625 is 257/256 and it is needed because the rle compression
            // can be greater than the input array (in the case of random data) 
            uint64 maxcsize = static_cast<uint64>(((float64)m.num_elements()*sizeof(uint8)*1.00390625) + 2);
            boost::shared_array<uint8> cdata = boost::shared_array<uint8>(new uint8[maxcsize]);
            imageplus::compress::Rle rle;

            uint64 csize = rle.compress(m.data(),
                                        cdata.get(),
                                        m.num_elements() * sizeof(uint8));

            // write size of compress data
            fp.write((char*)&csize, sizeof(uint64));

            // write compress data
            fp.write((char*)cdata.get(), csize);
        }
            break;
        
        case NONE:
        {
            // No compression
            uint64 csize = m.num_elements() * sizeof(uint8);
            // write size of compress data
            fp.write((char*)&csize, sizeof(uint64));
            // write compress data
            fp.write((char*)m.data(), csize);
        }
            break;
        
        default:
            throw ImagePlusError("Unknown compress type");
            break;
    }

}


template<int D>
void WriteMultiArray::_append_multiarray(const MultiArray<uint32,D>& m,
                                         std::ofstream& fp)
{
    _append_multiarray_header(m.dims(),UINT32,fp);
    std::bitset<8> temp8;
    // compress data
    switch (_compress)
    {
        case BYTE_RUNLENGTH:
        {
            // The number 1.00390625 is 257/256 and it is needed because the rle compression
            // can be greater than the input array (in the case of random data) 
            uint64 maxcsize = static_cast<uint64>(((float64)m.num_elements()*sizeof(uint32)*1.00390625) + 2);
            boost::shared_array<uint8> cdata = boost::shared_array<uint8>(new uint8[maxcsize]);
            imageplus::compress::Rle rle;

            uint64 csize = rle.compress(reinterpret_cast<const uint8 *>(m.data()),
                                        cdata.get(),
                                        m.num_elements() * sizeof(uint32));

            // write size of compress data
            fp.write((char*)&csize, sizeof(uint64));

            // write compress data
            fp.write((char*)cdata.get(), csize);
            
        }
        break;
        
        case PARTITION_RUNLENGTH:
        {
        	// Pointer to the input data
        	const uint32 *input = m.data();
        	
        	// Width of the multiarray
        	const uint64 width = m.dims(0);
        	
        	// Compute the maximum value
        	const uint64 num_elements = m.num_elements();
        	uint32 max_value = 0;
        	const uint32 *temp = input;
        	for(uint64 ii=0; ii<num_elements; ii++)
        	{
        		if(*temp>max_value) max_value = *temp;
        		temp++;
        	}

        	// Compute the number of bits needed
        	const uint8 num_bits = (uint8)ceil(log((float64)(max_value+1))/log(2.));
        	
        	// Write the number of bits used
        	fp.write((char*)&num_bits, 1);
        	
        	uint32 current_label=*input;
        	uint32 max_label = current_label;
        	
        	uint8  current_length = 0;
        	uint8  n_bits_to_write;
        	uint64 to_write;
    		
        	fp.close();
        	
    		WriteBitStream wbs(_filename.c_str(), APPEND);
    		
    		// Write first label
			to_write = (uint64)(((uint64)7)<<num_bits)+(uint64)current_label; // 111 + N bits label
			n_bits_to_write = num_bits+3;
			wbs.write(to_write, n_bits_to_write);  		
    		    		
			
        	for(uint64 ii=0; ii<num_elements; ii++)
        	{
        		if(*input==current_label && current_length < 255)
        		{
        			current_length++;
        		}
        		else
        		{
        			// Length casuistry
        			_code_length(current_length, to_write, n_bits_to_write);
			
        			// Write length
        			wbs.write(to_write, n_bits_to_write);
        			       	
        			// New label
        			current_label = *input;
        			current_length = 1;
        			
        			if (ii>=width) //We are not in the first row
        			{
        				// Label casuistry:
            			// 	"Up" value           -->  0
            			// 	"Up-one-right" value -->  10
            			// 	"Max label" +1       -->  110
            			//  "Label directly"     -->  111 (+ N bits of label)
        				uint32 ref_label1 = *(input-width);
        				uint8 num_changes = 0;
        				bool found = false;
        				uint32 offset = 0;
        				
        				do
        				{
        					uint32 ref_label2 = ref_label1;
        					ref_label1 = *(input-width+offset);
        					
        					if(ref_label1 != ref_label2)
        						num_changes++;
        					
        					if(ref_label1 == current_label)
        						found = true;

        					offset++;
        				}
        				while(num_changes<1 && ((ii+offset)%width>0) && !found);
        				
        				if (found)
        				{
        				    switch (num_changes)
        				    {
        				        case 0:
        				        {
        				        	to_write = 0; //0
        				        	n_bits_to_write = 1;
        				        }
        				        break;
        				        case 1:
        				        {
			        				to_write = 2; //10
			        				n_bits_to_write = 2;
        				        }
        				        break;
        				        default: // We shouldn't get here...
        				        	ASSERT(false, "Looking for current_label in the upper row, but something went wrong");  
       				        	break;
        				    }
        				}
        				else
        				{
        					if ((current_label-max_label)==1)
        					{
        						to_write = 6; //110
        						n_bits_to_write = 3;
        					}
        					else
        					{
        						to_write = (uint64)(((uint64)7)<<num_bits)+(uint64)current_label; // 111 + N bits label
        						n_bits_to_write = num_bits+3;
        					}
        				}
        			}
        			else // We are in the first row, we have no "up" reference
        			{
    					if ((current_label-max_label)==1)
    					{
    						to_write = 6; //110
    						n_bits_to_write = 3;
    					}
    					else
    					{
    						to_write = (uint64)(((uint64)7)<<num_bits)+(uint64)current_label; // 111 + N bits label
    						n_bits_to_write = num_bits+3;
    					}
        			}
        			
        			// Write label
        			wbs.write(to_write, n_bits_to_write);
        			
        			// Update max_label
        			if(max_label<current_label)
        			{
        				max_label = current_label;
        			}
        		}
        		input++;
        	}
        	
			//Write last length
        	_code_length(current_length, to_write, n_bits_to_write);

			// Actually write it
			wbs.write(to_write, n_bits_to_write);
    		wbs.force_write();
    		
    		// close the bitstream
    		wbs.close();
    	}
        break;
        
        default:
        	throw ImagePlusError("Unknown compress type");
        break;
    }
}


void WriteMultiArray::_code_length(const uint8& length, uint64& to_write, uint8& n_bits_to_write)
{
	switch (length)
	{
		case 1:
			to_write = 0; //000
			n_bits_to_write = 3;        					
		break;
		case 2:
			to_write = 1; //001
			n_bits_to_write = 3;
		break;
		case 3:
			to_write = 2; //010
			n_bits_to_write = 3;
		break;
		case 4:
			to_write = 3; //011
			n_bits_to_write = 3;
		break;
		default:  // >4
			to_write = (uint64)256+(uint64)length; //1 + 8 bits length
			n_bits_to_write = 9;
	}
}



template<int D>
void WriteMultiArray::_append_multiarray(const MultiArray<int64,D>& m,
                                         std::ofstream& fp)
{
    _append_multiarray_header(m.dims(),INT64,fp);

    // compress data
    switch (_compress)
    {
        case BYTE_RUNLENGTH:
        {
            // The number 1.00390625 is 257/256 and it is needed because the rle compression
            // can be greater than the input array (in the case of random data) 
            uint64 maxcsize = static_cast<uint64>(((float64)m.num_elements()*sizeof(int64)*1.00390625) + 2);
            boost::shared_array<uint8> cdata = boost::shared_array<uint8>(new uint8[maxcsize]);
            imageplus::compress::Rle rle;

            uint64 csize = rle.compress(reinterpret_cast<const uint8 *>(m.data()),
                                        cdata.get(),
                                        m.num_elements() * sizeof(int64));

            // write size of compress data
            fp.write((char*)&csize, sizeof(uint64));

            // write compress data
            fp.write((char*)cdata.get(), csize);
        }
            break;
        default:
            throw ImagePlusError("Unknown compress type");
            break;
    }
}


template<int D>
void WriteMultiArray::_append_multiarray(const MultiArray<float64,D>& m,
                                         std::ofstream& fp)
{
    _append_multiarray_header(m.dims(),FLOAT64,fp);

    // convert floats to portable
    uint64 s = m.num_elements()*11;
    boost::shared_array<uint8> data = boost::shared_array<uint8>(new uint8[s]);
    for (uint64 i = 0; i < s; i++)
    {
        data[i] = 0;
    }
    PortableFloat pf;
    for (uint64 i = 0; i < s/11; i++)
    {
        pf.encode(m.data()[i],data.get()+(11*i));
    }

    // compress data
    switch (_compress)
    {
        case BYTE_RUNLENGTH:
        {
            uint64 maxcsize = s*257/256+2;
            boost::shared_array<uint8> cdata = boost::shared_array<uint8>(new uint8[maxcsize]);
            imageplus::compress::Rle rle;

            uint64 csize = rle.compress(data.get(),
                                        cdata.get(),
                                        s);

            // write size of compress data
            fp.write((char*)&csize, sizeof(uint64));

            // write compress data
            fp.write((char*)cdata.get(), csize);
        }
            break;
        default:
            throw ImagePlusError("Unknown compress type");
            break;
    }


}


template void imageplus::io::WriteMultiArray::_append_multiarray<1>(const MultiArray<uint8,1>&, std::ofstream& );
template void imageplus::io::WriteMultiArray::_append_multiarray<2>(const MultiArray<uint8,2>&, std::ofstream& );
template void imageplus::io::WriteMultiArray::_append_multiarray<3>(const MultiArray<uint8,3>&, std::ofstream& );

template void imageplus::io::WriteMultiArray::_append_multiarray<1>(const MultiArray<uint32,1>&, std::ofstream& );
template void imageplus::io::WriteMultiArray::_append_multiarray<2>(const MultiArray<uint32,2>&, std::ofstream& );
template void imageplus::io::WriteMultiArray::_append_multiarray<3>(const MultiArray<uint32,3>&, std::ofstream& );

template void imageplus::io::WriteMultiArray::_append_multiarray<1>( const MultiArray<int64,1>&, std::ofstream& );
template void imageplus::io::WriteMultiArray::_append_multiarray<2>( const MultiArray<int64,2>&, std::ofstream& );
template void imageplus::io::WriteMultiArray::_append_multiarray<3>( const MultiArray<int64,3>&, std::ofstream& );

template void imageplus::io::WriteMultiArray::_append_multiarray<1>( const MultiArray<float64,1>&, std::ofstream& );
template void imageplus::io::WriteMultiArray::_append_multiarray<2>( const MultiArray<float64,2>&, std::ofstream& );
template void imageplus::io::WriteMultiArray::_append_multiarray<3>( const MultiArray<float64,3>&, std::ofstream& );

