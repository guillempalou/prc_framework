/*
 * occlusion_evaluation.cpp
 *
 *  Created on: Mar 4, 2013
 *      Author: gpalou
 */

#include <imageplus/core/image_signal.hpp>
#include <imageplus/core/video_signal.hpp>
#include <imageplus/core/colorspace_converter.hpp>

#include <imageplus/optical_flow/flow_io.hpp>
#include <imageplus/optical_flow/occlusions/photo_consistency_error.hpp>
#include <imageplus/optical_flow/occlusions/flow_variation_error.hpp>
#include <imageplus/optical_flow/occlusions/reverse_endpoint_error.hpp>
#include <imageplus/optical_flow/occlusions/reverse_angle_error.hpp>
#include <imageplus/optical_flow/occlusions/bijective_error.hpp>

#include <imageplus/math/algebra/robust_regression.hpp>

#include <boost/filesystem.hpp>
#include <imageplus/toolbox/tictoc.hpp>
#include <iostream>
#include <iomanip>
#include <fstream>
#include <vector>
#include <set>

using namespace imageplus;

#define uint64 imageplus::uint64

typedef VideoSignal<float64,3> 																		VideoType;
typedef VideoSignal<float64,3>::ImageType															FrameType;
typedef ImageSignal<float64,1>																		ConfidenceMapType;
typedef VideoSignal<float64,2>																		OpticalFlowType;
typedef OpticalFlowType::ImageType																	OpticalFlowFrame;


typedef VideoType::coord_type 																		coord3d;

// The vector is of the same type
typedef VideoType::value_type																		lab_type;
typedef VideoType::value_type																		rgb_type;


std::pair<float64,float64> single_precision_recall(ConfidenceMapType& result, ConfidenceMapType& gt, ConfidenceMapType& mask) {
	float64 tp = 0;
	float64 tn = 0;
	float64 fp = 0;
	float64 fn = 0;
	for (ConfidenceMapType::iterator p = result.begin(); p != result.end(); ++p) {
		ConfidenceMapType::coord_type pos = p.pos();
		float64 v = (*p)(0);
		if (mask(pos)(0) != 0) continue;
		if (v < 0) continue;
		v = ((*p)(0) > 0) ? 1 : 0;
		float64 v_gt = gt(pos)(0);
		if (v ==v_gt) {
			if (v == 0) tn++;
			if (v == 1) tp++;
		} else {
			if (v == 0) fn++;
			if (v == 1) fp++;
		}
	}
	float64 p = 0;
	float64 r = 0;
	if (tp+fp == 0) {
		p = 1;
		r = 0;
	} else {
		p =  tp / (tp + fp);
		if (tp+fn == 0)
			r = 0;
		else
			r = tp / (tp + fn);
	}
	return std::pair<float64,float64>(p,r);
}

void precision_recall(ConfidenceMapType& result, ConfidenceMapType& gt, ConfidenceMapType& mask, uint64 nth, std::string path) {
	std::ofstream ofs(path.c_str());

	float64 div =1.0/nth;
	for (float64 th = div; th < 1; th+=div) {
		float64 tp = 0;
		float64 tn = 0;
		float64 fp = 0;
		float64 fn = 0;
		for (ConfidenceMapType::iterator p = result.begin(); p != result.end(); ++p) {
			ConfidenceMapType::coord_type pos = p.pos();
			float64 v = (*p)(0);
			if (mask(pos)(0) != 0) continue;
			if (v < 0) continue;
			v = ((*p)(0) > th) ? 1 : 0;
			float64 v_gt = gt(pos)(0);
			if (v ==v_gt) {
				if (v == 0) tn++;
				if (v == 1) tp++;
			} else {
				if (v == 0) fn++;
				if (v == 1) fp++;
			}
		}
		float64 p = 0;
		float64 r = 0;
		if (tp+fp == 0) {
			p = 1;
			r = 0;
		} else {
			p =  tp / (tp + fp);
			r = tp / (tp + fn);
		}
		ofs << th << " " << p << " " << r << " " << (2*p*r)/(p+r) << std::endl;
	}
}

int main(int argc, char* argv[]) {

	std::string dataset_path = argv[1];
	std::string occlusions_path = argv[2];

	uint64 N = 13;
	uint64 Nreg = 49;
	uint64 train[] = {9,10,17,18,19,22,24,27,29,30,39,49,50};
	//uint64 regions[] = {2,3,4,5,10,20,30,40,60,80,100,200,400,500};
	//uint64 regions[] = {1000,1151,1325,1526,1757,2023,2329,2682,3088,3556,4094,4714,5428,6250,7196,8286,9540,10985,12648,14563,16768,19306,22229,25595,29470,33932,39069,44984,51794,59636,68664,79060,91029,104811,120679,138949,159985,184206,212095,244205,281176,323745,372759,429193,494171,568986,655128,754312,868511};
	uint64 regions[50];
	for (uint64 i = 0; i < 50; i++) regions[i] = i;
	//uint64 regions[] = {2,3,4,5,10,20,30,40,60,80,90,100,110,120,130,150,170,200,220,240,260,300,350,400,440,460,500};
	std::vector<std::string> methods;

	methods.push_back("bijectivity");
	methods.push_back("flow_variation");
	methods.push_back("photo_consistency");
	methods.push_back("reverse_angle");
	methods.push_back("reverse_endpoint");
	//methods.push_back("region");
	methods.push_back("flow_models");
	methods.push_back("final");
	methods.push_back("lean");

	uint64 Nth = 1000;

	for (uint64 i = 0; i < N; i++) {
		std::cout << "Gathering data for seq " << train[i] << ", is " << i+1 << "/" << N << std::endl;

		std::ostringstream os;

		for (uint64 k = 0; k < methods.size(); k++) {
			ConfidenceMapType groundtruth, mask;

			os << dataset_path << "/groundtruth/" << train[i] << ".png";
			groundtruth.read(os.str()); os.str("");
			os << dataset_path << "/groundtruth/" << train[i] << "_mask.jpg";
			mask.read(os.str()); os.str("");

			groundtruth.channel(0) /= groundtruth.channel(0).maxCoeff();
			mask.channel(0) /= mask.channel(0).maxCoeff();

			os << occlusions_path << "/" << train[i] << "/" + methods[k] + ".txt";
			std::string output_file = os.str(); os.str("");
			ConfidenceMapType occs;

			if (methods[k] != "flow_models")
				continue;

			if (methods[k] == "region" || methods[k] == "flow_models") {

				std::ofstream ofs(output_file.c_str());
				for (uint64 j = 0; j < Nreg; j++) {
					os << occlusions_path << "/" << train[i] << "/" << methods[k] << "/" << regions[j] << "/occ_000.png";
					occs.read(os.str()); os.str("");
					occs.channel(0) /= occs.channel(0).maxCoeff();
					std::pair<float64,float64> pr = single_precision_recall(occs,groundtruth,mask);
					ofs << regions[j] << " " << pr.first << " " << pr.second << " " << 2*pr.first*pr.second/(pr.first+pr.second) << std::endl;
				}

			} else {
				os << occlusions_path << "/" << train[i] << "/" << methods[k] << "/00000.png";
				occs.read(os.str()); os.str("");
				occs.channel(0) /= occs.channel(0).maxCoeff();
				precision_recall(occs,groundtruth, mask, Nth, output_file);
			}
		}

	}
}
