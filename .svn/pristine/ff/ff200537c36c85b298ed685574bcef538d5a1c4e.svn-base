/*
 * boundary_owner.hpp
 *
 *  Created on: Jan 10, 2013
 *      Author: gpalou
 */

#ifndef BOUNDARY_OWNER_HPP_
#define BOUNDARY_OWNER_HPP_

#include <imageplus/math/algebra/robust_regression.hpp>
#include <imageplus/math/math_types.hpp>

namespace imageplus {
	namespace optical_flow {

	template<class MaskModel, class PartitionModel>
	MaskModel construct_mask(PartitionModel& partition, uint64 d) {
		typedef  	typename PartitionModel::coord_type 						coord_type;
		typename PartitionModel::iterator p = partition.begin();
		typename PartitionModel::iterator end = partition.end();
		MaskModel mask(partition.sizes());

		for (; p != end; ++p) {
			coord_type radius = p.pos(); radius.fill(d);
			coord_type center = p.pos();
			coord_type upper = center - radius;
			coord_type lower = center + radius;
			uint64 value = 0;
			//std::cout << upper.transpose() << " " << lower.transpose() << std::endl;
			for (typename PartitionModel::roi_iterator x = partition.roi_begin(upper,lower); x != partition.roi_end(upper,lower); ++x) {
				if (partition.inside(x.pos())) {
					if ((*p)(0) != (*x)(0)) {
						value = 1;
					}
				}
			}
			mask(p.pos())(0) = value;
		}
		return mask;
	}


	template<class PartitionModel, class MaskModel, class OpticalFlowModel>
	std::map<uint64, std::map<uint64,float64> > boundary_owners(PartitionModel& partition, MaskModel& avoid, OpticalFlowModel& flow) {

		typedef 	math::algebra::RobustRegression<math::numeric::L1Robust> 	RobustRegression; // We fit 6 parameters, hence the dimension is 6
		typedef  	typename PartitionModel::coord_type 						coord_type;

		typename PartitionModel::iterator p = partition.begin();
		typename PartitionModel::iterator end = partition.end();

		std::map<uint64, std::map<uint64,float64> > owners;

		typedef typename PartitionModel::template general_adjacency_iterator<PartitionModel::default_forward_connectivity>::type  adj_iterator;
		for (; p != end; ++p) {
			typename PartitionModel::coord_type pos = p.pos();
			adj_iterator adj		 	= partition.template general_adjacency_begin<PartitionModel::default_forward_connectivity>(p.pos());
			adj_iterator adj_end 		= partition.template general_adjacency_end<PartitionModel::default_forward_connectivity>(p.pos());

			uint64 id1 	= (*p)(0);

			for (; adj!=adj_end;++adj) {
				uint64 id2 		= (*adj)(0);
				if (id1 != id2) {
					// compute average region motion and its difference with the edge motion

					//place a circle of radius 7

					coord_type radius = p.pos(); radius.fill(7);
					coord_type center = p.pos();
					coord_type upper = center - radius;
					coord_type lower = center + radius;
					typename OpticalFlowModel::value_type edge_flow = flow(p.pos());

					uint64 N1 = 0;
					uint64 N2 = 0;
					for (typename PartitionModel::roi_iterator x = partition.roi_begin(upper,lower); x != partition.roi_end(upper,lower); ++x) {
						//check if x is in bounds and it should not be avoided
						if (!partition.inside(x.pos())) continue;
						if (avoid(x.pos())(0) == 1) continue;
						if ((x.pos()-center).squaredNorm() > radius(0)*radius(0)) continue;
						if ((*x)(0) == id1) N1++;
						if ((*x)(0) == id2) N2++;
					}


					// check if we have enough candidates
					if (N1 < 10 || N2 < 10) continue;

					math::Matrix A1 = math::Matrix::Zero(2*N1,6);
					math::Vector b1 = math::Vector::Zero(2*N1);
					math::Matrix A2 = math::Matrix::Zero(2*N2,6);
					math::Vector b2 = math::Vector::Zero(2*N2);

					//populate the points
					uint64 p1 = 0;
					uint64 p2 = 0;
					for (typename PartitionModel::roi_iterator x = partition.roi_begin(upper,lower); x != partition.roi_end(upper,lower); ++x) {
						//check if x is in bounds and it should not be avoided
						if (!partition.inside(x.pos())) continue;
						if (avoid(x.pos())(0) == 1) continue;
						if ((x.pos()-center).squaredNorm() > radius(0)*radius(0)) continue;
						if ((*x)(0) == id1) {
							// Each point contributes to 2 equations
							b1(p1)  	= flow(x.pos())(0);
							b1(p1+1) 	= flow(x.pos())(1);

							A1(p1,0) = 1; 		A1(p1,1) = x.pos()(0); 		A1(p1,2) = x.pos()(1);
							A1(p1+1,3) = 1; 	A1(p1+1,4) = x.pos()(0); 	A1(p1+1,5) = x.pos()(1);

							p1+=2;
						}
						if ((*x)(0) == id2) {
							// Each point contributes to 2 equations
							b2(p2)  	= flow(x.pos())(0);
							b2(p2+1) 	= flow(x.pos())(1);

							A2(p2,0) = 1; 		A2(p2,1) = x.pos()(0); 		A2(p2,2) = x.pos()(1);
							A2(p2+1,3) = 1; 	A2(p2+1,4) = x.pos()(0); 	A2(p2+1,5) = x.pos()(1);

							p2+=2;
						}
					}
					// fit the models

					RobustRegression rr;
					rr.fit(A1,b1);

					math::Vector a1 = rr.solution();

					rr.fit(A2,b2);
					math::Vector a2 = rr.solution();
					//evaluate the models to the edge point
					typename OpticalFlowModel::value_type motion1(a1(0) + a1(1)*p.pos()(0) + a1(2)*p.pos()(1), a1(3) + a1(4)*p.pos()(0) + a1(5)*p.pos()(1));
					typename OpticalFlowModel::value_type motion2(a2(0) + a2(1)*p.pos()(0) + a2(2)*p.pos()(1), a2(3) + a2(4)*p.pos()(0) + a2(5)*p.pos()(1));

					//std::cout << id1 << " " << id2 << " " << (motion1 - edge_flow).squaredNorm() << " " <<  (motion2 - edge_flow).squaredNorm() << std::endl;

					// assign the owner (depth relation owner->owned) to the region with less distance
					if ((motion1 - edge_flow).squaredNorm() > (motion2 - edge_flow).squaredNorm()) {
						owners[id2][id1]++;
					}
					if ((motion1 - edge_flow).squaredNorm() < (motion2 - edge_flow).squaredNorm()) {
						owners[id1][id2]++;
					}
				}
			}
		}
		return owners;
	}

	}
}

#endif /* BOUNDARY_OWNER_HPP_ */
