/*
 * robust_regression.hpp
 *
 *  Created on: Feb 28, 2012
 *      Author: guillem
 */

#ifndef ROBUST_REGRESSION_HPP_
#define ROBUST_REGRESSION_HPP_

#include <imageplus/math/algebra/least_squares_regression.hpp>
#include <imageplus/math/numeric/robust_functions.hpp>

namespace imageplus {
	namespace math {
		namespace algebra {

			//! Struct containing the parameters to perform robust regression
			struct RobustRegressionParameters {

				//! maxmimum number of iterations
				uint64 max_iterations;
				//! tolerance on the improvement
				float64 tolerance;
				RobustRegressionParameters() : 	max_iterations(10),
												tolerance(1e-100) {

				}
			};

			//! Class to solve the problem argmin_b \sum_i Psi(x_i'*b - y)
			//! Where Psi is a robust function
			//! \author Guillem Palou <guillem.palou@upc.edu>
			//! \date 20-03-2011
			template<class RobustFunction>
			class RobustRegression {
			public:

				//!
				//! Vector x contains the independent coordinates, Vector b contains the dependent variable. L are the parameters
				//! for each row R the residual is:
				//! x[R][0]*b[0] + x[R][1]*b[1] + .... + x[R][D]*b[D-1] - y[R]
				//!
				//! \param[in] X : the matrix
				//! \param[in] y : vector of solutions
				//! \param[in] f : robust function
				RobustRegression() {
				}

				//! Function to fit the parameters. Uses Iterative Least Squares
				//!
				//! Vector x contains the independent coordinates, Vector b contains the dependent variable. L are the parameters
				//! for each row R the residual is:
				//! x[R][0]*b[0] + x[R][1]*b[1] + .... + x[R][D]*b[D-1] - y[R]
				//!
				//! \param[in] X : the matrix
				//! \param[in] y : vector of solutions
				//! \param[in] f : robust function
				//! \return Vector with the parameters
				Vector& fit(Matrix& X, Vector& y) {
					uint64 N = y.rows();

					RobustFunction f;

					Vector w(N);
					/*
					 * Find an initial estimate by Least Squares
					 */
					LeastSquaresRegression sq;
					sq.fit(X,y);
					Vector b = sq.solution();

					//std::cout << "fit " << y.transpose() << std::endl;
					//std::cout << X << std::endl;
					//std::cout << "initial solution " << b.transpose() << std::endl;

					uint32 iterations = 0;
					do {

						// Compute the residual
						Vector e = y - X*b;

						Vector d(1);
						for (uint64 i = 0; i < N; i++) {
							d(0) = e(i);
							if (e(i) == 0) d(0) = 1; else d = f.gradient(d) / e(i);
							w(i) = d(0);
						}

						// check the residual norm!
						float64 norm_r = e.norm(), norm_y = y.norm();

						if (norm_r / (norm_y+pars.tolerance) < pars.tolerance) break;

						// Form the matrices
						Matrix Xt = X;
						for (uint32 i = 0; i < N; i++) {
							Xt.row(i) *= w(i);
						}

						Matrix XX = X.transpose() * Xt;
						Vector bb = X.transpose() * (y.array() * w.array()).matrix();

						/*
						 *
						 * Prepare the system to solve X'*W*X*p = X'*W*b
						 * Where p is the parameter vector
						 **/

						Vector ant_b = b;
						b = XX.jacobiSvd(Eigen::ComputeThinU | Eigen::ComputeThinV).solve(bb);

						/*Check the improvement!*/
						if ((ant_b-b).norm() / (ant_b.norm() + pars.tolerance) < pars.tolerance) break;

					} while (iterations++ < pars.max_iterations);

					_solution = b;
					return _solution;
				}

				//!Function returning the parameters. fit() should be called prior to this function
				Vector& solution() {return _solution;}

			private:

				//! Parameters
				RobustRegressionParameters pars;

				//! found parameters
				Vector _solution;
			};

		}
	}
}


#endif /* ROBUST_REGRESSION_HPP_ */
