/*
 * binary_partition_tree.hpp
 *
 *  Created on: Aug 21, 2012
 *      Author: guillem
 */

#ifndef BINARY_PARTITION_TREE_HPP_
#define BINARY_PARTITION_TREE_HPP_

#include <imageplus/segmentation/partition/hierarchical_region_partition.hpp>
#include <imageplus/core/regions/hierarchical_region.hpp>

#include <imageplus/descriptors/descriptor_manager.hpp>
#include <imageplus/descriptors/color/color_signature.hpp>

#include <imageplus/bpt/stop_conditions.hpp>

#include <boost/filesystem.hpp>
#include <fstream>
#include <iomanip>
#include <limits>

namespace imageplus {
	namespace bpt {

	template<class Signal, class StopCondition = NumberOfRegionsStopCondition, class RegionModel = HierarchicalRegion<typename Signal::coord_type>, ConnectivityType adjacency_type = neighborhood_traits<RegionModel::dimensions>::default_forward_connectivity>
	class BinaryPartitionTree {

	public:

		typedef typename Signal::coord_type														coord_type;

		typedef RegionModel																		RegionType;

		typedef segmentation::HierarchicalRegionPartition<RegionType, adjacency_type>			BPT;

		typedef StopCondition																	StopConditionType;

		typedef typename RegionType::RegionBaseType												RegionBaseType;
		typedef typename RegionBaseType::RegionLinkType											RegionLinkType;

		typedef typename RegionType::identifier_type											identifier_type;

		typedef typename BPT::PartitionType														PartitionType;
		typedef descriptors::DescriptorManager													DescriptorManagerType;

	public:

		struct Parameters {
			bool debug;
			bool update_roots_partition;
			uint64 num_regions_until_stop;
			float64 step;

			typename StopConditionType::Parameters stop_parameters;

			Parameters() : debug(false), update_roots_partition(false), num_regions_until_stop(1), step(0) {

			}

		};

		static const Parameters default_parameters() {
			Parameters p;
			p.debug = false;
			p.update_roots_partition = false;
			p.step = 0.0;
			p.num_regions_until_stop = 1;
			return p;
		}

	public:

		BinaryPartitionTree(const Parameters& pars = default_parameters()) : _pars(pars), _manager() {
		}

		template <class DistanceModel>
		inline uint64 merge_iteration(Signal& signal, DistanceModel* model) {

			RegionLinkType* to_merge;
			do {
				to_merge = _links.get_first();

				// find the adjacent neighbors and add the following triplets
				if (to_merge->type == LinkTypeSkip) {

				}

			} while(to_merge->type != LinkTypeNormal);

			//get link characteristics
			RegionType* reg1 = (RegionType*)to_merge->neighbor1;
			RegionType* reg2 = (RegionType*)to_merge->neighbor2;

			//std::cout << "Merging " << reg1->label() << " " << reg2->label() << " " << to_merge->distance << std::endl;

			//remove all links belonging to the child regions from list
			typename RegionBaseType::neighbor_iterator n, n_end;
			n = reg1->neighbors_begin();
			n_end = reg1->neighbors_end();
			for (; n != n_end; ++n) {
				_links.erase(n.link_data());
			}
			n = reg2->neighbors_begin();
			n_end = reg2->neighbors_end();
			for (; n != n_end; ++n) {
				if ((*n) != reg1) {
					_links.erase(n.link_data());
				}
			}

			RegionType& parent = _bpt.merge_regions(*reg1,*reg2, ++_current_label);

			//remove merged link from list
			// the link is removed with the previous process
			//_links.erase(to_merge);

			// recalculate father distances
			n = parent.neighbors_begin();
			n_end = parent.neighbors_end();

			//uint64 neighs = 0;
			for (; n != n_end; ++n) {

				//neighs++;
				float64 d = model->region_distance(parent, *((RegionType *)(*n)), signal, _bpt, _manager);
				n.link_data()->distance = d;
				_links.put(n.link_data());
			}
			//std::cout << "Creating " << parent.label() << " from " << reg1->label() << " " << reg2->label() << std::endl;
			_manager.clear_all_region_descriptors(*reg1);
			_manager.clear_all_region_descriptors(*reg2);

			return --_N;
		}

		void init(Signal& signal, PartitionType& initial_partition) {

			_bpt.init(initial_partition);

			_bpt.set_update_partition(_pars.update_roots_partition);

			_manager.set_max_number_of_regions(2*_bpt.max_label()+1);

			_N = _bpt.max_label()+1;

			_current_label = _bpt.max_label();

			_condition.template init(signal, _bpt, _manager, _pars.stop_parameters);
		}

		template <class DistanceModel>
		void create(Signal& signal, const typename DistanceModel::Parameters& pars = DistanceModel::default_parameters()) {

			DistanceModel* model = new DistanceModel(pars);

			uint64 num_regions = _N;
			uint64 	total_mergings 		= num_regions - _pars.num_regions_until_stop;
			uint64 	total_mergings_done = 0;
			float64 merging_step = _pars.step * total_mergings;
			uint64 	current_merging_step = 0;

			typename BPT::global_iterator it = _bpt.begin();
			typename BPT::global_iterator end = _bpt.end();

			if (_pars.debug) std::cerr << "Starting from " << _bpt.max_label()+1 << " regions " << std::endl;
			// put the links into a priority queue
			for (; it!=end;++it) {

				for (typename RegionType::neighbor_iterator n = (*it).neighbors_begin(); n != (*it).neighbors_end(); ++n) {

					if ((*it).label() < (*n)->label()) continue;

					//std::cout << "Distance " << ((RegionType&)(*it)).label() << " " << ((RegionType *)(*n))->label() << std::endl;
					float64 d = model->region_distance((RegionType&)(*it), *((RegionType *)(*n)), signal, _bpt, _manager);
					//std::cout << "done " << std::endl;
					//exit(0);
					n.link_data()->distance = d;

					_links.put(n.link_data());
				}
			}

			if (_pars.debug) std::cout << "Done 0%" << std::endl;
			while (!_condition.template should_stop(signal, _bpt, _manager)) { //num_regions > _pars.num_regions_until_stop) {
				num_regions = merge_iteration(signal, model);
				// debug info

				_condition.template update(signal, _bpt, _manager);

				if (_pars.debug) {
					current_merging_step++;
					total_mergings_done++;
					if (current_merging_step >= merging_step) {
						current_merging_step = 0;
						std::cerr << "Done " << (int)(total_mergings_done * 100 / total_mergings) << "% " << std::endl;
					}
				}

			}

			_N = num_regions;

			delete model;
		}

		//! Returns the descriptor manager
		DescriptorManagerType& manager() {
			return _manager;
		}

		//! Returns a reference to the tree
		BPT& bpt() {
			return _bpt;
		}

		uint64 num_regions() {
			return _N;
		}

	protected:

		StopCondition	_condition;

		Parameters _pars;

		uint64 	_N; //! number of actual regions
		uint64 _current_label; //! label of the new region to create

		BST<typename RegionBaseType::RegionLinkType, typename RegionBaseType::RegionLinkType::compare_distance_function>		_links; //! links
		DescriptorManagerType																									_manager; //! descriptor manager
		BPT																														_bpt;
	};

	}
}

#endif /* BINARY_PARTITION_TREE_HPP_ */
