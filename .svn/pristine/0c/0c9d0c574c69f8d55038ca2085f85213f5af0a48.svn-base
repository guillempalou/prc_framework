/*
 * learning_bpt.cpp
 *
 *  Created on: Jan 11, 2013
 *      Author: gpalou
 */

#define IL_STD

#include <imageplus/segmentation/slic/slic.hpp>
#include <imageplus/segmentation/measures/boundary_recall.hpp>
#include <imageplus/segmentation/visualization/false_color.hpp>

#include <imageplus/bpt/learning_bpt.hpp>
#include <imageplus/bpt/models/metric_model.hpp>

#include <imageplus/core/colorspace_converter.hpp>

#include <ilcplex/ilocplex.h>

using namespace imageplus;
#define uint64 imageplus::uint64

typedef ImageSignal<float64,3> 						ImageType;

typedef bpt::LearningBPT<ImageType>																	BPTAlgorithm;
typedef BPTAlgorithm::BPT																			BPT;
typedef BPTAlgorithm::PartitionType																	PartitionType;

typedef BPTAlgorithm::DescriptorType::type															DescriptorVector;

static const uint64 D = DescriptorVector::RowsAtCompileTime;

typedef bpt::MetricModel<ImageType, BPT::RegionType> 												DistanceModelType;

typedef struct {
	math::Matrix region_descriptors;
	math::Matrix triplets;
} MergingIncompatibilities;

typedef struct {
	math::Vector kernel_w;
	math::Vector mean;
	math::Vector stddev;
} OptimizationResult;

MergingIncompatibilities perform_bpt_with_groundtruth(ImageType& img, PartitionType& gt, bool initialized, OptimizationResult& opt, math::Matrix& xi, float64 sigma) {

	segmentation::SLIC slic;

	PartitionType partition = slic.segment_with_superpixel_number(img,1000,1);

	//assign each superpixel to a region
	PartitionType::iterator p = partition.begin();
	PartitionType::iterator end = partition.end();
	std::map<uint64, uint64> assignment;
	std::map<uint64, std::map<uint64, uint64> > intersect;

	for (; p != end; ++p) {
		PartitionType::coord_type pos = p.pos();
		intersect[partition(pos)(0)][gt(pos)(0)] +=1;
	}
	for (std::map<uint64, std::map<uint64, uint64> >::iterator r1 = intersect.begin(); r1 != intersect.end(); ++r1) {
		uint64 assigned = r1->second.begin()->first;
		assignment[r1->first] = assigned;
		for (std::map<uint64,uint64>::iterator r2 = r1->second.begin(); r2 != r1->second.end(); ++r2) {
			if (intersect[r1->first][assigned] < r2->second) {
				assignment[r1->first] = r2->first;
			}
		}
	}

	// The SLIC algorithm does not conver to CIE Lab the original data
	ColorSpaceConverter<ImageType> converter;
	converter.convert(img, ColorSpaceLAB);

	BPTAlgorithm::Parameters pars;
	pars.debug = false;
	pars.update_roots_partition = false;
	pars.gt_assignment = assignment;
	BPTAlgorithm bpt_metric(pars);

	DistanceModelType::Parameters model_pars;

	model_pars.initialized = initialized;
	model_pars.assignment = assignment;
	model_pars.sigma = sigma;

	model_pars.w = opt.kernel_w;
	model_pars.mean = opt.mean;
	model_pars.stddev = opt.stddev;

	model_pars.xi = xi.transpose();

	bpt_metric.init(img, partition);
	bpt_metric.create<DistanceModelType>(img, model_pars);

	uint64 Nreg = bpt_metric.pars().reg_index.size();
	uint64 Ntri = bpt_metric.pars().triplets.size();

	std::cout << "Incompatibilities: " << bpt_metric.pars().incompatibilities << std::endl;
	std::cout << "Regions: " <<  Nreg << std::endl;
	std::cout << "Triplets: " <<  Ntri << std::endl;

	MergingIncompatibilities incompatibilities;

	incompatibilities.region_descriptors.resize(Nreg, DistanceModelType::dimensions);
	incompatibilities.triplets.resize(Ntri, 3);

	uint64 i = 0;
	for (std::list<DescriptorVector>::iterator it = bpt_metric.pars().descriptors.begin(); it != bpt_metric.pars().descriptors.end(); ++it, ++i) {
		incompatibilities.region_descriptors.row(i) = (*it).transpose();
	}
	i = 0;
	for (std::list<BPTAlgorithm::triplet>::iterator it = bpt_metric.pars().triplets.begin(); it != bpt_metric.pars().triplets.end(); ++it,++i) {
		incompatibilities.triplets.row(i) = (*it).transpose().cast<float64>();
	}

	//std::cout << incompatibilities.region_descriptors;
	//std::cout << incompatibilities.triplets;

	return incompatibilities;
}

OptimizationResult optimize_metric(math::Matrix& descriptors, math::Matrix& triplets, float64 sigma=1, float64 C = 1)
{
    std::size_t n_reg = descriptors.rows();
    std::size_t n_constr = triplets.rows();

    // Normalize features
    OptimizationResult opt;

    //std::cout << descriptors << std::endl;

    math::Vector mean     = descriptors.colwise().mean();
    math::Matrix zeromean = descriptors.rowwise() - mean.transpose();
    math::Vector stddev = descriptors.array().square().colwise().mean() - (mean.array()*mean.array()).transpose();
    stddev = stddev.array().sqrt();
    //variance
    //std::cout << "------" << std::endl;
    //std::cout << mean.transpose() << std::endl;
    //std::cout << stddev.transpose() << std::endl;
    //std::cout << "------" << std::endl;

    //normalize


    for (uint64 i = 0; i < n_reg; i++) {
    	descriptors.row(i) = zeromean.row(i).array() / stddev.transpose().array();
    }

    //std::cout << descriptors << std::endl;
    //std::cout << "------" << std::endl;

    //descriptors = (zeromean.array().rowwise() / stddev.transpose().array());
    opt.mean = mean;
    opt.stddev = stddev;

    // Create matrix L
    math::Matrix L(n_reg,n_reg);
    for (std::size_t ii=0; ii<n_reg; ++ii)
    {
        for (std::size_t jj=ii; jj<n_reg; ++jj)
        {
            float64 norm2 = (descriptors.row(ii)-descriptors.row(jj)).squaredNorm();
            L(ii,jj) = exp(-norm2/(sigma*sigma));
            L(jj,ii) = L(ii,jj);
        }
    }

    L = L + 1e-5*math::Matrix::Identity(n_reg,n_reg);

    //std::cout << L << std::endl;
    //exit(0);
    //std::cout << " ---------------- " << std::endl;


    IloEnv env;
    math::Vector w(n_reg);

    try
    {
        // Variables
        // IloNumVarArray(const IloEnv env, IloInt n, IloNum lb, IloNum ub, IloNumVar::Type type=ILOFLOAT)
        IloNumVarArray omega(env, n_reg    , 0, +IloInfinity, ILOFLOAT);
        IloNumVarArray ksi  (env, n_constr , 0, +IloInfinity, ILOFLOAT);

        // Expression for the objective function
        IloExpr expr(env);
        for (std::size_t ii=0; ii<n_reg; ++ii)
            for (std::size_t jj=0; jj<n_reg; ++jj)
                expr += 0.5*L(ii,jj)*(omega[ii]*omega[jj]);
        for (std::size_t ii=0; ii<n_constr; ++ii)
            expr += C*ksi[ii];
        IloObjective obj(env, expr, IloObjective::Minimize);

        // Define model
        IloModel model(env);
        model.add(obj); // Add objective function

        // Add the constraints
        // Expression for the constraints
        for (std::size_t ii=0; ii<n_constr; ++ii)
        {
            // Triplet involved
            std::size_t i = triplets(ii,0);
            std::size_t j = triplets(ii,1);
            std::size_t k = triplets(ii,2);

            // Compute delta (At*xi-At*xk)*(At*xi-At*xk)
            math::Vector deltaij(n_reg);
            math::Vector deltaik(n_reg);
            for (std::size_t n=0; n<n_reg; ++n)
            {
                float64 normni = (descriptors.row(n)-descriptors.row(i)).squaredNorm();
                float64 normnj = (descriptors.row(n)-descriptors.row(j)).squaredNorm();
                float64 normnk = (descriptors.row(n)-descriptors.row(k)).squaredNorm();

                float64 kni = exp(-normni/(2*sigma*sigma));
                float64 knj = exp(-normnj/(2*sigma*sigma));
                float64 knk = exp(-normnk/(2*sigma*sigma));

                deltaij(n) = (kni-knj)*(kni-knj);
                deltaik(n) = (kni-knk)*(kni-knk);
            }

            IloExpr cst_expr(env);
            for (std::size_t jj=0; jj<n_reg; ++jj)
                cst_expr += omega[jj]*(deltaik(jj)-deltaij(jj));
            cst_expr += ksi[ii];

            model.add(IloRange(env, 1, cst_expr, +IloInfinity));
        }

        // Solve the model
        IloCplex cplex(model);
        cplex.setParam(IloCplex::TuningDisplay,0);
        cplex.setParam(IloCplex::BarDisplay, 0);
        cplex.setParam(IloCplex::SimDisplay,0);
        cplex.setParam(IloCplex::Threads,1);
        if ( !cplex.solve() )
        {
            env.error() << "Failed to optimize QP." << std::endl;
            throw(-1);
        }

        // Show the result
        env.out() << "Solution status = " << cplex.getStatus() << std::endl;
        env.out() << "Solution value  = " << cplex.getObjValue() << std::endl;
        IloNumArray vals_omega(env);
        cplex.getValues(vals_omega, omega);
        // env.out() << "Omega = " << vals_omega << std::endl;
        IloNumArray vals_ksi(env);
        cplex.getValues(vals_ksi, ksi);
        // env.out() << "Ksi = " << vals_ksi << std::endl;

        // Count the number of violated contraints
        uint64 num_violated = 0;
        uint64 num_equal = 0;
        for (std::size_t ii=0; ii<n_constr; ++ii)
        {
            if (vals_ksi[ii]>1+1e-6)
                num_violated += 1;
            else if ( (vals_ksi[ii]<1+1e-6) && (vals_ksi[ii]>1-1e-6))
                num_equal +=1;
        }
        std::cout << "------------------------" << std::endl;
        std::cout << "Constraints:" << std::endl;
        std::cout << " " << n_constr-num_equal-num_violated << " ok"       << std::endl;
        std::cout << " " << num_violated                    << " violated" << std::endl;
        std::cout << " " << num_equal                       << " equal"    << std::endl;
        std::cout << " " << n_constr                        << " total" << std::endl;
        std::cout << "------------------------" << std::endl;

        for (uint64 i =0 ; i < n_reg; i++)
        	w(i) = vals_omega[i];
    }
    catch (IloException& e) {
        std::cerr << "Concert exception caught: " << e << std::endl;
    }
    catch (...) {
        std::cerr << "Unknown exception caught" << std::endl;
    }

    env.end();

    opt.kernel_w = w;
    return opt;
}

inline float64 distance(const Eigen::Matrix<float64, 1, 3>& x, const Eigen::Matrix<float64, 1, 3>& y, math::Matrix xi, math::Vector w, uint64 sigma) {
	uint64 N = xi.rows();
	float64 d = 0;
	for (uint64 i =0 ; i < N; i++) {
		float64 kx = std::exp(-(x-xi.row(i)).squaredNorm()/(2*sigma*sigma));
		float64 ky = std::exp(-(y-xi.row(i)).squaredNorm()/(2*sigma*sigma));
		d += w(i)*(kx-ky)*(kx-ky);
	}

	return d;
}

int main(int argc, char *argv[]) {

	std::string path 				= argv[1];
	std::string path_gt 			= argv[2];

	//std::string path_result			= argv[3];
	//boost::filesystem::path	result_path(path_result);
	//boost::filesystem::create_directory(result_path);

	ImageType 			image_partition;

	PartitionType		partition;
	PartitionType		partition_gt;

	image_partition.read(path_gt);

	partition_gt = segmentation::to_partition<PartitionType>(image_partition);

	OptimizationResult opt;
	math::Matrix xi = math::Matrix();
	float64 sigma = 1;
	float64 C = 1;

	uint64 iter = 0;
	bool condition=false;

	while (condition == false) {
		ImageType 			img;
		img.read(path);

		MergingIncompatibilities incompatibilities = perform_bpt_with_groundtruth(img,partition_gt,iter!=0,opt,xi,sigma);
		OptimizationResult now_opt = optimize_metric(incompatibilities.region_descriptors, incompatibilities.triplets, sigma, C);

		/*uint64 N = incompatibilities.triplets.rows();

		std::cout << kernel_w.transpose() << std::endl;

		for (uint64 i = 0; i < N; i++) {
			uint64 ri = incompatibilities.triplets(i,0);
			uint64 rj = incompatibilities.triplets(i,1);
			uint64 rk = incompatibilities.triplets(i,2);

			Eigen::Matrix<float64, 1, 3> xi = incompatibilities.region_descriptors.row(ri);
			Eigen::Matrix<float64, 1, 3> xj = incompatibilities.region_descriptors.row(rj);
			Eigen::Matrix<float64, 1, 3> xk = incompatibilities.region_descriptors.row(rk);

			float64 dij = distance(xi, xj, incompatibilities.region_descriptors, kernel_w, sigma);
			float64 dik = distance(xi, xk, incompatibilities.region_descriptors, kernel_w, sigma);

			std::cout << "(" << xi << ") (" << xj << ") (" << xk << ")" << " -- " << dij << " :: " << dik << " -- " << (dij < dik) << std::endl;
		}*/


		opt = now_opt;
		xi = incompatibilities.region_descriptors;

		iter++;

		if (iter==15) condition = true;
	}

	std::cout << opt.kernel_w.transpose() << std::endl;
}
