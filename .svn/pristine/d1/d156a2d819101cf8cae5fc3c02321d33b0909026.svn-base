// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------

//!
//! \file histogram.test
//!
//! Tests for the Histogram class
//!
#include <imageplus/math/statistics/histogram.hpp>
#include <imageplus/io/readimage.hpp>
#include <imageplus/io/writeimage.hpp>
#include <imageplus/math/statistics/multiarray_statistics.hpp>
#include <imageplus/core/multiarray_arithmetic.hpp>

BOOST_AUTO_TEST_SUITE ( Histogram_Suite );

using namespace imageplus;
using namespace imageplus::math::statistics;

typedef boost::mpl::list< uint8, uint16, uint32, uint64, int8, 
                          int16, int32, int64, float32, float64 > HistogramTypes;
typedef boost::mpl::list< float32, float64 >                      HistogramFloatTypes;
typedef boost::mpl::list< uint8, int64, float64 >                 HistogramVolumeTypes;
typedef boost::mpl::list< uint8, uint16 >                         HistogramImageYUVTypes;
typedef boost::mpl::list< uint8, uint16, uint32, uint64, int8, 
                          int16, int32, int64 >                   HistogramImageTypes;


BOOST_AUTO_TEST_CASE( Histogram_test)
{    
    ImagePartition<> my_im_part(3,3);
    my_im_part[0][0] = 25;  my_im_part[1][0] = 10;  my_im_part[2][0] = 25;
    my_im_part[0][1] = 25;  my_im_part[1][1] = 10;  my_im_part[2][1] = 25;
    my_im_part[0][2] = 25;  my_im_part[1][2] = 10;  my_im_part[2][2] = 10;
    
    ImageRGB<uint8> my_image(3,3);
    my_image(0) = 1;
    my_image(1) = 2;
    my_image(2) = 3;
    my_image(0)[0][0] = 25;
    my_image(0)[0][1] = 2;
    my_image(0)[2][2] = 6;
    
    typedef ImageRGB<uint8> InputType;
    typedef RegionContour<Coord2D<int64> > RegionType;
    typedef Partition<RegionType> partition_type;
    partition_type my_part(my_im_part);
    
    merge_regions(25, 10, 30, my_part);

    const Histogram<InputType>& desc = calc_descriptor(new Histogram<InputType>(0,25,26), my_image, my_part[25]);
    
    Histogram<InputType>::ContainerBase histo_ok(26,26,26);
    histo_ok = 0;
    histo_ok [1][2][3] = 3;
    histo_ok[25][2][3] = 1;
    histo_ok [2][2][3] = 1;
    
    BOOST_CHECK( desc == histo_ok );
    
    for(std::size_t ch = 0; ch<3; ++ch)
    {
        BOOST_CHECK(desc.quantizer()[ch]  == Quantizer<uint8>(0,25,26));
    }

    const Histogram<InputType>& desc2 = calc_descriptor(new Histogram<InputType>(0,25,26), my_image, my_part[10]);
    
    histo_ok = 0;
    histo_ok[1][2][3] = 3;
    histo_ok[6][2][3] = 1;
    
    BOOST_CHECK(desc2  == histo_ok);
    for(std::size_t ch = 0; ch<3; ++ch)
    {
        BOOST_CHECK(desc.quantizer()[ch]  == Quantizer<uint8>(0,25,26));
    }

    
    const Histogram<InputType>& desc3 = calc_descriptor(new Histogram<InputType>(0,25,26), my_image, my_part[30]);
    
    histo_ok = 0;
    histo_ok [1][2][3] = 6;
    histo_ok [6][2][3] = 1;
    histo_ok[25][2][3] = 1;
    histo_ok [2][2][3] = 1;
    
    BOOST_CHECK(desc3 == histo_ok);
}

BOOST_AUTO_TEST_CASE( Histogram_test_no_computed)
{
    ImagePartition<> my_im_part(3,3);
    my_im_part[0][0] = 25;  my_im_part[1][0] = 10;  my_im_part[2][0] = 25;
    my_im_part[0][1] = 25;  my_im_part[1][1] = 10;  my_im_part[2][1] = 25;
    my_im_part[0][2] = 25;  my_im_part[1][2] = 10;  my_im_part[2][2] = 10;

    ImageRGB<uint8> my_image(3,3);
    my_image(0) = 1;
    my_image(1) = 2;
    my_image(2) = 3;
    my_image(0)[0][0] = 25;
    my_image(0)[0][1] = 2;
    my_image(0)[2][2] = 6;

    typedef ImageRGB<uint8> InputType;
    typedef RegionContour<Coord2D<int64> > RegionType;
    typedef Partition<RegionType> partition_type;
    partition_type my_part(my_im_part);

    merge_regions(25, 10, 30, my_part);

    const Histogram<InputType>& desc3 = calc_descriptor(new Histogram<InputType>(0,25,26), my_image, my_part[30]);

    Histogram<InputType>::ContainerBase histo_ok(26,26,26);
    histo_ok = 0;
    histo_ok [1][2][3] = 6;
    histo_ok [6][2][3] = 1;
    histo_ok[25][2][3] = 1;
    histo_ok [2][2][3] = 1;

    BOOST_CHECK(desc3 == histo_ok);

    const Histogram<InputType>& desc = calc_descriptor(new Histogram<InputType>(0,25,26), my_image, my_part[25]);

    histo_ok = 0;
    histo_ok [1][2][3] = 3;
    histo_ok[25][2][3] = 1;
    histo_ok [2][2][3] = 1;

    BOOST_CHECK(desc  == histo_ok);

    const Histogram<InputType>& desc2 = calc_descriptor(new Histogram<InputType>(0,25,26), my_image, my_part[10]);

    histo_ok = 0;
    histo_ok[1][2][3] = 3;
    histo_ok[6][2][3] = 1;

    BOOST_CHECK(desc2  == histo_ok);
}

BOOST_AUTO_TEST_CASE( Histogram_test_no_coll_vd)
{
    ImagePartition<> my_im_part(3,3);
    my_im_part[0][0] = 25;  my_im_part[1][0] = 10;  my_im_part[2][0] = 25;
    my_im_part[0][1] = 25;  my_im_part[1][1] = 10;  my_im_part[2][1] = 25;
    my_im_part[0][2] = 25;  my_im_part[1][2] = 10;  my_im_part[2][2] = 10;

    ImageRGB<uint8> my_image(3,3);
    my_image(0) = 1;
    my_image(1) = 2;
    my_image(2) = 3;
    my_image(0)[0][0] = 25;
    my_image(0)[0][1] = 2;
    my_image(0)[2][2] = 6;

    typedef ImageRGB<uint8> InputType;
    typedef RegionContour<Coord2D<int64> > RegionType;
    typedef Partition<RegionType> partition_type;
    partition_type my_part(my_im_part);

    merge_regions(25, 10, 30, my_part);

    const Histogram<InputType>& desc = calc_descriptor(new Histogram<InputType>(0,25,26), my_image, my_part[25]);

    Histogram<InputType>::ContainerBase histo_ok(26,26,26);    
    histo_ok = 0;
    histo_ok [1][2][3] = 3;
    histo_ok[25][2][3] = 1;
    histo_ok [2][2][3] = 1;

    BOOST_CHECK(desc  == histo_ok);

    const Histogram<InputType>& desc2 = calc_descriptor(new Histogram<InputType>(0,25,26), my_image, my_part[10]);

    histo_ok = 0;
    histo_ok[1][2][3] = 3;
    histo_ok[6][2][3] = 1;

    BOOST_CHECK(desc2  == histo_ok);

    const Histogram<InputType>& desc3 = calc_descriptor(new Histogram<InputType>(0,25,26), my_image, my_part[30]);

    histo_ok = 0;
    histo_ok [1][2][3] = 6;
    histo_ok [6][2][3] = 1;
    histo_ok[25][2][3] = 1;
    histo_ok [2][2][3] = 1;

    BOOST_CHECK(desc3 == histo_ok);
}

BOOST_AUTO_TEST_CASE( ChannelHistogram_test)
{
    ImagePartition<> my_im_part(3,3);
    my_im_part[0][0] = 25;  my_im_part[1][0] = 10;  my_im_part[2][0] = 25;
    my_im_part[0][1] = 25;  my_im_part[1][1] = 10;  my_im_part[2][1] = 25;
    my_im_part[0][2] = 25;  my_im_part[1][2] = 10;  my_im_part[2][2] = 10;

    ImageRGB<uint8> my_image(3,3);
    my_image(RED_CHANNEL) = 1;
    my_image(BLUE_CHANNEL) = 2;
    my_image(GREEN_CHANNEL) = 3;
    my_image(RED_CHANNEL)[0][0] = 25;
    my_image(BLUE_CHANNEL)[0][1] = 100;
    my_image(GREEN_CHANNEL)[2][2] = 6;

    typedef ImageRGB<uint8> InputType;
    typedef RegionContour<Coord2D<int64> > RegionType;
    typedef Partition<RegionType> partition_type;
    partition_type my_part(my_im_part);

    merge_regions(25, 10, 30, my_part);

    const ChannelHistogram<InputType>& desc = calc_descriptor(new ChannelHistogram<InputType>(0,255,256), my_image, my_part[25]);

    Histogram<InputType,uint64,math::statistics::SingleChannelType>::ContainerBase histo_ok(256);

    histo_ok     = 0;
    histo_ok [1] = 4;
    histo_ok[25] = 1;
    BOOST_CHECK(desc.at(RED_CHANNEL) == histo_ok);

    histo_ok      = 0;
    histo_ok  [2] = 4;
    histo_ok[100] = 1;
    BOOST_CHECK(desc[BLUE_CHANNEL] == histo_ok);

    histo_ok    = 0;
    histo_ok[3] = 5;
    BOOST_CHECK(desc[GREEN_CHANNEL] == histo_ok);


    const ChannelHistogram<InputType>& desc2 = calc_descriptor(new ChannelHistogram<InputType>(0,255,256), my_image, my_part[10]);

    histo_ok    = 0;
    histo_ok[1] = 4;
    BOOST_CHECK(desc2[RED_CHANNEL] == histo_ok);

    histo_ok    = 0;
    histo_ok[2] = 4;
    BOOST_CHECK(desc2[BLUE_CHANNEL] == histo_ok);

    histo_ok    = 0;
    histo_ok[3] = 3;
    histo_ok[6] = 1;
    BOOST_CHECK(desc2[GREEN_CHANNEL] == histo_ok);


    // Test the recursive computation without the use of calc_descriptor
    ChannelHistogram<InputType> histo3(0,255,256);
    histo3.recursive_calculate(my_part[10].coll_vd(), my_part[25].coll_vd(), &(my_part[30].coll_vd()));

    histo_ok     = 0;
    histo_ok[1]  = 8;
    histo_ok[25] = 1;
    BOOST_CHECK(histo3.at(RED_CHANNEL) == histo_ok);

    histo_ok = 0;
    histo_ok[2] = 8;
    histo_ok[100] = 1;
    BOOST_CHECK(histo3.at(BLUE_CHANNEL) == histo_ok);

    histo_ok = 0;
    histo_ok[3] = 8;
    histo_ok[6] = 1;
    BOOST_CHECK(histo3.at(GREEN_CHANNEL) == histo_ok);



    // Test the recursive computation with the use of calc_descriptor
    const ChannelHistogram<InputType>& histo4 = calc_descriptor(new ChannelHistogram<InputType>(0,255,256), my_image, my_part[30]);

    histo_ok = 0;
    histo_ok[1] = 8;
    histo_ok[25] = 1;
    BOOST_CHECK(histo4.at(RED_CHANNEL) == histo_ok);

    histo_ok = 0;
    histo_ok[2] = 8;
    histo_ok[100] = 1;
    BOOST_CHECK(histo4.at(BLUE_CHANNEL) == histo_ok);

    histo_ok = 0;
    histo_ok[3] = 8;
    histo_ok[6] = 1;
    BOOST_CHECK(histo4.at(GREEN_CHANNEL) == histo_ok);
}


BOOST_AUTO_TEST_CASE( ChannelHistogram_test_no_computed)
{
    ImagePartition<> my_im_part(3,3);
    my_im_part[0][0] = 25;  my_im_part[1][0] = 10;  my_im_part[2][0] = 25;
    my_im_part[0][1] = 25;  my_im_part[1][1] = 10;  my_im_part[2][1] = 25;
    my_im_part[0][2] = 25;  my_im_part[1][2] = 10;  my_im_part[2][2] = 10;

    ImageRGB<uint8> my_image(3,3);
    my_image(RED_CHANNEL) = 1;
    my_image(BLUE_CHANNEL) = 2;
    my_image(GREEN_CHANNEL) = 3;
    my_image(RED_CHANNEL)[0][0] = 25;
    my_image(BLUE_CHANNEL)[0][1] = 100;
    my_image(GREEN_CHANNEL)[2][2] = 6;

    typedef ImageRGB<uint8> InputType;
    typedef RegionContour<Coord2D<int64> > RegionType;
    typedef Partition<RegionType> partition_type;
    partition_type my_part(my_im_part);

    merge_regions(25, 10, 30, my_part);

    Histogram<InputType,uint64,math::statistics::SingleChannelType>::ContainerBase histo_ok(256);

    // Test the recursive computation with the use of calc_descriptor
    const ChannelHistogram<InputType>& histo4 = calc_descriptor(new ChannelHistogram<InputType>(0,255,256), my_image, my_part[30]);

    histo_ok = 0;
    histo_ok[1] = 8;
    histo_ok[25] = 1;
    BOOST_CHECK(histo4.at(RED_CHANNEL) == histo_ok);

    histo_ok = 0;
    histo_ok[2] = 8;
    histo_ok[100] = 1;
    BOOST_CHECK(histo4.at(BLUE_CHANNEL) == histo_ok);

    histo_ok = 0;
    histo_ok[3] = 8;
    histo_ok[6] = 1;
    BOOST_CHECK(histo4.at(GREEN_CHANNEL) == histo_ok);

    const ChannelHistogram<InputType>& histo = calc_descriptor(new ChannelHistogram<InputType>(0,255,256), my_image, my_part[25]);

    histo_ok = 0;
    histo_ok[1]  = 4;
    histo_ok[25] = 1;
    BOOST_CHECK(histo.at(RED_CHANNEL) == histo_ok);

    histo_ok = 0;
    histo_ok[2] = 4;
    histo_ok[100] = 1;
    BOOST_CHECK(histo.at(BLUE_CHANNEL) == histo_ok);

    histo_ok = 0;
    histo_ok[3] = 5;
    BOOST_CHECK(histo.at(GREEN_CHANNEL) == histo_ok);


    const ChannelHistogram<InputType>& histo2 = calc_descriptor(new ChannelHistogram<InputType>(0,255,256), my_image, my_part[10]);

    histo_ok = 0;
    histo_ok[1] = 4;
    BOOST_CHECK(histo2.at(RED_CHANNEL) == histo_ok);

    histo_ok = 0;
    histo_ok[2] = 4;
    BOOST_CHECK(histo2.at(BLUE_CHANNEL) == histo_ok);

    histo_ok = 0;
    histo_ok[3] = 3;
    histo_ok[6] = 1;
    BOOST_CHECK(histo2.at(GREEN_CHANNEL) == histo_ok);
}



// Test reading image from disk
BOOST_AUTO_TEST_CASE( test_histogram_read_imagegray_multiarray )
{
    // Reading input image:
    std::string infile  = std::string(TEST_DATA_PATH_R) + "/writeimage_gray_uint8.jpg";

    io::ReadImage readImage(infile);

    ImageGray<uint8> image_gray;
    readImage >> image_gray;

    uint64 num_bins = 10;

    Histogram< ImageGray<uint8> >    hg ( 0, 255, num_bins );
    Histogram< MultiArray<uint8,2> > hma( 0, 255, num_bins );

    hg .calculate( image_gray.colors_begin(), image_gray.colors_end() );
    hma.calculate( image_gray(0) );

    BOOST_CHECK( hg == hma );
    BOOST_CHECK( hg.num_points() == ( image_gray.size_x() * image_gray.size_y() ) );
    BOOST_CHECK( hg.num_bins()[0] == num_bins );
    
    BOOST_CHECK(hg[0] == 47585); // values obtanied in matlab:
    BOOST_CHECK(hg[1] == 40722); //
    BOOST_CHECK(hg[2] == 41069); // >> im = imread('writeimage_gray_uint8.jpg');
    BOOST_CHECK(hg[3] == 42970); // >> g  = im(:,:,1);
    BOOST_CHECK(hg[4] == 37774); // >> hist(double( g(:) ),10)
    BOOST_CHECK(hg[5] == 29185); //
    BOOST_CHECK(hg[6] == 37040);
    BOOST_CHECK(hg[7] == 35624);
    BOOST_CHECK(hg[8] == 40498);
    BOOST_CHECK(hg[9] == 89901);
    
    // test copy constructor
    Histogram< ImageGray<uint8> > hg_c(hg);

    BOOST_CHECK( hg_c.num_points() == ( image_gray.size_x() * image_gray.size_y() ) );
    BOOST_CHECK( hg_c.num_bins()[0] == num_bins );
    BOOST_CHECK( hg_c[0] == 47585 ); // values obtanied in matlab:
    BOOST_CHECK( hg_c[1] == 40722 ); //
    BOOST_CHECK( hg_c[2] == 41069 ); // >> im = imread('writeimage_gray_uint8.jpg');
    BOOST_CHECK( hg_c[3] == 42970 ); // >> g  = im(:,:,1);
    BOOST_CHECK( hg_c[4] == 37774 ); // >> hist(double( g(:) ),10)
    BOOST_CHECK( hg_c[5] == 29185 ); //
    BOOST_CHECK( hg_c[6] == 37040 );
    BOOST_CHECK( hg_c[7] == 35624 );
    BOOST_CHECK( hg_c[8] == 40498 );
    BOOST_CHECK( hg_c[9] == 89901 );

    // test copy operator
    Histogram< ImageGray<uint8> > hg_o;
    hg_o = hg;

    BOOST_CHECK( hg_o.num_points() == ( image_gray.size_x() * image_gray.size_y() ) );
    BOOST_CHECK( hg_o.num_bins()[0] == num_bins );
    
    BOOST_CHECK( hg_o[0] == 47585 ); // values obtanied in matlab:
    BOOST_CHECK( hg_o[1] == 40722 ); //
    BOOST_CHECK( hg_o[2] == 41069 ); // >> im = imread('writeimage_gray_uint8.jpg');
    BOOST_CHECK( hg_o[3] == 42970 ); // >> g  = im(:,:,1);
    BOOST_CHECK( hg_o[4] == 37774 ); // >> hist(double( g(:) ),10)
    BOOST_CHECK( hg_o[5] == 29185 ); //
    BOOST_CHECK( hg_o[6] == 37040 );
    BOOST_CHECK( hg_o[7] == 35624 );
    BOOST_CHECK( hg_o[8] == 40498 );
    BOOST_CHECK( hg_o[9] == 89901 );

    BOOST_CHECK(hg == hg_c);
    BOOST_CHECK(hg == hg_o);
    BOOST_CHECK(hg_c == hg_o);
}


// Simple constructor with ImaVol
BOOST_AUTO_TEST_CASE_TEMPLATE( test_histogram_new_ImaVol_1_ma, T, HistogramTypes )
{
    ImaVol< T,1,2 > image(4,4);

    // Initialize images to fixed value
    for( uint64 i = 0; i < image.size_x(); i++ )
        for( uint64 j = 0; j < image.size_y(); j++ )
            for( uint64 k = 0; k < image.num_channels(); k++ )
                image( k )[ i ][ j ] = 128;

    uint64 num_bins = 256;
    uint64 min_value = 0, max_value = 255;
    if ( typeid(T) == typeid(int8) )
    {
        min_value = -128;
        max_value = 127;
    }
    boost::array< T, 1 > color;
    color[0] = 128;

    Histogram< ImaVol< T,1,2 > >  h  ( min_value, max_value, num_bins );
    Histogram< MultiArray<T,2> >  hma( min_value, max_value, num_bins );

    h.calculate( image.colors_begin(), image.colors_end() );
    hma.calculate(image(0));

    BOOST_CHECK( h == hma );
    BOOST_CHECK( maxval( h ) == 16 );
    BOOST_CHECK( minval( h ) == 0 );
    BOOST_CHECK( h.num_points() == ( image.size_x() * image.size_y() ) );
    BOOST_CHECK( h.num_bins()[0] == num_bins );
}

// Constructor with Quantizer and ImaVol
BOOST_AUTO_TEST_CASE_TEMPLATE( test_histogram_new_ImaVol_with_quantizer, T, HistogramTypes )
{
    ImaVol< T,1,2 > image(4,4);

    // Initialize images to fixed value
    for( uint64 i = 0; i < image.size_x(); i++ )
        for( uint64 j = 0; j < image.size_y(); j++ )
            for( uint64 k = 0; k < image.num_channels(); k++ )
                image( k )[ i ][ j ] = 128;

    uint64 num_bins = 256;
    uint64 min_value = 0, max_value = 255;
    if ( typeid(T) == typeid(int8) )
    {
        min_value = -128;
        max_value = 127;
    }
    boost::array< T, 1 > color;
    color[0] = 128;
    Quantizer<T> q( min_value, max_value, num_bins );

    Histogram< ImaVol< T,1,2 > >   h( q );
    Histogram< MultiArray<T,2 > >  hma( q );

    h.calculate( image.colors_begin(), image.colors_end() );
    hma.calculate( image(0) );

    BOOST_CHECK( h == hma );
    BOOST_CHECK( maxval( h ) == 16 );
    BOOST_CHECK( minval( h ) == 0 );
//    BOOST_CHECK( h.color( color ) == 16);
    BOOST_CHECK( h.num_points() == ( image.size_x() * image.size_y() ) );
    BOOST_CHECK( h.num_bins()[0] == num_bins );
    BOOST_CHECK( h.num_channels() == image.num_channels() );
}


// Constructor with boost::array of Quantizers and ImaVol
BOOST_AUTO_TEST_CASE_TEMPLATE( test_histogram_new_ImaVol_with_quantizer_array, T, HistogramTypes )
{
    ImaVol< T,1,2 > image(4,4);

    // Initialize images to fixed value
    for( uint64 i = 0; i < image.size_x(); i++ )
        for( uint64 j = 0; j < image.size_y(); j++ )
            for( uint64 k = 0; k < image.num_channels(); k++ )
                image( k )[ i ][ j ] = 128;

    uint64 num_bins = 256;
    uint64 min_value = 0, max_value = 255;
    if ( typeid(T) == typeid(int8) )
    {
        min_value = -128;
        max_value = 127;
    }
    boost::array< T, 1 > color;
    color[0] = 128;
    Quantizer<T> q( min_value, max_value, num_bins );
    boost::array< class Quantizer<T>, 1 > array_q;
    array_q[0] = q;

    Histogram< ImaVol< T,1,2 > >    h( array_q );
    Histogram< MultiArray< T,2 > >  hma( array_q );

    h.calculate( image.colors_begin(), image.colors_end() );
    hma.calculate( image(0) );

    BOOST_CHECK( maxval( h ) == 16 );
    BOOST_CHECK( minval( h ) == 0 );
//    BOOST_CHECK( h.color( color ) == 16 );
    BOOST_CHECK( h.num_points() == ( image.size_x() * image.size_y() ) );
    BOOST_CHECK( h.num_bins()[0] == num_bins );
    BOOST_CHECK( h.num_channels() == image.num_channels() );
}


// Test for floats with ImaVol
BOOST_AUTO_TEST_CASE_TEMPLATE( test_histogram_new_ImaVol_float, T, HistogramFloatTypes )
{
    ImaVol< T,1,2 > image(4,4);

    // Initialize images to fixed value
    for( uint64 i = 0; i < image.size_x(); i++ )
        for( uint64 j = 0; j < image.size_y(); j++ )
            for( uint64 k = 0; k < image.num_channels(); k++ )
                image( k )[ i ][ j ] = 128;

    // Tests with floats
    float64 min_value_float = -10.5, max_value_float = 200.5;
    uint64 num_bins_float = 500;
    boost::array< T, 1 > color;
    color[0] = 128;

    Histogram< ImaVol< T,1,2 > >    h_float   ( min_value_float, max_value_float, num_bins_float );
    Histogram< MultiArray< T,2 > >  h_float_ma( min_value_float, max_value_float, num_bins_float );

    h_float.calculate( image.colors_begin(), image.colors_end() );
    h_float_ma.calculate( image(0) );

    BOOST_CHECK( h_float == h_float_ma );
    BOOST_CHECK( maxval( h_float ) == 16 );
    BOOST_CHECK( minval( h_float ) == 0 );
//    BOOST_CHECK( h_float.color( color ) == 16 );
    BOOST_CHECK( h_float.num_bins()[0] == num_bins_float );
}


// Constructor with non_uniform array_q and ImaVol
BOOST_AUTO_TEST_CASE ( test_histogram_new_ImaVol_with_non_uniform_quantizer_array )
{
    ImaVol< int16,1,2 > image(4,4);

    // Initialize images to fixed value
    for( uint64 i = 0; i < image.size_x(); i++ )
        for( uint64 j = 0; j < image.size_y(); j++ )
            for( uint64 k = 0; k < image.num_channels(); k++ )
                image( k )[ i ][ j ] = 246;

    // Test more complicated image (floats)
    image( 0 )[ 2 ][ 2 ] = 2; // To validate working floats

    uint64 num_bins = 25;
    uint16 min_value = -255, max_value = 255;
    boost::array< int16, 1 > color;
    color[0] = 246;

    Histogram< ImaVol< int16,1,2 > >    hh( min_value, max_value, num_bins );
    Histogram< MultiArray< int16,2 > >  hhma( min_value, max_value, num_bins );

    hh.calculate( image.colors_begin(), image.colors_end() );
    hhma.calculate( image(0) );

    BOOST_CHECK( hh == hhma );
    BOOST_CHECK( maxval( hh ) == 15 );
    BOOST_CHECK( minval( hh ) == 0 );
//    BOOST_CHECK( hh.color( color ) == 15 );
    BOOST_CHECK( hh.num_points() == 16 );
    BOOST_CHECK( hh.num_bins()[0] == num_bins );
    BOOST_CHECK( hh.num_channels() == image.num_channels() );

    // Test with array of Quantizers
    MultiArray< int16, 1 > ma(11);
    ma[0] =   0; ma[1] =  25; ma[2] =  51; ma[3] =  76; ma[ 4] = 102; ma[5] = 128; 
    ma[6] = 153; ma[7] = 179; ma[8] = 204; ma[9] = 230; ma[10] = 255;

    boost::array< class Quantizer<int16>, 1 > array_q;

    Quantizer<int16> q(ma);
    array_q[0] = q;
//  array_q[0] = [ 25 51 76 102 128 153 179 204 230 255 ]; // num_bins=10

    Histogram< ImaVol< int16,1,2 > >    h_q( array_q );
    Histogram< MultiArray< int16,2 > >  h_qma( array_q );

    h_q.calculate( image.colors_begin(), image.colors_end() );
    h_qma.calculate( image(0) );

    BOOST_CHECK( h_q == h_qma );
    BOOST_CHECK( maxval( h_q ) == 15 );
    BOOST_CHECK( minval( h_q ) == 0 );
    BOOST_CHECK( h_q.num_points() == 16 );
    BOOST_CHECK( h_q.num_bins()[0] == 10 );
    BOOST_CHECK( h_q.num_channels() == image.num_channels() );
}


// Simple constructor with ImageRGB
BOOST_AUTO_TEST_CASE_TEMPLATE( test_histogram_new_ImageRGB, T, HistogramImageTypes )
{
    // Different types of images
    ImageRGB< T > image(4,4);

    // Initialize images to fixed value
    for( uint64 i = 0; i < image.size_x(); i++ )
        for( uint64 j = 0; j < image.size_y(); j++ )
            for( uint64 k = 0; k < image.num_channels(); k++ )
                image( k )[ i ][ j ] = j+100;

    uint64 num_bins = 256;
    T min_value = 0, max_value = 255;
    if ( typeid(T) == typeid(int8) )
    {
        min_value = -128;
        max_value = 127;
    }
    boost::array< T, 3 > color;
    color[0] = 100; color[1] = 100; color[2] = 100;

    Histogram< ImageRGB< T > >  h( min_value, max_value, num_bins );

    h.calculate( image.colors_begin(), image.colors_end() );

    BOOST_CHECK( maxval(h) == 4 );
    BOOST_CHECK( minval(h) == 0 );
//    BOOST_CHECK( h.color( color ) == 4 );
    BOOST_CHECK( h.num_points() == ( image.size_x() * image.size_y() ) );
    BOOST_CHECK( h.num_bins()[0] == num_bins );
    BOOST_CHECK( h.num_bins()[1] == num_bins );
    BOOST_CHECK( h.num_bins()[2] == num_bins );
    BOOST_CHECK( h.num_channels() == image.num_channels() );

    /*
     * AGIL: The following test do not work for int8, since values used
     */
    if(typeid(T) == typeid(int8))
    {
        BOOST_WARN_MESSAGE(false, "Test disabled for int8 because values used are out of range");
    }
    else
    {
        // With non_uniform quantizer
        MultiArray< T, 1 > ma(11);
        ma[0] =   0; ma[1] =  25; ma[2] =  51; ma[3] =  76; ma[ 4] = 102; ma[5] = 128; 
        ma[6] = 153; ma[7] = 179; ma[8] = 204; ma[9] = 230; ma[10] = 255;
    
        MultiArray< T, 1 > ma2(5);
        ma2[0] = 0; ma2[1] = 101;  ma2[2] = 128;  ma2[3] = 250; ma2[4] = 255;
    
        boost::array< class Quantizer<T>, 3 > array_q;
    
        Quantizer<T> q( min_value, max_value, num_bins );
        Quantizer<T> q1( ma );
        Quantizer<T> q3( ma2 );
        array_q[0] = q; array_q[1] = q1; array_q[2] = q3;
        Histogram< ImageRGB< T > >  h_q_rare( array_q );
    
        h_q_rare.calculate( image.colors_begin(), image.colors_end() );
    
        BOOST_CHECK( maxval(h_q_rare) == 4 ); // (15/16)
        BOOST_CHECK( minval(h_q_rare) == 0 );
//      BOOST_CHECK( h_q_rare.color( color ) == 4 );
        if ( typeid(T) != typeid(int8) ) BOOST_CHECK( h_q_rare[ 100 ][ 3 ][ 0 ] == 4 );
        BOOST_CHECK( h_q_rare.num_points() == ( image.size_x() * image.size_y() ) );
        BOOST_CHECK( h_q_rare.num_bins()[0] == num_bins );
        BOOST_CHECK( h_q_rare.num_bins()[1] == 10 );
        BOOST_CHECK( h_q_rare.num_bins()[2] == 4 );
        BOOST_CHECK( h_q_rare.num_channels() == image.num_channels() );
    }
}


// Simple constructor with ImageGray
BOOST_AUTO_TEST_CASE_TEMPLATE( test_histogram_new_ImageGray, T, HistogramImageTypes )
{
    // Different types of images
    ImageGray< T > image(4,4);

    // Initialize images to fixed value
    for( uint64 i = 0; i < image.size_x(); i++ )
        for( uint64 j = 0; j < image.size_y(); j++ )
            for( uint64 k = 0; k < image.num_channels(); k++ )
                image( k )[ i ][ j ] = 128;

    uint64 num_bins = 256;
    uint64 min_value = 0, max_value = 255;
    if ( typeid(T) == typeid(int8) )
    {
        min_value = -128;
        max_value = 127;
    }
    boost::array< T, 1 > color;
    color[0] = 128;

    Histogram< ImageGray< T > >  h( min_value, max_value, num_bins ); // 1 Channel

    h.calculate( image.colors_begin(), image.colors_end() );

    BOOST_CHECK( maxval(h) == 16 );
    BOOST_CHECK( minval(h) == 0 );
//    BOOST_CHECK( h.color( color ) == 16 );
    BOOST_CHECK( h.num_points() == ( image.size_x() * image.size_y() ) );
    BOOST_CHECK( h.num_bins()[0] == num_bins );
    BOOST_CHECK( h.num_channels() == image.num_channels() );
}


// Simple constructor with ImageYUV
BOOST_AUTO_TEST_CASE_TEMPLATE( test_histogram_new_ImageYUV, T, HistogramImageYUVTypes )
{
    // Different types of images
    ImageYUV< T > image(4,4);

    // Initialize images to fixed value
    for( uint64 i = 0; i < image.size_x(); i++ )
        for( uint64 j = 0; j < image.size_y(); j++ )
            for( uint64 k = 0; k < image.num_channels(); k++ )
                image( k )[ i ][ j ] = 12;

    uint64 num_bins = 256;
    uint64 min_value = 0, max_value = 255;
    boost::array< T, 3 > colorYUV;
    colorYUV[0] = 12; colorYUV[1] = 12; colorYUV[2] = 12;


    // Constructor with mode U,V
    boost::array< T, 2 > colorUV;
    colorUV[0] = 12; colorUV[1] = 12;
    // Histogram should have 2 channels
    Histogram< ImageYUV<T>, uint64,  math::statistics::HistogramYUV_UV_Type >  h_0( min_value, max_value, num_bins );

    h_0.calculate( image.colors_begin(), image.colors_end() );

    BOOST_CHECK( maxval(h_0) == 16 );
    BOOST_CHECK( minval(h_0) == 0 );
//    BOOST_CHECK( h_0.color( colorUV ) == 16 );
    BOOST_CHECK( h_0.num_points() == ( image.size_x() * image.size_y() ) );
    BOOST_CHECK( h_0.num_bins()[0] == num_bins );
    BOOST_CHECK( h_0.num_bins()[1] == num_bins );
    BOOST_CHECK( h_0.num_channels() == 2 );

    Histogram< ImageYUV< T > >  h( min_value, max_value, num_bins ); // 3 Channel

    h.calculate( image.colors_begin(), image.colors_end() );

    BOOST_CHECK( maxval(h) == 16 );
    BOOST_CHECK( minval(h) == 0 );
//    BOOST_CHECK( h.color( colorYUV ) == 16 );
    BOOST_CHECK( h.num_points() == ( image.size_x() * image.size_y() ) );
    BOOST_CHECK( h.num_bins()[0] == num_bins );
    BOOST_CHECK( h.num_bins()[1] == num_bins );
    BOOST_CHECK( h.num_bins()[2] == num_bins );
    BOOST_CHECK( h.num_channels() == image.num_channels() );

    // Constructor with mode YUYV
    boost::array< T, 2 > colorYUYV;
    colorYUYV[0] = 12*12; colorYUYV[1] = 12*12;
    // Histogram should have 2 channels
    Histogram< ImageYUV< T >, uint64, math::statistics::HistogramYUV_YUYV_Type >  h_1( min_value, max_value, num_bins );

    h_1.calculate( image.colors_begin(), image.colors_end() );

    BOOST_CHECK( maxval(h_1) == 16 );
    BOOST_CHECK( minval(h_1) == 0 );
//    BOOST_CHECK( h_1.color( colorYUYV ) == 16 );
    BOOST_CHECK( h_1.num_points() == ( image.size_x() * image.size_y() ) );
    BOOST_CHECK( h_1.num_bins()[0] == num_bins );
    BOOST_CHECK( h_1.num_bins()[1] == num_bins );
    BOOST_CHECK( h_1.num_channels() == 2 );


    // Constructor with mode Y
    boost::array< T, 1 > colorY;
    colorY[0] = 12;
    // Histogram should have 2 channels
    Histogram< ImageYUV< T >, uint64, math::statistics::HistogramYUV_Y_Type >  h_y( min_value, max_value, num_bins );

    h_y.calculate( image.colors_begin(), image.colors_end() );

    BOOST_CHECK( maxval(h_y) == 16 );
    BOOST_CHECK( minval(h_y) == 0 );
//    BOOST_CHECK( h_y.color( colorY ) == 16 );
    BOOST_CHECK( h_y.num_points() == ( image.size_x() * image.size_y() ) );
    BOOST_CHECK( h_y.num_bins()[0] == num_bins );
    BOOST_CHECK( h_y.num_channels() == 1 );
}

// Simple constructor with VolumeRGB
BOOST_AUTO_TEST_CASE_TEMPLATE( test_histogram_new_VolumeRGB, T, HistogramVolumeTypes )
{
    // Different types of images
    VolumeRGB< T > volume(4,4,4);

    // Initialize images to fixed value
    for( uint64 i = 0; i < volume.size_x(); i++ )
        for( uint64 j = 0; j < volume.size_y(); j++ )
            for( uint64 k = 0; k < volume.size_z(); k++ )
                for( uint64 l = 0; l < volume.num_channels(); l++ )
                    volume( l )[ i ][ j ][ k ] = 128;

    uint64 num_bins = 256;
    uint64 min_value = 0, max_value = 255;
    boost::array< T, 3 > color;
    color[0] = 128; color[1] = 128; color[2] = 128;
    if ( typeid(T) == typeid(int8) )
    {
        min_value = -128;
        max_value = 127;
    }

    Histogram< VolumeRGB< T > >  h( min_value, max_value, num_bins );

    h.calculate( volume.colors_begin(), volume.colors_end() );

    BOOST_CHECK( maxval(h) == 64 );
    BOOST_CHECK( minval(h) == 0 );
//    BOOST_CHECK( h.color( color ) == 64 );
    BOOST_CHECK( h.num_points() == ( volume.size_x() * volume.size_y() * volume.size_z() ) );
    BOOST_CHECK( h.num_bins()[0] == num_bins );
    BOOST_CHECK( h.num_bins()[1] == num_bins );
    BOOST_CHECK( h.num_bins()[2] == num_bins );
    BOOST_CHECK( h.num_channels() == volume.num_channels() );
}

// Simple constructor with VolumeYUV
BOOST_AUTO_TEST_CASE_TEMPLATE( test_histogram_new_VolumeYUV, T, HistogramVolumeTypes )
{
    // Different types of images
    VolumeYUV< T > volume(4,4,4);

    // Initialize images to fixed value
    for( uint64 i = 0; i < volume.size_x(); i++ )
        for( uint64 j = 0; j < volume.size_y(); j++ )
            for( uint64 k = 0; k < volume.size_z(); k++ )
                for( uint64 l = 0; l < volume.num_channels(); l++ )
                    volume( l )[ i ][ j ][ k ] = 128;

    uint64 num_bins = 256;
    uint64 min_value = 0, max_value = 255;
    boost::array< T, 3 > color;
    color[0] = 128; color[1] = 128; color[2] = 128;
    if ( typeid(T) == typeid(int8) )
    {
        min_value = -128;
        max_value = 127;
    }

    Histogram< VolumeYUV< T > >  h( min_value, max_value, num_bins );

    h.calculate( volume.colors_begin(), volume.colors_end() );

    BOOST_CHECK( maxval(h) == 64 );
    BOOST_CHECK( minval(h) == 0 );
//    BOOST_CHECK( h.color( color ) == 64 );
    BOOST_CHECK( h.num_points() == ( volume.size_x() * volume.size_y() * volume.size_z() ) );
    BOOST_CHECK( h.num_bins()[0] == num_bins );
    BOOST_CHECK( h.num_bins()[1] == num_bins );
    BOOST_CHECK( h.num_bins()[2] == num_bins );
    BOOST_CHECK( h.num_channels() == volume.num_channels() );
}

// Simple constructor with VolumeGray
BOOST_AUTO_TEST_CASE_TEMPLATE( test_histogram_new_VolumeGray, T, HistogramVolumeTypes )
{
    // Different types of images
    VolumeGray< T > volume(4,4,4);

    // Initialize images to fixed value
    for( uint64 i = 0; i < volume.size_x(); i++ )
        for( uint64 j = 0; j < volume.size_y(); j++ )
            for( uint64 k = 0; k < volume.size_z(); k++ )
                for( uint64 l = 0; l < volume.num_channels(); l++ )
                    volume( l )[ i ][ j ][ k ] = k + 128;

    uint64 num_bins = 256;
    uint64 min_value = 0, max_value = 255;
    boost::array< T, 1 > color;
    color[0] = 128;
    if ( typeid(T) == typeid(int8) )
    {
        min_value = -128;
        max_value = 127;
    }

    Histogram< VolumeGray< T > >  h( min_value, max_value, num_bins );

    h.calculate( volume.colors_begin(), volume.colors_end() );

    BOOST_CHECK( maxval(h) == 16 );
    BOOST_CHECK( minval(h) == 0 );
//    BOOST_CHECK( h.color( color ) == 16 );
    BOOST_CHECK( h.num_points() == ( volume.size_x() * volume.size_y() * volume.size_z() ) );
    BOOST_CHECK( h.num_bins()[0] == num_bins );
    BOOST_CHECK( h.num_channels() == volume.num_channels() );
}

BOOST_AUTO_TEST_SUITE_END ();
