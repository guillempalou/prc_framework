/*
 * resolve_depth_conflicts.hpp
 *
 *  Created on: Dec 21, 2012
 *      Author: gpalou
 */

#ifndef RESOLVE_DEPTH_CONFLICTS_HPP_
#define RESOLVE_DEPTH_CONFLICTS_HPP_

#include <imageplus/core/multiarray.hpp>
#include <imageplus/math/graphs/algorithms/network_reliability.hpp>
#include <imageplus/math/graphs/algorithms/max_flow_min_cut.hpp>
#include <imageplus/math/graphs/algorithms/minimum_spanning_tree.hpp>
#include <imageplus/math/graphs/algorithms/ordering.hpp>

namespace imageplus {
	namespace monocular_depth {

	template<class DOG>
	void resolve_depth_conflicts(DOG& dog) {

		typedef typename DOG::Node	Node;
		typedef typename DOG::Edge	Edge;

		uint32 N = dog.num_nodes();

		// create adjacency matrix
		MultiArray<float64,2> t(N,N);

		// eliminate self connected cycles
		for (uint64 j = 0; j < N; j++) { t[j][j] = 0; }

		bool conflicts = false;
		do {
			conflicts = false;

			/*Construct an auxiliary Graph without parallel edges*/
			DOG d(dog.num_nodes());

			for (typename DOG::edge_iterator e = dog.edges_begin(); e != dog.edges_end(); ++e) {
				Node a = dog.source(*e);
				Node b = dog.target(*e);

				typename DOG::EdgePropertiesType p = dog.edge_properties(*e);
				Edge e2;

				//std::cout << "edge from " << dog.node_properties(a).id << " to " << dog.node_properties(b).id << " with " << p.capacity << std::endl;

				if (!d.edge_exists(a,b)) {
					e2 = d.add_edge(a,b);
					d.edge_properties(e2) = p;

				} else {
					e2 = d.edge(a,b);
					float64 w = p.weight;
					float64 new_p = 1 - (1-d.edge_properties(e2).weight)*(1-w);
					d.edge_properties(e2).weight   = new_p;
					d.edge_properties(e2).capacity = new_p;
				}
			}

			// Calculate the PoP or, equivalently, the Network Reliability
			MultiArray<float64,2> p;

			//if (N >= 10) {
			math::graphs::ReliabilityAllPairsUpperBound<DOG> PoP;
			PoP.calculate(d);
			p = PoP.reliability();

			float64 min_pop = 1e10;
			//float64 eps = 1e-6;
			std::pair<uint64,uint64> node_pair;

			for (uint32 i = 0; i < N; i++) {
				for (uint32 k = i+1; k < N; k++) {

					if (p[k][i] > 0 && p[i][k] > 0) {
						if (p[k][i] <= p[i][k] && min_pop > p[k][i]) {conflicts = true; min_pop = p[k][i]; node_pair = std::pair<uint64,uint64>(k,i);}
						if (p[i][k] < p[k][i] && min_pop > p[i][k]) {conflicts = true; min_pop = p[i][k]; node_pair = std::pair<uint64,uint64>(i,k);}
					}
				}
			}

			if (conflicts) {
				uint32 id1 = node_pair.first;
				uint32 id2 = node_pair.second;
				//Find min-cut from id1-id2 and eliminate all the edges forming it

				math::graphs::MaxFlowMinCut<DOG> max_flow;
				max_flow.calculate(d, id1, id2, false); // Cut the graph!!

				typedef typename math::graphs::MaxFlowMinCut<DOG>::EdgeMap EdgeMap;
				EdgeMap mincut = max_flow.min_cut();

				//std::cout << "Eliminating " << id1 << " " << id2 << " " << mincut.size() << std::endl;
				for (typename EdgeMap::iterator i = mincut.begin(); i != mincut.end(); i++) {


					Node a = i->first.first;
					Node b = i->first.second;

					typename DOG::out_edge_iterator next = dog.out_edges_begin(a);
					for (typename DOG::out_edge_iterator e = dog.out_edges_begin(a); e != dog.out_edges_end(a); e = next) {
						++next;
						Node target = dog.target(*e);
						if (target != b) continue;

						dog.remove_edge(*e);
					}
				}
			}

		} while (conflicts != false);

	}

	}
}

#endif /* RESOLVE_DEPTH_CONFLICTS_HPP_ */
