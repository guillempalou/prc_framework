// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------

//!
//!  \file ublas_adaptors.hpp
//!
//!  Interface for adaptor class to switch between MultiArray and ublas matrices and vectors
//!

#ifndef IMAGEPLUS_NUMERIC_UBLAS_ADAPTORS_HPP
#define IMAGEPLUS_NUMERIC_UBLAS_ADAPTORS_HPP

#include <imageplus/core.hpp>
#include <numeric/ublas_adaptors_storage.hpp>


namespace imageplus
{
    namespace math
    {
        namespace numeric
        {
    
            //!
            //! \brief class to adapt multiarrays and ublas matrices
            //!
            //! \author Javier Ruiz Hidalgo <j.ruiz@upc.edu>
            //! \author Ramon Morros <morros@gps.tsc.upc.edu>
            //!
            //! \date 22-01-2008
            //!
            //! This class adapts a multiarray with 2 dimensions to a ublas::matrix. No data copy
            //! is performed so the adaptation is very fast. Usage
            //!
            //! \code
            //!   MultiArray<float64,2> m(10,10);
            //!   m = 10;
            //!   UblasAdaptationMatrix u(m.data(),m.dims(0),m.dims(1));
            //!   u(5,5) = 0;
            //!   cout << m[5][5] << endl; // this outputs 0 not 10!
            //! \endcode
            //!
            //! Use this class to create wrappers for needed ublas functions in the numeric module. As an example
            //! check the file multiarray_operations.cpp
            //!
            template <class float_T>
            struct UblasAdaptionMatrix : boost::numeric::ublas::matrix<float_T, boost::numeric::ublas::row_major, array_handle<float_T> >
            {
    
                    //!
                    //! \brief pointer to data in the array
                    //!
                    typedef float_T*                chunk_type;
    
                    //!
                    //! \brief handle array class with specific type
                    //!
                    typedef array_handle<float_T>   array_type;
                    
                    //!
                    //! \brief base class for UblasAdaptationMatrix
                    //!
                    typedef boost::numeric::ublas::matrix<float_T, boost::numeric::ublas::row_major, array_type >  base_type;
                    
                    //!
                    //! \brief Constructor for ublas adaptation
                    //!
                    //! \param[in,out] chunk : pointer to multiarray data, note that data itself is not copied so
                    //!                        be extra carefull as ublas functions might change the values
                    //! \param[in]     size1 : X dimension of the matrix
                    //! \param[in]     size2 : Y dimension of the matrix
                    //!
                    UblasAdaptionMatrix(chunk_type const& chunk, std::size_t size1, std::size_t size2)
                            : base_type(size2, size1, array_type(size1*size2, chunk) )
                    {;}
                    
                    //!
                    //! \brief Assigment operator ublas adaptors
                    //!
                    //! \param[in] r : ublas matrix to copy
                    //!
                    //! As the MultiArray data is referenced this operator= only copies matrices will exactly the same dimensions
                    //! as the adapted MultiArray, otherwise a exception occurs
                    //!
                    template <class matrix_T>
                    void operator=(const boost::numeric::ublas::matrix_expression<matrix_T>& r) throw (ImagePlusError)
                    {
                        if ( (r().size1() != this->size1() ) || (r().size2() != this->size2()) )
                        {
                            throw ImagePlusError("ERROR(UblasAdaptionMatrix::operator=): Only works for equal sized matrices");
                        }
                        
                        typedef typename array_type::size_type size_type;
                        for (size_type x = 0; x < this->size1(); x++ )
                        {
                            for (size_type y = 0; y < this->size2(); y++ )
                            {
                                this->operator()(x,y) = r()(x,y);
                            }
                        }
                        
                    }
                    
            };
    
    
            //!
            //! \brief class to adapt multiarrays and ublas vectors
            //!
            //! \author Javier Ruiz Hidalgo <j.ruiz@upc.edu>
            //! \author Ramon Morros <morros@gps.tsc.upc.edu>
            //!
            //! \date 22-01-2008
            //!
            //! This class adapts a multiarray with 1 dimension to a ublas::vector. No data copy
            //! is performed so the adaptation is very fast. Usage:
            //!
            //! \code
            //!   MultiArray<float64,1> v(10);
            //!   v = 10;
            //!   UblasAdaptationVector u(v.data(),v.dims(0));
            //!   u(5) = 0;
            //!   cout << v[5] << endl; // this outputs 0 not 10!
            //! \endcode
            //!
            //! Use this class to create wrappers for needed ublas functions in the numeric module. As an example
            //! check the file multiarray_operations.cpp
            //!
            template <class float_T>
            struct UblasAdaptionVector : boost::numeric::ublas::vector<float_T,  array_handle<float_T> >
            {
                    //!
                    //! \brief pointer to data in the array
                    //!
                    typedef float_T*                                         chunk_type;
                    
                    //!
                    //! \brief handle array class with specific type
                    //!
                    typedef array_handle<float_T>   array_type;
                    
                    //!
                    //! \brief base class for UblasAdaptationVector
                    //!
                    typedef boost::numeric::ublas::vector<float_T, array_handle<float_T> >  base_type;
                    
                    //!
                    //! \brief Constructor for ublas adaptation
                    //!
                    //! \param[in,out] chunk : pointer to multiarray data, note that data itself is not copied
                    //!                        so be extra carefull as ublas functions might change the values
                    //! \param[in]      size : Length of the vector
                    //!
                    UblasAdaptionVector(chunk_type const& chunk, std::size_t size)
                            : base_type(size, array_type(size, chunk) )
                    {;}
                    
                    //!
                    //! \brief Assigment operator ublas adaptors
                    //!
                    //! \param[in] vec_expr : ublas vector to copy
                    //!
                    //! As the MultiArray data is referenced this operator= only copies vectors will exactly the same dimensions
                    //! as the adapted MultiArray, otherwise a exception occurs
                    //!
                    template <class vector_T>
                    void operator=(const boost::numeric::ublas::vector_expression<vector_T>& vec_expr) throw (ImagePlusError)
                    {
                        if (vec_expr().size() != this->size() )
                        {
                            throw ImagePlusError("ERROR(uBlasAdaptionVector::operator=): Only works for equal sized matrices");
                        }
                        
                        typedef typename array_type::size_type size_type;
                        for (size_type i = 0; i < this->size(); ++i )
                        {
                            this->operator()(i) = vec_expr()(i);
                        }
                    }
            };
            
        } //  namespace numeric
    } //  namespace math
} // namespace imageplus



#endif

