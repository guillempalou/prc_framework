/*
 * channel_distance.hpp
 *
 *  Created on: Feb 22, 2013
 *      Author: gpalou
 */

#ifndef CHANNEL_DISTANCE_HPP_
#define CHANNEL_DISTANCE_HPP_

#include <imageplus/descriptors/descriptor_manager.hpp>
#include <imageplus/descriptors/color/color_mean.hpp>
#include <imageplus/bpt/models/bpt_distance_model.hpp>

namespace imageplus
{
    namespace bpt
    {

        //! Class from which any model must inherit to work properly
        template<class SignalModel, class BPT, typename order_type=float64>
        class ChannelMeanDistanceModel : public BaseDistanceModel<SignalModel, BPT, order_type>
        {
        	typedef typename BPT::RegionType					RegionType;
        	typedef descriptors::ColorMean<SignalModel>			ColorMeanDescriptor;

        public:

        	struct Parameters {
        		uint64 channel;
        		float64 norm;

        		Parameters(uint64 ch, float64 n) : channel(ch), norm(n) {

        		}
        	};

        	static const Parameters default_parameters() {
        		return Parameters();
        	}


        	ChannelMeanDistanceModel(const Parameters& pars = default_parameters()) : _channel(pars.channel), _norm(pars.norm) {

        	}

            //! This function computes the order of a given link (edge of the RAG)
            //!
            //! \param reg1 : Region of one extremum of the link
            //! \param reg2 : Region of the other extremum of the link
            //! \param image : Image being processed
            //! \param bpt : Partition at the moment of the merging
            //! \return The order of the link
            order_type region_distance(RegionType& reg1, RegionType& reg2, SignalModel& image, BPT& bpt, descriptors::DescriptorManager& manager) {

            	const typename ColorMeanDescriptor::type& 				mean1 = manager.calc_descriptor<ColorMeanDescriptor>(image, reg1);
            	const typename ColorMeanDescriptor::type& 				mean2 = manager.calc_descriptor<ColorMeanDescriptor>(image, reg2);

            	//std::cout << "means " << mean1.transpose() << " -- " << mean2.transpose() << " channel " << _channel << " - " << std::fabs(mean1(_channel) - mean2(_channel)) << std::endl;

            	return (mean1(_channel) - mean2(_channel))/_norm;
            }
        private:

        	uint64 _channel;

        	float64 _norm;
        };

    }
}

#endif /* CHANNEL_DISTANCE_HPP_ */
