/*
 * occlusion_with_segmentation.cpp
 *
 *  Created on: Mar 1, 2013
 *      Author: gpalou
 */
#include <imageplus/core/image_signal.hpp>
#include <imageplus/core/video_signal.hpp>
#include <imageplus/core/colorspace_converter.hpp>

#include <imageplus/segmentation/partition/partition.hpp>
#include <imageplus/segmentation/partition/hierarchical_region_partition.hpp>
#include <imageplus/segmentation/visualization/false_color.hpp>

#include <imageplus/math/graphs/graph.hpp>

#include <imageplus/optical_flow/flow_io.hpp>
#include <imageplus/optical_flow/trajectory_tracking.hpp>
#include <imageplus/optical_flow/occlusions/boundary_owner.hpp>
#include <imageplus/optical_flow/occlusions/bijective_error.hpp>
#include <imageplus/optical_flow/occlusions/region_occlusion_error.hpp>
#include <imageplus/optical_flow/occlusions/detect_occlusion_relations.hpp>

#include <imageplus/bpt/energy_minimization/binary_pruner.hpp>
#include <imageplus/bpt/pruning/merging_sequence_pruner.hpp>
#include <imageplus/bpt/pruning/min_area_pruner.hpp>

#include <imageplus/video_segmentation/trajectory_bpt/trajectory.hpp>
#include <imageplus/video_segmentation/trajectory_bpt/motion_color_distance.hpp>
#include <imageplus/video_segmentation/optical_flow_fitting/occlusion_cost.hpp>
#include <imageplus/video_segmentation/optical_flow_fitting/bidirectional_projective_cost.hpp>
#include <imageplus/video_segmentation/optical_flow_fitting/bidirectional_affine_cost.hpp>
#include <imageplus/video_segmentation/optical_flow_fitting/model_optical_flow.hpp>

#include <boost/filesystem.hpp>
#include <iomanip>
#include <iostream>

using namespace imageplus;

#define uint64 imageplus::uint64
#define int64 imageplus::int64

typedef VideoSignal<float64,3> 																		VideoType;
typedef VideoSignal<float64,2>																		OpticalFlowType;
typedef VideoSignal<uint64,1>																		PartitionIndexType;
typedef VideoSignal<float64,1>																		ConfidenceMapType;

typedef VideoType::ImageType																		FrameType;
typedef OpticalFlowType::ImageType																	OpticalFlowFrame;
typedef PartitionIndexType::ImageType																PartitionIndexFrame;
typedef ConfidenceMapType::ImageType																ConfidenceMapFrame;

typedef FrameType::coord_type																		coord2d;
typedef VideoType::coord_type																		coord3d;
typedef VideoType::value_type																		rgb_type;

typedef HierarchicalRegion<coord3d>																	Region3D;
typedef video_segmentation::Trajectory<VideoType>													TrajectoryType;
typedef segmentation::HierarchicalRegionPartition<TrajectoryType>									BPT;
typedef BPT::PartitionType																			PartitionType;

FrameType convert_map_to_image(ConfidenceMapFrame& s) {
	typedef ConfidenceMapFrame::coord_type 	coord2d;
	FrameType res(s.sizes());
	for (ConfidenceMapFrame::iterator p = s.begin(); p!=s.end(); ++p) {
		coord2d pos = p.pos();
		float64 value = (*p)(0); if (value < 0) value=0;
		res(pos) = value*rgb_type(255,255,255);
	}
	return res;
}

int main(int argc, char *argv[]) {

	std::string path 		= argv[1];
	std::string segm_path 	= argv[2];
	std::string result_path = argv[3];

	std::vector<float64> list;

	for (int64 i = 4; i < argc; i++) {
		std::string a = argv[i];
		std::cout << a << " ";
		std::istringstream is(a);
		float64 n;
		is >> n;
		list.push_back(n);
	}

	std::string video_path = path + "/frames";
	std::string flows_path = path + "/flows";
	std::string partition_path = segm_path + "/leaves.sgm";
	std::string mergings_path  = segm_path + "/mergings.txt";

	std::cout << "Reading tree" << std::endl;
	BPT bpt;
	bpt.load_from_files(partition_path, mergings_path);
	coord3d sizes = bpt.leaves_partition().sizes();

	uint64 Nframes = sizes(2);

	OpticalFlowType forward_flows(sizes);
	OpticalFlowType backward_flows(sizes);

	VideoType video(sizes);



	std::cout << "Reading video with " << Nframes << " frames " << std::endl;
	for (uint64 k = 0; k < Nframes; k++) {
		std::ostringstream os;
		os << video_path << "/frame" << std::setw(3) << std::setfill('0') << k << ".png";
		//std::cout << "reading " << os.str() << std::endl;
		video.read_frame(os.str(),k); // read frame k and put it to the position k of the current block
	}

	// Read forward optical flows
	std::cout << "Reading forward flow" << std::endl;
	for (uint64 k = 0; k < Nframes-1; k++) {
		std::ostringstream os;
		//std::cout << k << std::endl;
		os << flows_path << "/flow_" << k << "_" << k+1 << ".flo";
		OpticalFlowFrame flow = forward_flows.frame(k);
		optical_flow::read_optical_flow(flow, os.str());  // read flow k,k+1 and put it to the position k of the current block
	}

	// Read backward optical flows
	std::cout << "Reading backward flow" << std::endl;
	for (uint64 k = 1; k < Nframes; k++) {
		std::ostringstream os;
		os << flows_path << "/flow_" << k << "_" << k-1 << ".flo";
		OpticalFlowFrame flow = backward_flows.frame(k);
		optical_flow::read_optical_flow(flow, os.str()); // read flow k,k-1 and put it to the position k of the current block
	}

	std::cout << "Creating segmentations " << std::endl;
	BPT::PartitionType partition(sizes);

	typedef bpt::BidirectionalProjectiveCost<BPT,OpticalFlowType> 				OpticalFlowCostFunction;
	typedef bpt::BinaryPruner<BPT,OpticalFlowType,OpticalFlowCostFunction>		FlowPruner;

	descriptors::DescriptorManager manager;
	OpticalFlowCostFunction projective_flow_cost(manager, bpt.max_label(),0);
	FlowPruner optical_flow_pruner(projective_flow_cost,false);

	projective_flow_cost.set_flows(forward_flows, backward_flows);
	sort(list.begin(), list.end());

	float64 root_cost = projective_flow_cost.region_cost(bpt,forward_flows,bpt.max_label());

	for (uint64 i = 0; i < list.size(); i++) {

		//bpt::MergingSequencePruner<BPT, VideoType> merging_sequence_pruner(list[i],false);
		//merging_sequence_pruner.prune_bpt(bpt,video);
		//std::set<uint64> regs = merging_sequence_pruner.regions(); //optical_flow_pruner.regions();

		std::cout << "Regularizer " << list[i] << std::endl;
		projective_flow_cost.set_lambda(list[i]*root_cost);
		std::set<uint64> regs = optical_flow_pruner.find_pruned_regions(bpt, forward_flows, bpt.max_label()); //regularizer acts as the number of regions
		std::cout << "Regions " << regs.size() << std::endl;

		OpticalFlowType fwd_modeled(forward_flows.sizes());
		OpticalFlowType bwd_modeled(backward_flows.sizes());

		for (std::set<uint64>::iterator r = regs.begin(); r != regs.end(); ++r) {
			for (int64 frame = bpt(*r).frame_begin(); frame <= bpt(*r).frame_end(); ++frame) {
				OpticalFlowFrame fwd 				= forward_flows.frame(frame);
				OpticalFlowFrame bwd 				= backward_flows.frame(frame);
				OpticalFlowFrame fwd_model_frame 	= fwd_modeled.frame(frame);
				OpticalFlowFrame bwd_model_frame 	= bwd_modeled.frame(frame);

				video_segmentation::projective_flow_model(bpt, fwd, fwd_model_frame,frame, *r);
				video_segmentation::projective_flow_model(bpt, bwd, bwd_model_frame,frame, *r);
			}
		}

		PartitionType partition_flow(video.sizes());
		for (std::set<uint64>::iterator r = regs.begin(); r != regs.end(); ++r) {
			for (BPT::RegionType::iterator p = bpt(*r).begin(); p != bpt(*r).end(); ++p) {
				partition_flow(*p)(0) = *r;
			}
		}

		//FrameType part(video.size_x(), video.size_y());
		//part = segmentation::to_false_color<FrameType>(partition_flow);
		//part.write(result_path + "/partition.png");

		std::cout << "Computing region based occlusions" << std::endl;
		ConfidenceMapType occlusions(video.sizes());
		for (uint64 k = 0; k < Nframes-1; k++) {
			ConfidenceMapFrame 		occ    	= occlusions.frame(k);
			OpticalFlowFrame 		fwd		= fwd_modeled.frame(k);
			OpticalFlowFrame 		bwd		= bwd_modeled.frame(k+1); //backward_flows.frame(k+1);

			ConfidenceMapFrame bij = optical_flow::region_occlusion_error(partition_flow, fwd, bwd, k);
			occ.channel(0) = bij.channel(0);
		}

		//output the segmentation
		std::ostringstream os;
		os << result_path << "/flow_models/" << i;
		boost::filesystem::path result_path_p(os.str());
		boost::filesystem::create_directories(result_path_p);

		std::cout << "Output occlusion maps" << std::endl;
		// Write occlusion map
		for (uint64 k = 0; k < Nframes-1; k++) {
			ConfidenceMapFrame of = occlusions.frame(k);
			FrameType o    = convert_map_to_image(of);

			std::ostringstream os2;
			os2 << os.str() << "/occ_" << std::setw(3) << std::setfill('0') << k << ".png";
			o.write(os2.str()); os2.str("");
		}

	}

}
