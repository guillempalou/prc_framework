// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------

//!
//!  \file error_measures.hpp
//!
//!  \author Carolina Martínez <alcarol@gps.tsc.upc.edu>
//!
//!  Error measures for multiarrays. 
//!

#ifndef IMAGEPLUS_MATH_NUMERIC_ERROR_MEASURES_HPP
#define IMAGEPLUS_MATH_NUMERIC_ERROR_MEASURES_HPP

#include <imageplus/core.hpp>
#include <imageplus/math.hpp>


namespace imageplus
{
    namespace math
    {
        namespace numeric
        {

            //!
            //! \brief It compares two given multiarrays, computing the number of pixels that differ more than a threshold.
            //!
            //! \tparam T : Type of the data
            //! \tparam D : Number of dimensions
            //!
            //! \param[in] d1: Input MultiArray
            //! \param[in] d2: Input MultiArray
            //! \param[in] threshold: Maximum difference between two values to be considered different
            //!
            //! \return  Number of bad matching elements
            //!
            //! \author Carolina Martínez <alcarol@gps.tsc.upc.edu>
            //!
            //! \date 26-06-2008
            //!
            template<typename T, std::size_t D>
            uint64 bad_matching_elements(const MultiArray <T,D>& d1, const MultiArray <T,D>& d2, float64 threshold=0.0);
    	
            //!
            //! \brief Computes the Mean Squared Error (MSE) between two MultiArray elements.
            //!
            //! For two m×n multiarrays I and K where one of the multiarrays is considered a noisy approximation of the other, the MSE is defined as:
            //! \f$ \mathit{MSE} = \frac{1}{mn}\sum_{i=0}^{m-1}\sum_{j=0}^{n-1} ||I(i,j) - K(i,j)||^2 \f$
            //!
            //! \tparam T : Type of the data
            //! \tparam D : Number of dimensions
            //!
            //! \param[in] d1: Input MultiArray
            //! \param[in] d2: Input MultiArray
            //!
            //! \return The resulting MSE
            //! 	
            //! \author Carolina Martínez <alcarol@gps.tsc.upc.edu>
            //!
            //! \date 26-06-2008
            //!
            template<typename T, std::size_t D>
            float64 mse (const MultiArray <T,D> &d1, const MultiArray <T,D> &d2);
    	


            //!
            //! \brief Computes the Mean Squared Error (MSE) between two imavol (images, volumes, etc) elements.
            //!
            //! For two m×n images I and K where one of the image is considered a noisy approximation of the other, the MSE is defined as:
            //! \f$ \mathit{MSE} = \frac{1}{mn}\sum_{i=0}^{m-1}\sum_{j=0}^{n-1} ||I(i,j) - K(i,j)||^2 \f$
            //!
            //! \tparam T : Type of the data
            //! \tparam N : Number of channels
            //! \tparam D : Number of dimensions
            //!
            //! \param[in] d1: Input ImaVol
            //! \param[in] d2: Input ImaVol
            //!
            //! \return The resulting MSE
            //! 	
            //! \author Ramon Morros <ramon.morros@upc.edu>
            //!
            //! \date 26-06-2008
            //!
            template<typename T, std::size_t N, std::size_t D>
            float64 mse (const ImaVol<T,N,D>& d1, const ImaVol<T,N,D>& d2);

            //!
            //! \brief Computes the Peak Signal-to-Noise Ratio [PSNR] between two MultiArray elements.
            //!
            //! For two mxn multiarrays I and K where one of the multiarrays is considered a noisy approximation of the other, the PSNR is defined as:
            //! \f$ \mathit{PSNR} = 10 \cdot \log_{10} \left( \frac{\mathit{MAX}_I^2}{\mathit{MSE}} \right) = 20 \cdot \log_{10} \left( \frac{\mathit{MAX}_I}{\sqrt{\mathit{MSE}}} \right) \f$
            //! Here, \f$ MAX_i \f$ is the maximum possible pixel value of the image. When the pixels are represented using 8 bits per sample, this is 255\n
            //! The PSNR is most commonly used as a measure of quality of reconstruction of lossy compression codecs 
            //! (e.g. for image compression). The signal in this case is the original data, and the noise is the error introduced by compression.
            //! PSNR is expressed in terms of the logarithmic decibel scale, where the higher value is the better. When the two images are 
            //! identical the MSE will be equal to zero, resulting in an infinite PSNR
            //!
            //! \tparam T : Type of the data
            //! \tparam D : Number of dimensions
            //!
            //! \param[in] d1    : Input MultiArray
            //! \param[in] d2    : Input MultiArray
            //! \param[in] maxval: The maximum possible value of the images
            //!
            //! \return The resulting PSNR
            //!
            //! \author Carolina Martínez <alcarol@gps.tsc.upc.edu>
            //!
            //! \date 26-06-2008
            //!
            template<typename T, std::size_t D>
            float64 psnr (const MultiArray <T,D> &d1,const MultiArray <T,D> &d2, float64 maxval = 255.0);    	

            //!
            //! \brief Computes the Peak Signal-to-Noise Ratio [PSNR] between two ImaVol (images, volumes, etc) elements.
            //!
            //! For two mxn imavol I and K where one of the imavols is considered a noisy approximation of the other, the PSNR is defined as:
            //! \f$ \mathit{PSNR} = 10 \cdot \log_{10} \left( \frac{\mathit{MAX}_I^2}{\mathit{MSE}} \right) = 20 \cdot \log_{10} \left( \frac{\mathit{MAX}_I}{\sqrt{\mathit{MSE}}} \right) \f$
            //! Here, \f$ MAX_i \f$ is the maximum possible pixel value of the image. When the pixels are represented using 8 bits per sample, this is 255\n
            //! The PSNR is most commonly used as a measure of quality of reconstruction of lossy compression codecs 
            //! (e.g. for image compression). The signal in this case is the original data, and the noise is the error introduced by compression.
            //! PSNR is expressed in terms of the logarithmic decibel scale, where the higher value is the better. When the two images are 
            //! identical the MSE will be equal to zero, resulting in an infinite PSNR
            //!
            //! \tparam T : Type of the data
            //! \tparam D : Number of dimensions
            //!
            //! \param[in] d1    : Input MultiArray
            //! \param[in] d2    : Input MultiArray
            //! \param[in] maxval: The maximum possible value of the images
            //!
            //! \return The resulting PSNR
            //!
            //! \author Carolina Martínez <alcarol@gps.tsc.upc.edu>
            //!
            //! \date 26-06-2008
            //!
            template<typename T, std::size_t N, std::size_t D>
            float64 psnr (const ImaVol <T,N,D> &d1,const ImaVol <T,N,D> &d2, float64 maxval = 255.0);

            //!
            //! \brief Computes the Peak Signal-to-Noise Ratio [PSNR] between two ImageYUV420 elements.
            //!
            //! This function is a specialization for ImageYUV420 elements of the generic psnr() function\n
            //! For two mxn imavol I and K where one of the imavols is considered a noisy approximation of the other, the PSNR is defined as:
            //! \f$ \mathit{PSNR} = 10 \cdot \log_{10} \left( \frac{\mathit{MAX}_I^2}{\mathit{MSE}} \right) = 20 \cdot \log_{10} \left( \frac{\mathit{MAX}_I}{\sqrt{\mathit{MSE}}} \right) \f$
            //! Here, $MAX_i$ is the maximum possible pixel value of the image. When the pixels are represented using 8 bits per sample, this is 255\n
            //! The PSNR is most commonly used as a measure of quality of reconstruction of lossy compression codecs 
            //! (e.g. for image compression). The signal in this case is the original data, and the noise is the error introduced by compression.
            //! PSNR is expressed in terms of the logarithmic decibel scale, where the higher value is the better. When the two images are 
            //! identical the MSE will be equal to zero, resulting in an infinite PSNR
            //!
            //! \tparam T : Type of the data
            //!
            //! \param[in] d1    : Input MultiArray
            //! \param[in] d2    : Input MultiArray
            //! \param[in] maxval: The maximum possible value of the images
            //!
            //! \return The resulting PSNR
            //!
            //! \author Carolina Martínez <alcarol@gps.tsc.upc.edu>
            //!
            //! \date 26-06-2008
            //!
            template<typename T>
            float64 psnr (const ImageYUV420 <T>& d1,const ImageYUV420 <T>& d2, float64 maxval = 255.0);
        }
    }
}




//
// Implementation of Template Functions
//

namespace imageplus
{
    namespace math
    {
        namespace numeric
        {
            template<typename T, std::size_t D>
            IMAGEPLUS_INLINE
            uint64 bad_matching_elements(const MultiArray <T,D>& d1, const MultiArray <T,D>& d2, float64 threshold)
            {
                //Bad matching elements: BME = Sum (|d1(x,y)-d2(x,y)| > threshold)
                uint64 numel     = d1.num_elements();
                uint64 num_error = 0;

                const T* pd1 = d1.data();
                const T* pd2 = d2.data();


                for (uint64 i = 0; i < numel; i++)
                {
                    if (std::abs (pd1[i]-pd2[i]) > threshold)
                    {
                        num_error++;			
                    }
                }

                return num_error;
            }


            template<typename T, std::size_t D>
            IMAGEPLUS_INLINE
            float64 mse (const MultiArray <T,D>& d1, const MultiArray <T,D>& d2)
            {
                float64 val = 0.0;		
                uint64 numel = d1.num_elements();

                const T* pd1 = d1.data();
                const T* pd2 = d2.data();
		
                for (uint64 i = 0; i < numel; i++) 
                {
                    val += static_cast<float64>(pd1[i]-pd2[i]) * static_cast<float64>((pd1[i]-pd2[i]));
                }

                return (val/numel);
            }



            template<typename T, std::size_t N, std::size_t D>
            IMAGEPLUS_INLINE
            float64 mse (const ImaVol <T,N,D>& d1, const ImaVol <T,N,D>& d2)
            {
                float64 val = 0.0;		

                for (uint64 channel = 0; channel < N; channel++)
                {
                    val += mse (d1(channel), d2(channel));
                }

                return (val / N);
            }



            template<typename T, std::size_t D>
            IMAGEPLUS_INLINE
            float64 psnr (const MultiArray <T,D>& d1, const MultiArray <T,D>& d2, float64 maxval)
            {
                return 10.0 * std::log10 (std::pow(maxval,(float64)D) / mse(d1,d2));;
            }


            template<typename T, std::size_t N, std::size_t D>
            IMAGEPLUS_INLINE
            float64 psnr (const ImaVol <T,N,D>& d1, const ImaVol <T,N,D>& d2, float64 maxval)
            {
                return 10.0 * std::log10 (std::pow(maxval,(float64)D) / mse (d1,d2));
            } 


            template<typename T>
            IMAGEPLUS_INLINE
            float64 psnr (const ImageYUV420 <T> &d1,const ImageYUV420 <T> &d2, float64 maxval)
            {
                throw ImagePlusNotImplemented ("psnr() not implemented for images where the channels do not have the same size");
            }

        }
    }
}
#endif
