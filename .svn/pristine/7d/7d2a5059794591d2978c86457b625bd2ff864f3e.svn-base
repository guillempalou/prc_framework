// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------

//!
//!  \file integral_image.cpp
//!
//!  Add brief description of the file here
//!


#include <imageplus/math/transforms/integral_image.hpp>

using namespace imageplus;
using namespace imageplus::math::transforms;

template<typename T2, typename T1>
MultiArray<T2,2> imageplus::math::transforms::integral_image (const MultiArray<T1,2>& ma)
{
    uint64 width  = ma.dims(0);
    uint64 height = ma.dims(1);

    MultiArray<T2,2> intimage(width, height);

    // Define pointers to the images data
    const T1* i_m   = ma.data();
    T2*      ii_m  = intimage.data();
    
    ii_m[0]  = i_m[0];

    // Create the first row of the integral image
    for (uint64 x = 1; x < width; x++)
    {
        ii_m[x]  = ii_m[x-1]  + i_m[x];
    }


    // Compute each other row/column
    for (uint64 y = 1, Y = width, YY=0; y < height; y++, Y+=width, YY+=width)
    {
        // Keep track of the row sum
        T2 r  = 0; // Row sum for original pixels

        for (uint64 x = 0; x < width; x++)
        {
            r  += i_m[Y + x];
            ii_m[Y + x]  = ii_m[YY + x]  + r;
        }
    }

    return (intimage);
}




template<typename T2, typename T1>
MultiArray<T2,2> imageplus::math::transforms::sq_integral_image (const MultiArray<T1,2>& ma)
{
    uint64 width  = ma.dims(0);
    uint64 height = ma.dims(1);


    MultiArray<T2,2> sq_intimage(width, height);

    // Define pointers to the images data
    const T1* i_m   = ma.data();
    T2*      sii_m = sq_intimage.data();
    

    sii_m[0] = i_m[0] * i_m[0];

    // First row of integral image of the squares of the elements in image
    for (uint64 x = 1; x < width; x++)
    {
        sii_m[x] = sii_m[x-1] + i_m[x]*i_m[x];
    }

    // Compute each other row/column
    for (uint64 y = 1, Y = width, YY=0; y < height; y++, Y+=width, YY+=width)
    {
        // Keep track of the row sum
        T2 rs = 0; // Row sum for squared pixels
        
        for (uint64 x = 0; x < width; x++)
        {
            rs += i_m[Y + x]*i_m[Y + x];
            sii_m[Y + x] = sii_m[YY + x] + rs;
        }
    }

    return (sq_intimage);
}


// Instantiations
namespace imageplus
{
    namespace math
    {
        namespace transforms
        {
            template MultiArray<int64,2>   integral_image<int64>(const MultiArray<uint8,2>&  ); 
            template MultiArray<int64,2>   integral_image<int64>(const MultiArray<int16,2>&  ); 
            template MultiArray<int64,2>   integral_image<int64>(const MultiArray<int32,2>&  ); 
            template MultiArray<int64,2>   integral_image<int64>(const MultiArray<int64,2>&  ); 

            template MultiArray<int32,2>   integral_image<int32>(const MultiArray<uint8,2>&  ); 
            template MultiArray<int32,2>   integral_image<int32>(const MultiArray<int16,2>&  ); 
            template MultiArray<int32,2>   integral_image<int32>(const MultiArray<int32,2>&  ); 
    
            template MultiArray<float64,2> integral_image<float64>(const MultiArray<float64,2>& ); 
    
            template MultiArray<int64,2>   sq_integral_image<int64>(const MultiArray<uint8,2>& ); 
            template MultiArray<int64,2>   sq_integral_image<int64>(const MultiArray<int16,2>& ); 
            template MultiArray<int64,2>   sq_integral_image<int64>(const MultiArray<int32,2>& ); 
            template MultiArray<int64,2>   sq_integral_image<int64>(const MultiArray<int64,2>& ); 
    
            template MultiArray<int32,2>   sq_integral_image<int32>(const MultiArray<uint8,2>& ); 
            template MultiArray<int32,2>   sq_integral_image<int32>(const MultiArray<int16,2>& ); 
            template MultiArray<int32,2>   sq_integral_image<int32>(const MultiArray<int32,2>& ); 

            template MultiArray<float64,2> sq_integral_image<float64>(const MultiArray<float64,2>& ); 
        }
    }
}

