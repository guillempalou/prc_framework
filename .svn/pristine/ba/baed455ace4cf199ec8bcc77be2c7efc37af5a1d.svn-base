/*
 * color__histogram.hpp
 *
 *  Created on: Feb 11, 2013
 *      Author: gpalou
 */

#ifndef COLOR__HISTOGRAM_HPP_
#define COLOR__HISTOGRAM_HPP_

#include <imageplus/descriptors/descriptor_base.hpp>
#include <imageplus/math/math_types.hpp>
#include <imageplus/descriptors/geometry/area.hpp>

#include <boost/math/distributions/normal.hpp>

namespace imageplus
{
    namespace descriptors
    {
        //!
        //! \brief Area visual descriptor
        //!
        //! \author Jordi Pont <jpont@gps.tsc.upc.edu>, Guillem Palou <guillem.palou@gmail.com>
        //!
        //! \date 02-06-2009
    	template<class Signal>
        class ColorHistogram : public DescriptorBase
        {
        public:

        	//! base structur for descriptors using parameters
        	struct ColorHistogramDescriptorParameters {

        		std::vector<uint64> bins;
        		std::vector<float64> left;
        		std::vector<float64> right;

        		std::vector<std::vector<float64> > thresholds;

        		ColorHistogramDescriptorParameters() {

        		}

        		ColorHistogramDescriptorParameters(std::vector<float64> range_begin, std::vector<float64> range_end, std::vector<uint64> b) : bins(b), left(range_begin), right(range_end) {
        			_init();
        		}

        	private:

        		void _init() {
        			thresholds.resize(bins.size());

        			for (uint64 ch = 0; ch < left.size(); ch++) {
        				uint64 b = bins[ch];

        				thresholds[ch].resize(b);

        				float64 delta = (right[ch] - left[ch])/b;
        				boost::math::normal norm;

        				for (uint64 i = 0; i <b-1; i++) {
        					//std::cout << "threshold " << (i+1)*delta << " - " << left[ch] << " : " << right[ch] << std::endl;
        					thresholds[ch][i] = (i+1)*delta;
        				}
        				thresholds[ch][b-1] = right[ch]; // put a dummy infinite value
        			}
        			//exit(0);
        		}
        	};

        	typedef ColorHistogramDescriptorParameters 	Parameters;


        	struct Histogram {
        		std::vector<math::Vector> histogram; // vector of size Channels with each histogram

        		uint64 area;

        		math::Vector normalized(uint64 ch) const {
        			return histogram[ch]/area;
        		}
        	};

        	//! Type to refer to the type of data which will be returned by this descriptor
        	typedef Histogram							type;
            typedef typename Area::type					area_type;

            //! function returning the id given a set of parameters
            //! \param[in] pars: parameters to the descriptors (null in this case)
            static const std::string id(const Parameters& pars = default_parameters()) {
            	return "color__histogram";
            }

            //! Default parameters for descriptors
            static const Parameters default_parameters() {
            	return Parameters();
            }

            //!
            //! \brief Default constructor
            //!
            ColorHistogram(const Parameters& pars = default_parameters()) : DescriptorBase(true) {};

            //! Virtual destructor
            ~ColorHistogram(){};

            //! \brief Calculates the area of a region, given a pair of iterators.
            //!
            //! \param[in] first      : Iterator to the beginning of the region
            //! \param[in] last       : Iterator to the end of the region
            //! \param[in] peer_descs : Pointer to CollaborativeDescriptors, in principle is never 0x0 but it is a good idea to ASSERT it
            template< class SignalModel, class RegionModel >
            void calculate(SignalModel& signal, RegionModel& region, const Parameters& pars, typename DescriptorBase::ManagerType* manager)
            {
                const area_type& 			area 				= manager->calc_descriptor<Area>(signal, region);

                _value.histogram.clear();
                for (int64 ch = 0; ch < SignalModel::num_channels; ch++) {
                	_value.histogram.push_back(math::Vector::Zero(pars.bins[ch]));
                }

                for (typename RegionModel::iterator p = region.begin(); p != region.end(); ++p) {
                	typename Signal::value_type v = signal(*p);


                	for (uint64 ch = 0; ch < (uint64)Signal::num_channels; ch++) {
                		uint64 assigned_bin = 0;

                		while (pars.thresholds[ch][assigned_bin] < v(ch))  {assigned_bin++; }
                		_value.histogram[ch](assigned_bin)++;
                	}
                }
                //std::cout << "histogram for " << region.label() << std::endl;
                //for (uint64 i = 0; i < 1; i++)
                //	std::cout << _value.histogram[i].transpose()/area << std::endl;

                _value.area = area;
            }

            //!
            //! \brief Calculates recursively area of the father region given the sons ones.
            //!
            //! \param[in] son1_descs : CollaborativeDescriptors of the son 1
            //! \param[in] son2_descs : CollaborativeDescriptors of the son 2
            //! \param[in] peer_descs : Pointer to CollaborativeDescriptors, in principle is never 0x0 but it is a good idea to ASSERT it
            template<class SignalModel, class RegionModel, class ChildContainer>
            void recursive_calculate(SignalModel& signal, RegionModel& region, ChildContainer& childs, const Parameters& pars, typename DescriptorBase::ManagerType* manager)
            {
            	_value.histogram.clear();
            	for (int64 ch = 0; ch < SignalModel::num_channels; ch++)
            		_value.histogram.push_back(math::Vector::Zero(pars.bins[ch]));

            	for (typename ChildContainer::iterator child = childs.begin(); child != childs.end(); ++child) {
                    const type& 	color_child 		= manager->calc_descriptor<ColorHistogram<SignalModel> >(signal,**child, pars);
                    for (uint64 ch = 0; ch < (uint64)SignalModel::num_channels; ch++) {
                    	_value.histogram[ch] += color_child.histogram[ch];
                    }
            	}
                 const area_type& 			area 				= manager->calc_descriptor<Area>(signal,region);

                 //std::cout << "histogram for " << region.label() << std::endl;
                 //for (uint64 i = 0; i < (uint64)SignalModel::num_channels; i++)
                //	 std::cout << _value.histogram[i].transpose()/area << std::endl;

                 _value.area = area;
            }

            const type& value() const {
            	return _value;
            }

        private:
            //! Area of the region
            type _value;

        };
    }
}

#endif /* COLOR__HISTOGRAM_HPP_ */
