// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------


//!
//! \file writeyuv.cpp
//!
#include <writeyuv.hpp>

#include<fstream>

void imageplus::io::write_dat_info(const std::string& datfile,
                                  const uint64& sizex,
                                  const uint64& sizey,
                                  const uint64& totalframes,
                                  const float64& fps,
                                  const SeqFormat& format,
                                  const std::string& comment) throw (ImagePlusError)
{
    std::ofstream fp;
    fp.open( datfile.c_str(), std::ios::out );
    
    if (fp.is_open())
    {
        int64 formatnumber;

        // Transform format label to corresponding code number.
        switch (format)
        {

            case YUV400P:
                formatnumber = 400;
                break;

            case YUV420P:
                formatnumber = 420;
                break;

            case YUV444P:
                formatnumber = 444;
                break;

            default:
                throw ImagePlusError( "Unknown format in dat file" );
                break;

        }
        
        // Write all data
        fp << sizex << " " << sizey << " " << totalframes << " " << fps << " " << formatnumber << " ";

        if(!fp.write(comment.c_str(),comment.size()))
        {
            throw ImagePlusError("Cannot write to file in disk.");
        }
                
        // Close dat file
        fp.close();

    }
    else
    {
        throw ImagePlusError("Cannot access file to write frame.");
    }

}



void imageplus::io::write_frame_yuv400(const MultiArray<uint8,2>& image, uint64 frame, std::fstream& fp) throw (ImagePlusError)
{
    uint64 yuvframesize;
    uint64 sizex = image.dims(0);
    uint64 sizey = image.dims(1);
    yuvframesize = static_cast<uint64> (sizex*sizey);

    if(fp.is_open())
    {
        // \todo : Check if the frame index falls within the file allocated memory  boundaries. 
        // Move the frame pointer in the stream.
        
        fp.seekp(frame*yuvframesize, std::ios::beg);
        
        //Allocate space for y and uv images.
        uint8* data = new uint8[sizex*sizey];
                                
        
        // Write Data for Y image.
        for (uint64 pnt = 0, y = 0; y < sizey; y++)
        {
            for (uint64 x = 0; x < sizex; x++, pnt++)
            {
                data[pnt] = image[x][y];
            }
        }
        if(!fp.write((char *)data, sizex*sizey))
        {
            // \todo : Improve the error handling.
            delete []data;
            throw ImagePlusError("Can't write data to file.");
        }
        
       fp.flush();
       // Free data
       delete []data;
        
    }
    else
    {
        throw ImagePlusError("Cannot access file to write frame.");
    }

}

void imageplus::io::write_frame_yuv420(const ImageYUV420<uint8>& image, uint64 frame, std::fstream& fp) throw (ImagePlusError)
{
    uint64 yuvframesize;
    uint64 sizex = image.size_x();
    uint64 sizey = image.size_y();
    yuvframesize = static_cast<uint64> (1.5*sizex*sizey);

    if(fp.is_open())
    {
        // \todo : Check if the frame index falls within the file allocated memory  boundaries. 
        // Move the frame pointer in the stream.
        
        fp.seekp(frame*yuvframesize, std::ios::beg);
        
        //Allocate space for y and uv images.
        uint8* data = new uint8[sizex*sizey];
                                
        
        // Write Data for Y image.
        for (uint64 pnt = 0, y = 0; y < sizey; y++)
        {
            for (uint64 x = 0; x < sizex; x++, pnt++)
            {
                data[pnt] = image(Y_CHANNEL)[x][y];
            }
        }
        if(!fp.write((char *)data, sizex*sizey))
        {
            // \todo : Improve the error handling.
            delete []data;
            throw ImagePlusError("Can't write data to file.");
        }
        
        // Write Data for UV image
       for (uint64 c = 1; c < 3; c++)
       {

           for (uint64 pnt = 0, y = 0; y < sizey/2; y++)
           {
               for (uint64 x = 0; x < sizex/2; x++, pnt++)
               {
                   data[pnt] = image(c)[x][y];
               }
           }
           if ( !fp.write((char *)data, sizex*sizey/4) )
           {
               // \todo : Improve the error handling.
               delete []data;
               fp.close();
               throw ImagePlusError("Can't write data to file.");
           }

       }
       fp.flush();
       // Free data
       delete []data;
        
    }
    else
    {
        throw ImagePlusError("Cannot access file to write frame.");
    }

}

void imageplus::io::write_frame_yuv444(const ImageYUV<uint8>& image, uint64 frame, std::fstream& fp) throw (ImagePlusError)
{
    uint64 yuvframesize;
    uint64 sizex = image.size_x();
    uint64 sizey = image.size_y();
    yuvframesize = static_cast<uint64> (3*sizex*sizey);

    if(fp.is_open())
    {
        // \todo : Check if the frame index falls within the file allocated memory  boundaries. 
        // Move the frame pointer in the stream.
        
        fp.seekp(frame*yuvframesize, std::ios::beg);
              
        // Write Data for YUV image
       for (uint64 c = 0; c < 3; c++)
       {

           if ( !fp.write((char *)image(c).data(), sizex*sizey) )
           {
               // \todo : Improve the error handling.
               fp.close();
               throw ImagePlusError("Can't write data to file.");
           }

       }
       fp.flush();
    }
    else
    {
        throw ImagePlusError("Cannot access file to write frame.");
    }

}

//end of file
