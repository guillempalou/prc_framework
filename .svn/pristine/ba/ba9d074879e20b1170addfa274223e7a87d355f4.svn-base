// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------

//!
//!  \file distance_transform.hpp
//!
//!  Descriptor to compute the distance tranform
//!

#ifndef IMAGEPLUS_MATH_TRANSFORMS_DISTANCE_TRANSFORM_HPP
#define IMAGEPLUS_MATH_TRANSFORMS_DISTANCE_TRANSFORM_HPP

#include <imageplus/core/imagegray.hpp>
#include <imageplus/core/mask.hpp>
#include <imageplus/core/border.hpp>

#include <queue>

namespace imageplus
{
    namespace math
    {
        namespace transforms
        {
            /*! 
             * Distance transform: ImageGray with the distance of each pixel to the contour of the region given
             * 
             * \author Jordi Pont Tuset <jordi.pont@upc.edu>
             */
            class DistanceTransform : public DescriptorBase, 
                                      public ImageGray<uint16>
            {
            public:
                /*! Default constructor
                 */
                DistanceTransform() :  DescriptorBase("DistanceTransform", false), ImageGray<uint16>()
                {
                }
                
                //! \brief Calculates the distance transform 
                //!
                //! \tparam IteratorModel: Type of iterator received
                //! \param[in] first : Iterator to the beginning of the image
                //! \param[in] last : Iterator to the end of the image
                //! \param[in] peer_descs : Pointer to CollaborativeDescriptors, in principle is never 0x0 but it is a good idea to ASSERT it
                //!
                template< class IteratorModel >
                void calculate(IteratorModel first, IteratorModel last, CollaborativeDescriptors* peer_descs)
                {
                    ASSERT(peer_descs!=0x0, "DistanceTransform calculate: peer_descs must be non null");

                    typedef ContourMask<typename IteratorModel::imavol_type::CoordType> CMask;
                    typedef BoundingBox<typename IteratorModel::imavol_type::CoordType> BBoxType;

                    CMask& contour_mask = peer_descs->calculate(new CMask(), first, last);

                    boost::array<std::size_t,IteratorModel::imavol_type::dimensions> borders;
                    for(std::size_t ii = 0; ii<IteratorModel::imavol_type::dimensions; ++ii)
                    {
                        borders[ii] = 1;
                    }
                    const BBoxType& bbox = peer_descs->global_desc()->calculate(new BBoxType,(*first).global_begin(), (*first).global_end());

                    this->resize(bbox.side(0), bbox.side(1));
                    (*this)(0) = not_assigned<uint16>();
                    const Border<ImageGray<uint16> >& tmp_border =
                            calc_descriptor(new Border<ImageGray<uint16> >(borders, 0), (*this));

                    Neighborhood2D neighb;
                    neighb.resize(4);
                    neighb[0]=Neighborhood2D::CoordType( 1, 0);
                    neighb[1]=Neighborhood2D::CoordType( 0, 1);
                    neighb[2]=Neighborhood2D::CoordType(-1, 0);
                    neighb[3]=Neighborhood2D::CoordType( 0,-1);

                    typedef Border<ImageGray<uint16> >::const_iterator<ImaVolMask<2> >::pixel_type pix_type;
                    std::queue<pix_type> pixel_queue;
                    Border<ImageGray<uint16> >::const_iterator<ImaVolMask<2> > it = tmp_border.colors_begin(contour_mask.value());
                    Border<ImageGray<uint16> >::const_iterator<ImaVolMask<2> > it_end = tmp_border.colors_end(contour_mask.value());
                    for(; it!=it_end; ++it)
                    {
                        (*this)((*it).position()) = 0;
                        pixel_queue.push(*it);
                    }
                    while (!pixel_queue.empty())
                    {
                        pix_type curr_pixel = pixel_queue.front();
                        pixel_queue.pop();
                        
                        pix_type::neighbor_iterator neigh_it     = curr_pixel.local_begin(neighb);
                        pix_type::neighbor_iterator neigh_it_end = curr_pixel.local_end(neighb);
                        for(; neigh_it!=neigh_it_end; ++neigh_it)
                        {
                            if(!tmp_border.is_border((*neigh_it).position()))
                            {
                                if((uint16)((*this)(curr_pixel.position())[0]+1)<(uint16)(*this)((*neigh_it).position())[0])
                                {
                                    (*this)((*neigh_it).position())[0]=(*this)(curr_pixel.position())[0]+1;
                                    pixel_queue.push((*neigh_it));
                                }
                            }
                        }
                    }
                }
            };
        }
    }
}


#endif
