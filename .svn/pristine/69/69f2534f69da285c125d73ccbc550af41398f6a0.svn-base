// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------

/*!
 * \file imagegray.hpp
 */

#ifndef IMAGEPLUS_CORE_IMAGEGRAY_HPP
#define IMAGEPLUS_CORE_IMAGEGRAY_HPP

#include <imageplus/core/image.hpp>

namespace imageplus
{
    /*!
     * Class for Gray images.
     *
     * See ImaVol for further details.
     *
     * \see imageplus::ImaVol, imageplus::ImageRGB, imageplus::ImageYUV
     *
     * \tparam T : the type of the data, usually uint8
     *
     * \author 2008-01 - Javier Ruiz Hidalgo - Creation
     * \author 2008-01 - Josep Ramon Morros  - Creation
     * \author 2011-07 - Albert Gil Moreno   - Review
     */
    template<typename T>
    class ImageGray : public Image <T,1>
    {
    private:
        /*!
         * The base class of ImageGray.
         *
         * Please note that it is Image, but Image is only specialization of ImaVol for 2D. \n
         * So, the real base class of ImageGray is more ImaVol, than Image.
         */
        typedef Image <T,1> Base;
    public:

        /*!
         * Default constructor
         */
        ImageGray();

        /*!
         * Copy constructor from the Base::Base class (ImaVol<T,1,2>)
         *
         * It also works to create an ImageGray from a Image<T,1> and from another ImageGray.
         *
         * \param[in] copy : ImaVol<T,1,2> to copy from
         *
         * \todo should we use T1 and T2 here?
         */
        ImageGray(const ImaVol<T,1,2>& copy);

        /*!
         * Specific constructor for 2 dimensions (width/height)
         *
         * \param[in] width  : size of the first dimension (X) of the ImageRGB
         * \param[in] height : size of the second dimension (Y) of the ImageRGB
         */
        ImageGray(std::size_t width, std::size_t height);

        /*!
         * Specific constructor by dimensions (per channel)
         *
         * \see ImaVol
         *
         * \param[in] dims: Vector of vectors with the dimension of each channel
         *
         * \todo agil: use array instead of vectors, or the ExtentsTemplate as in MultiArray
         */
        explicit
        ImageGray(const std::vector< std::vector<uint64> >& dims);

        /*!
         * Assignment operator (=) from the Base::Base class (ImaVol<T,3,2>)
         *
         * \param[in] copy : ImaVol<T,3,2> to copy from
         *
         * \returns this, just to concatenate
         *
         * \todo should we use T1 and T2 here?
         */
        const ImageGray& operator=( const ImaVol<T,1,2>& copy );

        /*!
         * Assignment operator (=) from a scalar value
         *
         * It fills the entire ImageRGB with the scalar value, all the channels.
         *
         * \param[in] scalar : the data_type to fill up the entire ImageRGB
         *
         * \returns this, just to concatenate
         *
         * \todo should we use T1 and T2 here?
         * \todo it should be a "RGB color", not a "T-scalar value"
         */
        const ImageGray& operator=( const T& scalar );

        //!
        //! \brief Overload of operator[] to be able to use imagegray[x][y] instead of imagegray(0)[x][y]
        //!
        //! \param[in] pos : coordinate X of the image
        //!
        //! \return Reference to sub_array with 1 dimension (to be able to access coordinate Y)
        //!
        boost::detail::multi_array::sub_array<T,1> operator[]( std::size_t pos )
        {
            return (*this)(0)[pos];
        }

        //!
        //! \brief Overload of operator[] to be able to use imagegray[x][y] instead of imagegray(0)[x][y]
        //!
        //! \param[in] pos : coordinate X of the image
        //!
        //! \return Reference to sub_array with 1 dimension (to be able to access coordinate Y)
        //!
        boost::detail::multi_array::const_sub_array<T,1> operator[]( std::size_t pos ) const
        {
            return (*this)(0)[pos];
        }
        
           //!
            //! \brief Color space
            //!
            //! \return Color space
            //!
            virtual
            ColorSpace color_space() const
            {
                return Gray;
            }
    }; // ImageGray
} // imageplus

#endif // IMAGEPLUS_CORE_IMAGEGRAY_HPP
