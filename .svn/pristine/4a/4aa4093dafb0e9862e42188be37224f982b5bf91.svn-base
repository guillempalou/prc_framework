// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------

//! 
//! \file xml_auxiliar.test
//!
//! Tests for auxiliar BPT functions
//!
#include <string>

#include <imageplus/core.hpp>
#include <imageplus/io/io_types.hpp>

#ifdef USE_XML
#include <imageplus/io/xml_auxiliar.hpp>
XERCES_CPP_NAMESPACE_USE
#endif

BOOST_AUTO_TEST_SUITE ( XML_Auxiliar_Suite );

using namespace imageplus;
using namespace io;



BOOST_AUTO_TEST_CASE( xml_auxiliar_functions )
{
#ifdef USE_XML
    
    // XML variables
    DOMNode *curr_node;
    DOMNode *curr_node2;
	DOMNode *curr_node3;
    DOMNodeList *child_list, *child_list2;
    DOMNamedNodeMap *node_attr;
    XERCES_CPP_NAMESPACE::DOMDocument* doc;


    // Output merging sequence
    std::vector<uint32> fathers;
    std::vector<uint32> sons1;
    std::vector<uint32> sons2;
    
    // Other variables
    char *name;
    int jj;
    int64 num_children, num_children2;
    int num_sons_found;
    uint32 num_father, num_son1, num_son2;

    // Open XML file and initialize the structure. It returns the root node of the XML
    curr_node = xml_init("tests/data_r/io/xml_example.xml", doc);

    //Check that the name of the node is "Mpeg7"
    name = XMLString::transcode(curr_node->getNodeName());
    if(strcmp(name,"Mpeg7") != 0)
        throw ImagePlusError("XML reading: 'Mpeg7' node not found");

    // Check that there is a sequence of sons named:
    // "Description/MultimediaContent/Image"
    // and returns a pointer to it
    curr_node = xml_get_check_son(curr_node, "Description");
    curr_node = xml_get_check_son(curr_node, "MultimediaContent");
    curr_node = xml_get_check_son(curr_node, "Image");
    
    // Let's check that there is  a node "CreationInformation/RelatedMaterial (id=PartitionSearchFile)/MediaLocator/MediaUri
    curr_node2 = xml_get_check_son(curr_node, "CreationInformation");

    curr_node3 = xml_get_check_son_by_field(curr_node2, "RelatedMaterial", "id", "NotAvailableID");

	BOOST_CHECK(curr_node3 ==0x0);
	
	curr_node2 = xml_get_check_son_by_field(curr_node2, "RelatedMaterial", "id", "PartitionSearchFile");
	
	BOOST_CHECK(curr_node2 !=0x0);
		
	curr_node2 = xml_get_check_son(curr_node2, "MediaLocator");
	curr_node2 = xml_get_check_son(curr_node2, "MediaUri");

	// Check it has a text node with "Dummy data"
	std::string text = xml_get_text_son(curr_node2, curr_node2);
		
	BOOST_CHECK_EQUAL(text, "Dummy data");
	BOOST_CHECK_EQUAL(XMLString::transcode(curr_node2->getNodeValue()), "Dummy data");
	

	// Go on with the structure	
    curr_node = xml_get_check_son(curr_node, "SpatialDecomposition");
    
    // Gets the list of children
    child_list = curr_node->getChildNodes();
    
    // Gets the number of children
    num_children = child_list->getLength();
    
    if(num_children==0)
        throw ImagePlusError("An empty merging sequence has been found.");
    else
    {
        // We go through all the children
        for(int64 ii=0; ii<num_children; ii++ )
        {
            // Pointer to the specific child
            curr_node = child_list->item(ii);
            
            // Discard those child that are not "real" nodes 
            if(curr_node->getNodeType() == DOMNode::ELEMENT_NODE)
            {
                // Check it has sons
                if(curr_node->hasChildNodes())
                {
                    // Get attributes of a node
                    node_attr = curr_node->getAttributes();

                    // Get an specific attribute "id"
                    curr_node2 = node_attr->getNamedItem(XMLString::transcode("id"));
                    
                    // We expect it to be of the form "Regioni", so we get the value
                    sscanf(XMLString::transcode(curr_node2->getNodeValue()), "Region%u", &num_father);

                    // Get a node named "SpatialDecomposition"
                    curr_node = xml_get_check_son(curr_node, "SpatialDecomposition");
                    
                    // Get the children
                    child_list2 = curr_node->getChildNodes();
                    
                    // Get number of children
                    num_children2 = child_list2->getLength();
                    
                    num_sons_found = 0;
                    jj=0;
                    
                    do
                    {
                        curr_node = child_list2->item(jj);
                        
                        // Discard those child that are not "real" nodes 
                        if(curr_node->getNodeType() == DOMNode::ELEMENT_NODE)
                        {
                            name = XMLString::transcode(curr_node->getNodeName());
                            if(strcmp(name, "StillRegionRef") == 0)
                            {
                                node_attr = curr_node->getAttributes();
                                curr_node2 = node_attr->getNamedItem(XMLString::transcode("idref"));
                                if(num_sons_found == 0)
                                    sscanf(XMLString::transcode(curr_node2->getNodeValue()), "Region%u", &num_son1);
                                else
                                    sscanf(XMLString::transcode(curr_node2->getNodeValue()), "Region%u", &num_son2);
                                
                                num_sons_found++;
                            }
                        }
                        
                        jj++;
                    }
                    while(jj<num_children2 && num_sons_found<2);
                    
                    // We expect every "father" to have 2 children
                    if(num_sons_found<2)
                        throw ImagePlusError("There is a region description that is not correct.");
                    
                    // Save the values obtained
                    fathers.push_back(num_father);
                    sons1.push_back(num_son1);
                    sons2.push_back(num_son2);
                }
            }
        }
    }
    
    XMLString::release(&name);
    
    BOOST_CHECK_EQUAL(fathers[0], (uint32) 9);
    BOOST_CHECK_EQUAL(  sons1[0], (uint32) 1);
    BOOST_CHECK_EQUAL(  sons2[0], (uint32) 2);
            
    BOOST_CHECK_EQUAL(fathers[1], (uint32)10);
    BOOST_CHECK_EQUAL(  sons1[1], (uint32) 3);
    BOOST_CHECK_EQUAL(  sons2[1], (uint32) 4);

    BOOST_CHECK_EQUAL(fathers[2], (uint32)11);
    BOOST_CHECK_EQUAL(  sons1[2], (uint32) 5);
    BOOST_CHECK_EQUAL(  sons2[2], (uint32) 6);

    BOOST_CHECK_EQUAL(fathers[3], (uint32)12);
    BOOST_CHECK_EQUAL(  sons1[3], (uint32)10);
    BOOST_CHECK_EQUAL(  sons2[3], (uint32)11);
    
    BOOST_CHECK_EQUAL(fathers[4], (uint32)13);
    BOOST_CHECK_EQUAL(  sons1[4], (uint32) 8);
    BOOST_CHECK_EQUAL(  sons2[4], (uint32) 9);
    
#endif
}

BOOST_AUTO_TEST_SUITE_END ();
