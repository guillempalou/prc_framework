/*
 * emd.hpp
 *
 *  Created on: Feb 28, 2012
 *      Author: guillem
 */

#ifndef EMD_HPP_
#define EMD_HPP_

#include <imageplus/math/statistics/signature.hpp>

namespace imageplus {
	namespace math {
		namespace optimization {

		//! Class to compute the Earth Mover's Distance
		//! Wrapper from the Rubner algorithm ICCV 2000
		//! \author Guillem Palou <guillem.palou@upc.edu>
		//! \date 10-04-2012
		template<class Distance = statistics::PerceptualDistance<statistics::Signature<>::FeatureType> >
		class EMD {

		public:

			typedef Distance							DistanceType;
			typedef typename DistanceType::FeatureType	Feature;
			typedef statistics::Signature<Feature> 		Signature;

			//! Default constructor
			EMD() {

			}

			//! Constructor with a given distance
			//! \param[in]
			EMD(Distance& distance) : _distance(distance) {

			}

			//! Main function
			float64 calculate(Signature s1, Signature s2) {

				float64 flow = _emd(s1,s2);

				return flow;
			}

			//! set
			void set_distance(Distance& distance) {
				_distance = distance;
			}

		private:

			/*!
			 * \cond SKIP_DOC
			 */
			static const uint64  MAX_SIG_SIZE1 = 256;
			static const uint64  MAX_ITERATIONS = 1000;
			//static const float64 INFINITY = 1e20;

			typedef struct node1_t {
				uint64 i;
				double val;
				struct node1_t *Next;
			} node1_t;

			/* node1_t IS USED FOR DOUBLE-LINKED LISTS */

			typedef struct node2_t {
				uint64 i, j;
				double val;
				struct node2_t *NextC;               /* NEXT COLUMN */
				struct node2_t *NextR;               /* NEXT ROW */
			} node2_t;

			typedef struct
			{
				uint64 n;                /* Number of features in the signature */
				Feature *Features;  /* Pointer to the features vector */
				float *Weights;       /* Pointer to the weights of the features */
			} signature_t;

			typedef struct
			{
				uint64 from;             /* Feature number in signature 1 */
				uint64 to;               /* Feature number in signature 2 */
				float amount;         /* Amount of flow from "from" to "to" */
			} flow_t;

		private:

			float _emd(Signature& Signature1, Signature& Signature2, flow_t *Flow = NULL)
			{
				uint64 itr;
				double totalCost;
				float w;
				node2_t *XP;
				flow_t *FlowP = NULL;
				node1_t U[MAX_SIG_SIZE1], V[MAX_SIG_SIZE1];

				w = init(Signature1, Signature2);

				if (_n1 > 1 && _n2 > 1)  /* IF _n1 = 1 OR _n2 = 1 THEN WE ARE DONE */
				{
					for (itr = 1; itr < MAX_ITERATIONS; itr++)
					{
						/* FIND BASIC VARIABLES */
						findBasicVariables(U, V);

						/* CHECK FOR OPTIMALITY */
						if (isOptimal(U, V))
							break;

						/* IMPROVE SOLUTION */
						newSol();
					}

					//if (itr == MAX_ITERATIONS)
						//fprintf(stderr, "emd: Maximum number of iterations has been reached (%d)\n",
						//		MAX_ITERATIONS);
				}

				/* COMPUTE THE TOTAL FLOW */
				totalCost = 0;
				if (Flow != NULL)
					FlowP = Flow;

				for(XP=_X; XP < _EndX; XP++)
				{
					if (XP == _EnterX)  /* _EnterX IS THE EMPTY SLOT */
						continue;
					if (XP->i == Signature1.elements() || XP->j == Signature2.elements())  /* DUMMY FEATURE */
						continue;

					if (XP->val == 0)  /* ZERO FLOW */
						continue;

					totalCost += (double)XP->val * _C[XP->i][XP->j];
					if (Flow != NULL)
					{
						FlowP->from = XP->i;
						FlowP->to = XP->j;
						FlowP->amount = XP->val;
						FlowP++;
					}
				}
				//if (Flow != NULL)
				//	*FlowSize = FlowP-Flow;

				/* RETURN THE NORMALIZED COST == EMD */
				return (float)(totalCost / w);
			}

			/**********************
				   init
			 **********************/
			float init(Signature& Signature1, Signature& Signature2)
			{
				uint32 i, j;
				double sSum, dSum, diff;
				double S[MAX_SIG_SIZE1], D[MAX_SIG_SIZE1];

				_n1 = Signature1.elements();
				_n2 = Signature2.elements();

				if (_n1 > MAX_SIG_SIZE1-1 || _n2 > MAX_SIG_SIZE1-1)
				{
					//fprintf(stderr, "emd: Signature size is limited to %d\n", MAX_SIG_SIZE1);
					exit(1);
				}

				/* COMPUTE THE DISTANCE MATRIX */
				_maxC = 0;
				for(i=0; i < _n1; i++) {
					for(j=0; j < _n2; j++)
					{
						_C[i][j] = _distance.distance(Signature1.features[i],Signature2.features[j]);
						if (_C[i][j] > _maxC)
							_maxC = _C[i][j];
					}
				}

				/* SUM UP THE SUPPLY AND DEMAND */
				sSum = 0.0;
				for(i=0; i < _n1; i++)
				{
					S[i] = Signature1.weights(i);
					sSum += Signature1.weights(i);
					_RowsX[i] = NULL;
				}
				dSum = 0.0;
				for(j=0; j < _n2; j++)
				{
					D[j] = Signature2.weights(j);
					dSum += Signature2.weights(j);
					_ColsX[j] = NULL;
				}

				/* IF SUPPLY DIFFERENT THAN THE DEMAND, ADD A ZERO-COST DUMMY CLUSTER */
				diff = sSum - dSum;
				if (fabs(diff) >= 1e-10 * sSum)
				{
					if (diff < 0.0)
					{
						for (j=0; j < _n2; j++)
							_C[_n1][j] = 0;
						S[_n1] = -diff;
						_RowsX[_n1] = NULL;
						_n1++;
					}
					else
					{
						for (i=0; i < _n1; i++)
							_C[i][_n2] = 0;
						D[_n2] = diff;
						_ColsX[_n2] = NULL;
						_n2++;
					}
				}

				/* INITIALIZE THE BASIC VARIABLE STRUCTURES */
				for (i=0; i < _n1; i++)
					for (j=0; j < _n2; j++)
						_IsX[i][j] = 0;
				_EndX = _X;

				_maxW = sSum > dSum ? sSum : dSum;

				/* FIND INITIAL SOLUTION */
				russel(S, D);

				_EnterX = _EndX++;  /* AN EMPTY SLOT (ONLY _n1+_n2-1 BASIC VARIABLES) */

				return sSum > dSum ? dSum : sSum;
			}


			/**********************
					findBasicVariables
			 **********************/
			uint64 findBasicVariables(node1_t *U, node1_t *V)
			{
				uint64 i, j, found;
				uint64 UfoundNum, VfoundNum;
				node1_t u0Head, u1Head, *CurU, *PrevU;
				node1_t v0Head, v1Head, *CurV, *PrevV;

				/* INITIALIZE THE ROWS LIST (U) AND THE COLUMNS LIST (V) */
				u0Head.Next = CurU = U;
				for (i=0; i < _n1; i++)
				{
					CurU->i = i;
					CurU->Next = CurU+1;
					CurU++;
				}
				(--CurU)->Next = NULL;
				u1Head.Next = NULL;

				CurV = V+1;
				v0Head.Next = _n2 > 1 ? V+1 : NULL;
				for (j=1; j < _n2; j++)
				{
					CurV->i = j;
					CurV->Next = CurV+1;
					CurV++;
				}
				(--CurV)->Next = NULL;
				v1Head.Next = NULL;

				/* THERE ARE _n1+_n2 VARIABLES BUT ONLY _n1+_n2-1 INDEPENDENT EQUATIONS,
					 SO SET V[0]=0 */
				V[0].i = 0;
				V[0].val = 0;
				v1Head.Next = V;
				v1Head.Next->Next = NULL;

				/* LOOP UNTIL ALL VARIABLES ARE FOUND */
				UfoundNum=VfoundNum=0;
				while (UfoundNum < _n1 || VfoundNum < _n2)
				{

					found = 0;
					if (VfoundNum < _n2)
					{
						/* LOOP OVER ALL MARKED COLUMNS */
						PrevV = &v1Head;
						for (CurV=v1Head.Next; CurV != NULL; CurV=CurV->Next)
						{
							j = CurV->i;
							/* FIND THE VARIABLES IN COLUMN j */
							PrevU = &u0Head;
							for (CurU=u0Head.Next; CurU != NULL; CurU=CurU->Next)
							{
								i = CurU->i;
								if (_IsX[i][j])
								{
									/* COMPUTE U[i] */
									CurU->val = _C[i][j] - CurV->val;
									/* ...AND ADD IT TO THE MARKED LIST */
									PrevU->Next = CurU->Next;
									CurU->Next = u1Head.Next != NULL ? u1Head.Next : NULL;
									u1Head.Next = CurU;
									CurU = PrevU;
								}
								else
									PrevU = CurU;
							}
							PrevV->Next = CurV->Next;
							VfoundNum++;
							found = 1;
						}
					}
					if (UfoundNum < _n1)
					{
						/* LOOP OVER ALL MARKED ROWS */
						PrevU = &u1Head;
						for (CurU=u1Head.Next; CurU != NULL; CurU=CurU->Next)
						{
							i = CurU->i;
							/* FIND THE VARIABLES IN ROWS i */
							PrevV = &v0Head;
							for (CurV=v0Head.Next; CurV != NULL; CurV=CurV->Next)
							{
								j = CurV->i;
								if (_IsX[i][j])
								{
									/* COMPUTE V[j] */
									CurV->val = _C[i][j] - CurU->val;
									/* ...AND ADD IT TO THE MARKED LIST */
									PrevV->Next = CurV->Next;
									CurV->Next = v1Head.Next != NULL ? v1Head.Next: NULL;
									v1Head.Next = CurV;
									CurV = PrevV;
								}
								else
									PrevV = CurV;
							}
							PrevU->Next = CurU->Next;
							UfoundNum++;
							found = 1;
						}
					}
					if (! found)
					{
						fprintf(stderr, "emd: Unexpected error in findBasicVariables!\n");
						fprintf(stderr, "This typically happens when the 1e-10 defined in\n");
						fprintf(stderr, "emd.h is not right for the scale of the problem.\n");
						// exit(1);
						return 0;
					}
				}
				return 1;
			}

			/**********************
					isOptimal
			 **********************/
			uint64 isOptimal(node1_t *U, node1_t *V)
			{
				double delta, deltaMin;
				uint64  i, j, minI=0, minJ=0;

				/* FIND THE MINIMAL Cij-Ui-Vj OVER ALL i,j */
				deltaMin = INFINITY;
				for(i=0; i < _n1; i++)
					for(j=0; j < _n2; j++)
						if (! _IsX[i][j])
						{
							delta = _C[i][j] - U[i].val - V[j].val;
							if (deltaMin > delta)
							{
								deltaMin = delta;
								minI = i;
								minJ = j;
							}
						}

				if (deltaMin == INFINITY)
				{
					fprintf(stderr, "emd: Unexpected error in isOptimal.\n");
					exit(0);
				}

				_EnterX->i = minI;
				_EnterX->j = minJ;

				/* IF NO NEGATIVE deltaMin, WE FOUND THE OPTIMAL SOLUTION */
				return deltaMin >= -1e-10* _maxC;

				/*
				   return deltaMin >= -1e-10;
				 */
			}


			/**********************
					newSol
			 **********************/
			void newSol()
			{
				uint64 i, j, k;
				double xMin;
				uint64 steps;
				node2_t *Loop[2*MAX_SIG_SIZE1], *CurX, *LeaveX = Loop[0];

				/* ENTER THE NEW BASIC VARIABLE */
				i = _EnterX->i;
				j = _EnterX->j;
				_IsX[i][j] = 1;
				_EnterX->NextC = _RowsX[i];
				_EnterX->NextR = _ColsX[j];
				_EnterX->val = 0;
				_RowsX[i] = _EnterX;
				_ColsX[j] = _EnterX;

				/* FIND A CHAIN REACTION */
				steps = findLoop(Loop);

				/* FIND THE LARGEST VALUE IN THE LOOP */
				xMin = INFINITY;
				for (k=1; k < steps; k+=2)
				{
					if (Loop[k]->val < xMin)
					{
						LeaveX = Loop[k];
						xMin = Loop[k]->val;
					}
				}

				/* UPDATE THE LOOP */
				for (k=0; k < steps; k+=2)
				{
					Loop[k]->val += xMin;
					Loop[k+1]->val -= xMin;
				}

				/* REMOVE THE LEAVING BASIC VARIABLE */
				i = LeaveX->i;
				j = LeaveX->j;
				_IsX[i][j] = 0;
				if (_RowsX[i] == LeaveX)
					_RowsX[i] = LeaveX->NextC;
				else
					for (CurX=_RowsX[i]; CurX != NULL; CurX = CurX->NextC)
						if (CurX->NextC == LeaveX)
						{
							CurX->NextC = CurX->NextC->NextC;
							break;
						}
				if (_ColsX[j] == LeaveX)
					_ColsX[j] = LeaveX->NextR;
				else
					for (CurX=_ColsX[j]; CurX != NULL; CurX = CurX->NextR)
						if (CurX->NextR == LeaveX)
						{
							CurX->NextR = CurX->NextR->NextR;
							break;
						}

				/* SET _EnterX TO BE THE NEW EMPTY SLOT */
				_EnterX = LeaveX;
			}


			/**********************
					findLoop
			 **********************/
			uint64 findLoop(node2_t **Loop)
			{
				uint64 i, steps;
				node2_t **CurX, *NewX;
				char IsUsed[2*MAX_SIG_SIZE1];

				for (i=0; i < _n1+_n2; i++)
					IsUsed[i] = 0;

				CurX = Loop;
				NewX = *CurX = _EnterX;
				IsUsed[_EnterX-_X] = 1;
				steps = 1;

				do
				{
					if (steps%2 == 1)
					{
						/* FIND AN UNUSED X IN THE ROW */
						NewX = _RowsX[NewX->i];
						while (NewX != NULL && IsUsed[NewX-_X])
							NewX = NewX->NextC;
					}
					else
					{
						/* FIND AN UNUSED X IN THE COLUMN, OR THE ENTERING X */
						NewX = _ColsX[NewX->j];
						while (NewX != NULL && IsUsed[NewX-_X] && NewX != _EnterX)
							NewX = NewX->NextR;
						if (NewX == _EnterX)
							break;
					}

					if (NewX != NULL)  /* FOUND THE NEXT X */
					{
						/* ADD X TO THE LOOP */
						*++CurX = NewX;
						IsUsed[NewX-_X] = 1;
						steps++;
					}
					else  /* DIDN'T FIND THE NEXT X */
					{
						/* BACKTRACK */
						do
						{
							NewX = *CurX;
							do
							{
								if (steps%2 == 1)
									NewX = NewX->NextR;
								else
									NewX = NewX->NextC;
							} while (NewX != NULL && IsUsed[NewX-_X]);

							if (NewX == NULL)
							{
								IsUsed[*CurX-_X] = 0;
								CurX--;
								steps--;
							}
						} while (NewX == NULL && CurX >= Loop);

						IsUsed[*CurX-_X] = 0;
						*CurX = NewX;
						IsUsed[NewX-_X] = 1;
					}
				} while(CurX >= Loop);

				if (CurX == Loop)
				{
					fprintf(stderr, "emd: Unexpected error in findLoop!\n");
					exit(1);
				}

				return steps;
			}



			/**********************
					russel
			 **********************/
			void russel(double *S, double *D)
			{
				uint64 i, j, found, minI = 0, minJ = 0;
				double deltaMin, oldVal, diff;
				double Delta[MAX_SIG_SIZE1][MAX_SIG_SIZE1];
				node1_t Ur[MAX_SIG_SIZE1], Vr[MAX_SIG_SIZE1];
				node1_t uHead, *CurU, *PrevU;
				node1_t vHead, *CurV, *PrevV;
				node1_t *PrevUMinI = NULL, *PrevVMinJ = NULL, *Remember;

				/* INITIALIZE THE ROWS LIST (Ur), AND THE COLUMNS LIST (Vr) */
				uHead.Next = CurU = Ur;
				for (i=0; i < _n1; i++)
				{
					CurU->i = i;
					CurU->val = -INFINITY;
					CurU->Next = CurU+1;
					CurU++;
				}
				(--CurU)->Next = NULL;

				vHead.Next = CurV = Vr;
				for (j=0; j < _n2; j++)
				{
					CurV->i = j;
					CurV->val = -INFINITY;
					CurV->Next = CurV+1;
					CurV++;
				}
				(--CurV)->Next = NULL;

				/* FIND THE MAXIMUM ROW AND COLUMN VALUES (Ur[i] AND Vr[j]) */
				for(i=0; i < _n1 ; i++)
					for(j=0; j < _n2 ; j++)
					{
						float v;
						v = _C[i][j];
						if (Ur[i].val <= v)
							Ur[i].val = v;
						if (Vr[j].val <= v)
							Vr[j].val = v;
					}

				/* COMPUTE THE Delta MATRIX */
				for(i=0; i < _n1 ; i++)
					for(j=0; j < _n2 ; j++)
						Delta[i][j] = _C[i][j] - Ur[i].val - Vr[j].val;

				/* FIND THE BASIC VARIABLES */
				do
				{

					/* FIND THE SMALLEST Delta[i][j] */
					found = 0;
					deltaMin = INFINITY;
					PrevU = &uHead;
					for (CurU=uHead.Next; CurU != NULL; CurU=CurU->Next)
					{
						uint64 i;
						i = CurU->i;
						PrevV = &vHead;
						for (CurV=vHead.Next; CurV != NULL; CurV=CurV->Next)
						{
							uint64 j;
							j = CurV->i;
							if (deltaMin > Delta[i][j])
							{
								deltaMin = Delta[i][j];
								minI = i;
								minJ = j;
								PrevUMinI = PrevU;
								PrevVMinJ = PrevV;
								found = 1;
							}
							PrevV = CurV;
						}
						PrevU = CurU;
					}

					if (! found)
						break;

					/* ADD X[minI][minJ] TO THE BASIS, AND ADJUST SUPPLIES AND COST */
					Remember = PrevUMinI->Next;
					addBasicVariable(minI, minJ, S, D, PrevUMinI, PrevVMinJ, &uHead);

					/* UPDATE THE NECESSARY Delta[][] */
					if (Remember == PrevUMinI->Next)  /* LINE minI WAS DELETED */
					{
						for (CurV=vHead.Next; CurV != NULL; CurV=CurV->Next)
						{
							uint64 j;
							j = CurV->i;
							if (CurV->val == _C[minI][j])  /* COLUMN j NEEDS UPDATING */
							{
								/* FIND THE NEW MAXIMUM VALUE IN THE COLUMN */
								oldVal = CurV->val;
								CurV->val = -INFINITY;
								for (CurU=uHead.Next; CurU != NULL; CurU=CurU->Next)
								{
									uint64 i;
									i = CurU->i;
									if (CurV->val <= _C[i][j])
										CurV->val = _C[i][j];
								}

								/* IF NEEDED, ADJUST THE RELEVANT Delta[*][j] */
								diff = oldVal - CurV->val;
								if (fabs(diff) < 1e-10 * _maxC)
									for (CurU=uHead.Next; CurU != NULL; CurU=CurU->Next)
										Delta[CurU->i][j] += diff;
							}
						}
					}
					else  /* COLUMN minJ WAS DELETED */
					{
						for (CurU=uHead.Next; CurU != NULL; CurU=CurU->Next)
						{
							uint64 i;
							i = CurU->i;
							if (CurU->val == _C[i][minJ])  /* ROW i NEEDS UPDATING */
							{
								/* FIND THE NEW MAXIMUM VALUE IN THE ROW */
								oldVal = CurU->val;
								CurU->val = -INFINITY;
								for (CurV=vHead.Next; CurV != NULL; CurV=CurV->Next)
								{
									uint64 j;
									j = CurV->i;
									if(CurU->val <= _C[i][j])
										CurU->val = _C[i][j];
								}

								/* If NEEDED, ADJUST THE RELEVANT Delta[i][*] */
								diff = oldVal - CurU->val;
								if (fabs(diff) < 1e-10 * _maxC)
									for (CurV=vHead.Next; CurV != NULL; CurV=CurV->Next)
										Delta[i][CurV->i] += diff;
							}
						}
					}
				} while (uHead.Next != NULL || vHead.Next != NULL);
			}


			/**********************
					addBasicVariable
			 **********************/
			void addBasicVariable(uint64 minI, uint64 minJ, double *S, double *D,
					node1_t *PrevUMinI, node1_t *PrevVMinJ,
					node1_t *UHead)
			{
				double T;

				if (fabs(S[minI]-D[minJ]) <= 1e-10 * _maxW)  /* DEGENERATE CASE */
				{
					T = S[minI];
					S[minI] = 0;
					D[minJ] -= T;
				}
				else if (S[minI] < D[minJ])  /* SUPPLY EXHAUSTED */
				{
					T = S[minI];
					S[minI] = 0;
					D[minJ] -= T;
				}
				else  /* DEMAND EXHAUSTED */
				{
					T = D[minJ];
					D[minJ] = 0;
					S[minI] -= T;
				}

				/* X(minI,minJ) IS A BASIC VARIABLE */
				_IsX[minI][minJ] = 1;

				_EndX->val = T;
				_EndX->i = minI;
				_EndX->j = minJ;
				_EndX->NextC = _RowsX[minI];
				_EndX->NextR = _ColsX[minJ];
				_RowsX[minI] = _EndX;
				_ColsX[minJ] = _EndX;
				_EndX++;

				/* DELETE SUPPLY ROW ONLY IF THE EMPTY, AND IF NOT LAST ROW */
				if (S[minI] == 0 && UHead->Next->Next != NULL)
					PrevUMinI->Next = PrevUMinI->Next->Next;  /* REMOVE ROW FROM LIST */
				else
					PrevVMinJ->Next = PrevVMinJ->Next->Next;  /* REMOVE COLUMN FROM LIST */
			}

		private:

			//Distance Function
			Distance _distance;


			/* GLOBAL VARIABLE DECLARATION */
			// comes from the C implementation
			uint64  _n1, _n2;                          /* SIGNATURES SIZES */
			float64 _C[MAX_SIG_SIZE1][MAX_SIG_SIZE1];/* THE COST MATRIX */
			node2_t _X[MAX_SIG_SIZE1*2];            /* THE BASIC VARIABLES VECTOR */
			/* VARIABLES TO HANDLE _X EFFICIENTLY */
			node2_t *_EndX, *_EnterX;
			uint8 _IsX[MAX_SIG_SIZE1][MAX_SIG_SIZE1];
			node2_t *_RowsX[MAX_SIG_SIZE1], *_ColsX[MAX_SIG_SIZE1];
			float64 _maxW;
			float64 _maxC;

			/*!
			 * \endcond SKIP_DOC
			 */

		};

		}
	}
}

#endif /* EMD_HPP_ */
