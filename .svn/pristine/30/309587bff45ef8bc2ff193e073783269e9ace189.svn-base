// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------

/*!
 * \file camera_ptz.test
 * 
 * These unit tests only checks the functions NOT related to the EviLib.
 * To test the functions related to the EviLib we need a camera connected to the serial port of the 
 * test platform, not an option.
 * 
 * \author Albert Gil Moreno
 */ 

#ifdef USE_SMARTFLOW

#include<imageplus/toolbox/camera_ptz.hpp>
//#include<imageplus/multiview.hpp> // to test the "update" function projecting points

BOOST_AUTO_TEST_SUITE ( CameraPTZ_Suite );

using namespace std;
using namespace imageplus;
using namespace imageplus::toolbox;

BOOST_AUTO_TEST_CASE( CameraPTZ_Constructor )
{
    /*
     * Initializing the ptz 1
     */
    CameraPTZ cam( string(TEST_DATA_PATH_R)+"/multiview/calib_ptz1.txt");
    
    /*
     * Creating the expected data
     */
    MultiArray<float64,1> trans(3);
    MultiArray<float64,2> rot  (3,3);
    
    trans[0] = 85.750; trans[1] = 242.721; trans[2] = 42.568;
    
    rot[0][0] = 0; rot[1][0] = 1; rot[2][0] = 0;
    rot[0][1] = 0; rot[1][1] = 0; rot[2][1] = 1;
    rot[0][2] = 1; rot[1][2] = 0; rot[2][2] = 0;
    
    /*
     * Checking the translation and rotation matrix
     */
    for(std::size_t i=0; i<3; ++i)
    {
        BOOST_CHECK_SMALL( cam.trans()[i] - trans[i], 0.001 );
    }
    
    for(std::size_t y=0; y<3; ++y)
    for(std::size_t x=0; x<3; ++x)
    {
        BOOST_CHECK_SMALL( cam.rot()[x][y] - rot[x][y], 0.001 );
    }
}
    
BOOST_AUTO_TEST_CASE( CameraPTZ_xyz2ptz )
{
    /*
     * Initializing the ptz 1
     */
    CameraPTZ cam( string(TEST_DATA_PATH_R)+"/multiview/calib_ptz1.txt");
    
    /*
     * Checking the canversion from xyz to ptz 
     */
    Point3D             xyz; // the xyz to point to    
    CameraPTZ::Position ptz; // the ptz position to point to xyz
    CameraPTZ::Position out; // the test result
    
    /* 
     * point to front to the camera
     */
    xyz.set(300,800,2360);  
    out.set(0,0,0);         
    
    ptz = cam.xyz2ptz(xyz);
    
    for(std::size_t i=0; i<3; ++i)
    {
        BOOST_CHECK_SMALL( ptz[i] - out[i], 0.001 );
    }

    /*
     * point to the right side (90 degree of pan) 
     */
    xyz.set(140, 0, 2360);
    out.set(90*cam.pan_scale_factor(),0,0);
    
    ptz = cam.xyz2ptz(xyz);
    
    for(std::size_t i=0; i<3; ++i)
    {
        BOOST_CHECK_SMALL( ptz[i] - out[i], 0.001 );
    }
    
    /*
     * point just below of the camera (90 degree of tilt)
     * note that we move a 0.01 in x, just to avoid indetermination of pan 
     */
    xyz.set(140.01, 800, 0);
    out.set(0,-90*cam.tilt_scale_factor(),0);
    
    ptz = cam.xyz2ptz(xyz);

    for(std::size_t i=0; i<3; ++i)
    {
        BOOST_CHECK_SMALL( ptz[i] - out[i], 0.001 );
    }
}


BOOST_AUTO_TEST_CASE( CameraPTZ_eval_polynomial )
{
    MultiArray<float64, 1> pol(3);
    
    pol[0] = 3;
    pol[1] = 2;
    pol[2] = 1;
    
    BOOST_CHECK_CLOSE( CameraPTZ::eval_polynomial(pol,   0),     1, 0.0001 );
    BOOST_CHECK_CLOSE( CameraPTZ::eval_polynomial(pol,   1),     6, 0.0001 );
    BOOST_CHECK_CLOSE( CameraPTZ::eval_polynomial(pol, 100), 30201, 0.0001 );
}


/*
 * The "update" function is not working properly, so it is now private. 
 */
//BOOST_AUTO_TEST_CASE ( test_CameraPTZ_projection )
//{
//    Point2D             p2d;
//    Point3D             p3d;
//    CameraPTZ::Position ptz;
//    CameraPTZ           cam( string(TEST_DATA_PATH_R)+"/multiview/calib_ptz1.txt");
//
//    /* 
//     * point to front to the camera
//     */
//    p3d.set(300,800,2360);  
//    ptz = cam.xyz2ptz(p3d);
//
//    cam.update(ptz);
//
//    multiview::fast_world2image( p3d, cam, p2d);
//    
//    std::cout << "p3d: " << p3d << std::endl;
//    std::cout << "ptz: " << ptz << std::endl;
//    std::cout << "p2d: " << p2d << std::endl;
//    
//    BOOST_CHECK_SMALL( p2d[0], 2.0);
//    BOOST_CHECK_SMALL( p2d[1], 2.0);
//}


BOOST_AUTO_TEST_SUITE_END ();

#endif // USE_SMARTFLOW
