// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------

/*!
 * \file label_flatzone.test
 */ 

#include <imageplus/segmentation/label_flatzone.hpp>
#include <imageplus/io/readimage.hpp>

BOOST_AUTO_TEST_SUITE ( Segmentation_Label_Flatzone_Suite );

using namespace imageplus;
using namespace segmentation;
using namespace std;

BOOST_AUTO_TEST_CASE( label_flatzone_simple_test )
{
    ImageRGB<uint8>  image_rgb_in(2,2);
    image_rgb_in(0)[0][0] =  25;  image_rgb_in(0)[1][0] =  25;
    image_rgb_in(1)[0][1] = 233;  image_rgb_in(1)[1][1] = 233;
    
    ImagePartition<uint32> partition_gt(2,2);
    partition_gt[0][0] = 1;  partition_gt[1][0] = 1;
    partition_gt[0][1] = 2;  partition_gt[1][1] = 2;
    
    const FlatZone& my_flatzone = calc_descriptor(new FlatZone(), image_rgb_in);
    
    BOOST_CHECK( my_flatzone==partition_gt );
    BOOST_CHECK( my_flatzone.num_regions()==2);
}

BOOST_AUTO_TEST_CASE( label_flatzone_iterators_test )
{
    ImageGray<uint8> image_gray_in;
    ImageRGB<uint8>  image_rgb_in;
    io::ReadImage readImage;
    readImage.open(string(TEST_DATA_PATH_R) + "/core/imagepartition_real.png");
    readImage >> image_gray_in;
    readImage >> image_rgb_in;
    
    ImagePartition<uint32> partition_gt(image_gray_in.size_x(), image_gray_in.size_y());
    partition_gt(0) = convert<uint32>(image_gray_in(0));
    relabel(partition_gt, partition_gt);
    
    const FlatZone& my_flatzone = calc_descriptor(new FlatZone(), image_rgb_in);
    BOOST_CHECK( my_flatzone==partition_gt );
    
    const FlatZone& my_flatzone_gray = calc_descriptor(new FlatZone(), image_gray_in);
    BOOST_CHECK( my_flatzone_gray==partition_gt );
}

BOOST_AUTO_TEST_CASE( label_flatzone_tolerance_test )
{
    ImageGray<uint8> im(9,5);
    ImagePartition<uint32> partition(9,5);

    im(0) = 100;
    im[1][1] = 1; im[2][1] = 1; im[3][1] = 1; im[4][1] = 100; im[5][1] = 1; im[6][1] = 1; im[7][1] = 1;
    im[1][2] = 1; im[2][2] = 3; im[3][2] = 1; im[4][2] = 100; im[5][2] = 1; im[6][2] = 15; im[7][2] = 1;
    im[1][3] = 1; im[2][3] = 1; im[3][3] = 1; im[4][3] = 100; im[5][3] = 1; im[6][3] = 1; im[7][3] = 1;
    
    std::vector<float64> weights(1,1.);
    
    ImagePartition<uint32> gt(9,5);
    gt[0][0] = 1;    gt[1][0] = 1;    gt[2][0] = 1;    gt[3][0] = 1;    gt[4][0] = 1;    gt[5][0] = 1;    gt[6][0] = 1;    gt[7][0] = 1;    gt[8][0] = 1;  
    gt[0][1] = 1;    gt[1][1] = 2;    gt[2][1] = 2;    gt[3][1] = 2;    gt[4][1] = 1;    gt[5][1] = 3;    gt[6][1] = 3;    gt[7][1] = 3;    gt[8][1] = 1;
    gt[0][2] = 1;    gt[1][2] = 2;    gt[2][2] = 2;    gt[3][2] = 2;    gt[4][2] = 1;    gt[5][2] = 3;    gt[6][2] = 4;    gt[7][2] = 3;    gt[8][2] = 1;
    gt[0][3] = 1;    gt[1][3] = 2;    gt[2][3] = 2;    gt[3][3] = 2;    gt[4][3] = 1;    gt[5][3] = 3;    gt[6][3] = 3;    gt[7][3] = 3;    gt[8][3] = 1;
    gt[0][4] = 1;    gt[1][4] = 1;    gt[2][4] = 1;    gt[3][4] = 1;    gt[4][4] = 1;    gt[5][4] = 1;    gt[6][4] = 1;    gt[7][4] = 1;    gt[8][4] = 1;
    
    typedef FlatZoneTolerance<tolerance_color_norm2> flatzone_type;
    const flatzone_type& my_flatzone = calc_descriptor(new flatzone_type(tolerance_color_norm2(3,weights)), im);
    BOOST_CHECK( my_flatzone==gt );
    BOOST_CHECK( my_flatzone.num_regions()==4 );
}

BOOST_AUTO_TEST_CASE( label_flatzone_tolerance_gradient_test )
{
    ImageGray<uint8> im(9,5);
    ImagePartition<uint32> partition(9,5);

    im(0) = 100;
    im[1][1] = 1; im[2][1] = 1; im[3][1] = 1; im[4][1] = 100; im[5][1] = 1; im[6][1] = 1; im[7][1] = 1;
    im[1][2] = 1; im[2][2] = 3; im[3][2] = 1; im[4][2] = 100; im[5][2] = 1; im[6][2] = 15; im[7][2] = 1;
    im[1][3] = 1; im[2][3] = 1; im[3][3] = 1; im[4][3] = 100; im[5][3] = 1; im[6][3] = 1; im[7][3] = 1;

    std::vector<float64> weights(1,1.);
    uint32 num_reg = label_flatzone_tolerance_gradient(im, partition, tolerance_color_norm2(3,weights));
    
    ImagePartition<uint32> gt(9,5);
    gt[0][0] = 3;    gt[1][0] = 3;    gt[2][0] = 3;    gt[3][0] = 3;    gt[4][0] = 3;    gt[5][0] = 3;    gt[6][0] = 3;    gt[7][0] = 3;    gt[8][0] = 3;  
    gt[0][1] = 3;    gt[1][1] = 1;    gt[2][1] = 1;    gt[3][1] = 1;    gt[4][1] = 3;    gt[5][1] = 2;    gt[6][1] = 2;    gt[7][1] = 2;    gt[8][1] = 3;
    gt[0][2] = 3;    gt[1][2] = 1;    gt[2][2] = 1;    gt[3][2] = 1;    gt[4][2] = 3;    gt[5][2] = 2;    gt[6][2] = 4;    gt[7][2] = 2;    gt[8][2] = 3;
    gt[0][3] = 3;    gt[1][3] = 1;    gt[2][3] = 1;    gt[3][3] = 1;    gt[4][3] = 3;    gt[5][3] = 2;    gt[6][3] = 2;    gt[7][3] = 2;    gt[8][3] = 3;
    gt[0][4] = 3;    gt[1][4] = 3;    gt[2][4] = 3;    gt[3][4] = 3;    gt[4][4] = 3;    gt[5][4] = 3;    gt[6][4] = 3;    gt[7][4] = 3;    gt[8][4] = 3;
    
    BOOST_CHECK( num_reg == 4 );
    BOOST_CHECK( partition == gt );
}

BOOST_AUTO_TEST_CASE( label_flatzone_hole_filling_test )
{
    ImageGray<uint8> im(7,3);
    im[0][0] = 1; im[1][0] = 1; im[2][0] = 1; im[3][0] = 100; im[4][0] = 1; im[5][0] = 1;  im[6][0] = 1;
    im[0][1] = 1; im[1][1] = 3; im[2][1] = 1; im[3][1] = 100; im[4][1] = 1; im[5][1] = 15; im[6][1] = 1;
    im[0][2] = 1; im[1][2] = 1; im[2][2] = 1; im[3][2] = 100; im[4][2] = 1; im[5][2] = 1;  im[6][2] = 1;

    ImagePartition<uint32> partition(7,3);

    ImagePartition<uint32> gt(7,3);    
    gt[0][0] = 1; gt[1][0] = 1; gt[2][0] = 1; gt[3][0] = 2; gt[4][0] = 3; gt[5][0] = 3; gt[6][0] = 3;
    gt[0][1] = 1; gt[1][1] = 4; gt[2][1] = 1; gt[3][1] = 2; gt[4][1] = 3; gt[5][1] = 5; gt[6][1] = 3;
    gt[0][2] = 1; gt[1][2] = 1; gt[2][2] = 1; gt[3][2] = 2; gt[4][2] = 3; gt[5][2] = 3; gt[6][2] = 3;
    
    const FlatZoneHoleFilling& my_flatzone = calc_descriptor(new FlatZoneHoleFilling(1,1), im);
    BOOST_CHECK(my_flatzone==gt);
    BOOST_CHECK(my_flatzone.num_regions() == 5);
    BOOST_CHECK(my_flatzone.id() == "FlatZoneHoleFilling_1_1");
    
    gt[1][1] = 1;
    const FlatZoneHoleFilling& my_flatzone2 = calc_descriptor(new FlatZoneHoleFilling(1,14), im);
    BOOST_CHECK(my_flatzone2==gt);
    BOOST_CHECK(my_flatzone2.num_regions() == 4);
    BOOST_CHECK(my_flatzone2.id() == "FlatZoneHoleFilling_1_14");

    gt[5][1] = 3;
    const FlatZoneHoleFilling& my_flatzone3 = calc_descriptor(new FlatZoneHoleFilling(1,1000), im);
    BOOST_CHECK(my_flatzone3==gt);
    BOOST_CHECK(my_flatzone3.num_regions() == 3);
    BOOST_CHECK_EQUAL(my_flatzone3.id(), "FlatZoneHoleFilling_1_1000");
}

BOOST_AUTO_TEST_SUITE_END ();

