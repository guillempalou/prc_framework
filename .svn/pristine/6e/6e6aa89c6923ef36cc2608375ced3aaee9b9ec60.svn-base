// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------

//!
//!  \file point.test
//!
//!  Tests for the Point classs 
//!

#include <imageplus/core/point.hpp>
#include <boost/math/constants/constants.hpp>

BOOST_AUTO_TEST_SUITE ( suite_point );

using namespace imageplus;
    
BOOST_AUTO_TEST_CASE ( test_Point )
{
    // Default constructor 
    Point<3> p;
    BOOST_CHECK(p.dims() == 3);
    
    // From a multiarray
    MultiArray<float64,1> mpoint(4);
    mpoint[0] = 4;
    mpoint[1] = 3;
    mpoint[2] = 2;
    mpoint[3] = 1;
    
    Point<4> pm(mpoint);
    BOOST_CHECK(pm.dims() == 4);
    BOOST_CHECK(pm[0] == 4);
    BOOST_CHECK(pm[1] == 3);
    BOOST_CHECK(pm[2] == 2);
    BOOST_CHECK(pm[3] == 1);
    
    // Copy constructor
    Point<4> cp(pm);
    BOOST_CHECK(cp.dims() == 4);
    BOOST_CHECK(cp[0] == 4);
    BOOST_CHECK(cp[1] == 3);
    BOOST_CHECK(cp[2] == 2);
    BOOST_CHECK(cp[3] == 1);
    
    // 2 dimension point
    Point<2> p2d(3,2);
    BOOST_CHECK(p2d.dims() == 2);
    BOOST_CHECK(p2d[0] == 3);
    BOOST_CHECK(p2d[1] == 2);

    // 3 dimension point
    Point<3> p3d(4,1,5);
    BOOST_CHECK(p3d.dims() == 3);
    BOOST_CHECK(p3d[0] == 4);
    BOOST_CHECK(p3d[1] == 1);
    BOOST_CHECK(p3d[2] == 5);
        
    // Access methods
    BOOST_CHECK(p3d.x() == 4);
    BOOST_CHECK(p3d.y() == 1);
    BOOST_CHECK(p3d.z() == 5);
    
    p3d.x() = 1;
    p3d.y() = 2;
    p3d.z() = 3;
    
    BOOST_CHECK(p3d.x() == 1);
    BOOST_CHECK(p3d.y() == 2);
    BOOST_CHECK(p3d.z() == 3);
    
    // Assignements
    p = p3d;
    BOOST_CHECK(p == p3d);
    BOOST_CHECK(p.dims() == 3);
    BOOST_CHECK(p.x() == 1);
    BOOST_CHECK(p.y() == 2);
    BOOST_CHECK(p.z() == 3);
}

BOOST_AUTO_TEST_CASE ( test_PointSpheric )
{
    static const double PI = boost::math::constants::pi<double>();
    
    /*
     * Default constructor
     */
    PointSpheric sph;
    BOOST_CHECK_SMALL( sph.radius(), 0.1 );
    BOOST_CHECK_SMALL( sph.theta (), 0.1 );
    BOOST_CHECK_SMALL( sph.phi   (), 0.1 );

    /*
     * Set method and copy constructor
     */
    sph.set(2.5, PI/2, PI/4);
    PointSpheric sph2( sph );
    BOOST_CHECK_CLOSE( sph2.radius(), 2.5 , 0.1 );
    BOOST_CHECK_CLOSE( sph2.theta (), PI/2, 0.1 );
    BOOST_CHECK_CLOSE( sph2.phi   (), PI/4, 0.1 );
    
    /*
     * Assignment operator
     */
    sph.set(4.0, PI/4, -PI/3);
    sph2 = sph;
    BOOST_CHECK_CLOSE( sph2.radius(), 4.0 , 0.1 );
    BOOST_CHECK_CLOSE( sph2.theta (), PI/4, 0.1 );
    BOOST_CHECK_CLOSE( sph2.phi   (),-PI/3, 0.1 );
    
    /*
     * Conversions from cartesian points (Point3D)
     */
    sph = Point3D(10,0,0); // x-axis
    BOOST_CHECK_CLOSE( sph.radius(), 10.0, 0.1 );
    BOOST_CHECK_CLOSE( sph.theta (), PI/2, 0.1 );
    BOOST_CHECK_SMALL( sph.phi   (),       0.1 );
    
    sph = Point3D(0,20,0); // y-axis
    BOOST_CHECK_CLOSE( sph.radius(), 20.0, 0.1 );
    BOOST_CHECK_CLOSE( sph.theta (), PI/2, 0.1 );
    BOOST_CHECK_CLOSE( sph.phi   (), PI/2, 0.1 );

    sph = Point3D(0,0,15); // z-axis
    BOOST_CHECK_CLOSE( sph.radius(), 15.0, 0.1 );
    BOOST_CHECK_SMALL( sph.theta (),       0.1 );
    BOOST_CHECK_SMALL( sph.phi   (),       0.1 );

    sph = Point3D(-10,0,0); // x-axis inverse
    BOOST_CHECK_CLOSE( sph.radius(), 10.0, 0.1 );
    BOOST_CHECK_CLOSE( sph.theta (), PI/2, 0.1 );
    BOOST_CHECK_CLOSE( sph.phi   (), PI  , 0.1 );
    
    sph = Point3D(0,-20,0); // y-axis inverse
    BOOST_CHECK_CLOSE( sph.radius(), 20.0, 0.1 );
    BOOST_CHECK_CLOSE( sph.theta (), PI/2, 0.1 );
    BOOST_CHECK_CLOSE( sph.phi   (),-PI/2, 0.1 );
    
    sph = Point3D(0,0,-15); // z-axis inverse
    BOOST_CHECK_CLOSE( sph.radius(), 15.0, 0.1 );
    BOOST_CHECK_CLOSE( sph.theta (), PI  , 0.1 );
    BOOST_CHECK_SMALL( sph.phi   (),       0.1 );
    
    /*
     * Checking the 8 quadrants
     */
    sph = Point3D(1,1,1);
    BOOST_CHECK_CLOSE( sph.radius(), 1.732 , 0.1 );
    BOOST_CHECK_CLOSE( sph.theta (), 0.955 , 0.1 );
    BOOST_CHECK_CLOSE( sph.phi   (), PI/4  , 0.1 );
    
    sph = Point3D(-1,1,1);
    BOOST_CHECK_CLOSE( sph.radius(), 1.732 , 0.1 );
    BOOST_CHECK_CLOSE( sph.theta (), 0.955 , 0.1 );
    BOOST_CHECK_CLOSE( sph.phi   (), PI*3/4, 0.1 );

    sph = Point3D(1,-1,1);
    BOOST_CHECK_CLOSE( sph.radius(), 1.732 , 0.1 );
    BOOST_CHECK_CLOSE( sph.theta (), 0.955 , 0.1 );
    BOOST_CHECK_CLOSE( sph.phi   (),-PI/4  , 0.1 );

    sph = Point3D(-1,-1,1);
    BOOST_CHECK_CLOSE( sph.radius(), 1.732 , 0.1 );
    BOOST_CHECK_CLOSE( sph.theta (), 0.955 , 0.1 );
    BOOST_CHECK_CLOSE( sph.phi   (),-PI*3/4, 0.1 );

    sph = Point3D(1,1,-1);
    BOOST_CHECK_CLOSE( sph.radius(), 1.732 , 0.1 );
    BOOST_CHECK_CLOSE( sph.theta (), 2.186 , 0.1 );
    BOOST_CHECK_CLOSE( sph.phi   (), PI/4  , 0.1 );

    sph = Point3D(-1,1,-1);
    BOOST_CHECK_CLOSE( sph.radius(), 1.732 , 0.1 );
    BOOST_CHECK_CLOSE( sph.theta (), 2.186 , 0.1 );
    BOOST_CHECK_CLOSE( sph.phi   (), PI*3/4, 0.1 );

    sph = Point3D(1,-1,-1);
    BOOST_CHECK_CLOSE( sph.radius(), 1.732 , 0.1 );
    BOOST_CHECK_CLOSE( sph.theta (), 2.186 , 0.1 );
    BOOST_CHECK_CLOSE( sph.phi   (),-PI/4  , 0.1 );

    sph = Point3D(-1,-1,-1);
    BOOST_CHECK_CLOSE( sph.radius(), 1.732 , 0.1 );
    BOOST_CHECK_CLOSE( sph.theta (), 2.186 , 0.1 );
    BOOST_CHECK_CLOSE( sph.phi   (),-PI*3/4, 0.1 );
    
    /*
     * Zero is zero
     */
    sph = Point3D(0,0,0);
    BOOST_CHECK_SMALL( sph.radius(), 0.1 );
    BOOST_CHECK_SMALL( sph.theta (), 0.1 );
    BOOST_CHECK_SMALL( sph.phi   (), 0.1 );
}

#ifndef NDEBUG
BOOST_AUTO_TEST_CASE ( test_PointSpheric_debug )
{
    static const double PI = boost::math::constants::pi<double>();

    /*
     * Testing out of range values in constructor
     */
    BOOST_CHECK_THROW(PointSpheric(-1,  0,    0), ImagePlusInternalError);
    BOOST_CHECK_THROW(PointSpheric( 0,-PI,    0), ImagePlusInternalError);
    BOOST_CHECK_THROW(PointSpheric( 0,  0, 2*PI), ImagePlusInternalError);

    /*
     * Testing out of range values in the "set" methods
     */
    PointSpheric sph;
    BOOST_CHECK_THROW(sph.set(-2,   0,    0), ImagePlusInternalError);
    BOOST_CHECK_THROW(sph.set(0,-PI/2,    0), ImagePlusInternalError);
    BOOST_CHECK_THROW(sph.set(0,    0,-3*PI), ImagePlusInternalError);
    
    /*
     * Testing out of range values in accessors
     */
    BOOST_CHECK_THROW(sph.radius(   -3), ImagePlusInternalError);
    BOOST_CHECK_THROW(sph.theta (-PI/3), ImagePlusInternalError);
    BOOST_CHECK_THROW(sph.phi   ( 4*PI), ImagePlusInternalError);
}
#endif // NDEBUG

BOOST_AUTO_TEST_SUITE_END ();
