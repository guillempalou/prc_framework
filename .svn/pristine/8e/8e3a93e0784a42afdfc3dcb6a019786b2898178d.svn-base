// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------

//!
//!  \file readmultiarray.hpp
//!
//!  Class for reading MultiArrays from disk
//!

#ifndef IMAGEPLUS_IO_READMULTIARRAY_HPP
#define IMAGEPLUS_IO_READMULTIARRAY_HPP

#include <string>
#include <fstream>

#include <imageplus/core.hpp>
#include <imageplus/core/mesh.hpp>


#include <imageplus/io/io_types.hpp>

namespace imageplus
{

    namespace io
    {


        //!
        //! \brief class for reading a MultiArray from disk
        //!
        //! CAREFUL!! This code only works if writing and reading are done in the same
        //! little/big endian machine! as there are no little-endian big endian conversions.
        //!
        //! Usage:
        //! \code
        //!    MultiArray<int64,2> m;
        //!    ...
        //!    io::ReadMultiArray readMultiArray("prova.multi");
        //!    readMultiArray >> m;
        //! \endcode
        //!
        //! \todo Add suport for NONE compression for types != uint8
        //!
        //! \author Javier Ruiz Hidalgo <j.ruiz@upc.edu>
        //! \date 18-4-2008
        //!
        class ReadMultiArray
        {

            public:

                //!
                //! \brief Constructor from file name
                //!
                //! \param[in] filename  : File name
                //!
                explicit ReadMultiArray( const std::string& filename );

                //!
                //! \brief basic Constructor
                //!
                ReadMultiArray();

                //!
                //! \brief open filename
                //!
                //! \param[in] filename  : File name with data on disk
                //!
                void open( const std::string& filename );

                //!
                //! \brief Destructor
                //!
                ~ReadMultiArray();

                //!
                //! \brief Operator to read a multiarray
                //!
                //! \tparam M : template must be a MultiArray<T,D>
                //!
                //! \param[in] m : Destination multiarray
                //!
                template<class M>
                void operator>>(M& m) const
                {

                    // Open file
                    std::ifstream fp (_filename.c_str(), std::ios::in | std::ios::binary);
                    if (!fp.is_open())
                    {
                        throw ImagePlusFileNotFound(_filename);
                    }
                    
                    // read magic number to start of file
                    uint16 mn;
                    fp.read((char*)&mn,sizeof(mn));
                    if (mn != MULT_MAGIC_NUMBER)
                    {
                        throw ImagePlusError("Magic number does not exists in the file");
                    }
                    
                    // read filetype
                    uint8 ft;
                    fp.read((char*)&ft,sizeof(ft));
                    if (ft != MULT_FILETYPE)
                    {
                        throw ImagePlusError("File type is not multiarray");
                    }
                    
                    // read compress
                    uint8 c;
                    fp.read((char*)&c,sizeof(c));
                    CompressType compress = static_cast<CompressType>(c);
                    
                    // read datatype
                    uint8 dt;
                    fp.read((char*)&dt,sizeof(dt));
                    DataType datatype = static_cast<DataType>(dt);
                    
                    // read dimensions
                    uint64 d;
                    fp.read((char*)&d,sizeof(d));

                    ASSERT(d == M::dimensions, "Diferent MA dimensions!!");
                    
                    std::vector<uint64> dims(d);
                    for (uint64 i = 0; i < d; i++)
                    {
                        uint64 s;
                        fp.read((char*)&s,sizeof(s));
                        dims[i] = s;
                    }
                    
                    _read(fp,datatype,compress,dims,m);
                    
                    // finished
                    fp.close();

                }
                
                /*!
                 * Operator to read a multiarray file and store its contents to a FaceVertexMesh.
                 * 
                 * This operator assumes that the input file is a MultiArray<int64,3> where and its values repressent
                 * the X,Y,Z coordinates in milimeters of a "image" of 3D points.
                 * 
                 * This operator is used when working with Time-Of-Fly cameras.
                 * 
                 * \param[in] mesh : The mesh to be overwritted with the data readed
                 * 
                 * \author Albert Gil Moreno <albert.gil@upc.edu>
                 */ 
                void operator>>(FaceVertexMesh& mesh) const
                {
                    /*
                     * Read the multiarray
                     */
                    MultiArray<int64,3> ma;
                    (*this) >> ma;

                    /*
                     * Add point to a temporal mesh
                     * 
                     * \todo reset the input mesh and add points there directly
                     */
                    FaceVertexMesh mesh_tmp;
                    float64 scale = 1000.0; //we assume integers in mm
                    for( std::size_t y=0; y<ma.dims(1); ++y)
                    {
                        for( std::size_t x=0; x<ma.dims(0); ++x)
                        {
                            mesh_tmp.add_vertex( Point3D(ma[x][y][0]/scale, ma[x][y][1]/scale, ma[x][y][2]/scale) );
                        }
                    }

                    /*
                     * Overwrite the input mesh with the temporal
                     */
                    mesh = mesh_tmp;
                }

            private:

                //! Stores the file name in disk
                std::string _filename;

                //!
                //! \brief Private and overloaded method to read a MultiArray<uint8,D>
                //!
                //! \tparam  D : The number of dimensions of the multiarray
                //!
                //! \param[in]       fp : File pointer with data to read
                //! \param[in]       dt : DataType format in disk
                //! \param[in] compress : Compression format in disk
                //! \param[in]     dims : Dimesions of the multiarray in disk
                //! \param[in]        m : Destination multiarray
                //!
                //!
                template<int D>
                void _read_multiarray(std::ifstream& fp,
                                      DataType dt,
                                      CompressType compress,
                                      std::vector<uint64>& dims,
                                      MultiArray<uint8,D>& m) const throw (ImagePlusFileNotFound, ImagePlusError);
                
                //!
                //! \brief Private and overloaded method to read a MultiArray<uint32,D>
                //!
                //! \tparam  D : The number of dimensions of the multiarray
                //!
                //! \param[in]       fp : File pointer with data to read
                //! \param[in]       dt : DataType format in disk
                //! \param[in] compress : Compression format in disk
                //! \param[in]     dims : Dimesions of the multiarray in disk
                //! \param[in]        m : Destination multiarray
                //!
                //!
                template<int D>
                void _read_multiarray(std::ifstream& fp,
                                      DataType dt,
                                      CompressType compress,
                                      std::vector<uint64>& dims,
                                      MultiArray<uint32,D>& m) const throw (ImagePlusFileNotFound, ImagePlusError);
                

                //!
                //! \brief Private and overloaded method to read a MultiArray<int64,D>
                //!
                //! Used in operator>>(FaceVertexMesh& mesh)
                //!
                //! \tparam  D : The number of dimensions of the multiarray
                //!
                //! \param[in]       fp : File pointer with data to read
                //! \param[in]       dt : DataType format in disk
                //! \param[in] compress : Compression format in disk
                //! \param[in]     dims : Dimesions of the multiarray in disk
                //! \param[in]        m : Destination multiarray
                //!
                template<int D>
                void _read_multiarray(std::ifstream& fp,
                                      DataType dt,
                                      CompressType compress,
                                      std::vector<uint64>& dims,
                                      MultiArray<int64,D>& m ) const throw (ImagePlusFileNotFound, ImagePlusError);

                
                //!
                //! \brief Private and overloaded method to read a MultiArray<float64,D>
                //!
                //! \tparam  D : The number of dimensions of the multiarray
                //!
                //! \param[in]       fp : File pointer with data to read
                //! \param[in]       dt : DataType format in disk
                //! \param[in] compress : Compression format in disk
                //! \param[in]     dims : Dimesions of the multiarray in disk
                //! \param[in]        m : Destination multiarray
                //!
                //!
                template<int D>
                void _read_multiarray(std::ifstream& fp,
                                      DataType dt,
                                      CompressType compress,
                                      std::vector<uint64>& dims,
                                      MultiArray<float64,D>& m) const throw (ImagePlusFileNotFound, ImagePlusError);

                //!
                //! \brief Private and overloaded method to read a MultiArray<uint8,1>
                //!
                //! This is one big hack to avoid using templates inside multiarrays in the operator>> function. This way one can use
                //! readmultiarray >> m instead of readmultiarray.operator>><uint8,1>( m )
                //!
                //! So operator>> calls directly a function *without* templates (_read)
                //!
                //! After that _read can call any templated function but it must use <uint8,1> in the code.
                //! If you want to use more dimensions you must add more lines of code here.
                //!
                //! \param[in]       fp : File pointer with data to read
                //! \param[in]       dt : DataType format in disk
                //! \param[in] compress : Compression format in disk
                //! \param[in]     dims : Dimesions of the multiarray in disk
                //! \param[in]        m : Destination multiarray
                //!
                void _read(std::ifstream& fp,
                           DataType dt,
                           CompressType compress,
                           std::vector<uint64>& dims,
                           MultiArray<uint8,1>& m) const throw (ImagePlusFileNotFound, ImagePlusError)
                {
                    _read_multiarray<1>(fp,dt,compress,dims,m);
                }

                //!
                //! \brief Private and overloaded method to read a MultiArray<uint8,2>
                //!
                //! \param[in]       fp : File pointer with data to read
                //! \param[in]       dt : DataType format in disk
                //! \param[in] compress : Compression format in disk
                //! \param[in]     dims : Dimesions of the multiarray in disk
                //! \param[in]        m : Destination multiarray
                //!
                void _read(std::ifstream& fp,
                           DataType dt,
                           CompressType compress,
                           std::vector<uint64>& dims,
                           MultiArray<uint8,2>& m) const throw (ImagePlusFileNotFound, ImagePlusError)
                {
                    _read_multiarray<2>(fp,dt,compress,dims,m);
                }

                //!
                //! \brief Private and overloaded method to read a MultiArray<uint8,3>
                //!
                //! \param[in]       fp : File pointer with data to read
                //! \param[in]       dt : DataType format in disk
                //! \param[in] compress : Compression format in disk
                //! \param[in]     dims : Dimesions of the multiarray in disk
                //! \param[in]        m : Destination multiarray
                //!
                void _read(std::ifstream& fp,
                           DataType dt,
                           CompressType compress,
                           std::vector<uint64>& dims,
                           MultiArray<uint8,3>& m) const throw (ImagePlusFileNotFound, ImagePlusError)
                {
                    _read_multiarray<3>(fp,dt,compress,dims,m);
                }

                //!
                //! \brief Private and overloaded method to read a MultiArray<uint32,1>
                //!
                //! This is one big hack to avoid using templates inside multiarrays in the operator>> function. This way one can use
                //! readmultiarray >> m instead of readmultiarray.operator>><uint32,1>( m )
                //!
                //! So operator>> calls directly a function *without* templates (_read)
                //!
                //! After that _read can call any templated function but it must use <uint32,1> in the code.
                //! If you want to use more dimensions you must add more lines of code here.
                //!
                //! \param[in]       fp : File pointer with data to read
                //! \param[in]       dt : DataType format in disk
                //! \param[in] compress : Compression format in disk
                //! \param[in]     dims : Dimesions of the multiarray in disk
                //! \param[in]        m : Destination multiarray
                //!
                void _read(std::ifstream& fp,
                           DataType dt,
                           CompressType compress,
                           std::vector<uint64>& dims,
                           MultiArray<uint32,1>& m) const throw (ImagePlusFileNotFound, ImagePlusError)
                {
                    _read_multiarray<1>(fp,dt,compress,dims,m);
                }

                //!
                //! \brief Private and overloaded method to read a MultiArray<uint32,2>
                //!
                //! \param[in]       fp : File pointer with data to read
                //! \param[in]       dt : DataType format in disk
                //! \param[in] compress : Compression format in disk
                //! \param[in]     dims : Dimesions of the multiarray in disk
                //! \param[in]        m : Destination multiarray
                //!
                void _read(std::ifstream& fp,
                           DataType dt,
                           CompressType compress,
                           std::vector<uint64>& dims,
                           MultiArray<uint32,2>& m) const throw (ImagePlusFileNotFound, ImagePlusError)
                {
                    _read_multiarray<2>(fp,dt,compress,dims,m);
                }

                //!
                //! \brief Private and overloaded method to read a MultiArray<uint32,3>
                //!
                //! \param[in]       fp : File pointer with data to read
                //! \param[in]       dt : DataType format in disk
                //! \param[in] compress : Compression format in disk
                //! \param[in]     dims : Dimesions of the multiarray in disk
                //! \param[in]        m : Destination multiarray
                //!
                void _read(std::ifstream& fp,
                           DataType dt,
                           CompressType compress,
                           std::vector<uint64>& dims,
                           MultiArray<uint32,3>& m) const throw (ImagePlusFileNotFound, ImagePlusError)
                           {
                	_read_multiarray<3>(fp,dt,compress,dims,m);
                           }


                //!
                //! \brief Private and overloaded method to read a MultiArray<uint32,3>
                //!
                //! \param[in]       fp : File pointer with data to read
                //! \param[in]       dt : DataType format in disk
                //! \param[in] compress : Compression format in disk
                //! \param[in]     dims : Dimesions of the multiarray in disk
                //! \param[in]        m : Destination multiarray
                //!
                void _read(std::ifstream& fp,
                		DataType dt,
                		CompressType compress,
                		std::vector<uint64>& dims,
                		MultiArray<int64,2>& m) const throw (ImagePlusFileNotFound, ImagePlusError)
                		{
                	_read_multiarray<2>(fp,dt,compress,dims,m);
                		}

                //!
                //! \brief Private and overloaded method to read a MultiArray<uint32,3>
                //!
                //! \param[in]       fp : File pointer with data to read
                //! \param[in]       dt : DataType format in disk
                //! \param[in] compress : Compression format in disk
                //! \param[in]     dims : Dimesions of the multiarray in disk
                //! \param[in]        m : Destination multiarray
                //!
                void _read(std::ifstream& fp,
                           DataType dt,
                           CompressType compress,
                           std::vector<uint64>& dims,
                           MultiArray<int64,3>& m) const throw (ImagePlusFileNotFound, ImagePlusError)
                {
                    _read_multiarray<3>(fp,dt,compress,dims,m);                   
                }

                
                //!
                //! \brief Private and overloaded method to read a MultiArray<float64,1>
                //!
                //! This is one big hack to avoid using templates inside multiarrays in the operator>> function. This way one can use
                //! readmultiarray >> m instead of readmultiarray.operator>><float64,1>( m )
                //!
                //! So operator>> calls directly a function *without* templates (_read)
                //!
                //! After that _read can call any templated function but it must use <float64,1> in the code.
                //! If you want to use more dimensions you must add more lines of code here.
                //!
                //! \param[in]       fp : File pointer with data to read
                //! \param[in]       dt : DataType format in disk
                //! \param[in] compress : Compression format in disk
                //! \param[in]     dims : Dimesions of the multiarray in disk
                //! \param[in]        m : Destination multiarray
                //!
                void _read(std::ifstream& fp,
                           DataType dt,
                           CompressType compress,
                           std::vector<uint64>& dims,
                           MultiArray<float64,1>& m) const throw (ImagePlusFileNotFound, ImagePlusError)
                {
                    _read_multiarray<1>(fp,dt,compress,dims,m);
                }

                //!
                //! \brief Private and overloaded method to read a MultiArray<float64,2>
                //!
                //! \param[in]       fp : File pointer with data to read
                //! \param[in]       dt : DataType format in disk
                //! \param[in] compress : Compression format in disk
                //! \param[in]     dims : Dimesions of the multiarray in disk
                //! \param[in]        m : Destination multiarray
                //!
                void _read(std::ifstream& fp,
                           DataType dt,
                           CompressType compress,
                           std::vector<uint64>& dims,
                           MultiArray<float64,2>& m) const throw (ImagePlusFileNotFound, ImagePlusError)
                {
                    _read_multiarray<2>(fp,dt,compress,dims,m);
                }

                //!
                //! \brief Private and overloaded method to read a MultiArray<float64,3>
                //!
                //! \param[in]       fp : File pointer with data to read
                //! \param[in]       dt : DataType format in disk
                //! \param[in] compress : Compression format in disk
                //! \param[in]     dims : Dimesions of the multiarray in disk
                //! \param[in]        m : Destination multiarray
                //!
                void _read(std::ifstream& fp,
                           DataType dt,
                           CompressType compress,
                           std::vector<uint64>& dims,
                           MultiArray<float64,3>& m) const throw (ImagePlusFileNotFound, ImagePlusError)
                {
                    _read_multiarray<3>(fp,dt,compress,dims,m);
                }

        };


    } // namespace io

} //namespace imageplus

#endif
