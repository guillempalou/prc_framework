// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------

//!
//!  \file rotations.cpp
//!
//!  Rotation matrices representations
//!

#include <imageplus/math/geometry/rotations.hpp>

#include <imageplus/core.hpp>

using namespace imageplus;

template<typename T>
MultiArray<T,1> imageplus::math::geometry::rot_matrix_to_vector(const MultiArray<T,2> m)
{
    MultiArray<T,1> v( 4 );
    
    v.data()[3] = acos((m.data()[0] + m.data()[4] + m.data()[8] - 1) * 0.5);
    if (v.data()[3] == 0.0) {
        v.data()[0] = 1.0; v.data()[1] = 0.0; v.data()[2] = 0.0;
    } else {
        T factor = v.data()[3] * 0.5 / sin(v.data()[3]);
        v.data()[0] = factor * (m.data()[7] - m.data()[5]);
        v.data()[1] = factor * (m.data()[2] - m.data()[6]);
        v.data()[2] = factor * (m.data()[3] - m.data()[1]);
    }

    return v;
}

template<typename T>
MultiArray<T,2> imageplus::math::geometry::rot_vector_to_matrix(const MultiArray<T,1> v)
{
    MultiArray<T,2> m( 3, 3 );
    
    T u2 = v.data()[0] * v.data()[0];
    T v2 = v.data()[1] * v.data()[1];
    T w2 = v.data()[2] * v.data()[2];
    T co = cos(v.data()[3]);
    T u2v2cos = (u2 + v2) * co;
    T u2w2cos = (u2 + w2) * co;
    T v2w2cos = (v2 + w2) * co;
    T uv1cos = v.data()[0] * v.data()[1] * (1 - co);
    T uw1cos = v.data()[0] * v.data()[2] * (1 - co);
    T vw1cos = v.data()[1] * v.data()[2] * (1 - co);
    T mod = u2 + v2 + w2;
    T sqrtsin = std::sqrt(mod) * sin(v.data()[3]);
    mod = 1.0 / mod;
    m.data()[0]=(u2+v2w2cos)*mod;                   m.data()[1]=(uv1cos-v.data()[2]*sqrtsin)*mod;   m.data()[2]=(uw1cos+v.data()[1]*sqrtsin)*mod;
    m.data()[3]=(uv1cos+v.data()[2]*sqrtsin)*mod;   m.data()[4]=(v2+u2w2cos)*mod;                   m.data()[5]=(vw1cos-v.data()[0]*sqrtsin)*mod;
    m.data()[6]=(uw1cos-v.data()[1]*sqrtsin)*mod;   m.data()[7]=(vw1cos+v.data()[0]*sqrtsin)*mod;   m.data()[8]=(w2+u2v2cos)*mod;

    return m;
}

namespace imageplus
{
    namespace math
    {
        namespace geometry
        {
            template MultiArray<float64,1> rot_matrix_to_vector(const MultiArray<float64,2> m);
            
            template MultiArray<float64,2> rot_vector_to_matrix(const MultiArray<float64,1> v);
        }
    }
}
