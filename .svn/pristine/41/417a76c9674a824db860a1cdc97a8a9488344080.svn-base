// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------

/*!
 * \file color.hpp
 */

#ifndef IMAGEPLUS_CORE_COLOR_HPP
#define IMAGEPLUS_CORE_COLOR_HPP

#include <boost/array.hpp>
#include <imageplus/core/imageplus_types.hpp>

namespace imageplus
{
    /*!
     * Class to handle colors, not views
     */
    /*!
     * \cond SKIP_DOC
     *
     * Private classes and types to handle color views (not in public documentation)
     */
    template< typename view_type, std::size_t N, class ContainerBase >
    class ColorViewBase;


    template<typename T, std::size_t N>
    class ExternalColor : public boost::array< T, N >
    {
        typedef boost::array< T, N >  Base;
    public:

        typedef typename Base::value_type   data_type;

        ExternalColor()
        {}

        template<typename T2>
        ExternalColor(const boost::array<T2,N>& cpy)
        {
            Base::operator=(cpy);
        }

        template< typename another_view_type, class AnotherContainerBase>
        ExternalColor(const ColorViewBase<another_view_type, N, AnotherContainerBase>& cc)
        {
            (*this) = cc;
        }

        ExternalColor(data_type init_data)
        {
            this->assign(init_data);
        }


//        const Color& operator++()
//        {
//            for (std::size_t i=0; i<this->size(); i++) ++(*this)[i];
//            return *this;
//        }


        template<typename T2>
        const ExternalColor& operator=(const boost::array<T2,N>& cpy)
        {
            Base::operator=(cpy);
            return *this;
        }

        const data_type& operator=(const data_type& val)
        {
            for (std::size_t i=0; i<this->size(); i++) (*this)[i] = val;
            return val;
        }

//                const ColorBase& operator=(const ColorBase& copy)
//                {
//                    ColorBase::operator=(copy);
//                    return copy;
//                }

        template< typename another_view_type, class AnotherContainerBase>
        const ExternalColor& operator=(const ColorViewBase<another_view_type,N, AnotherContainerBase>& copy)
        {
            for (std::size_t i=0; i<this->size(); i++) (*this)[i] = copy[i];
            return *this;
        }

//                template< typename AnotherColor>
//                const Color& operator=(const AnotherColor& copy)
//                {
//                    for (std::size_t i=0; i<this->size(); i++) (*this)[i] = copy[i];
//                    return *this;
//                }

    };

    template<typename T, std::size_t N>
    ExternalColor<T,N> operator*(const ExternalColor<T,N>& color, const T& scalar)
    {
        ExternalColor<T,N> out;
        for (std::size_t ii=0; ii < color.size(); ++ii) out[ii] = color[ii] * scalar;

        return out;
    }

    template< typename view_type, std::size_t N, class ContainerBase >
    class ColorViewBase : public ContainerBase
    {
        template<typename TT, std::size_t NN, std::size_t DD>
        friend class ImaVol;

    public:

        typedef typename ContainerBase::value_type conainter_data;
        typedef view_type             data_type;
        typedef ExternalColor<view_type,N>    Color;

        view_type& operator[](std::size_t idx)
        {
            return *(ContainerBase::operator[](idx) );
        }

        const view_type& operator[](std::size_t idx) const
        {
            return *(ContainerBase::operator[](idx) );
        }

        const ColorViewBase& operator=(const Color& copy)
        {
            for (std::size_t i=0; i<this->size(); i++) (*this)[i] = copy[i];
            return *this;
        }

        const ColorViewBase& operator=(const ColorViewBase& copy)
        {
            for (std::size_t i=0; i<this->size(); i++) (*this)[i] = copy[i];
            return *this;
        }

        const view_type& operator=(const view_type& val)
        {
            for (std::size_t i=0; i<this->size(); i++) (*this)[i] = val;
            return val;
        }

        // TODO - AGIL: this should be moved to an iostream file
        friend
        std::ostream& operator<<(std::ostream& os, const ColorViewBase& m)
        {
            typedef typename ColorViewBase::data_type data_type;

            for (std::size_t i=0; i<m.size(); i++)
            {
                os.width(3);
                if (sizeof(view_type) == 1)
                {
                    os << static_cast<int16>(m[i]);
                }
                else
                {
                    os << m[i];
                }
                os << "  ";
            }
            return os;
        }

        friend
        Color operator+(const ColorViewBase& view1, const ColorViewBase& view2)
        {
            Color out;

            for (std::size_t i=0; i<out.size(); ++i) out[i] = view1[i] + view2[i];

            return out;
        }


        template<typename T2>
        friend
        ExternalColor<T2,N> operator+(const ColorViewBase& view, const ExternalColor<T2,N>& col)
        {
            ExternalColor<T2,N> out;

            for (std::size_t i=0; i<out.size(); ++i) out[i] = view[i] + col[i];

            return out;
        }

        template<typename T2>
        friend
        ExternalColor<T2,N> operator+(const ExternalColor<T2,N>& col, const ColorViewBase& view)
        {
            return view + col;
        }

        friend
        ColorViewBase operator/=(const ColorViewBase& view, const view_type& scalar)
        {
            for (std::size_t i=0; i<view.size(); ++i) view[i] = view[i] / scalar;
            return view;
        }

        friend
        bool operator==(const Color& col, const ColorViewBase& view)
        {
            for (std::size_t i=0; i<col.size(); i++)
            {
                if(col[i] != view[i]) return false;
            }
            return true;
        }

        friend
        bool operator==(const ColorViewBase& view, const Color& col)
        {
            return col == view;
        }

        friend
        bool operator==(const ColorViewBase& view1, const ColorViewBase& view2)
        {
            for (std::size_t i=0; i<view1.size(); i++)
            {
                if(view1[i] != view2[i]) return false;
            }
            return true;

        }

        // Implicit cast to Color.
        // Needed to pass a view as a Color
        //operator const Color() const
        template<typename T>
        operator const ExternalColor<T,N>() const
        {
            //Color col;
            ExternalColor<T,N> col;
            for (std::size_t i=0; i<this->size(); i++) col[i] = (*this)[i];
            return col;
        }

        template<typename T>
        ExternalColor<T,N> color() const
        {
            //ExternalColor<view_type,N> col = *this;
            ExternalColor<T,N> col;
            for (std::size_t i=0; i<this->size(); i++) col[i] = (*this)[i];
            return col;
        }

    public:

        void assign_ptr(std::size_t idx, conainter_data /*view_type**/ ptr)
        {
            ContainerBase::operator[](idx) = ptr;
        }
    };

    /*! \endcond */





#if 0
    
    /*!
     * \cond SKIP_DOC 
     * 
     * Private classes and types to handle color views (not in public documentation)
     * 
     * \author Albert Gil Moreno <albert.gil@upc.edu>
     */
    
    template< typename view_type, std::size_t channels, class ContainerBase = boost::array<view_type*, channels> >
    class ColorViewBase : public ContainerBase
    {
        template<typename T, std::size_t N, std::size_t D>
        friend class ImaVol;
        
        template< class IteratorType >
        friend class ChannelIterator; 
        
    public:
        
        typedef view_type                            data_type;
        typedef boost::array< data_type, channels >  ColorBase;
        
        
        /*!
         * Class to handle colors, not views
         */
        class Color : public ColorBase
        {
        public:
            
            typedef typename ColorBase::value_type   data_type;
            
            Color()
            {
            }
            
            Color(data_type init_data)
            {
                (*this) = init_data;
            }
            
            const Color& operator++()
            {
                for (std::size_t i=0; i<this->size(); i++) ++(*this)[i];
                return *this;
            }

            
            const data_type& operator=(const data_type& val)
            {
                for (std::size_t i=0; i<this->size(); i++) (*this)[i] = val;
                return val;
            }
            
            const ColorBase& operator=(const ColorBase& copy)
            {
                ColorBase::operator=(copy);
                return copy;
            }
        };
        
        view_type& operator[](std::size_t idx)
        {
            return *(ContainerBase::operator[](idx) );
        }
        
        const view_type& operator[](std::size_t idx) const
        {
            return *(ContainerBase::operator[](idx) );
        }
        
        const ColorBase& operator=(const ColorBase& copy)
        {
            for (std::size_t i=0; i<this->size(); i++) (*this)[i] = copy[i];
            return copy;
        }
        
        const ColorViewBase& operator=(const ColorViewBase& copy)
        {
            for (std::size_t i=0; i<this->size(); i++) (*this)[i] = copy[i];
            return copy;
        }

        
        const view_type& operator=(const view_type& val)
        {
            for (std::size_t i=0; i<this->size(); i++) (*this)[i] = val;
            return val;
        }
        
        // TODO - AGIL: this should be moved to an iostream file  
        friend
        std::ostream& operator<<(std::ostream& os, const ColorViewBase& m)
        {
            typedef typename ColorViewBase::data_type data_type;
            
            for (std::size_t i=0; i<m.size(); i++)
            {
                os.width(3);
                if (sizeof(data_type) == 1)
                {
                    os << static_cast<int16>(m[i]);
                }
                else
                {
                    os << m[i];
                }
                os << "  ";
            }
            return os;
        }

        friend
        Color operator+(const ColorViewBase& view1, const ColorViewBase& view2)
        {
            Color out;
            
            for (std::size_t i=0; i<out.size(); ++i) out[i] = view1[i] + view2[i];

            return out;
        }
        
        friend
        ColorBase operator+(const ColorViewBase& view, const ColorBase& col)
        {
            ColorBase out;
            
            for (std::size_t i=0; i<out.size(); ++i) out[i] = view[i] + col[i];

            return out;
        }
        
        friend
        ColorBase operator+(const ColorBase& col, const ColorViewBase& view)
        {
            return view + col;
        }
        
        friend
        bool operator==(const Color& col, const ColorViewBase& view)
        {
            for (std::size_t i=0; i<col.size(); i++)
            {
                if(col[i] != view[i]) return false;
            }        
            return true;
        }
        
        friend
        bool operator==(const ColorViewBase& view, const Color& col)
        {
            return col == view;
        }
        
        friend
        bool operator==(const ColorViewBase& view1, const ColorViewBase& view2)
        {
            for (std::size_t i=0; i<view1.size(); i++)
            {
                if(view1[i] != view2[i]) return false;
            }        
            return true;

        }
        
        // Implicit cast to Color.
        // Needed to pass a view as a Color
        operator const Color() const  
        {
            Color col;
            for (std::size_t i=0; i<this->size(); i++) col[i] = (*this)[i];
            return col;
        }
        
    public:
        
        void assign_ptr(std::size_t idx, view_type* ptr)
        {   
            ContainerBase::operator[](idx) = ptr;
        }

    };
    
    /*! \endcond */
#endif
}

#endif
