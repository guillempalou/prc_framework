// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------

//!
//!  \file pixel_channel_pdf.hpp
//!
//!  Class to compute histograms from pixels using patch similarities (NL-means algorithm)
//!

#ifndef IMAGEPLUS_MATH_STATISTICS_PIXEL_CHANNEL_PDF_HPP
#define IMAGEPLUS_MATH_STATISTICS_PIXEL_CHANNEL_PDF_HPP

#include <imageplus/core/visual_descriptors.hpp>
#include <imageplus/core/border.hpp>
#include <imageplus/descriptors/geometry/centered_squared_window.hpp>
#include <imageplus/core/quantizer.hpp>
#include <imageplus/core/iterator.hpp>
#include <boost/array.hpp>

namespace imageplus
{
    namespace math
    {
        namespace statistics
        {
        	/*!
        	 * Descriptor that is used to estimte the pixel histogram used the Non-local means algorithm
        	 * For more details of how this works read the paper from Buades et al. "A Non-Local Algorithm for Image Denoising"
        	 * \author Guillem Palou <guillem.palou@upc.edu>
			 * \date 16-07-2010
			 */
            template< class InputModel, typename T = float64>
            class PixelChannelPDF :	 public DescriptorBase,
                                     public boost::array<std::vector<T>, InputModel::channels>
            {
            public:

                //! The data_type of expected input data.
                typedef typename InputModel::data_type data_type;
                //! Coordinates type
                typedef Neighborhood2D::CoordType CoordType;

                //! Container to the channel histogram
                typedef std::vector<T> channel_type;
                //! Container to the pixel histogram
                typedef boost::array<channel_type, InputModel::channels> vd_type;

                //! Number of channels
                static const std::size_t channels  = InputModel::channels;

                /*! \brief Constructor
                 * \param[in] min_value : min value of the pixels
                 * \param[in] max_value : max value of the pixels
                 * \param[in] num_bins : number of bins to divide the histogram
                 * \param[in] h : filtering parameter. Be aware of touching this value.
                 */
                PixelChannelPDF( data_type min_value = 0, data_type max_value = 255, size_type num_bins = 256, float64 h = 30 )
                    : DescriptorBase("PixelChannelPDF",true)
                {
                    ASSERT( num_bins > 0, "The number of bins should be bigger than 0" );

                    // create the a homogeneous Quantizer, and initialize the _array_q whit it
                    Quantizer<data_type> q_map( min_value, max_value, num_bins );
                    for( size_type ii = 0; ii < channels; ++ii )
                    {
                        _array_q[ii] = q_map;
                    }

                    _bigPatchSize = 10;
                    _smallPatchSize = 3;
                    _h = h;

                    // common initialization
                    _init();
                }

                /*! Calculates the histogram of a set of pixels. You should not call this method directly
                 * \param[in] first : first pixel to estimate
                 * \param[in] last : last pixel to estimate
                 * \param[in] peer_descs : collaborative descriptors structure. you should not touch this value
                 */
                template< class IteratorModel >
                void calculate(IteratorModel first, IteratorModel last, CollaborativeDescriptors* peer_descs)
                {
                	for(std::size_t ii = 0; ii<InputModel::dimensions; ++ii) {
                		_borders[ii] = _smallPatchSize + _bigPatchSize;
                	}

                	Border<InputModel>* image_with_padding = NULL;
                	descriptors::CenteredSquaredWindow*	bigWindow = NULL;
                	descriptors::CenteredSquaredWindow* smallWindow = NULL;

                    if(peer_descs->global_desc()!=NULL) {
                        image_with_padding = &(peer_descs->global_desc()->calculate(new Border<InputModel>(_borders,0), (*first).global_begin(), (*first).global_end()));
                        bigWindow = &(peer_descs->global_desc()->calculate(new descriptors::CenteredSquaredWindow(_bigPatchSize,true), (*first).global_begin(), (*first).global_end()));
                        smallWindow = &(peer_descs->global_desc()->calculate(new descriptors::CenteredSquaredWindow(_smallPatchSize,false), (*first).global_begin(), (*first).global_end()));
                    } else {
                        throw ImagePlusNotImplemented("PixelChannelPDF without global descriptors.");
                    }

                	// Calculate
                	uint32 points = 0;
                	uint32 N_small_patch = smallWindow->size();
                	uint32 N_big_patch = bigWindow->size();



                	std::vector<float64> dist(channels,0); // hold the distances for each channel for one specific pixel

                	for(; first!=last; ++first, points++) {
                		CoordType center = (*first).position();

                		std::vector<std::vector<float64> > distances; 	// vector to hold all the distances
                		std::vector<float64> Z(channels,0);				//normalizing factor for each channel

                		for(uint32 i = 0; i < N_big_patch; ++i) { // iterate through all the pixels of the big patch
                			CoordType p(center);
                			p[0] += (*bigWindow)[i][0]; p[1] += (*bigWindow)[i][1];

                			if(image_with_padding->is_border(p)) continue; // check if it is not border
                			for (uint32 k = 0; k < channels; k++) dist[k] = 0;

                			for (uint32 k=0; k < N_small_patch; k++) {
                				CoordType px(p); // fix the center of the small patch to the pixel being examined in the big window
                				CoordType cx(center); // center patch at the origin pixel

                				cx[0] += (*smallWindow)[k][0]; cx[1] += (*smallWindow)[k][1];
                				px[0] += (*smallWindow)[k][0]; px[1] += (*smallWindow)[k][1];

								if(image_with_padding->is_border(px))   continue;
								if(image_with_padding->is_border(cx)) 	continue;

								float64 z = std::sqrt(float64( (*smallWindow)[k][0]*(*smallWindow)[k][0] + (*smallWindow)[k][1]*(*smallWindow)[k][1]));
								for( size_type ch = 0; ch < channels; ++ch )
								{
									float64 d = (*image_with_padding)(ch)(px) - (*image_with_padding)(ch)(cx);
									d /= (2*z+1); d*=d; // distance from one channel
									dist[ch]+=d;
								}
							}

                			//cout << "(" << p[0] << "," << p[1] << ")  - ";

                			for (size_type ch = 0; ch < channels; ch++) { dist[ch] = std::exp(-dist[ch]/_h); Z[ch] += dist[ch];} //cout << dist[ch] << " ";} cout << endl;
                			distances.push_back(dist); // put the distance for this patch for posterior processing

                		}

                		// construct the pixel histogram for the big patch
                		int k = 0;
                		for(uint32 i = 0; i < N_big_patch; ++i) { // iterate through all the pixels of the big patch
                			CoordType p(center);
                			p[0] += (*bigWindow)[i][0]; p[1] += (*bigWindow)[i][1];

                			if(image_with_padding->is_border(p)) continue; // check if it is not border
                			for (size_type ch = 0; ch < channels; ch++) {
                				uint32 bin = _array_q[ch].bin((*image_with_padding)(ch)(p));
                				(*this)[ch][bin] += distances[k][ch]/Z[ch];
                			}
                			k++;
                		}


                	}

                	// normalize the histogram
                	for (size_type ch = 0; ch < channels; ch++) {
                		for (uint32 i = 0; i < _num_bins[ch]; i++) {
                			(*this)[ch][i] /= points;
                		}
                	}

                	_num_points = points;
                }



                //! \brief Calculates dominant colors of the father region given the son's ones.
                //!
                //! \param[in] son1_descs : CollaborativeDescriptors of the son 1
                //! \param[in] son2_descs : CollaborativeDescriptors of the son 2
                //! \param[in] peer_descs : Pointer to CollaborativeDescriptors, in principle is never 0x0 but it is a good idea to ASSERT it
                void recursive_calculate(CollaborativeDescriptors& son1_descs, CollaborativeDescriptors& son2_descs, CollaborativeDescriptors* peer_descs)
                {
                	(*this) = son1_descs.get(*this) + son2_descs.get(*this);
                }

                /*!
                 * \param[in] copy : descriptor from which we're copying
                 *
                 * \returns copy, to concatenate
                 */
                const PixelChannelPDF& operator=( const PixelChannelPDF& copy)
                {
                    _id          = copy._id;
                    _array_q     = copy._array_q;
                    _num_bins    = copy._num_bins;
                    _num_points  = copy._num_points;

                    vd_type::operator=(copy);
                    return copy;
                }

                /*!
                 * \param[in] other : the PixelChannelPDF to sum
                 *
                 * \return the normalized addition of the object plus other
                 */ 
                PixelChannelPDF operator+( const PixelChannelPDF& other ) const
                {
                    PixelChannelPDF out;
                    out._id = _id;
                    out._array_q = _array_q;
                    out._num_bins = _num_bins;
                    out._num_points = _num_points + other._num_points;

                    out._init();

                    for(std::size_t ch=0; ch<channels; ++ch)
                    {
                    	/*
                    	 * AGIL: .data() not available in MSVC, replaced 
                    	 *       by &vector[0].
                    	 */
//                        T* p_out = out[ch].data();
//                        const T* p_in1 = vd_type::at(ch).data();
//                        const T* p_in2 = other[ch].data();
                    	T*       p_out = &out[ch][0];
                        const T* p_in1 = &vd_type::at(ch)[0];
                        const T* p_in2 = &other[ch][0];

                        std::size_t n_elem = vd_type::at(ch).size();
                        float64 alpha1 = hist_sum()/(float64)(hist_sum()+other.hist_sum());
                        float64 alpha2 = other.hist_sum()/(float64)(hist_sum()+other.hist_sum());
                        for(std::size_t ii = 0; ii< n_elem; ++ii)
                        {
                            *p_out = alpha1*(*p_in1) + alpha2*(*p_in2);
                            ++p_out; ++p_in1; ++p_in2;
                        }
                    }
                    return out;
                }

                /*! \brief numer of points of this histogram
                 * \return the numer of pixels
                 */
                uint64 hist_sum() const {
                	return _num_points;
                }

            private:

            	/*! \brief Function to initialize the histograms containers
            	 * 
            	 */
                void _init()
                {
                    // Create _num_bins array based on the quantizer
                	// Allocate memory
                    for( size_type ii = 0; ii < channels; ++ii )
                    {
                    	_num_bins[ii] = _array_q[ii].num_bins();
                    	(*this)[ii].resize( _num_bins[ii] );
                    }
                }

                //! Quantizer arrays
                boost::array<Quantizer<data_type>, channels>                           	_array_q;
                //! Number of bins for each channel
                boost::array<std::size_t, channels>							          	_num_bins;
                //! borders needed for the neighborhood
                boost::array<std::size_t, InputModel::dimensions>			          	_borders;
                //! number of pixels contained in the histogram
                uint32																	_num_points;
                //! size of the big neighborhood to search for similar patches
                uint32																	_bigPatchSize;
                //! size of the small patch size that will be compared with the center
				uint32																	_smallPatchSize;
				//! filtering parameter
				float64																	_h; // parameter for the exponential
            };

        }
    }
}


#endif
