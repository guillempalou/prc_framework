// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------

//!
//!  \file xml_auxiliar.cpp
//!

#ifdef USE_XML
#include <imageplus/io/xml_auxiliar.hpp>
#include <boost/filesystem.hpp>


#include <imageplus/core/exceptions.hpp>

using namespace imageplus;
using namespace XERCES_CPP_NAMESPACE;


XERCES_CPP_NAMESPACE::DOMNode* imageplus::io::xml_init(const std::string& file_name, XERCES_CPP_NAMESPACE::DOMDocument*& doc) throw (ImagePlusFileError, ImagePlusError)
{
    DOMImplementation *impl;
    DOMBuilder        *parser;

    // Initialization of all the stuff needed from xerces
    try
    {
         XMLPlatformUtils::Initialize();
    }
    catch (const XMLException& toCatch)
    {
        char* message = NULL;
        sprintf( message, "XML reading exception message is: '%s'",  toNative(toCatch.getMessage()).c_str());
        throw ImagePlusError( message );
    }

    // Instantiate the DOM parser.
    static const XMLCh gLS[] = { chLatin_L, chLatin_S, chNull };
    impl = DOMImplementationRegistry::getDOMImplementation(gLS);
    parser = ((DOMImplementationLS*)impl)->createDOMBuilder(DOMImplementationLS::MODE_SYNCHRONOUS, 0);

    doc = 0;

    try
    {
        doc = parser->parseURI(file_name.c_str());
    }
    catch (const XMLException& toCatch)
    {
        char* message = NULL;
        sprintf( message, "XML reading exception message is: '%s'",  toNative(toCatch.getMessage()).c_str());
        throw ImagePlusError( message );
    }
    catch (const DOMException& toCatch)
    {
        char* message = NULL;
        sprintf( message, "XML reading exception message is: '%s'",  toNative(toCatch.getMessage()).c_str());
        throw ImagePlusError( message );
    }
    catch(std::exception e)
    {
        std::cout << e.what() << std::endl;
        exit(1);
    }
    catch (...)
    {
        throw ImagePlusError("xml_init: Unexpected XML reading exception in file '"+file_name+"'.");
    }

    if (doc==0)
    {
        throw ImagePlusFileError(file_name, "It seems not to be available" );
    }

    // We start to read the XML file and we check the structure while we advance through it
    return (DOMNode *)doc->getDocumentElement();
}

XERCES_CPP_NAMESPACE::DOMNode* imageplus::io::xml_init(const std::string& file_name, XERCES_CPP_NAMESPACE::DOMDocument*& doc, XERCES_CPP_NAMESPACE::DOMBuilder*& parser) throw (ImagePlusFileError, ImagePlusError)
{
    DOMImplementation *impl;

    // Initialization of all the stuff needed from xerces
    try
    {
         XMLPlatformUtils::Initialize();
    }
    catch (const XMLException& toCatch)
    {
        char* message = NULL;
        sprintf( message, "XML reading exception message is: '%s'",  toNative(toCatch.getMessage()).c_str());
        throw ImagePlusError( message );
    }

    // Instantiate the DOM parser.
    static const XMLCh gLS[] = { chLatin_L, chLatin_S, chNull };
    impl = DOMImplementationRegistry::getDOMImplementation(gLS);
    parser = ((DOMImplementationLS*)impl)->createDOMBuilder(DOMImplementationLS::MODE_SYNCHRONOUS, 0);

    doc = 0;

    try
    {
        doc = parser->parseURI(file_name.c_str());
    }
    catch (const XMLException& toCatch)
    {
        char* message = NULL;
        sprintf( message, "XML reading exception message is: '%s'",  toNative(toCatch.getMessage()).c_str());
        throw ImagePlusError( message );
    }
    catch (const DOMException& toCatch)
    {
        char* message = NULL;
        sprintf( message, "XML reading exception message is: '%s'",  toNative(toCatch.getMessage()).c_str());
        throw ImagePlusError( message );
    }
    catch(std::exception e)
    {
        std::cout << e.what() << std::endl;
        exit(1);
    }
    catch (...)
    {
        throw ImagePlusError("xml_init: Unexpected XML reading exception in file '"+file_name+"'.");
    }

    if (doc==0)
    {
        throw ImagePlusFileError(file_name, "It seems not to be available" );
    }

    // We start to read the XML file and we check the structure while we advance through it
    return (DOMNode *)doc->getDocumentElement();
}


XERCES_CPP_NAMESPACE::DOMNode* imageplus::io::xml_init(const std::string& file_name) throw (ImagePlusFileError, ImagePlusError)
{
    XERCES_CPP_NAMESPACE::DOMDocument* doc=0x0;
    return xml_init(file_name, doc);
}


XERCES_CPP_NAMESPACE::DOMNode* imageplus::io::xml_get_check_son(XERCES_CPP_NAMESPACE::DOMNode *father, const char* node_name) throw (ImagePlusError)
{
    DOMNodeList *child_list;
    DOMNode *son;
    int64 num_children;
    bool child_found;
    
    child_list = father->getChildNodes();
    num_children = child_list->getLength();
    child_found = false;
    if(num_children > 0)
    {
        for(int64 ii=0; ii<num_children && child_found==false; ii++ )
        {
            son = child_list->item(ii);
            if(son->getNodeType() == DOMNode::ELEMENT_NODE)
            {
                if(toNative(son->getNodeName())==node_name)
                    child_found = true;
            }
        }
    }
    
    if(child_found == false) son = 0x0;

    return son;
}


DOMNode* imageplus::io::xml_get_check_son_by_field(DOMNode *father, const char* node_name, const char* field_name, const char* field_value)
{
    DOMNodeList *child_list;
    DOMNode *son;
    int64 num_children;
    bool child_found;

    child_list = father->getChildNodes();
    num_children = child_list->getLength();
    child_found = false;

    if(num_children>0)
    {
        for(int64 ii=0; ii<num_children && child_found==false; ii++ )
        {
            son = child_list->item(ii);
            if(son->getNodeType() == DOMNode::ELEMENT_NODE)
            {
                if(toNative(son->getNodeName())==node_name)
                {
                    // Get attributes of a node
                    DOMNamedNodeMap *node_attr = son->getAttributes();
                    DOMNode * prop_node = node_attr->getNamedItem(fromNative(field_name).c_str());
                    if(toNative(prop_node->getNodeValue())==field_value)
                    {
                        child_found = true;
                    }
                }
            }
        }
    }

    if(child_found == false) son = 0x0;

    return son;
}


std::string imageplus::io::xml_get_text_son(DOMNode *father, DOMNode*& son) throw (ImagePlusError)
{
    DOMNodeList *child_list;
    int64 num_children;
    bool child_found;

    child_list = father->getChildNodes();
    num_children = child_list->getLength();
    child_found = false;
    char err_message[100];
    sprintf(err_message, "XML reading: Text node not found");

    if(num_children==0) throw ImagePlusError(err_message);
    else
    {
        for(int64 ii=0; ii<num_children && child_found==false; ii++ )
        {
            son = child_list->item(ii);
            if(son->getNodeType() == DOMNode::TEXT_NODE)
            {
                child_found = true;
            }
        }

        if(child_found == false) throw ImagePlusError(err_message);
    }
    
    return toNative(son->getNodeValue());
}


std::string imageplus::io::xml_get_text_son(DOMNode *father) throw (ImagePlusError)
{
    DOMNode* son;
    return xml_get_text_son(father, son);
}


void imageplus::io::xml_write(XERCES_CPP_NAMESPACE::DOMDocument *doc, const std::string& file_name) throw (ImagePlusError)
{
    boost::filesystem::path file_path( file_name );
    boost::filesystem::path filename_branch = file_path.branch_path();
    if (!boost::filesystem::exists(filename_branch) && filename_branch.string()!="")
    {
        throw ImagePlusError( "xml_write: Directory " + filename_branch.string() + " not found." );
    }

    DOMImplementation* impl =  DOMImplementationRegistry::getDOMImplementation(fromNative("Core").c_str());

    XMLFormatTarget *myFormTarget;
    myFormTarget = new LocalFileFormatTarget(file_name.c_str());

    DOMWriter  *theSerializer = ((DOMImplementationLS*)impl)->createDOMWriter();
    theSerializer->setFeature(XMLUni::fgDOMWRTFormatPrettyPrint, true);
    bool success = theSerializer->writeNode(myFormTarget, *doc);
    if (!success) throw ImagePlusError("xml_write: An error has occured when trying to write the XML file");

    delete myFormTarget;
    theSerializer->release();
}


// BPT helper functions
XERCES_CPP_NAMESPACE::DOMElement* imageplus::io::bpt_xml_write_header(XERCES_CPP_NAMESPACE::DOMDocument *doc, const std::vector<std::string>& uri_names, const std::vector<std::string>& uri_values)
{
    ASSERT(uri_names.size() == uri_values.size(), "bpt_xml_write_header: uri_names and uri_values sizes must be the same" )

    DOMElement* rootElem = doc->getDocumentElement();
    rootElem->setAttribute(fromNative("xmlns").c_str(), fromNative("urn:mpeg:mpeg7:schema:2001").c_str());
    rootElem->setAttribute(fromNative("xmlns:xsi").c_str(), fromNative("http://www.w3.org/2001/XMLSchema-instance").c_str());
    rootElem->setAttribute(fromNative("xmlns:mpeg7").c_str(), fromNative("urn:mpeg:mpeg7:schema:2001").c_str());
    rootElem->setAttribute(fromNative("xsi:schemaLocation").c_str(), fromNative("urn:mpeg:mpeg7:schema:2001 .\\Mpeg7-2001.xsd").c_str());
    
        DOMElement*  descElem = doc->createElement(fromNative("Description").c_str());
        descElem->setAttribute(fromNative("xmlns:urn").c_str(), fromNative("urn:mpeg:mpeg7:schema:2001").c_str());
        descElem->setAttribute(fromNative("xsi:type").c_str(), fromNative("urn:ContentEntityType").c_str());
        rootElem->appendChild(descElem);

            DOMElement*  multElem = doc->createElement(fromNative("MultimediaContent").c_str());
            multElem->setAttribute(fromNative("xsi:type").c_str(), fromNative("urn:ImageType").c_str());
            descElem->appendChild(multElem);

                DOMElement*  imaElem = doc->createElement(fromNative("Image").c_str());
                multElem->appendChild(imaElem);

                    DOMElement*  creinfElem = doc->createElement(fromNative("CreationInformation").c_str());
                    imaElem->appendChild(creinfElem);

                        DOMElement*  creatElem = doc->createElement(fromNative("Creation").c_str());
                        creinfElem->appendChild(creatElem);

                            DOMElement*  titleElem = doc->createElement(fromNative("Title").c_str());
                            creatElem->appendChild(titleElem);

                                DOMText*  textElem = doc->createTextNode(fromNative("MPEG-7 description of an image").c_str());
                                titleElem->appendChild(textElem);

                    for(std::size_t ii=0; ii<uri_names.size(); ii++)
                    {
                        DOMElement* relatElem = doc->createElement(fromNative("RelatedMaterial").c_str());
                        relatElem->setAttribute(fromNative("id").c_str(), fromNative(uri_names[ii].c_str()).c_str());
                        creinfElem->appendChild(relatElem);

                            DOMElement* mediaElem = doc->createElement(fromNative("MediaLocator").c_str());
                            relatElem->appendChild(mediaElem);

                                DOMElement* mediauElem = doc->createElement(fromNative("MediaUri").c_str());
                                mediaElem->appendChild(mediauElem);

                                    textElem = doc->createTextNode(fromNative(uri_values[ii].c_str()).c_str());
                                    mediauElem->appendChild(textElem);
                    }

    return imaElem;

}


void  imageplus::io::bpt_xml_write_fusion(XERCES_CPP_NAMESPACE::DOMDocument *doc,
                                          XERCES_CPP_NAMESPACE::DOMElement *spatial_elem,
                                          uint32 father, uint32 son1, uint32 son2,
                                          uint32 merging_order, float64 significance)
{
    DOMElement*  spat2Elem;
    DOMElement*  stillElem;
    DOMElement*  still2Elem;

    char append[50];

    stillElem = doc->createElement(fromNative("StillRegion").c_str());
    sprintf (append, "Region%u", father);
    stillElem->setAttribute(fromNative("id").c_str(), fromNative(append).c_str());
    spatial_elem->appendChild(stillElem);

        spat2Elem = doc->createElement(fromNative("Relation").c_str());
        spat2Elem->setAttribute(fromNative("type").c_str(), fromNative("Significance").c_str());
        sprintf (append, "%f", significance);
        spat2Elem->setAttribute(fromNative("strength").c_str(), fromNative(append).c_str());
        stillElem->appendChild(spat2Elem);

        spat2Elem = doc->createElement(fromNative("Relation").c_str());
        spat2Elem->setAttribute(fromNative("type").c_str(), fromNative("MergingOrder").c_str());
        sprintf (append, "%u", merging_order);
        spat2Elem->setAttribute(fromNative("id").c_str(), fromNative(append).c_str());
        stillElem->appendChild(spat2Elem);

        spat2Elem = doc->createElement(fromNative("SpatialDecomposition").c_str());
        spat2Elem->setAttribute(fromNative("gap").c_str(), fromNative("false").c_str());
        spat2Elem->setAttribute(fromNative("overlap").c_str(), fromNative("false").c_str());
        stillElem->appendChild(spat2Elem);

            sprintf (append, "Region%u", son2);
            still2Elem = doc->createElement(fromNative("StillRegionRef").c_str());
            still2Elem->setAttribute(fromNative("idref").c_str(), fromNative(append).c_str());
            spat2Elem->appendChild(still2Elem);

            sprintf (append, "Region%u", son1);
            still2Elem = doc->createElement(fromNative("StillRegionRef").c_str());
            still2Elem->setAttribute(fromNative("idref").c_str(), fromNative(append).c_str());
            spat2Elem->appendChild(still2Elem);
}

XERCES_CPP_NAMESPACE::DOMNode* imageplus::io::bpt_xml_read_header(std::string filename, std::map<std::string,std::string>& uris)
{
    XERCES_CPP_NAMESPACE::DOMDocument* doc;
    XERCES_CPP_NAMESPACE::DOMBuilder*  parser;
    XERCES_CPP_NAMESPACE::DOMNode* curr_node = io::xml_init(filename, doc, parser);
    
    //Check that the name of the node is "Mpeg7"
//    char* name = xercesc::XMLString::transcode(curr_node->getNodeName());
//    if(strcmp(name,"Mpeg7") != 0)
    if(strcmp(toNative(curr_node->getNodeName()).c_str(),"Mpeg7") != 0)
        throw ImagePlusError("XML reading: 'Mpeg7' node not found");

    // Check that there is a sequence of sons named:
    // "Description/MultimediaContent/Image"
    // and returns a pointer to it
    curr_node = io::xml_get_check_son(curr_node, "Description");
    curr_node = io::xml_get_check_son(curr_node, "MultimediaContent");
    curr_node = io::xml_get_check_son(curr_node, "Image");
    
    // Gets the uri names and values from the XML header
    XERCES_CPP_NAMESPACE::DOMNode* curr_node2 = io::xml_get_check_son(curr_node, "CreationInformation");
    XERCES_CPP_NAMESPACE::DOMNodeList *child_list;
    int64 num_children;
    // Gets the list of children
    child_list = curr_node2->getChildNodes();
    
    // Gets the number of children
    num_children = child_list->getLength();
    XERCES_CPP_NAMESPACE::DOMNode *son;
    for(int64 ii=0; ii<num_children; ii++ )
    {  
        son = child_list->item(ii);
        if(son->getNodeType() == XERCES_CPP_NAMESPACE::DOMNode::ELEMENT_NODE)
        {
            if(strcmp(toNative(son->getNodeName()).c_str(),"RelatedMaterial") == 0)
            {
                XERCES_CPP_NAMESPACE::DOMNamedNodeMap *node_attr = son->getAttributes();
                XERCES_CPP_NAMESPACE::DOMNode* curr_node3 = node_attr->getNamedItem(fromNative("id").c_str());
                std::string uri_name = toNative(curr_node3->getNodeValue());
                curr_node3 = io::xml_get_check_son(son, "MediaLocator");
                curr_node3 = io::xml_get_check_son(curr_node3, "MediaUri");
                std::string uri_value = io::xml_get_text_son(curr_node3, curr_node3);
                uris.insert(std::pair<std::string, std::string>(uri_name,uri_value));
            }
        }
    }
    return curr_node;
}

XERCES_CPP_NAMESPACE::DOMNode* imageplus::io::bpt_xml_read_header(std::string filename, std::map<std::string,std::string>& uris, XERCES_CPP_NAMESPACE::DOMBuilder*& parser)
{
    XERCES_CPP_NAMESPACE::DOMDocument* doc;
    XERCES_CPP_NAMESPACE::DOMNode* curr_node = io::xml_init(filename, doc, parser);
    
    //Check that the name of the node is "Mpeg7"
    if(strcmp(toNative(curr_node->getNodeName()).c_str(),"Mpeg7") != 0)
        throw ImagePlusError("XML reading: 'Mpeg7' node not found");

    // Check that there is a sequence of sons named:
    // "Description/MultimediaContent/Image"
    // and returns a pointer to it
    curr_node = io::xml_get_check_son(curr_node, "Description");
    curr_node = io::xml_get_check_son(curr_node, "MultimediaContent");
    curr_node = io::xml_get_check_son(curr_node, "Image");
    
    // Gets the uri names and values from the XML header
    XERCES_CPP_NAMESPACE::DOMNode* curr_node2 = io::xml_get_check_son(curr_node, "CreationInformation");
    XERCES_CPP_NAMESPACE::DOMNodeList *child_list;
    int64 num_children;
    // Gets the list of children
    child_list = curr_node2->getChildNodes();
    
    // Gets the number of children
    num_children = child_list->getLength();
    XERCES_CPP_NAMESPACE::DOMNode *son;
    for(int64 ii=0; ii<num_children; ii++ )
    {  
        son = child_list->item(ii);
        if(son->getNodeType() == XERCES_CPP_NAMESPACE::DOMNode::ELEMENT_NODE)
        {
            if(strcmp(toNative(son->getNodeName()).c_str(),"RelatedMaterial") == 0)
            {
                XERCES_CPP_NAMESPACE::DOMNamedNodeMap *node_attr = son->getAttributes();
                XERCES_CPP_NAMESPACE::DOMNode* curr_node3 = node_attr->getNamedItem(fromNative("id").c_str());
                std::string uri_name = toNative(curr_node3->getNodeValue());
                curr_node3 = io::xml_get_check_son(son, "MediaLocator");
                curr_node3 = io::xml_get_check_son(curr_node3, "MediaUri");
                std::string uri_value = io::xml_get_text_son(curr_node3, curr_node3);
                uris.insert(std::pair<std::string, std::string>(uri_name,uri_value));
            }
        }
    }
    return curr_node;
}


#endif
