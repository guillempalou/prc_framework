// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------

//!
//!  \file ublas_adaptors_storage.hpp
//!
//!  Interface for adaptor class to switch between MultiArray and ublas matrices and vectors
//!

#ifndef IMAGEPLUS_NUMERIC_UBLAS_ADAPTORS_STORAGE_HPP
#define IMAGEPLUS_NUMERIC_UBLAS_ADAPTORS_STORAGE_HPP

#include <algorithm>
#include <boost/numeric/ublas/exception.hpp>
#include <boost/numeric/ublas/vector.hpp>
#include <boost/numeric/ublas/matrix.hpp>
#include <boost/numeric/ublas/detail/iterator.hpp>


namespace imageplus
{
    namespace math
    {
        namespace numeric
        {
    
            //!
            //! \brief storage class to adapt multiarrays and ublas matrices
            //!
            //! \author Javier Ruiz Hidalgo <j.ruiz@upc.edu>
            //! \author Ramon Morros <morros@gps.tsc.upc.edu>
            //!
            //! \date 22-01-2008
            //!
            //! This class implements an ublas storage to adapt MultiArray data. The data itself is not copied but referenced using a pointer.
            //! See class UblasAdaptMatrix and UblasAdaptVector for usage.
            //! The original code is <a href="http://lists.boost.org/MailArchives/ublas/2007/06/2148.php">here</a>.
            //! As the method functions replicate the ublas storage class they are not documented properly.
            //!
            template<class T>
            class array_handle : public boost::numeric::ublas::storage_array<array_handle<T> >
            {
    
                    //!
                    //! \brief self type
                    //!
                    typedef array_handle<T> self_type;
    
                public:
    
                    //!
                    //! \brief size of the data
                    //!
                    typedef std::size_t size_type;
    
                    //!
                    //! \brief difference type
                    //!
                    typedef std::ptrdiff_t difference_type;
    
                    //!
                    //! \brief type of the data
                    //!
                    typedef T value_type;
    
                    //!
                    //! \brief const reference to data type of the array
                    //!
                    typedef const T& const_reference;
    
                    //!
                    //! \brief reference to data type of the array
                    //!
                    typedef T& reference;
    
                    //!
                    //! \brief const pointer to data type
                    //!
                    typedef const T* const_pointer;
    
                    //!
                    //! \brief pointer to data type
                    //!
                    typedef T* pointer;
    
                    //!
                    //! \brief Constructor
                    //!
                    BOOST_UBLAS_INLINE
                    array_handle ()
                            : size_ (0), data_ (new value_type [0])
                    {}
    
                    //!
                    //! \brief Constructor with size
                    //!
                    //! \param[in] size: Size of the array
                    //!
                    explicit BOOST_UBLAS_INLINE
                    array_handle (size_type size)
                            : size_ (size),data_ (new value_type [size])
                    {}
    
                    //!
                    //! \brief Constructor with size and value
                    //!
                    //! \param[in] size: Size of the array
                    //! \param[in] init: value
                    //!
                    BOOST_UBLAS_INLINE
                    array_handle (size_type size, const value_type &init)
                            : size_ (size), data_ (new value_type [size])
                    {
                        std::fill (data_, data_ + size_, init);
                    }
    
                    //!
                    //! \brief Contructor with size and pointer
                    //!
                    //! \param[in] size: Size of the array
                    //! \param[in] data: Pointer to data (not copied but referenced)
                    //!
                    BOOST_UBLAS_INLINE
                    array_handle (size_type size, pointer data)
                            : size_ (size),  data_ (data)
                    {}
    
    
                    //!
                    //! \brief Copy constructor
                    //!
                    //! \param[in] a: array_handle to copy
                    //!
                    BOOST_UBLAS_INLINE
                    array_handle (const array_handle &a)
                            : boost::numeric::ublas::storage_array<self_type> (), size_ (a.size_),  data_ (a.data_)
                    {}
    
                    //!
                    //! \brief Desstructor
                    //!
                    BOOST_UBLAS_INLINE
                    ~array_handle ()
                    {}
    
                public:
    
                    //!
                    //! \returns size of the array
                    //!
                    BOOST_UBLAS_INLINE
                    size_type size () const
                    {
                        return size_;
                    }
    
                    //!
                    //! \brief Element access
                    //!
                    //! \param[in] i: index
                    //!
                    //! \return const reference to the i-th element
                    //!
                    BOOST_UBLAS_INLINE
                    const_reference operator [] (size_type i) const
                    {
                        BOOST_UBLAS_CHECK (i < size_, boost::numeric::ublas::bad_index ());
                        return data_ [i];
                    }
    
                    //!
                    //! \brief Element access
                    //!
                    //! \param[in] i: index
                    //!
                    //! \returns a reference to the i-th element
                    //!
                    BOOST_UBLAS_INLINE
                    reference operator [] (size_type i)
                    {
                        BOOST_UBLAS_CHECK (i < size_, boost::numeric::ublas::bad_index ());
                        return data_ [i];
                    }
    
                    //!
                    //! \brief Assignment operator
                    //!
                    //! \param[in] a: array_handle to copy
                    //!
                    //! \return this, just to concatenate assignments
                    //!
                    BOOST_UBLAS_INLINE
                    array_handle& operator = (const array_handle &a)
                    {
                        if (this != &a)
                        {
                            if ( this->size_ != a.size_)
                            {
                                std::cerr << "operator= of array_handle is only for equal sized matrices" << std::endl;
                                std::exit(1);
                            }
    
                            std::copy (a.data_, a.data_ + a.size_, data_);
                        }
                        return *this;
                    }
    
                    //!
                    //! \brief const iterator
                    //!
                    typedef const_pointer const_iterator;
    
                    //!
                    //! \returns a const iterator to the begin
                    //!
                    BOOST_UBLAS_INLINE
                    const_iterator begin () const
                    {
                        return data_;
                    }
    
                    //!
                    //! \returns a const iterator to the end (not dereferenceable)
                    //!
                    BOOST_UBLAS_INLINE
                    const_iterator end () const
                    {
                        return data_ + size_;
                    }
    
                    //!
                    //! \brief non-const iterator
                    //!
                    typedef pointer iterator;
    
                    //!
                    //! \returns an iterator to the begin
                    //!
                    BOOST_UBLAS_INLINE
                    iterator begin ()
                    {
                        return data_;
                    }
    
                    //!
                    //! \returns an iterator to the end (not dereferenceable)
                    //!
                    BOOST_UBLAS_INLINE
                    iterator end ()
                    {
                        return data_ + size_;
                    }
    
                    //!
                    //! \brief Reverse Iterators (const)
                    //!
                    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
    
                    //!
                    //! \brief Reverse Iterators (non const)
                    //!
                    typedef std::reverse_iterator<iterator> reverse_iterator;
    
                    //!
                    //! \returns a const-reverse iterator to the begin (not dereferenceable)
                    //!
                    BOOST_UBLAS_INLINE
                    const_reverse_iterator rbegin () const
                    {
                        return const_reverse_iterator (end ());
                    }
    
                    //!
                    //! \returns a const-reverse iterator to the end
                    //!
                    BOOST_UBLAS_INLINE
                    const_reverse_iterator rend () const
                    {
                        return const_reverse_iterator (begin ());
                    }
    
                    //!
                    //! \returns a reverse iterator to the begin (not dereferenceable)
                    //!
                    BOOST_UBLAS_INLINE
                    reverse_iterator rbegin ()
                    {
                        return reverse_iterator (end ());
                    }
    
                    //!
                    //! \returns a reverse iterator to the end
                    //!
                    BOOST_UBLAS_INLINE
                    reverse_iterator rend ()
                    {
                        return reverse_iterator (begin ());
                    }
    
                private:
    
                    //!
                    //! \brief Size of the array
                    //!
                    size_type size_;
    
                    //!
                    //! \brief Pointer to data
                    //!
                    pointer data_;
    
            };
        } //namespace numeric
    } //namespace math
} // namespace imageplus


#endif

