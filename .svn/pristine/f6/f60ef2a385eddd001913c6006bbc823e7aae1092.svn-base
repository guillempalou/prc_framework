// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------

/*!
 * \author Javi Vidal        - First version
 * \author Sergio Segura     - Moved to SF2 and ToolConfig and using the new CameraPTZ class
 * \author Albert Gil Moreno - Review
 */

#include <string>

// Config definitions
static const std::string TOOL_NAME   = "ptz_control";
static const std::string BRIEF       = "Control PTZ camera\n";
static const std::string DESCRIPTION = (std::string)
     "This client controls the movements of the PTZ camera.                              \n" +
     "It receives a flow with XYZ information and makes the conversion to pan-tilt-zoom. \n" +
     "It uses a calibration information for this conversion.                             \n" +
     "Finally it moves the camera to point to this position on the Smart Room.           \n" +
     "Also it sends the current position in a different and independent thread.";


// General includes
#include <queue>
#include <boost/thread/thread.hpp>
#include <boost/bind.hpp>

// Image Plus includes
#include <imageplus/toolbox/tool_config.hpp>
#include <imageplus/toolbox/flows_ptz_sf2.hpp>
#include <imageplus/toolbox/client_config_sf2.hpp>
#include <imageplus/toolbox/camera_ptz.hpp>


// Namespaces
using namespace std;
using namespace imageplus;
using namespace imageplus::toolbox;


// Global variables
static volatile bool    running = true;
std::queue<Point3D>     movements_queue;
SF2Client*				sfp = NULL;

// Configuration parameters
class MyConfig : public toolbox::ToolConfig
{
public:
    // my arguments
    int         pan_tilt_speed;  // value recommended 17
    int         zoom_speed;      // value recommended  7
    std::string calib_file;

    // constructor
    MyConfig(int argc, char* argv[]) : ToolConfig(TOOL_NAME, BRIEF, DESCRIPTION)
    {
        // add arguments in the desired order
        add_argument( pan_tilt_speed , "pan_tilt_speed" , "Pan and Tilt velocity of actuation (recomended: 17)" );
        add_argument( zoom_speed     , "zoom_speed"     , "Zoom velocity of actuation (recomended: 7)" );
        add_argument( calib_file     , "calib_file"     , "Path of the calibration file of the camera" );
        
        // configure
        configure(argc, argv);
        
        // read
        read( "pan_tilt_speed" , pan_tilt_speed );
        read( "zoom_speed"     , zoom_speed     );
        read( "calib_file"     , calib_file     );
     }
 };

/*!
 * Function used to stop the SF clients with Ctrl+C
 */
static 
void exit_function() 
{
    CLIENT_TRACE("EXIT FUNCTION");
    running = false;
    sfp->stop_flows();
};

/*!
 * Thread-Function used to receive the XYZ positions where the camera has to point
 */
void receive_movements( ImagePlusFlow& xyz_flow_in )
{
    Point3D    xyz_to_move;
    Timestamp  ts;

    while(running)
    {
    try
    {
        xyz_flow_in.receive (xyz_to_move, ts);
        movements_queue.push(xyz_to_move);
    }
    catch( ReceiveFlowException& e )
    {
         CLIENT_TRACE("Receive exception: %s", e.what());
    }
    catch( ImagePlusError& e )
    {
        CLIENT_TRACE("Exception in the running loop %s: ", e.what());
        if(running) exit_function();
    }
    }
}

/*!
 * Thread-function to move the camera and send the ptz flow
 */
void camera_control( ImagePlusFlow& ptz_flow_out, CameraPTZ& cam )
{
    CameraPTZ::Position ptz_origin;
    CameraPTZ::Position ptz_direction;
    Point3D             xyz_direction;

    CameraPTZ::Movement ptz_movement_data;

	/*
	 * Running loop
	 */
    while( running )
    {
        /*
         * If there is some movement to do:
         * - get the movement and remove it from the queue
         * - move the camera
         * - update origin and direction variables
         */
        if( !movements_queue.empty() )
        {
            /*
             * Get the movement and remove it from the queue
             */
            xyz_direction = movements_queue.back();
            movements_queue.pop();

            /*
             * Move the camera
             */
            cam.move(xyz_direction);

            /*
             * Updating ptz values
             */
            ptz_origin    = cam.where();
            ptz_direction = cam.xyz2ptz(xyz_direction);
        }
        
        /*
         * Filling up and sending the output flow
         */
        ptz_movement_data.vel_pt = cam.pt_speed();   // this is constant, but in may be variable in a future versions
        ptz_movement_data.vel_z  = cam.zoom_speed(); // this is constant, but in may be variable in a future versions
        ptz_movement_data.ptz    = cam.where();
        ptz_movement_data.ts     = clock_ts();
        ptz_movement_data.origin = ptz_origin;
        ptz_movement_data.target = ptz_direction;

        ptz_flow_out.send( ptz_movement_data, ptz_movement_data.ts );
    }    
}

/*
 * Main Function
 */
int main(int argc, char** argv) 
{
    try
    {
        /*
         * Initializing SF2 client and initializing flows
         */
        SF2Client sfc(argc, argv, exit_function );
        sfp = &sfc;

        ImagePlusFlow& ptz_flow_out = sfc.add_output_flow ( "ptz_flow_out", "ptz" );
        ImagePlusFlow& xyz_flow_in  = sfc.add_input_flow  ( "xyz_flow_in",  "xyz", 700 + FLOW_MAX_SIZE );

        /*
         * Getting the configuration parameters
         */
        MyConfig cfg(argc, argv);

        /*
         * CameraPTZ set-up
         */
        CameraPTZ cam( cfg.calib_file );
        cam.init();
        cam.speed(cfg.pan_tilt_speed, cfg.zoom_speed);
        
        //Configuring threads     
        boost::thread control_thread( boost::bind( &camera_control   , ptz_flow_out, cam ));
        boost::thread receive_thread( boost::bind( &receive_movements, xyz_flow_in       ));

        // Waiting for the end of the threads ("running-loop threads")
        control_thread.join();
        receive_thread.join();
    }
    catch(ImagePlusError& e)
    {
        CLIENT_TRACE("Error receving or sending flows. Probably client was stopped.");
        CLIENT_TRACE("Exception info: %s", e.what());
        if(running) exit_function();
    }
}   
