/*
 * model_flow_pruning_ucm.cpp
 *
 *  Created on: Mar 14, 2013
 *      Author: gpalou
 */

/*
 * mumford_shah.cpp
 *
 *  Created on: Mar 7, 2013
 *      Author: gpalou
 */

#include <imageplus/core/image_signal.hpp>
#include <imageplus/core/video_signal.hpp>
#include <imageplus/core/colorspace_converter.hpp>

#include <imageplus/segmentation/partition/partition.hpp>
#include <imageplus/segmentation/partition/hierarchical_region_partition.hpp>
#include <imageplus/segmentation/visualization/false_color.hpp>

#include <imageplus/optical_flow/flow_io.hpp>
#include <imageplus/optical_flow/trajectory_tracking.hpp>
#include <imageplus/optical_flow/occlusions/boundary_owner.hpp>
#include <imageplus/optical_flow/occlusions/bijective_error.hpp>
#include <imageplus/optical_flow/occlusions/region_occlusion_error.hpp>
#include <imageplus/optical_flow/occlusions/detect_occlusion_relations.hpp>

#include <imageplus/video_segmentation/optical_flow_fitting/image_projective_cost.hpp>
#include <imageplus/bpt/energy_minimization/binary_pruner.hpp>
#include <imageplus/bpt/pruning/merging_sequence_pruner.hpp>

#include <boost/filesystem.hpp>
#include <iomanip>
#include <iostream>

using namespace imageplus;

#define uint64 imageplus::uint64
#define int64 imageplus::int64

typedef ImageSignal<float64,3> 																		ImageType;
typedef ImageSignal<float64,2> 																		OpticalFlowType;

typedef ImageType::coord_type																		coord2d;
typedef ImageType::value_type																		rgb_type;

typedef HierarchicalRegion<coord2d>																	Region2D;
typedef segmentation::HierarchicalRegionPartition<Region2D>											BPT;
typedef BPT::PartitionType																			PartitionType;


int main(int argc, char *argv[]) {

	std::string sequence_path 		= argv[1];
	std::string tree_path 		= argv[2];
	std::string result_path 	= argv[3];
	uint64 frame = atoi(argv[4]);
	uint64 type = atoi(argv[5]);

	std::vector<float64> list;

	for (int64 i = 6; i < argc; i++) {
		std::string a = argv[i];
		std::cout << a << " ";
		std::istringstream is(a);
		float64 n;
		is >> n;
		list.push_back(n); //*1000);
	}

	// create the necessary paths
	boost::filesystem::path result_path_p(result_path);
	boost::filesystem::create_directories(result_path_p / "segmentations");
	boost::filesystem::create_directories(result_path_p / "mean_color");

	std::cout << "Reading tree" << std::endl;
	BPT bpt;
	bpt.load_from_prl(tree_path);

	coord2d sizes = bpt.leaves_partition().sizes();

	std::ostringstream os;
	os << sequence_path << "/flows/flow_" << frame << "_" << frame+1 << ".flo";

	OpticalFlowType flow(sizes);
	optical_flow::read_optical_flow(flow, os.str());

	descriptors::DescriptorManager manager;
	// estimate flow models (too costly)
	typedef bpt::ImageProjectiveCost<BPT,OpticalFlowType> 						OpticalFlowCostFunction;
	typedef bpt::BinaryPruner<BPT,OpticalFlowType,OpticalFlowCostFunction>		FlowPruner;

	//descriptors::DescriptorManager manager;

	std::set<uint64> regs;

	OpticalFlowCostFunction projective_flow_cost(manager, bpt.max_label());
	FlowPruner optical_flow_pruner(projective_flow_cost,false);

	projective_flow_cost.set_flow(flow);

	PartitionType partition(sizes);

	sort(list.begin(), list.end());

	int64 start = 0;
	int64 end = list.size();
	int64 increment = 1;

	for (int64 i = start; i != end; i+=increment) {

		projective_flow_cost.set_lambda(list[i]);

		std::set<uint64> regs;
		if (type == 0) {
			regs = optical_flow_pruner.find_pruned_regions(bpt, flow, bpt.max_label()); //regularizer acts as the number of regions
			regs = optical_flow_pruner.regions(); //optical_flow_pruner.regions();
		} else {
			bpt::MergingSequencePruner<BPT, OpticalFlowType> merging_sequence_pruner(list[i],false);
			merging_sequence_pruner.prune_bpt(bpt,flow);
			regs = merging_sequence_pruner.regions();
		}

		for (std::set<uint64>::iterator r = regs.begin(); r != regs.end(); ++r) {
			for (BPT::RegionType::iterator p = bpt(*r).begin(); p != bpt(*r).end(); ++p) {
				partition(*p)(0) = *r;
			}
		}

		std::ostringstream os,os2; os << list[i];

		std::string path_seg;

		if (type == 0)
			path_seg = "segmentations_projective_of";
		else
			path_seg = "segmentations";

		boost::filesystem::create_directories(result_path_p / path_seg / os.str());

		ImageType segmentation = segmentation::to_false_color<ImageType>(partition);

		// print segmentation
		partition.write_partition(result_path + "/" + path_seg + "/" + os.str() + "/partition.sgm");
		uint64 k = 0;
		os2 << result_path << "/" << path_seg << "/" << os.str() << "/" << std::setw(5) << std::setfill('0') << k << ".png";
		segmentation.write(os2.str());
	}

}
