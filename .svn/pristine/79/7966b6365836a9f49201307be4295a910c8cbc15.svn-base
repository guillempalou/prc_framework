// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------

//!
//!  \file information_measures.test
//!

#include <iostream>
#include <imageplus/core.hpp>
#include <imageplus/math/statistics/information_measures.hpp>
#include <imageplus/math/statistics/random_generators.hpp>

BOOST_AUTO_TEST_SUITE ( InformationMeasuresSuite );

using namespace imageplus;
using namespace imageplus::math;
using namespace imageplus::math::statistics;

BOOST_AUTO_TEST_CASE ( Entropy )
{
    std::vector <uint64> dims(1);
    const std::size_t exp_size=1000;
    dims[0]=exp_size;
    RandomVariableData< int32, 1, 1 > rv(dims);
    float64 result;

    boost::mt19937 rng1(3);

    for (std::size_t i=0; i<1000; ++i)
    {
    	rv(0)[i]=rand_uniform_int<int32>(0, 1, rng1);
    }

    Quantizer<int32> q(0, 1, 2);

    typedef PDF< RandomVariableData < int32, 1, 1 > > pdf_type;
    const pdf_type& discrete_pdf = calc_descriptor(new pdf_type(0, 1, 2), rv);

    result = entropy(discrete_pdf, 2); //OK for binary integer variables
 	BOOST_CHECK_CLOSE (result, 1.0, 0.1);
}


BOOST_AUTO_TEST_CASE ( PDF_from_RandomVariableData )
{
    const std::size_t exp_size=1000;
    std::vector < uint64 > dim_extents(2,exp_size);
    boost::array< Quantizer<int32>, 2 > array_q;

    Quantizer<int32> qint(0, 2, 3);
    array_q[0] = qint;
    array_q[1] = qint;

   // boost::mt19937 rng1(3);

    RandomVariableData< int32, 2, 1 > rmd(dim_extents);
    for (std::size_t i=0; i<exp_size; ++i)
    {
        rmd(0)[i]=static_cast<int32>(2.0*static_cast<float64>(i%3)/3.0); //rand_uniform_int<int32>(0, 2, rng1);
        rmd(1)[i]=static_cast<int32>(i*i)%3; //rand_uniform_int<int32>(0, 2, rng1);
    }

    const PDF < RandomVariableData < int32, 2, 1 > >& joint_pdf =
            calc_descriptor(new PDF < RandomVariableData < int32, 2, 1 > >(0,2,3), rmd);

    BOOST_CHECK_CLOSE(joint_pdf[0][0], 0.334, 0.1);
    BOOST_CHECK_CLOSE(joint_pdf[0][1], 0.333, 0.1);
    BOOST_CHECK_SMALL(joint_pdf[0][2], 0.1);
    BOOST_CHECK_SMALL(joint_pdf[1][0], 0.1);
    BOOST_CHECK_CLOSE(joint_pdf[1][1], 0.333, 0.1);
    BOOST_CHECK_SMALL(joint_pdf[1][2], 0.1);
    BOOST_CHECK_SMALL(joint_pdf[2][0], 0.1);
    BOOST_CHECK_SMALL(joint_pdf[2][1], 0.1);
    BOOST_CHECK_SMALL(joint_pdf[2][2], 0.1);
}

BOOST_AUTO_TEST_CASE ( MarginalizefromBidimensional )
{
    //Example 2
    const std::size_t exp_size=1000;
    std::vector < uint64 > dim_extents(2,exp_size);
    boost::array< Quantizer<int32>, 2 > array_q;

    Quantizer<int32> qint(0, 2, 3);
    array_q[0] = qint;
    array_q[1] = qint;

   // boost::mt19937 rng1(3);

    RandomVariableData< int32, 2, 1 > rmd(dim_extents);
    for (std::size_t i=0; i<exp_size; ++i)
    {
    	rmd(0)[i]=static_cast<int32>(2.0*static_cast<float64>(i%3)/3.0); //rand_uniform_int<int32>(0, 2, rng1);
    	rmd(1)[i]=static_cast<int32>(i*i)%3; //rand_uniform_int<int32>(0, 2, rng1);
    }

    const PDF < RandomVariableData < int32, 2, 1 > >& joint_pdf =
            calc_descriptor(new PDF < RandomVariableData < int32, 2, 1 > >(0,2,3), rmd);

	PDF < RandomVariableData < int32, 1, 1 > > pdf1 = marginalize(joint_pdf, 0);

    BOOST_CHECK_CLOSE(pdf1[0], 0.334, 0.1);
    BOOST_CHECK_CLOSE(pdf1[1], 0.666, 0.1);
    BOOST_CHECK_SMALL(pdf1[2], 0.1);

    pdf1=marginalize(joint_pdf, 1);

    BOOST_CHECK_CLOSE(pdf1[0], 0.667, 0.1);
    BOOST_CHECK_CLOSE(pdf1[1], 0.333, 0.1);
    BOOST_CHECK_SMALL(pdf1[2], 0.1);
}

BOOST_AUTO_TEST_CASE ( mutual_information )
{
	BOOST_CHECK(true);

    //Example (from Kwak and Choi)

    const std::size_t exp_size=1000;

    std::vector < uint64 > dim_extents(2,exp_size);

    std::vector < std::size_t > selected;

    boost::mt19937 rng1(3);

    std::vector < boost::array<float64, exp_size> > f(3);
    MultiArray < float64, 1 > zclass(1000);
    float64 X, Y;
    boost::array < float64, 3> mi;
    boost::array < float64, 3> mi_marginals;

    BOOST_CHECK(true);

    for (std::size_t i=0; i<exp_size; ++i)
    {
     	X=rand_uniform(-0.5, 0.5, rng1);
     	Y=rand_uniform(-0.5, 0.5, rng1);
     	f[0][i]=X; f[1][i]=X-Y; f[2][i]=Y*Y;
     	zclass[i]= (X+0.2*Y) > 0.0 ? 1 : 0;
    }

    BOOST_CHECK(true);

    //Array of quantizers
    boost::array< Quantizer<float64>, 2 > qclass;

    qclass[0]=Quantizer<float64>(0.0, 1.0, 10);
    qclass[1]=Quantizer<float64>(0, 1, 2);
    //Histogram (discrete pdf)

    PDF < RandomVariableData< float64, 2, 1 > > jointpdf(qclass);

    BOOST_CHECK(true);

    //Compute MI between features and class
    float64 min, max;
    for (std::size_t i=0; i<3; ++i)
    {
        RandomVariableData< float64, 2, 1 > class_data(dim_extents);

	    max=*(std::max_element(&f[i][0], &f[i][0]+f[i].size()));
	    min=*(std::min_element(&f[i][0], &f[i][0]+f[i].size()));
	    for (std::size_t j=0; j<exp_size; ++j)
	    {
	    	class_data(0)[j]=(f[i][j]-min)/(max-min); //Normalized features
	    	class_data(1)[j]=zclass[j];
	    }

	    jointpdf.calculate(class_data.colors_begin(), class_data.colors_end(), &(class_data.coll_vd()));
	    mi[i]=imageplus::math::statistics::mutual_information(jointpdf, 2);
	    mi_marginals[i]=imageplus::math::statistics::mutual_information(jointpdf, marginalize(jointpdf, 1), marginalize(jointpdf, 0), 2);

    }
    BOOST_CHECK(true);

    BOOST_CHECK_CLOSE(mi[0], 0.82757392715089495, 0.1);
    BOOST_CHECK_CLOSE(mi[1], 0.24722004174481321, 0.1);
    BOOST_CHECK_CLOSE(mi[2], 0.00867628322439564, 0.1);

    BOOST_CHECK_CLOSE(mi_marginals[0], 0.82757392715089495, 0.1);
    BOOST_CHECK_CLOSE(mi_marginals[1], 0.24722004174481321, 0.1);
    BOOST_CHECK_CLOSE(mi_marginals[2], 0.00867628322439564, 0.1);
}

BOOST_AUTO_TEST_CASE ( mutual_information_from_data_vector )
{
    //Example 2
    const std::size_t exp_size=1000;
    std::vector < uint64 > dim_extents(2,exp_size);
    boost::array< Quantizer<float64>, 2 > array_q;

    Quantizer<float64> qint(0, 2, 3);
    array_q[0] = qint;
    array_q[1] = qint;

   // boost::mt19937 rng1(3);

    RandomVariableData< float64, 2, 1 > rmd(dim_extents);
    for (std::size_t i=0; i<exp_size; ++i)
    {
    	rmd(0)[i]=static_cast<float64>(2.0*static_cast<float64>(i%3)/3.0); //rand_uniform_int<int32>(0, 2, rng1);
    	rmd(1)[i]=static_cast<float64>((i*i)%3); //rand_uniform_int<int32>(0, 2, rng1);
    }

    const PDF< RandomVariableData < float64, 2, 1 > >& joint_pdf =
            calc_descriptor(new PDF< RandomVariableData < float64, 2, 1 > >(array_q), rmd);

	float64 mi_data=imageplus::math::statistics::mutual_information(rmd, 3, 2.0);
    float64 mi=imageplus::math::statistics::mutual_information(joint_pdf, 2.0);

    BOOST_CHECK_CLOSE(mi, mi_data, 0.1);


}

BOOST_AUTO_TEST_CASE ( conditional_entropy )
{
    //Example (from Kwak and Choi)

    const std::size_t exp_size=1000;

    std::vector < uint64 > dim_extents(2,exp_size);
    std::vector < uint64 > marginal_extents(1,exp_size);

    std::vector < std::size_t > selected;

    boost::mt19937 rng1(3);

    std::vector < boost::array<float64, exp_size> > f(3);
    MultiArray < float64, 1 > zclass(1000);
    float64 X, Y;
    boost::array < float64, 3> mi;

    for (std::size_t i=0; i<exp_size; ++i)
    {
     	X=rand_uniform(-0.5, 0.5, rng1);
     	Y=rand_uniform(-0.5, 0.5, rng1);
     	f[0][i]=X; f[1][i]=X-Y; f[2][i]=Y*Y;
     	zclass[i]= (X+0.2*Y) > 0.0 ? 1 : 0;
    }
    //Array of quantizers
    boost::array< Quantizer<float64>, 2 > qclass;

    qclass[0]=Quantizer<float64>(0.0, 1.0, 10);
    qclass[1]=Quantizer<float64>(0, 1, 2);
    //Histogram (discrete pdf)

    PDF < RandomVariableData< float64, 2, 1 > > jointpdf(qclass);
    PDF < RandomVariableData< float64, 1, 1 > > marginalpdf; //(qclass[1]);

    //Compute MI between features and class
    float64 min, max;
    for (std::size_t i=0; i<3; ++i)
    {
        RandomVariableData< float64, 2, 1 > class_data(dim_extents);
        RandomVariableData< float64, 1, 1 > marginal_data(marginal_extents);
	    max=*(std::max_element(&f[i][0], &f[i][0]+f[i].size()));
	    min=*(std::min_element(&f[i][0], &f[i][0]+f[i].size()));
	    for (std::size_t j=0; j<exp_size; ++j)
	    {
	    	class_data(0)[j]    = (f[i][j]-min)/(max-min); //Normalized features
	    	marginal_data(0)[j] = zclass[j]; //(f[i][j]-min)/(max-min);
	    	class_data(1)[j]    = zclass[j];
	    }
	    //marginalpdf.calculate(marginal_data); //is the same than marginalizing

	    jointpdf.calculate(class_data.colors_begin(), class_data.colors_end(), &(class_data.coll_vd()));
	    marginalpdf=marginalize(jointpdf, 0); //p(class)
	    //mi[i]=imageplus::math::statistics::mutual_information(jointpdf, 2);
	    mi[i]=imageplus::math::statistics::conditional_entropy(jointpdf, marginalpdf, 2);
    }
    BOOST_CHECK_CLOSE(mi[0], 2.48903, 0.1);
    BOOST_CHECK_CLOSE(mi[1], 2.85412, 0.1);
    BOOST_CHECK_CLOSE(mi[2], 2.99424, 0.1);
}


BOOST_AUTO_TEST_CASE ( kullback_leibler )
{

    const std::size_t exp_size=1000;

    std::vector < uint64 > dim_extents(2,exp_size);
    std::vector < uint64 > marginal_extents(1,exp_size);

    std::vector < std::size_t > selected;

    boost::mt19937 rng1(3);

    std::vector < boost::array<float64, exp_size> > f(3);
    MultiArray < float64, 1 > zclass(1000);
    float64 X, Y;
    boost::array < float64, 3> mi;

    for (std::size_t i=0; i<exp_size; ++i)
    {
     	X=rand_uniform(-0.5, 0.5, rng1);
     	Y=rand_uniform(-0.5, 0.5, rng1);
     	f[0][i]=X; f[1][i]=X-Y; f[2][i]=Y*Y;
     	zclass[i]= (X+0.2*Y) > 0.0 ? 1 : 0;
    }
    //Array of quantizers
    boost::array< Quantizer<float64>, 2 > qclass;

    qclass[0]=Quantizer<float64>(0.0, 1.0, 3);
    qclass[1]=Quantizer<float64>(0, 1, 2);
    //Histogram (discrete pdf)

    PDF < RandomVariableData< float64, 2, 1 > > jointpdf(qclass);

   std::vector< PDF < RandomVariableData< float64, 2, 1 > > > jointpdf_collection;

    //Compute MI between features and class
    float64 min, max;
    for (std::size_t i=0; i<3; ++i)
    {
        RandomVariableData< float64, 2, 1 > class_data(dim_extents);
        RandomVariableData< float64, 1, 1 > marginal_data(marginal_extents);
	    max=*(std::max_element(&f[i][0], &f[i][0]+f[i].size()));
	    min=*(std::min_element(&f[i][0], &f[i][0]+f[i].size()));
	    for (std::size_t j=0; j<exp_size; ++j)
	    {
	    	class_data(0)[j]=(f[i][j]-min)/(max-min); //Normalized features
	    	marginal_data(0)[j]=zclass[j]; //(f[i][j]-min)/(max-min);
	    	class_data(1)[j]=zclass[j];
	    }

	    jointpdf.calculate(class_data.colors_begin(), class_data.colors_end(), &(class_data.coll_vd()));
	    jointpdf_collection.push_back(jointpdf);


	    //mi[i]=imageplus::math::statistics::conditional_entropy(jointpdf, marginalpdf, 2);



    }
    for (std::size_t i=0; i<2; ++i)
    {
    	mi[i]=imageplus::math::statistics::kullback_leibler_divergence(jointpdf_collection[i+1],jointpdf_collection[i], 2);

	}
	mi[2]=imageplus::math::statistics::kullback_leibler_divergence(jointpdf_collection[0],jointpdf_collection[1], 2);


    BOOST_CHECK_CLOSE(mi[0], -1.0, 0.1);
	BOOST_CHECK_CLOSE(mi[1], 0.915346, 0.1);
	BOOST_CHECK_CLOSE(mi[2], 0.300757, 0.1);
}



BOOST_AUTO_TEST_SUITE_END();
