// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------

/*!
 * \file camera_ptz.cpp
 */

#ifdef USE_SMARTFLOW

#include <imageplus/toolbox/camera_ptz.hpp>
#include <imageplus/math/numeric/products.hpp>
#include <fstream>

// Defines
#include <boost/math/constants/constants.hpp>
static const double PI = boost::math::constants::pi<double>();

using namespace std;
using namespace imageplus;
using namespace imageplus::toolbox;
namespace mn = math::numeric;

// Constructor
CameraPTZ::CameraPTZ( const std::string& calibration_filename, const std::string& port_path)
:   //_cam(NULL),
    _port_path(port_path),

    _pan_min_move (1),
    _tilt_min_move(1),
    _move_rate    (0.33),

    _pt_speed (17),
    _z_speed  ( 7),

    _trans_motor_in_zero(3),
    _rot_motor_in_zero(3,3),

    _rot_calib( 3, 3 ),
    _trans_calib( 3 ),
    _k_calib( 3, 3 ),
    _distortion_calib( 4 ),
    _focal_x_calib( 11 ),
    _focal_y_calib( 11 ),
    _principal_x_calib( 11 ),
    _principal_y_calib( 11 ),
    _skewness_calib( 11 )
{
    read_parameters( calibration_filename );
}

// Function to initialize the camera hardware
void CameraPTZ::init()
{
    _cam = boost::shared_ptr<EVI_D70P>(new EVI_D70P());

    //Opening serial port
    if(_cam->Init() != 1) throw ImagePlusError("Error initiating camera");

    if(_cam->Open(1, _port_path.c_str() ) != 1) throw ImagePlusError("Error initiating camera");

    //We do a power ON only if the camera is not already ON.
    int n = _cam->PowerInq();
    if(n == -1) throw ImagePlusError("Error initiating camera");
    if(n != -1)
    {
        if(n == EVILIB_OFF)
        {
            TRACE("Turning ON power...");
            if(_cam->Power(EVILIB_ON) != 1) throw ImagePlusError("Error initiating camera");
            TRACE("Turning ON power... done");
        }
    }

    // This MUST be done for the EVI-D70 after power(ON) (only for D70(P))
    _cam->DZoomCSModeInq();
}

// Function to move the camera to a XYZ position
void CameraPTZ::move( Point3D xyz_position )
{
    Position ptz_position = xyz2ptz( xyz_position );

    if( should_move( ptz_position ) )
    {
    	_cam->Pan_TiltDrive(EVILIB_ABSOLUTE, _pt_speed, _pt_speed, ptz_position.pan(), ptz_position.tilt(), EVILIB_NO_WAIT_COMP);
    }

    // Moving ZOOM (only if it is configured in combine mode)
	//
	//    if( _cam->getCombined() == EVILIB_COMBINE_MODE ){
	//        if( _cam->Zoom( EVILIB_DIRECT, _z_speed, z, EVILIB_NO_WAIT_COMP ) != 1 )  
	//            throw ImagePlusError("Error in zoom\n");     
	//    }else
	//        cout << "Zoom mode in Separate Mode!" << endl;

}

//Function to filter the positions to be sent to the function 'move'
bool CameraPTZ::should_move( Position new_pos )
{
	Timestamp new_ts = clock_ts();

	if( ( abs(_prev_pos.pan()  - new_pos.pan())  > _pan_min_move ||
	      abs(_prev_pos.tilt() - new_pos.tilt()) > _tilt_min_move ) &&
	      (new_ts - _prev_ts >= _move_rate) )
	{
		_prev_pos = new_pos;
		_prev_ts  = new_ts;

		return true;
	}

	return false;
}

//Function to know where the camera is at every moment
CameraPTZ::Position CameraPTZ::where()
{
    float32 pan;
    float32 tilt;
    float32 zoom;

    _cam->Pan_TiltPosInq( pan , tilt );
    _cam->ZoomPosInq    ( zoom );
    
    return Position(pan, tilt, zoom);
    
}

//Function to convert from XYZ coordinates to PTZ coordinates
CameraPTZ::Position CameraPTZ::xyz2ptz( Point3D xyz )
{
    Point3D                 cam_xyz;
    PointSpheric			sphere_xz;
    PointSpheric			sphere_yz;
    float64                 signp;
    float64                 signt;

    /*
     * Change the axis
     */
    cam_xyz = mn::prod( _rot_motor_in_zero, xyz ) - mn::prod( _rot_motor_in_zero, _trans_motor_in_zero );
    
    /*
     * Computing the sign
     */
    if( cam_xyz.x() > 0 ) signp = -1.0;
    else                  signp =  1.0;
    if( cam_xyz.y() > 0 ) signt = -1.0;
    else                  signt =  1.0;


    /*
     * Calculating sphere coordinates from the vector projected
     */
    sphere_xz = Point3D( cam_xyz.x(),
                         0,
                         cam_xyz.z() );

    sphere_yz = Point3D( cam_xyz.z(),
                         cam_xyz.x(),
                         cam_xyz.y() );
    
    Position out;

    out.pan ( _pan_scale_factor  * signp * (       sphere_xz.theta() * 180/PI)  );
    out.tilt( _tilt_scale_factor * signt * ( 90 - (sphere_yz.theta() * 180/PI)) );

    return out;
}

void CameraPTZ::read_parameters( const std::string & filename )
{
    char garbage[80];

    //Open input file
    ifstream ifs;
    ifs.open( filename.c_str(), ifstream::in );
    if( ifs.is_open() )
    {
        //Image size
        ifs.getline( garbage, 80 );

        ifs >> skipws >> _width >> _height;

        ifs.getline( garbage, 80 );
        ifs.getline( garbage, 80 );

        //Rotation matrix
        ifs.getline( garbage, 80 );

        ifs >> skipws >> _rot_calib[0][0] >> _rot_calib[1][0] >> _rot_calib[2][0];
        ifs >> skipws >> _rot_calib[0][1] >> _rot_calib[1][1] >> _rot_calib[2][1];
        ifs >> skipws >> _rot_calib[0][2] >> _rot_calib[1][2] >> _rot_calib[2][2];

        ifs.getline( garbage, 80 );
        ifs.getline( garbage, 80 );

        //Translation vector
        ifs.getline( garbage, 80 );

        ifs >> skipws >> _trans_calib[0] >>
                         _trans_calib[1] >>
                         _trans_calib[2];

        ifs.getline( garbage, 80 );
        ifs.getline( garbage, 80 );

        //Rotation radius, initial pan, initial tilt
        ifs.getline( garbage, 80 );

        ifs >> skipws >> _radius_calib >>_pan_calib >> _tilt_calib;

        ifs.getline( garbage, 80 );
        ifs.getline( garbage, 80 );

        //Non-written values of the projection matrix:
        float64 lenght_x;
        float64 lenght_y;
        float64 ppoint_x;
        float64 ppoint_y;

        //Focal lengthes zoom=0
        ifs.getline( garbage, 80 );

        ifs >> skipws >> lenght_x >> lenght_y;

        ifs.getline( garbage, 80 );
        ifs.getline( garbage, 80 );

        //Principal points zoom=0
        ifs.getline( garbage, 80 );

        ifs >> skipws >> ppoint_x >> ppoint_y;

        ifs.getline( garbage, 80 );
        ifs.getline( garbage, 80 );

        _k_calib[0][0] = lenght_x; _k_calib[1][0] =        0; _k_calib[2][0] = ppoint_x;
        _k_calib[0][1] =        0; _k_calib[1][1] = lenght_y; _k_calib[2][1] = ppoint_y;
        _k_calib[0][2] =        0; _k_calib[1][2] =        0; _k_calib[2][2] =        1;

        //distortion parameters
        ifs.getline( garbage, 80 );

        ifs >> skipws >> _distortion_calib[0] >>
                         _distortion_calib[1] >>
                         _distortion_calib[2];

        ifs.getline( garbage, 80 );
        ifs.getline( garbage, 80 );

        //focal length x polynomial model
        ifs.getline( garbage, 80 );

        ifs >> skipws >> _focal_x_calib[0] >> _focal_x_calib[1] >> _focal_x_calib[2] >>
                         _focal_x_calib[3] >> _focal_x_calib[4] >> _focal_x_calib[5] >>
                         _focal_x_calib[6] >> _focal_x_calib[7] >> _focal_x_calib[8] >>
                         _focal_x_calib[9] >> _focal_x_calib[10];

        ifs.getline( garbage, 80 );
        ifs.getline( garbage, 80 );

        //focal length y polynomial model
        ifs.getline( garbage, 80 );

        ifs >> skipws >> _focal_y_calib[0] >> _focal_y_calib[1] >> _focal_y_calib[2] >>
                         _focal_y_calib[3] >> _focal_y_calib[4] >> _focal_y_calib[5] >>
                         _focal_y_calib[6] >> _focal_y_calib[7] >> _focal_y_calib[8] >>
                         _focal_y_calib[9] >> _focal_y_calib[10];

        ifs.getline( garbage, 80 );
        ifs.getline( garbage, 80 );

        //principal point x polynomial model
        ifs.getline( garbage, 80 );

        ifs >> skipws >> _principal_x_calib[0] >> _principal_x_calib[1] >> _principal_x_calib[2] >>
                         _principal_x_calib[3] >> _principal_x_calib[4] >> _principal_x_calib[5] >>
                         _principal_x_calib[6] >> _principal_x_calib[7] >> _principal_x_calib[8] >>
                         _principal_x_calib[9] >> _principal_x_calib[10];

        ifs.getline( garbage, 80 );
        ifs.getline( garbage, 80 );

        //principal point y polynomial model
        ifs.getline( garbage, 80 );

        ifs >> skipws >> _principal_y_calib[0] >> _principal_y_calib[1] >> _principal_y_calib[2] >>
                         _principal_y_calib[3] >> _principal_y_calib[4] >> _principal_y_calib[5] >>
                         _principal_y_calib[6] >> _principal_y_calib[7] >> _principal_y_calib[8] >>
                         _principal_y_calib[9] >> _principal_y_calib[10];

        ifs.getline( garbage, 80 );
        ifs.getline( garbage, 80 );

        //skewness polynomial model
        ifs.getline( garbage, 80 );

        ifs >> skipws >> _skewness_calib[0] >> _skewness_calib[1] >> _skewness_calib[2] >>
                         _skewness_calib[3] >> _skewness_calib[4] >> _skewness_calib[5] >>
                         _skewness_calib[6] >> _skewness_calib[7] >> _skewness_calib[8] >>
                         _skewness_calib[9] >> _skewness_calib[10];

        ifs.getline( garbage, 80 );
        ifs.getline( garbage, 80 );

        //Pan and Tilt scale factor
        ifs.getline( garbage, 80 );

        ifs >> skipws >> _pan_scale_factor >> _tilt_scale_factor;

        ifs.getline( garbage, 80 );
        ifs.getline( garbage, 80 );

        //Motor point
        ifs.getline( garbage, 80 );
        ifs >> skipws >> _trans_motor_in_zero.x() >>
                         _trans_motor_in_zero.y() >>
                         _trans_motor_in_zero.z();
    }
    else
    {
        throw ImagePlusFileNotFound( filename );
    }

    ifs.close();

    update( Position(0,0,0) );
    _rot_motor_in_zero = _rot;
}

void CameraPTZ::update( const Position& ptz )
{
    //Extrinsics:
    float64 tilt_rad = ( ptz.tilt() + _tilt_calib ) * 0.0174532925; //in radians, from degrees
    float64 pan_rad  = ( ptz.pan()  +  _pan_calib ) * 0.0174532925; //in radians, from degrees

    float64 cost = cos( tilt_rad );
    float64 cosp = cos( pan_rad  );
    float64 sint = sin( tilt_rad );
    float64 sinp = sin( pan_rad  );

    MultiArray<float64,2> rot_t( 3, 3 );
    rot_t[0][0]=1; rot_t[1][0]=0;    rot_t[2][0]=0;
    rot_t[0][1]=0; rot_t[1][1]=cost; rot_t[2][1]=-sint;
    rot_t[0][2]=0; rot_t[1][2]=sint; rot_t[2][2]=cost;

    MultiArray<float64,2> rot_p( 3, 3 );
    rot_p[0][0]=cosp;  rot_p[1][0]=0; rot_p[2][0]=sinp;
    rot_p[0][1]=0;     rot_p[1][1]=1; rot_p[2][1]=0;
    rot_p[0][2]=-sinp; rot_p[1][2]=0; rot_p[2][2]=cosp;

    MultiArray<float64,2> rot_tp=math::numeric::prod( rot_t, rot_p );

    _trans = math::numeric::prod( rot_tp, _trans_calib ); //missing translation variable with focal length (with zoom==0, equals to _radius)
    _rot   = math::numeric::prod( rot_tp, _rot_calib   );

    //Intrinsics and center of projections, which varies with focal length:
    if( ptz.zoom() == 0 )
    {
        _trans[2]  += _radius_calib;
        _distortion = _distortion_calib;
        _k          = _k_calib;
    }
    else
    {
        std::cerr<<"WARNING: Zoom support still under development!!!!"<<std::endl;
        _trans[2]  += _radius_calib; //wrong
        _distortion = _distortion_calib; //wrong
        float64 * pdata = _k.data();
        pdata[0] = eval_polynomial( _focal_x_calib     , ptz.zoom() );
        pdata[1] = eval_polynomial( _skewness_calib    , ptz.zoom() ); //wrong
        pdata[2] = eval_polynomial( _principal_x_calib , ptz.zoom() );
        pdata[3] = 0;
        pdata[4] = eval_polynomial( _focal_y_calib     , ptz.zoom() );
        pdata[5] = eval_polynomial( _principal_y_calib , ptz.zoom() );
        pdata[6] = 0;
        pdata[7] = 0;
        pdata[8] = 1;
    }

    MultiArray<float64,2> marot   = math::numeric::prod( _k, _rot );
    MultiArray<float64,1> matrans = math::numeric::prod( _k, _trans );

    _p[0][0] = marot[0][0]; _p[1][0] = marot[1][0]; _p[2][0] = marot[2][0]; _p[3][0] = matrans[0];
    _p[0][1] = marot[0][1]; _p[1][1] = marot[1][1]; _p[2][1] = marot[2][1]; _p[3][1] = matrans[1];
    _p[0][2] = marot[0][2]; _p[1][2] = marot[1][2]; _p[2][2] = marot[2][2]; _p[3][2] = matrans[2];
}

float64 CameraPTZ::eval_polynomial( const MultiArray<float64,1>& polynomial, float64 point )
{
    std::size_t deg  = polynomial.dims(0) - 1;

    ASSERT( deg>=0, "Polynomial degree must be >= 0. Deg=" << deg );

    float64 res = polynomial[0];
    for( std::size_t i=0; i < deg; ++i)
    {
        res *= point;
        res += polynomial[i+1];
    }

    return res;
}

#endif // USE_SMARTFLOW
