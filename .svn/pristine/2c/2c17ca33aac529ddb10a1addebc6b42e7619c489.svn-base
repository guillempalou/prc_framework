// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------

//!
//!  \file sobel_gradient.hpp
//!
//!  Sobel gradient
//!
#ifndef IMAGEPLUS_FILTERS_SOBEL_GRADIENT_HPP
#define IMAGEPLUS_FILTERS_SOBEL_GRADIENT_HPP

#include <imageplus/core.hpp>
#include <imageplus/math/numeric/transformations.hpp>
#include <imageplus/filters/linear_convolution.hpp>

namespace imageplus
{
    namespace filters
    {
    	//! \brief Function to compute the sobel gradient of an image
    	//! \param[in] image : image from where the gradient is computed
    	//! \param[in] gradient : image where the gradient is stored
        template<class InputModel>
        void sobel_gradient(const InputModel& image, ImageGray<float64>& gradient)
        {
            MultiArray<float64,2> GxMask(3,3), GyMask(3,3);
            uint64 s_x=image.size_x(), s_y=image.size_y();

            /* Declare Sobel masks */
            GxMask[0][0] = -1.0; GxMask[0][1] = 0.0; GxMask[0][2] = 1.0;
            GxMask[1][0] = -2.0; GxMask[1][1] = 0.0; GxMask[1][2] = 2.0;
            GxMask[2][0] = -1.0; GxMask[2][1] = 0.0; GxMask[2][2] = 1.0;
            GxMask=imageplus::math::numeric::trans(GxMask);
            
            GyMask[0][0] =  1.0; GyMask[0][1] =  2.0; GyMask[0][2] =  1.0;
            GyMask[1][0] =  0.0; GyMask[1][1] =  0.0; GyMask[1][2] =  0.0;
            GyMask[2][0] = -1.0; GyMask[2][1] = -2.0; GyMask[2][2] = -1.0;
            GyMask=imageplus::math::numeric::trans(GyMask);

            //Analyze gradient strength
            gradient.resize(s_x, s_y); 
            ImageGray<int64> component_x(s_x, s_y), component_y(s_x, s_y), im64(s_x, s_y);

            filters::LinearConvolution sobx(GxMask), soby(GyMask);
            for (uint64 j=0; j<s_x*s_y; j++) im64(0).data()[j]=static_cast<int64>(image(0).data()[j]);
            component_x=sobx.filter(im64); 
            component_y=soby.filter(im64);

            //Sobel derivatives
            int64 *X, *Y; 
            X=component_x(0).data();
            Y=component_y(0).data();

            for (uint64 j=0; j<s_y*s_x; j++, ++X, ++Y)
            {
                gradient(0).data()[j]=std::sqrt(static_cast<float64>((*X))*static_cast<float64>((*X))+
                                                static_cast<float64>((*Y))*static_cast<float64>((*Y)));
            }
        }
    }
}
#endif

