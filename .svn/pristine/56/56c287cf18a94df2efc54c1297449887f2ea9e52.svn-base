// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------

/*!
 * \example coord.test
 * 
 * A test-examples of Coord class
 */  

#include <imageplus/core/coord.hpp>
#include <imageplus/core/array_arithmetic.hpp>

BOOST_AUTO_TEST_SUITE ( suite_coord );

using namespace imageplus;

typedef boost::mpl::list< boost::mpl::pair<   uint8, boost::mpl::int_<1> >,
                          boost::mpl::pair<  uint16, boost::mpl::int_<1> >,
                          boost::mpl::pair<  uint32, boost::mpl::int_<1> >,
                          boost::mpl::pair<  uint64, boost::mpl::int_<1> >,
                          boost::mpl::pair<    int8, boost::mpl::int_<1> >,
                          boost::mpl::pair<   int16, boost::mpl::int_<1> >,
                          boost::mpl::pair<   int32, boost::mpl::int_<1> >,
                          boost::mpl::pair<   int64, boost::mpl::int_<1> >,
                          
                          boost::mpl::pair<   uint8, boost::mpl::int_<2> >,
                          boost::mpl::pair<  uint16, boost::mpl::int_<2> >,
                          boost::mpl::pair<  uint32, boost::mpl::int_<2> >,
                          boost::mpl::pair<  uint64, boost::mpl::int_<2> >,
                          boost::mpl::pair<    int8, boost::mpl::int_<2> >,
                          boost::mpl::pair<   int16, boost::mpl::int_<2> >,
                          boost::mpl::pair<   int32, boost::mpl::int_<2> >,
                          boost::mpl::pair<   int64, boost::mpl::int_<2> >,
                          
                          boost::mpl::pair<   uint8, boost::mpl::int_<3> >,
                          boost::mpl::pair<  uint16, boost::mpl::int_<3> >,
                          boost::mpl::pair<  uint32, boost::mpl::int_<3> >,
                          boost::mpl::pair<  uint64, boost::mpl::int_<3> >,
                          boost::mpl::pair<    int8, boost::mpl::int_<3> >,
                          boost::mpl::pair<   int16, boost::mpl::int_<3> >,
                          boost::mpl::pair<   int32, boost::mpl::int_<3> >,
                          boost::mpl::pair<   int64, boost::mpl::int_<3> >,

                          boost::mpl::pair<   uint8, boost::mpl::int_<4> >,
                          boost::mpl::pair<  uint16, boost::mpl::int_<4> >,
                          boost::mpl::pair<  uint32, boost::mpl::int_<4> >,
                          boost::mpl::pair<  uint64, boost::mpl::int_<4> >,
                          boost::mpl::pair<    int8, boost::mpl::int_<4> >,
                          boost::mpl::pair<   int16, boost::mpl::int_<4> >,
                          boost::mpl::pair<   int32, boost::mpl::int_<4> >,
                          boost::mpl::pair<   int64, boost::mpl::int_<4> > > CoordTypes; 

    
BOOST_AUTO_TEST_CASE_TEMPLATE( test_coord_basic, TT, CoordTypes )
{
    /*
     * Template test by TT: boost::mpl::pair< T, boost::mpl::int_<D> >
     */
    typedef typename TT::first  T;
    static const std::size_t    D = TT::second::value;

    /*
     * Default constructor
     */
    Coord<T,D> c1;
    
    BOOST_CHECK(c1.dims() == D);
    for(std::size_t ii=0; ii<D; ++ii) 
    {
        BOOST_CHECK(c1[ii] == 0);
    }
    
    /*
     * Init test data
     */
    for(std::size_t ii=0; ii<D; ++ii)
    {
        c1[ii] = ii+3;
    }
    
    /*
     * Copy constructor
     */
    Coord<T,D> c2 = c1;
    BOOST_CHECK(c2 == c1);
    BOOST_CHECK(c2.dims() == c1.dims());
    for(std::size_t ii=0; ii<D; ++ii)
    {
        BOOST_CHECK(c2[ii] == c1[ii]);
        BOOST_CHECK(c2[ii] == T(ii+3)); // cast necessary for signed/unsigned comparations
    }
    
    /*
     * Copy constructor from a different data type
     */
    Coord<int64,D> c3 = c1;
    BOOST_CHECK(c3 == c1);
    BOOST_CHECK(c3.dims() == c1.dims());
    for(std::size_t ii=0; ii<D; ++ii)
    {
        BOOST_CHECK(c3[ii] == int64(c1[ii])); // cast necessary for signed/unsigned comparations
        BOOST_CHECK(c3[ii] == int64(ii+3));   // cast necessary for signed/unsigned comparations
    }
    
    /*
     * Copy constructor from a MultiArray
     */
    MultiArray<T,1>     mc1( boost::extents[D] );
    MultiArray<int64,1> mc2( boost::extents[D] );

    for(std::size_t ii=0; ii<D; ++ii)
    {
        mc1[ii] = ii+4;
        mc2[ii] = ii+5;
    }
    
    Coord<T,D> c4(mc1);
    Coord<T,D> c5(mc2);
    
    BOOST_CHECK(c4 == mc1);
    BOOST_CHECK(c5 == mc2);
    
    BOOST_CHECK(c4 != mc2); // just to also check operator != between array and multiarray
    BOOST_CHECK(c5 != mc1); // just to also check operator != between array and multiarray
    
    for(std::size_t ii=0; ii<D; ++ii)
    {
        BOOST_CHECK(c4[ii] ==   mc1[ii]);
        BOOST_CHECK(c5[ii] == T(mc2[ii]));   // cast necessary for signed/unsigned comparations
    }
    
    /*
     * Specific constructors and specific access methods
     */
    Coord<T,1> c1d(3);
    Coord<T,2> c2d(4,5);
    Coord<T,3> c3d(6,7,8);
    
    BOOST_CHECK(c1d.x() == 3);
    BOOST_CHECK(c2d.x() == 4);
    BOOST_CHECK(c2d.y() == 5);
    BOOST_CHECK(c3d.x() == 6);
    BOOST_CHECK(c3d.y() == 7);
    BOOST_CHECK(c3d.z() == 8);

    /*
     * Assignement operator
     */
    BOOST_CHECK(c4 != c5); // just to be sure... 
    c4=c5;
    BOOST_CHECK(c4 == c5);
    
    /*
     * Specific set methods
     */
    c1d.set(30);
    c2d.set(40,50);
    c3d.set(60,70,80);

    BOOST_CHECK(c1d.x() == 30);
    BOOST_CHECK(c2d.x() == 40);
    BOOST_CHECK(c2d.y() == 50);
    BOOST_CHECK(c3d.x() == 60);
    BOOST_CHECK(c3d.y() == 70);
    BOOST_CHECK(c3d.z() == 80);
    
    c1d.x() = 35;
    c2d.x() = 45;
    c2d.y() = 55;
    c3d.x() = 65;
    c3d.y() = 75;
    c3d.z() = 85;
    
    BOOST_CHECK(c1d.x() == 35);
    BOOST_CHECK(c2d.x() == 45);
    BOOST_CHECK(c2d.y() == 55);
    BOOST_CHECK(c3d.x() == 65);
    BOOST_CHECK(c3d.y() == 75);
    BOOST_CHECK(c3d.z() == 85);
    
    BOOST_CHECK(c1d.x() == c1d[0]);
    BOOST_CHECK(c2d.x() == c2d[0]);
    BOOST_CHECK(c2d.y() == c2d[1]);
    BOOST_CHECK(c3d.x() == c3d[0]);
    BOOST_CHECK(c3d.y() == c3d[1]);
    BOOST_CHECK(c3d.z() == c3d[2]);
}

BOOST_AUTO_TEST_CASE_TEMPLATE( test_coord_arithmetic, TT, CoordTypes )
{
    /*
     * Template test by TT: boost::mpl::pair< T, boost::mpl::int_<D> >
     */
    typedef typename TT::first  T;
    static const std::size_t    D = TT::second::value;

    /*
     * Init data
     */
    Coord<T,D>    c1;
    Coord<int8,D> c2;
    Coord<T,D>    out;
    for(std::size_t ii=0; ii<D; ++ii)
    {
        c1[ii] = ii;
        c2[ii] = ii;
    }
    
    /*
     * Addition
     */
    out = c1+c2;
    for(std::size_t ii=0; ii<D; ++ii)
    {
        BOOST_CHECK( out[ii] == T(2*ii));
    }
    
    /*
     * Substraction assignment
     */
    out -= c1;
    for(std::size_t ii=0; ii<D; ++ii)
    {
        BOOST_CHECK( out[ii] == T(ii));
    }

    /*
     * Substraction
     */
    out = c1-c2;
    for(std::size_t ii=0; ii<D; ++ii)
    {
        BOOST_CHECK( out[ii] == 0);
    }
    
    /*
     * Addition assignment
     */
    out += c1;
    for(std::size_t ii=0; ii<D; ++ii)
    {
        BOOST_CHECK( out[ii] == T(ii));
    }
    
    /*
     * Scalar addition
     */
    out = c1+T(5);
    for(std::size_t ii=0; ii<D; ++ii)
    {
        BOOST_CHECK( out[ii] == T(ii+5));
    }

    out = T(3)+c1;
    for(std::size_t ii=0; ii<D; ++ii)
    {
        BOOST_CHECK( out[ii] == T(3+ii));
    }
    
    out = T(3)+c1+T(5);
    for(std::size_t ii=0; ii<D; ++ii)
    {
        BOOST_CHECK( out[ii] == T(3+ii+5));
    }

    out += T(3);
    for(std::size_t ii=0; ii<D; ++ii)
    {
        BOOST_CHECK( out[ii] == T(6+ii+5));
    }
    
    /*
     * Scalar substraction
     */
    out = c1-T(5);
    for(std::size_t ii=0; ii<D; ++ii)
    {
        BOOST_CHECK( out[ii] == T(T(ii)-T(5)));
    }

    out = T(3)-c1;
    for(std::size_t ii=0; ii<D; ++ii)
    {
        BOOST_CHECK( out[ii] == T(3-ii));
    }
    
    out -= T(4);
    for(std::size_t ii=0; ii<D; ++ii)
    {
        BOOST_CHECK( out[ii] == T(T(-1)-T(ii)));
    }
        
    /*
     * Scalar product
     */
    out = T(3)*c1;
    for(std::size_t ii=0; ii<D; ++ii)
    {
        BOOST_CHECK( out[ii] == T(3*ii));
    }

    out = c1*T(5);
    for(std::size_t ii=0; ii<D; ++ii)
    {
        BOOST_CHECK( out[ii] == T(5*ii));
    }
    
    out = T(3)*c1*T(5);
    for(std::size_t ii=0; ii<D; ++ii)
    {
        BOOST_CHECK( out[ii] == T(15*ii));
    }
    
    /*
     * Scalar division
     */
    out = c1/T(2);
    for(std::size_t ii=0; ii<D; ++ii)
    {
        BOOST_CHECK( out[ii] == T(ii/2));
    }
    
    out = T(15)*c1/T(5);
    for(std::size_t ii=0; ii<D; ++ii)
    {
        BOOST_CHECK( out[ii] == T(3*ii));
    }
}

#ifndef NDEBUG
BOOST_AUTO_TEST_CASE( test_coord_assert_exceptions )
{
    /*
     * Test to just check some assert (in debug mode)
     */
    Coord<int16, 1> c1;
    Coord<int16, 2> c2;
    Coord<int16, 3> c3;
            
    BOOST_CHECK_THROW(c1.set(2,3)  , ImagePlusInternalError);
    BOOST_CHECK_THROW(c1.set(2,3,4), ImagePlusInternalError);
    
    BOOST_CHECK_THROW(c2.set(2)    , ImagePlusInternalError);
    BOOST_CHECK_THROW(c2.set(2,3,4), ImagePlusInternalError);

    BOOST_CHECK_THROW(c3.set(2)    , ImagePlusInternalError);
    BOOST_CHECK_THROW(c3.set(2,3)  , ImagePlusInternalError);
    
    BOOST_CHECK_THROW(c1.y(), ImagePlusInternalError);
    BOOST_CHECK_THROW(c1.z(), ImagePlusInternalError);
    BOOST_CHECK_THROW(c2.z(), ImagePlusInternalError);
}
#endif //NDEBUG

BOOST_AUTO_TEST_SUITE_END ();
