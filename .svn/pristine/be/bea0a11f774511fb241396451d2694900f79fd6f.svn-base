// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------

//!
//!  \file numeric_util.hpp
//!
//!  Add brief description of the file here
//!


#ifndef IMAGEPLUS_MATH_NUMERIC_NUMERIC_UTIL_HPP
#define IMAGEPLUS_MATH_NUMERIC_NUMERIC_UTIL_HPP


#include <imageplus/core.hpp>
#include <boost/numeric/conversion/cast.hpp>

namespace imageplus
{
    namespace math
    {
        namespace numeric
        {
            //!
            //! \brief Hypotenuse of real scalars a and b
            //!
            //! In a right triangle, if we let c be the length of the hypotenuse 
            //! and a and b be the lengths of the other two sides, the Pythagoras' theorem 
            //! states that:\n
            //!
            //! \f$ c = \sqrt{a^2 + b^2}.\f$\n 
            //!
            //! Underflow/overflow is avoided using \n
            //! \f$ \left( a \cdot \sqrt{ 1 + {b \over a} \cdot {b \over a}} \right) \f$, rather than \f$ \sqrt{a*a + b*b} \f$.
            //!
            //! \param [in] a : First cathetus
            //! \param [in] b : Second cathetus
            //! 
            //! \return Hypotenuse of real (non-complex) scalars a and b
            //!
            //! \author Ramon Morros <ramon.morros@upc.edu>
            //!
            //! \date 30-03-2008
            //!
            float64 hypot(float64 a, float64 b);

            //!
            //! \brief Rounding to nearest integer
            //!
            //! \tparam T1 : Type of the output data
            //! \tparam T2 : Type of the input data
            //!
            //! \param [in] inval : Value to round
            //! 
            //! \return Rounded value
            //!
            //! Usage:
            //! \code
            //!    float64 a = 3.7;
            //!    int64   b = mnint<int64>(a); // value of b will be 4
            //!    // You can use this function to return a real value representing an integer
            //!    float64 c = mnint<float64>(a); // Value of c will be 4.0
            //! \endcode
            //!
            //! \author Ramon Morros <ramon.morros@upc.edu>
            //!
            //! \date 3-05-2008
            //!
            template<typename T1, typename T2>
            T1 mnint (T2 inval);
        } // numeric
    } // math
} // imageplus

//
// Implementation
//
namespace imageplus
{
    namespace math
    {
        namespace numeric
        {
            inline
            float64 hypot(float64 a, float64 b)
            {
                if (a == 0)
                {
                    return fabs(b);
                }
                else
                {
                    float64 c = b/a;
                    return fabs(a) * std::sqrt(1 + c*c);
                }
            }

            template<typename T1, typename T2>
            T1 mnint (T2 inval)
            {
                // largest_integer outval = (inval < 0) ? static_cast<largest_integer>(inval-0.5) : static_cast<largest_integer>(inval+0.5);
                //largest_integer outval = static_cast<largest_integer>(floor(inval+0.5));

                //ASSERT (outval <= std::numeric_limits<T1>::max(), "Conversion causes data loss");
                // This 'hack' is needed because std::numeric_limits<T1>::min() for floating point values 
                // does not return the minimum negative value but the smallest POSITIVE number that can be represented
                //ASSERT (outval >= (std::numeric_limits<T1>::is_integer ? std::numeric_limits<T1>::min() : -std::numeric_limits<T1>::max()) , "Conversion causes data loss");
                
                return (boost::numeric_cast<T1>(floor(inval+0.5)));
            }
        }
    }
}

#endif // IMAGEPLUS_MATH_NUMERIC_NUMERIC_UTIL_HPP
