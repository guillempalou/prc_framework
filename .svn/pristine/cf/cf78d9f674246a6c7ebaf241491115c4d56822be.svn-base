/*
 * motion_color_model_distance.hpp
 *
 *  Created on: Apr 12, 2013
 *      Author: gpalou
 */

#ifndef MOTION_COLOR_MODEL_DISTANCE_HPP_
#define MOTION_COLOR_MODEL_DISTANCE_HPP_

#include <imageplus/descriptors/descriptor_manager.hpp>

#include <imageplus/descriptors/geometry/area.hpp>
#include <imageplus/descriptors/color/color_mean.hpp>
#include <imageplus/descriptors/video/temporal_max.hpp>
#include <imageplus/descriptors/video/temporal_mean.hpp>
#include <imageplus/descriptors/video/temporal_signature.hpp>
#include <imageplus/descriptors/video/temporal_model.hpp>
#include <imageplus/descriptors/color/color_signature.hpp>

#include <imageplus/math/optimization/emd.hpp>

#include <imageplus/bpt/models/bpt_distance_model.hpp>

namespace imageplus
{
    namespace video_segmentation
    {

        //! Class from which any model must inherit to work properly
        template<class SignalModel, class RegionModel, class OpticalFlowModel, typename order_type=float64>
        class MotionColorModelDistance : public bpt::BaseDistanceModel<SignalModel, RegionModel, order_type>
        {
        	typedef VideoSignal<float64,1>	ReliabilityMap;

        	typedef descriptors::ColorSignature<SignalModel>			ColorSignatureDescritor;
        	typedef descriptors::Area									AreaDescriptor;
        	typedef descriptors::TemporalModel<OpticalFlowModel>		MotionSignatureDescriptor;
        	typedef descriptors::TemporalMean<ReliabilityMap>			ReliabilityMeanDescriptor;

        public:

        	struct Parameters {
        		OpticalFlowModel optical_flow;
        		int64 num_colors;

        		float64 color_damping;
        		float64 motion_damping;
        		float64 spatial_damping;
        		float64 area_damping;

        		ReliabilityMap		flow_reliability; 	// the higher the more reliable

        		Parameters() : optical_flow(OpticalFlowModel::coord_type::Zero()), flow_reliability(ReliabilityMap::coord_type::Zero()) {

        		}
        	};

        	static const Parameters default_parameters() {
        		return Parameters();
        	}


        	MotionColorModelDistance(const Parameters& pars = default_parameters()) {
        		_pars = pars;

        		EMDDistance distance(SignalModel::value_float_type::Ones()*_pars.color_damping);

        		_emd 		= math::optimization::EMD<EMDDistance>(distance);
        	}

            //! This function computes the order of a given link (edge of the RAG)
            //!
            //! \param reg1 : Region of one extremum of the link
            //! \param reg2 : Region of the other extremum of the link
            //! \param image : Image being processed
            //! \param bpt : Partition at the moment of the merging
            //! \return The order of the link
        	template<class BPT>
            order_type region_distance(RegionModel& reg1, RegionModel& reg2, SignalModel& image, BPT& bpt, descriptors::DescriptorManager& manager) {

        		float64 dc = color_distance(reg1,reg2,image,bpt,manager);
        		std::vector<float64> dmr = motion_distance(reg1,reg2,image,bpt,manager);
        		float64 da = area_distance(reg1,reg2,image,bpt,manager);

        		float64 dm = dmr[0];
        		//float64 reliability = dmr[1];

        		//float64 ds = spatial_distance(reg1,reg2,image,bpt,manager);

        		if (dm > 1) dm = 0;
        		if (dc > 1) dc = 0;
        		//if (ds > 1) ds = 0;

        		float64 gamma = 0.99;

            	return (1 - (1-dc*gamma)*(1-dm*gamma))*da;
        	}

        	template<class BPT>
        	float64 color_distance(RegionModel& reg1, RegionModel& reg2, SignalModel& image, BPT& bpt, descriptors::DescriptorManager& manager) {

        		typename ColorSignatureDescritor::Parameters signature_pars;
        		signature_pars.num_colors = _pars.num_colors;
        		signature_pars.weights = SignalModel::value_float_type::Ones()*(_pars.color_damping);

        		const typename ColorSignatureDescritor::type& color1 = manager.calc_descriptor<ColorSignatureDescritor>(image, reg1, signature_pars);
        		const typename ColorSignatureDescritor::type& color2 = manager.calc_descriptor<ColorSignatureDescritor>(image, reg2, signature_pars);

        		return _emd.calculate(color1,color2);
        	}

        	template<class BPT>
        	std::vector<float64> motion_distance(RegionModel& reg1, RegionModel& reg2, SignalModel& image, BPT& bpt, descriptors::DescriptorManager& manager) {

        		const typename ReliabilityMeanDescriptor::type& reliability1 = manager.calc_descriptor<ReliabilityMeanDescriptor>(_pars.flow_reliability, reg1);
        		const typename ReliabilityMeanDescriptor::type& reliability2 = manager.calc_descriptor<ReliabilityMeanDescriptor>(_pars.flow_reliability, reg2);

        		const typename MotionSignatureDescriptor::type& motion1 = manager.calc_descriptor<MotionSignatureDescriptor>(_pars.optical_flow, reg1);
        		const typename MotionSignatureDescriptor::type& motion2 = manager.calc_descriptor<MotionSignatureDescriptor>(_pars.optical_flow, reg2);

        		float64 motion_distance = 0;
        		float64 reliability = 0;

        		int64 begin_frame = std::max(motion1.begin_frame, motion2.begin_frame);
        		int64 end_frame = std::min(motion1.end_frame, motion2.end_frame);

        		for (int64 f = begin_frame; f <= end_frame; f++) {

        			float64 r = std::min(reliability1.mean(f)(0),reliability2.mean(f)(0));

        			typename MotionSignatureDescriptor::parametric_type model1 = motion1.model_flow(f);
        			typename MotionSignatureDescriptor::parametric_type model2 = motion2.model_flow(f);

        			//std::cout << model1.transpose() << std::endl;
        			//std::cout << model2.transpose() << std::endl;

        			// evaluate the motion distance
        			float64 e1 = 0, e2 = 0;
        			float64 n1 = 0, n2 = 0;
        			for (typename RegionModel::iterator p = reg1.begin(); p != reg1.end(); ++p) {
        				math::Matrix A(2,8);

        				float64 x = (*p)(0);
        				float64 y = (*p)(1);

        				A.row(0) << 1, x, y, 0, 0, 0, x*x, x*y;
        				A.row(1) << 0, 0, 0, 1, x, y, x*y, y*y;

        				// calculate the error of the other model over own pixels
        				math::Vector flow = A*model2;
        				e1 += (flow-_pars.optical_flow(*p)).squaredNorm();
        				n1++;
        			}
        			for (typename RegionModel::iterator p = reg2.begin(); p != reg2.end(); ++p) {
        				math::Matrix A(2,8);

        				float64 x = (*p)(0);
        				float64 y = (*p)(1);

        				A.row(0) << 1, x, y, 0, 0, 0, x*x, x*y;
        				A.row(1) << 0, 0, 0, 1, x, y, x*y, y*y;

        				// calculate the error of the other model over own pixels
        				math::Vector flow = A*model1;
        				e2 += (flow-_pars.optical_flow(*p)).squaredNorm();
        				n2++;
        			}

        			e1 /= n1;
        			e2 /= n2;

        			float64 d = r*(1-std::exp(-std::max(e1,e2)/ _pars.motion_damping));

        			//std::cout << d/r << " " << d << std::endl;

        			if (d > motion_distance) {
        				motion_distance = d;
        				reliability = r;
        			}
        		}
        		//std::cout << "Distance - " << reg1.label() << " " << reg2.label() << "  =   " << motion_distance << std::endl << "---------------" << std::endl;

        		std::vector<float64> v(2);

        		v[0] = motion_distance;
        		v[1] = reliability;

        		return v;
        	}


        	template<class BPT>
        	float64 area_distance(RegionModel& reg1, RegionModel& reg2, SignalModel& image, BPT& bpt, descriptors::DescriptorManager& manager) {
        		const typename AreaDescriptor::type area1 = manager.calc_descriptor<AreaDescriptor>(image,reg1);
        		const typename AreaDescriptor::type area2 = manager.calc_descriptor<AreaDescriptor>(image,reg2);

        		float64 d = std::min(area1,area2); // * _pars.area_damping;

        		//return 1 - std::exp(-d);
        		return std::log(1+d);
        	}

        private:

        	typedef typename SignalModel::value_float_type 																	ColorType;
        	typedef typename OpticalFlowModel::value_float_type 															MotionType;
        	typedef typename math::statistics::PerceptualDistance<ColorType, typename SignalModel::value_float_type>		EMDDistance;
        	typedef typename math::statistics::PerceptualDistance<MotionType, typename OpticalFlowModel::value_float_type>	EMDMotionDistance;

        	math::optimization::EMD<EMDDistance> 		_emd;
        	math::optimization::EMD<EMDMotionDistance>  _emd_motion;
        	Parameters 									_pars;

        };

    }
}

#endif /* MOTION_COLOR_MODEL_DISTANCE_HPP_ */
