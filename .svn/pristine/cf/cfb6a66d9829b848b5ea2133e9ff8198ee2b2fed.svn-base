// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------

/*!
 * \file readwritepartition.test
 */ 

#include <imageplus/io/readwritepartition.hpp>
#include <imageplus/io/writeimage.hpp>


BOOST_AUTO_TEST_SUITE ( ReadWritePartition_Suite );

using namespace imageplus;
using namespace std;

BOOST_AUTO_TEST_CASE( read_write_partition_txt )
{
    ImagePartition<> temp_part(2,2);
     
    temp_part[0][0] = 3;
    temp_part[1][0] = 8;
    temp_part[0][1] = 8;
    temp_part[1][1] = 9;

    ImageRGB<uint8> temp_image(2,2);
    ImageRGB<uint8> temp_image2;
    
    typedef ImageRGB<uint8> InputType;
    typedef imageplus::Region<Coord2D<int64> > RegionType;
    typedef Partition<RegionType> partition_type;
    
    partition_type my_partition(temp_part);
    merge_regions(8,9,26,my_partition);

    io::WriteImage w_image;
    w_image.open(string(TEST_DATA_PATH_W) + "/rw_bpt_test_relative.png");
    w_image << temp_image;

    w_image.open(string(TEST_DATA_PATH_W) + "/rw_bpt_test_relative.prl");
    w_image << temp_part;
    
    std::vector<std::string> names;
     names.push_back("ImageFile");
     names.push_back("PartitionSearchFile");
    std::vector<std::string> values;
     values.push_back("rw_bpt_test_relative.png");
     values.push_back("rw_bpt_test_relative.prl");
    
    io::ReadWritePartition rw_bpt(string(TEST_DATA_PATH_W) + "/rw_bpt_test_relative.txt", names, values);
    rw_bpt.write(my_partition, temp_image);
    
    io::ReadWritePartition rw_bpt2(string(TEST_DATA_PATH_W) + "/rw_bpt_test_relative.txt");
    partition_type my_partition2;
    rw_bpt2.read(my_partition2, temp_image2);
    
    BOOST_CHECK(temp_image==temp_image2);
        
    BOOST_CHECK_EQUAL( my_partition2.num_regions(), (std::size_t)4 );
     
    BOOST_CHECK_EQUAL( my_partition2[3].size(), (std::size_t)1 );
    BOOST_CHECK_EQUAL( my_partition2[8].size(), (std::size_t)2 );
    BOOST_CHECK_EQUAL( my_partition2[9].size(), (std::size_t)1 );
    BOOST_CHECK_EQUAL( my_partition2[26].size(), (std::size_t)3 );
     
    BOOST_CHECK_EQUAL( my_partition2[3].label(), (uint32)3 );
    BOOST_CHECK_EQUAL( my_partition2[8].label(), (uint32)8 );
    BOOST_CHECK_EQUAL( my_partition2[9].label(), (uint32)9 );
    BOOST_CHECK_EQUAL( my_partition2[26].label(), (uint32)26 );

    BOOST_CHECK_EQUAL( my_partition[3].parts().size(), (std::size_t)0 );
    BOOST_CHECK_EQUAL( my_partition[8].parts().size(), (std::size_t)0 );
    BOOST_CHECK_EQUAL( my_partition[9].parts().size(), (std::size_t)0 );
    
    BOOST_CHECK_EQUAL( my_partition[3].is_composite(), (bool)true );
    BOOST_CHECK_EQUAL( my_partition[8].is_composite(), (bool)true );
    BOOST_CHECK_EQUAL( my_partition[9].is_composite(), (bool)true );
    BOOST_CHECK_EQUAL( my_partition[26].is_composite(), (bool)true );
     
    BOOST_CHECK_EQUAL( my_partition[26].parts().size(), (std::size_t)2 );
    BOOST_CHECK( (my_partition2[26].parts()[0]->label()==8 &&  my_partition2[26].parts()[1]->label()==9) ||
                 (my_partition2[26].parts()[0]->label()==9 &&  my_partition2[26].parts()[1]->label()==8) );
}

#ifdef USE_XML
BOOST_AUTO_TEST_CASE( read_write_partition )
{
    ImagePartition<> temp_part(2,2);
     
    temp_part[0][0] = 3;
    temp_part[1][0] = 8;
    temp_part[0][1] = 8;
    temp_part[1][1] = 9;

    ImageRGB<uint8> temp_image(2,2);
    ImageRGB<uint8> temp_image2;
    
    typedef ImageRGB<uint8> InputType;
    typedef imageplus::Region<Coord2D<int64> > RegionType;
    typedef Partition<RegionType> partition_type;
    
    partition_type my_partition(temp_part);
    merge_regions(8,9,26,my_partition);

    io::WriteImage w_image;
    w_image.open(string(TEST_DATA_PATH_W) + "/rw_bpt_test_relative.png");
    w_image << temp_image;

    w_image.open(string(TEST_DATA_PATH_W) + "/rw_bpt_test_relative.prl");
    w_image << temp_part;
    
    std::vector<std::string> names;
     names.push_back("ImageFile");
     names.push_back("PartitionSearchFile");
    std::vector<std::string> values;
     values.push_back("rw_bpt_test_relative.png");
     values.push_back("rw_bpt_test_relative.prl");
    
    io::ReadWritePartition rw_bpt(string(TEST_DATA_PATH_W) + "/rw_bpt_test_relative.xml", names, values);
    rw_bpt.write(my_partition, temp_image);
    
    io::ReadWritePartition rw_bpt2(string(TEST_DATA_PATH_W) + "/rw_bpt_test_relative.xml");
    partition_type my_partition2;
    rw_bpt2.read(my_partition2, temp_image2);
    
    BOOST_CHECK(temp_image==temp_image2);
        
    BOOST_CHECK_EQUAL( my_partition2.num_regions(), (std::size_t)4 );
     
    BOOST_CHECK_EQUAL( my_partition2[3].size(), (std::size_t)1 );
    BOOST_CHECK_EQUAL( my_partition2[8].size(), (std::size_t)2 );
    BOOST_CHECK_EQUAL( my_partition2[9].size(), (std::size_t)1 );
    BOOST_CHECK_EQUAL( my_partition2[26].size(), (std::size_t)3 );
     
    BOOST_CHECK_EQUAL( my_partition2[3].label(), (uint32)3 );
    BOOST_CHECK_EQUAL( my_partition2[8].label(), (uint32)8 );
    BOOST_CHECK_EQUAL( my_partition2[9].label(), (uint32)9 );
    BOOST_CHECK_EQUAL( my_partition2[26].label(), (uint32)26 );

    BOOST_CHECK_EQUAL( my_partition[3].parts().size(), (std::size_t)0 );
    BOOST_CHECK_EQUAL( my_partition[8].parts().size(), (std::size_t)0 );
    BOOST_CHECK_EQUAL( my_partition[9].parts().size(), (std::size_t)0 );
    
    BOOST_CHECK_EQUAL( my_partition[3].is_composite(), (bool)true );
    BOOST_CHECK_EQUAL( my_partition[8].is_composite(), (bool)true );
    BOOST_CHECK_EQUAL( my_partition[9].is_composite(), (bool)true );
    BOOST_CHECK_EQUAL( my_partition[26].is_composite(), (bool)true );
     
    BOOST_CHECK_EQUAL( my_partition[26].parts().size(), (std::size_t)2 );
    BOOST_CHECK( (my_partition2[26].parts()[0]->label()==8 &&  my_partition2[26].parts()[1]->label()==9) ||
                 (my_partition2[26].parts()[0]->label()==9 &&  my_partition2[26].parts()[1]->label()==8) );
}


BOOST_AUTO_TEST_CASE( read_write_complete_partition )
{
    ImagePartition<> temp_part(2,2);
     
    temp_part[0][0] = 3;
    temp_part[1][0] = 8;
    temp_part[0][1] = 8;
    temp_part[1][1] = 9;

    ImageRGB<uint8> temp_image(2,2);
    ImageRGB<uint8> temp_image2;
     
    typedef ImageRGB<uint8> InputType;
    typedef imageplus::Region<Coord2D<int64> > RegionType;
    typedef Partition<RegionType> partition_type;
    
    partition_type my_partition(temp_part);
    merge_regions(8,9,26,my_partition);
    
    boost::filesystem::path im_path( boost::filesystem::system_complete(string(TEST_DATA_PATH_W) + "/rw_bpt_test_complete.png") );
    boost::filesystem::path part_path( boost::filesystem::system_complete(string(TEST_DATA_PATH_W) + "/rw_bpt_test_complete.prl") );
    
    io::WriteImage w_image(im_path.string());
    w_image << temp_image;

    w_image.open(part_path.string());
    w_image << temp_part;
    
    std::vector<std::string> names;
     names.push_back("ImageFile");
     names.push_back("PartitionSearchFile");
    std::vector<std::string> values;
     values.push_back(im_path.string());
     values.push_back(part_path.string());
     
    io::ReadWritePartition rw_bpt(string(TEST_DATA_PATH_W) + "/rw_bpt_test_complete.xml", names, values);
    rw_bpt.write(my_partition,temp_image);
    
    io::ReadWritePartition rw_bpt2(string(TEST_DATA_PATH_W) + "/rw_bpt_test_complete.xml");
    partition_type my_partition2;
    rw_bpt2.read(my_partition2,temp_image2);
    
    BOOST_CHECK(temp_image==temp_image2);
    
    BOOST_CHECK_EQUAL( my_partition2.num_regions(), (std::size_t)4 );
     
    BOOST_CHECK_EQUAL( my_partition2[3].size(), (std::size_t)1 );
    BOOST_CHECK_EQUAL( my_partition2[8].size(), (std::size_t)2 );
    BOOST_CHECK_EQUAL( my_partition2[9].size(), (std::size_t)1 );
    BOOST_CHECK_EQUAL( my_partition2[26].size(), (std::size_t)3 );
     
    BOOST_CHECK_EQUAL( my_partition2[3].label(), (uint32)3 );
    BOOST_CHECK_EQUAL( my_partition2[8].label(), (uint32)8 );
    BOOST_CHECK_EQUAL( my_partition2[9].label(), (uint32)9 );
    BOOST_CHECK_EQUAL( my_partition2[26].label(), (uint32)26 );

    BOOST_CHECK_EQUAL( my_partition[3].parts().size(), (std::size_t)0 );
    BOOST_CHECK_EQUAL( my_partition[8].parts().size(), (std::size_t)0 );
    BOOST_CHECK_EQUAL( my_partition[9].parts().size(), (std::size_t)0 );
    
    BOOST_CHECK_EQUAL( my_partition[3].is_composite(), (bool)true );
    BOOST_CHECK_EQUAL( my_partition[8].is_composite(), (bool)true );
    BOOST_CHECK_EQUAL( my_partition[9].is_composite(), (bool)true );
    BOOST_CHECK_EQUAL( my_partition[26].is_composite(), (bool)true );
     
    BOOST_CHECK_EQUAL( my_partition[26].parts().size(), (std::size_t)2 );
    BOOST_CHECK( (my_partition2[26].parts()[0]->label()==8 &&  my_partition2[26].parts()[1]->label()==9) ||
                 (my_partition2[26].parts()[0]->label()==9 &&  my_partition2[26].parts()[1]->label()==8) );
}


BOOST_AUTO_TEST_CASE( read_write_relative_with_image_partition )
{
    ImagePartition<> temp_part(2,2);
     
    temp_part[0][0] = 3;
    temp_part[1][0] = 8;
    temp_part[0][1] = 8;
    temp_part[1][1] = 9;

    ImageRGB<uint8> temp_image(2,2);
    ImageRGB<uint8> temp_image2;
     
    typedef ImageRGB<uint8> InputType;
    typedef imageplus::Region<Coord2D<int64> > RegionType;
    typedef Partition<RegionType> partition_type;
    
    partition_type my_partition(temp_part);    merge_regions(8,9,26,my_partition);

    io::WriteImage w_image;
    w_image.open(string(TEST_DATA_PATH_W) + "/rw_bpt_test_image_relative.png");
    w_image << temp_image;

    w_image.open(string(TEST_DATA_PATH_W) + "/rw_bpt_test_image_relative.prl");
    w_image << temp_part;
    
    std::vector<std::string> names;
     names.push_back("ImageFile");
     names.push_back("PartitionSearchFile");
    std::vector<std::string> values;
     values.push_back("rw_bpt_test_image_relative.png");
     values.push_back("rw_bpt_test_image_relative.prl");
    
    io::ReadWritePartition rw_bpt(string(TEST_DATA_PATH_W) + "/rw_bpt_test_image_relative.xml", names, values, imageplus::io::WRITE_IMAGE_PART);
    rw_bpt.write(my_partition,temp_image);
    
    io::ReadWritePartition rw_bpt2(string(TEST_DATA_PATH_W) + "/rw_bpt_test_image_relative.xml");
    partition_type my_partition2;
    rw_bpt2.read(my_partition2,temp_image2);
    
    BOOST_CHECK(temp_image==temp_image2);
    
    BOOST_CHECK_EQUAL( my_partition2.num_regions(), (std::size_t)4 );
     
    BOOST_CHECK_EQUAL( my_partition2[3].size(), (std::size_t)1 );
    BOOST_CHECK_EQUAL( my_partition2[8].size(), (std::size_t)2 );
    BOOST_CHECK_EQUAL( my_partition2[9].size(), (std::size_t)1 );
    BOOST_CHECK_EQUAL( my_partition2[26].size(), (std::size_t)3 );
     
    BOOST_CHECK_EQUAL( my_partition2[3].label(), (uint32)3 );
    BOOST_CHECK_EQUAL( my_partition2[8].label(), (uint32)8 );
    BOOST_CHECK_EQUAL( my_partition2[9].label(), (uint32)9 );
    BOOST_CHECK_EQUAL( my_partition2[26].label(), (uint32)26 );

    BOOST_CHECK_EQUAL( my_partition[3].parts().size(), (std::size_t)0 );
    BOOST_CHECK_EQUAL( my_partition[8].parts().size(), (std::size_t)0 );
    BOOST_CHECK_EQUAL( my_partition[9].parts().size(), (std::size_t)0 );
    
    BOOST_CHECK_EQUAL( my_partition[3].is_composite(), (bool)true );
    BOOST_CHECK_EQUAL( my_partition[8].is_composite(), (bool)true );
    BOOST_CHECK_EQUAL( my_partition[9].is_composite(), (bool)true );
    BOOST_CHECK_EQUAL( my_partition[26].is_composite(), (bool)true );
     
    BOOST_CHECK_EQUAL( my_partition[26].parts().size(), (std::size_t)2 );
    BOOST_CHECK( (my_partition2[26].parts()[0]->label()==8 &&  my_partition2[26].parts()[1]->label()==9) ||
                 (my_partition2[26].parts()[0]->label()==9 &&  my_partition2[26].parts()[1]->label()==8) );
}



BOOST_AUTO_TEST_CASE( read_write_with_image_complete_partition )
{
    ImagePartition<> temp_part(2,2);
     
    temp_part[0][0] = 3;
    temp_part[1][0] = 8;
    temp_part[0][1] = 8;
    temp_part[1][1] = 9;

    ImageRGB<uint8> temp_image(2,2);
    ImageRGB<uint8> temp_image2;
     
    typedef ImageRGB<uint8> InputType;
    typedef imageplus::Region<Coord2D<int64> > RegionType;
    typedef Partition<RegionType> partition_type;
    
    partition_type my_partition(temp_part);    merge_regions(8,9,26,my_partition);
    
    boost::filesystem::path im_path( boost::filesystem::system_complete(string(TEST_DATA_PATH_W) + "/rw_bpt_test_image_complete.png") );
    boost::filesystem::path part_path( boost::filesystem::system_complete(string(TEST_DATA_PATH_W) + "/rw_bpt_test_image_complete.prl") );
    
    io::WriteImage w_image(im_path.string());
    w_image << temp_image;

    w_image.open(part_path.string());
    w_image << temp_part;
    
    std::vector<std::string> names;
     names.push_back("ImageFile");
     names.push_back("PartitionSearchFile");
    std::vector<std::string> values;
     values.push_back(im_path.string());
     values.push_back(part_path.string());
     
    io::ReadWritePartition rw_bpt(string(TEST_DATA_PATH_W) + "/rw_bpt_test_image_complete.xml", names, values, imageplus::io::WRITE_IMAGE_PART);
    rw_bpt.write(my_partition,temp_image);
    
    io::ReadWritePartition rw_bpt2(string(TEST_DATA_PATH_W) + "/rw_bpt_test_image_complete.xml");
    partition_type my_partition2;
    rw_bpt2.read(my_partition2,temp_image2);
    
    BOOST_CHECK(temp_image==temp_image2);
    
    BOOST_CHECK_EQUAL( my_partition2.num_regions(), (std::size_t)4 );
     
    BOOST_CHECK_EQUAL( my_partition2[3].size(), (std::size_t)1 );
    BOOST_CHECK_EQUAL( my_partition2[8].size(), (std::size_t)2 );
    BOOST_CHECK_EQUAL( my_partition2[9].size(), (std::size_t)1 );
    BOOST_CHECK_EQUAL( my_partition2[26].size(), (std::size_t)3 );
     
    BOOST_CHECK_EQUAL( my_partition2[3].label(), (uint32)3 );
    BOOST_CHECK_EQUAL( my_partition2[8].label(), (uint32)8 );
    BOOST_CHECK_EQUAL( my_partition2[9].label(), (uint32)9 );
    BOOST_CHECK_EQUAL( my_partition2[26].label(), (uint32)26 );

    BOOST_CHECK_EQUAL( my_partition[3].parts().size(), (std::size_t)0 );
    BOOST_CHECK_EQUAL( my_partition[8].parts().size(), (std::size_t)0 );
    BOOST_CHECK_EQUAL( my_partition[9].parts().size(), (std::size_t)0 );
    
    BOOST_CHECK_EQUAL( my_partition[3].is_composite(), (bool)true );
    BOOST_CHECK_EQUAL( my_partition[8].is_composite(), (bool)true );
    BOOST_CHECK_EQUAL( my_partition[9].is_composite(), (bool)true );
    BOOST_CHECK_EQUAL( my_partition[26].is_composite(), (bool)true );
     
    BOOST_CHECK_EQUAL( my_partition[26].parts().size(), (std::size_t)2 );
    BOOST_CHECK( (my_partition2[26].parts()[0]->label()==8 && my_partition2[26].parts()[1]->label()==9) ||
                 (my_partition2[26].parts()[0]->label()==9 && my_partition2[26].parts()[1]->label()==8) );
}



#endif


BOOST_AUTO_TEST_CASE( read_write_bpt_exceptions )
{
    io::ReadWritePartition rw_bpt;
    ImageRGB<uint8> my_image(2,2);
    ImagePartition<> my_part(2,2);
    typedef ImageRGB<uint8> InputType;
    typedef RegionContour<Coord2D<int64> > RegionType;
    typedef Partition<RegionType> partition_type;
    
    partition_type my_bpt(my_part);
        
    BOOST_CHECK_THROW(rw_bpt.write(my_bpt), std::exception);
    BOOST_CHECK_THROW(rw_bpt.read(my_bpt),  std::exception);
    
#ifdef USE_XML
    BOOST_CHECK_NO_THROW(rw_bpt.open(string(TEST_DATA_PATH_R) + "/bpt/fus_seq_utils.xml"));
#else
    BOOST_CHECK_THROW(rw_bpt.open(string(TEST_DATA_PATH_R) + "/bpt/fus_seq_utils.xml"), std::exception);
#endif
    BOOST_CHECK_THROW(rw_bpt.open(string(TEST_DATA_PATH_R) + "/bpt/BPT_image.png"), ImagePlusError);
    
    BOOST_CHECK_NO_THROW(rw_bpt.open(string(TEST_DATA_PATH_R) + "/bpt/fus_seq_utils.txt"));

    
#ifdef USE_XML
    BOOST_CHECK_THROW(rw_bpt.open("/this/path/does/not/exist.xml"), ImagePlusError);
    
    std::vector<std::string> names;
      names.push_back("ImageFile");
      names.push_back("PartitionSearchFile");
    std::vector<std::string> values;
      values.push_back("this_image_does_not_exist.png");
      values.push_back("this_partition_does_not_exist.prl");      

   rw_bpt.open(string(TEST_DATA_PATH_W) + "/this_path_exists_1.xml", names, values);
   BOOST_CHECK_THROW(rw_bpt.write(my_bpt,my_image), std::exception);

   rw_bpt.open(string(TEST_DATA_PATH_W) + "/this_path_exists_2.xml", names, values, imageplus::io::DO_NOT_CHECK_IMAGE_PART);
   BOOST_CHECK_NO_THROW(rw_bpt.write(my_bpt,my_image));
   
   
   names.resize(0);
     names.push_back("ImageFile");
     names.push_back("PartitionSearchFile");
   values.resize(0);
     values.push_back("this_image_exists.png");
     values.push_back("this_partition_exists.prl");      
   
   
   rw_bpt.open(string(TEST_DATA_PATH_W) + "/this_path_exists_3.xml", names, values, imageplus::io::WRITE_IMAGE_PART);
   BOOST_CHECK_NO_THROW(rw_bpt.write(my_bpt,my_image));
   
   rw_bpt.open(string(TEST_DATA_PATH_W) + "/this_path_exists_4.xml", names, values);
   BOOST_CHECK_NO_THROW(rw_bpt.write(my_bpt,my_image));

   rw_bpt.open(string(TEST_DATA_PATH_W) + "/this_path_exists_5.xml", names, values, imageplus::io::DO_NOT_CHECK_IMAGE_PART);
   BOOST_CHECK_NO_THROW(rw_bpt.write(my_bpt,my_image));
   
   rw_bpt.open(string(TEST_DATA_PATH_W) + "/this_path_exists_6.xml", names, values, imageplus::io::WRITE_IMAGE_PART);
   BOOST_CHECK_NO_THROW(rw_bpt.write(my_bpt,my_image));
#endif
   
}


BOOST_AUTO_TEST_SUITE_END ();
