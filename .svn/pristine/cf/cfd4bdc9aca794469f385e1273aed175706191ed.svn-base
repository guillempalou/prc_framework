// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------

//!
//!  \file edge_detection.cpp
//!
//!  Implementation for Edge detection with canny and morphological operators with foreground masks in order to 
//!  
//!

#define IMAGEPLUS_TOOL_CONFIG_NAME  edge_detection
//#define IMAGEPLUS_TOOL_CONFIG_GROUP nogroup

#include <imageplus/filters/canny.hpp>
#include <imageplus/filters/gaussian.hpp>
#include <imageplus/core/convert_colorspace.hpp>
#include <imageplus/io/readimage.hpp>
#include <imageplus/io/writeimage.hpp>
#include <imageplus/math/morphology/dilation.hpp>
#include <imageplus/math/numeric/transformations.hpp>
#include <boost/format.hpp>
#include <string>

#include <iostream>
#include <imageplus/toolbox/tool_config.hpp>

using namespace imageplus;
using namespace imageplus::filters;
using namespace imageplus::io;
using namespace imageplus::math::morphology;
using namespace imageplus::math::numeric;

IMAGEPLUS_TOOL_CONFIG_BRIEF()

    "Detects edges from a given sequence\n";

IMAGEPLUS_TOOL_CONFIG_DESCRIPTION()

    "Tool aiming at edge detection from a given frame or sequence  \n" +
    "The input images can be a single image, a sequence of images  \n" +
    "or a multiview sequence from cameras 1 to N. \n" +
    "Edge results are presented from black - 0 (no edge) to white -255 (strong edge) .  \n" +
    "************************************************************* \n"+
    "Three basic methods are implemented and 3 different post-processing steps can be applied. \n" +
    "1.- High Pass Filter: The easiest an less accurate. Smooths the original image with a \n" +
    "Gaussian mask and the result is substracted from the original gray image. \n" +
    "2.- Sobel Edges: Sobel Masks over X and Y are applied to the original Image. \n" +
    "Two thresolds must be provided: \n" +
    "Upper threshold: pixel with gradient strength  over this value is set to 255. \n" +
    "Lower threshold: pixel with gradient strength below this value is set to 0 \n" +
    "3.- Canny Edge Detector: Again, two thresholds must be provided: \n" +
    "Upper threshold: pixel with gradient strength over this value is considered edge pixel. \n" +
    "Lower threshold: pixel with gradient strength below this value is considered non-edge \n" +
    "in edge tracing operations. Please check ImagePlus documentation for more detailed information \n"+
    "***********************************************************************\n"+
    "Post-processing: (operations are applied in this order, if enabled) \n" +
    "Background suppression: Background edges can be removed providing foreground masks.\n" +
    "Dilation: Edge detection can be dilated qith a squared structuring element. size and\n" +
    "connectivity should be provided \n " + 
    "Smoothing: A gaussian mask is applied to the result. Mask parameters are the same of the high pass filter\n" +
    "********************************************************************************************** \n";

IMAGEPLUS_TOOL_CONFIG_PARAMETERS()

    // my options
	std::string intempl; //input path template
	std::string outempl;// output path template
	std::string masktempl; //fg mask template
	int32 ut, lt; //upper and lower thresholds
	uint64 numcams;
	int32 gmask_size;
	float64 dev;
	uint64 dil_con, dil_size;
	uint64 init_frame, end_frame;
	
    // my flags
	bool canny, sobel, high_pass; //modes
	bool dilate, smooth, background_suppression; //post-processing
	bool multiview; //multiview option
	
    // my arguments

IMAGEPLUS_TOOL_CONFIG_DEFAULT_VALUES()

    intempl="";
    outempl="";
    masktempl="";
    ut=60;
    lt=30;
    numcams=0;
    dil_size=0;
    dil_con=8;
    gmask_size=7;
    dev=0.8;
    init_frame=0;
    end_frame=0;
    	
    canny=false, sobel=false, high_pass=false;
    dilate=false, smooth=false, background_suppression=false;
    multiview=false;
    
        
IMAGEPLUS_TOOL_CONFIG_OPTIONS()

    add_option(init_frame, "init_frame", "first frame to process", 'I');
    add_option(end_frame, "end_frame", "las frame to process", 'E');
    add_option  (intempl , "intempl" , "formated input path (including the formatting for cameras if multiview processing is desired)", 'i' );
    add_option  (outempl , "outempl" , "formated output path (including the formatting for cameras if multiview processing is desired)", 'o' );
    add_option  (masktempl , "masktempl" , "formated foreground mask path (including the formatting for cameras if multiview processing is desired)", 'm' );
    add_option  (ut, "ut", "upper threshold" , 'u' );
    add_option  (lt , "lt ", "lower threshold",'l');
    add_option (numcams , "numcams", "number of views in the multiview sequence", 'N');
    add_option (dil_size, "dil_size", "Size of the post-dilation", 's');
    add_option (dil_con, "dil_con", "Connectivity for the post-dilation",'c');
    add_option (dev, "dev", "Standard deviation of the Gaussian Mask", 'D');
    add_option (gmask_size, "gmask_size", "Gaussian Mask size (odd)", 'g' );

IMAGEPLUS_TOOL_CONFIG_FLAGS()

    add_flag (canny        , "canny"        , "Canny Edge Detector "            , 'C' );
    add_flag (sobel        , "sobel"        , "Sobel Edge Detector "            , 'S' );
    add_flag (high_pass       , "high_pass"        , "High Pass Filter "            , 'H' );
    add_flag (smooth       , "smooth"        , "Gaussian Mask Post-processing " , 'f' );

IMAGEPLUS_TOOL_CONFIG_ARGUMENTS()


IMAGEPLUS_TOOL_CONFIG_READ_PARAMETERS()

    read("init_frame", init_frame);
    read("end_frame", end_frame);
    read("intempl" , intempl);
    read("outempl" , outempl);
    read("masktempl",masktempl );
    read("ut", ut);
    read("lt", lt);
    read("numcams", numcams);
    read("dil_size", dil_size);
    read("dil_con", dil_con);
    read("dev", dev);
    read("gmask_size", gmask_size);
    read("canny", canny);
    read("sobel", sobel);
    read("high_pass", high_pass);
    read("smooth", smooth);
        
    if (masktempl!="") background_suppression=true;
    if (numcams>0) multiview=true;
    if (dil_con >0 && dil_size>0) dilate=true;
    if (dev==0.0 || gmask_size==0)
    {
        high_pass=false;
        smooth=false;
    }

IMAGEPLUS_TOOL_CONFIG_MAIN()
{
	std::string intempl=cfg.intempl;
	std::string outempl=cfg.outempl;
	std::string masktempl=cfg.masktempl;
	std::string infile, outfile, maskfile;
	uint64 numcams=cfg.numcams;
	if (numcams<1) numcams=1;
	int32 ut=cfg.ut, lt=cfg.lt;
	ImageRGB <uint8> ima; 
	ImageGray <uint8> mask;
	uint64 im_x, im_y;
	uint64 init_frame=cfg.init_frame, end_frame=cfg.end_frame;
	Dilation<2> dil(8,3);
	uint64 dil_con, dil_size;
	if (cfg.dilate)
	{
		dil_size=cfg.dil_size;
		dil_con=cfg.dil_con;
	}
	else
	{
		dil_size=1;
		dil_con=8;
	}
	Dilation<2> dil2(dil_con,dil_size);
	
	MultiArray<float64,2> GxMask(3,3), GyMask(3,3);
	/* Declare Sobel masks */
	GxMask[0][0] = -1.0; GxMask[0][1] = 0.0; GxMask[0][2] = 1.0;
	GxMask[1][0] = -2.0; GxMask[1][1] = 0.0; GxMask[1][2] = 2.0;
	GxMask[2][0] = -1.0; GxMask[2][1] = 0.0; GxMask[2][2] = 1.0;
	//imageplus::division(GxMask, 2.0, tmp_sob);
	//tmp_sob=GxMask;
	GxMask=imageplus::math::numeric::trans(GxMask);
	GyMask[0][0] =  1.0; GyMask[0][1] =  2.0; GyMask[0][2] =  1.0;
	GyMask[1][0] =  0.0; GyMask[1][1] =  0.0; GyMask[1][2] =  0.0;
	GyMask[2][0] = -1.0; GyMask[2][1] = -2.0; GyMask[2][2] = -1.0;
	GxMask=imageplus::math::numeric::trans(GyMask);
	
	
	//Gaussian Mask

	int32 gmask_size=cfg.gmask_size;
	float64 dev=cfg.dev;
	float64 total=0.0;
	MultiArray<float64,2> gmask(gmask_size,gmask_size);
	gmask=gaussian_mask(dev, gmask_size);
	for (int64 i=0; i< gmask_size*gmask_size; ++i) total+=gmask.data()[i];
	imageplus::division(gmask, total, gmask);
	LinearConvolution smoother(gmask);


	//Get the image size by reading the first frame
	bool single_image=false;
	if (cfg.multiview)
		infile=str(boost::format( intempl.c_str() ) % 1 % init_frame);
	else if (intempl.find("%")!=std::string::npos)
		infile=str(boost::format( intempl.c_str() ) % init_frame);
	else
	{
		infile=intempl;
		init_frame=0; 
		end_frame=1;
		single_image=true;
	}
	
	std::cout << "Extracting image parameters from  " << infile << std::endl;	
	ReadImage rim(infile); 
	rim >> ima;
	im_x=ima(0).dims(0); im_y=ima(0).dims(1);
	std::cout << im_x  << " " << im_y << std::endl;	
	ImageGray <uint8> auxm(im_x, im_y);
	ImageGray <uint8> auxi(im_x, im_y);
	ImageGray <uint8> grayima(im_x, im_y);
	
	//Sobel filters and additional elements
	ImageGray<int64> component_x(im_x, im_y), component_y(im_x, im_y), im64(im_x, im_y);
	
	float64 grad;
	int64 *X, *Y;
	LinearConvolution sobx(GxMask), soby(GyMask);

	//Show the current operation mode
	if ( (cfg.canny && cfg.sobel) || (cfg.canny && cfg.high_pass) || (cfg.sobel && cfg.high_pass))
	{
		std::cout << "Only one method can be called!" << std::endl;
		exit(-1);
	}
	if (cfg.canny)
	{
		std::cout << "Canny Edge Detector --- Upper Threshold: " << ut << " Lower Threshold: " << lt << std::endl;
	}
	if (cfg.sobel)
	{
		std::cout << "Sobel Edge Detector --- Upper Threshold: " << ut << " Lower Threshold: " << lt << std::endl;
	}
	if (cfg.high_pass)
	{
		std::cout << "High Pass Filter --- (LP Gaussian Mask -> sigma: " << dev << " size: " <<  gmask_size << std::endl;
	}
	if (cfg.multiview)
		std::cout << "Multiple view processing enabled for " << cfg.numcams << " cameras" << std::endl; 
	std::cout << "************** Post-processing ************** " << std::endl;
	if (cfg.background_suppression)
		std::cout << "Background suppression enabled" << std::endl;
	if (cfg.dilate)
	{
		std::cout << "Dilation size " << cfg.dil_size << " " << cfg.dil_con << "-connectivity" << std::endl;
	}
	if (cfg.smooth)
	{
		std::cout << "Smoothing with Gaussian Mask -> sigma: " << dev << " size: " <<  gmask_size << std::endl;
	}
	
	for (uint64 frame=init_frame; frame<end_frame; frame++)
	{
		for (uint64 c=0; c<numcams; c++)
		{
			
			if (cfg.multiview)
			{
				infile=str(boost::format( intempl.c_str() ) % (c+1) % frame);
				outfile=str(boost::format( outempl.c_str() ) % (c+1) % frame);
				if (cfg.background_suppression)
					maskfile=str(boost::format( masktempl.c_str() ) % (c+1) % frame);
			}
			else if (!single_image)
			{
				infile=str(boost::format( intempl.c_str() ) % frame);
				outfile=str(boost::format( outempl.c_str() ) % frame);
				if (cfg.background_suppression)
					maskfile=str(boost::format( masktempl.c_str() ) % frame);
			}
			else
			{
				infile=intempl; outfile=outempl;
				if (cfg.background_suppression)
					maskfile=masktempl;
							
			}
			ReadImage rim(infile); WriteImage wim(outfile); 
			
			rim >> ima;
			
			if (cfg.background_suppression)
			{
				ReadImage rma(maskfile);
				rma >> mask;
			}
			
			grayima=to_gray(ima); //edges are detected in gray space
			
			if (cfg.canny)
			{
				//Detect by means of the Canny Edge detector
				//auxi=canny_edge_detector(grayima, ut, lt);
				auxi=canny(grayima, ut, lt, 3.0);
			}
			else if (cfg.high_pass)
			{
				//Detect by simple Gaussian Filter
				ut=0; lt=0;
				auxi=grayima-smoother.filter(grayima);
			}
			//Detect by Sobel Masking
			else if (cfg.sobel)
			{
				for (uint64 j=0; j<im_x*im_y; j++) im64(0).data()[j]=static_cast<int64>(grayima(0).data()[j]);
				
				component_x=sobx.filter(im64); 
				component_y=soby.filter(im64);
				
				X=component_x(0).data();
				Y=component_y(0).data();
				
				for (uint64 j=0; j<im_y*im_x; j++)
				{
					grad=std::sqrt(static_cast<float64>((*X))*static_cast<float64>((*X))+
					static_cast<float64>((*Y))*static_cast<float64>((*Y)));
					if (grad>static_cast<float64>(ut)) grad=255.0;
					if (grad<static_cast<float64>(lt)) grad=0.0;
					auxi(0).data()[j]=static_cast<uint8>(grad);
					X++; Y++;
				}
			}

			if (cfg.background_suppression)
			{	//Filter with a dilated version of the foreground extraction
				auxm=dil.filter(mask);
				for (uint64 i=0; i<im_y*im_x; ++i)
				{
					if (auxm(0).data()[i] < 128) auxi(0).data()[i]=0;
				}
			}
			if (cfg.dilate)
			{
				auxi=dil2.filter(auxi);
			}
			if (cfg.smooth)
			{
				auxi=smoother.filter(auxi);
			}

			wim << auxi;
		}
		
	}
	
}

//
// This last line is mandatory!
//
IMAGEPLUS_TOOL_CONFIG_END()
