// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------

//!
//!  \file ImageCIELab.cpp
//!
//! \author Javier Ruiz Hidalgo <j.ruiz@upc.edu>
//! \author Josep Ramon Morros <morros@gps.tsc.upc.edu>
//!
//!  Implementation for ImageCIELab class
//!

#include <imageplus/core/check_size.hpp>

#include <imageplus/core/imagecielab.hpp>

using namespace imageplus;

template<typename T>
ImageCIELab<T>::ImageCIELab()
        : Image<T,3>()
{
}


template<typename T>
ImageCIELab<T>::ImageCIELab(uint64 x, uint64 y)
        : Image<T,3>(x,y)
{
}


template<typename T>
ImageCIELab<T>:: ImageCIELab(const ImaVol<T,3,2>& copy)
        : Image<T,3>(copy)
{
    check_size_cielab(copy);
}


template<typename T>
ImageCIELab<T>::ImageCIELab(const Image<T,3>& copy)
        : Image<T,3>(copy)
{
    check_size_cielab(copy);
}


template<typename T>
ImageCIELab<T>::ImageCIELab(const ImageCIELab<T>& copy)
        : Image<T,3>(copy)
{
#ifndef NDEBUG
    check_size_cielab(copy);
#endif
}


template<typename T>
inline ImageCIELab<T>::ImageCIELab(const std::vector< std::vector<uint64> >& dims)
        : Image<T,3>(dims)
{
    if ( (dims[0][0] != dims[1][0]) || (dims[0][1] != dims[1][1]) )
    {
        throw ImagePlusError("a channel dimensions must be equal to L* channel dimensions");
    }

    if ( (dims[0][0] != dims[2][0]) || (dims[0][1] != dims[2][1]) )
    {
        throw ImagePlusError("b channel dimensions must be equal to L* channel dimensions");
    }
}

template<typename T>
ImageCIELab<T>::~ImageCIELab()
{
}


template<typename T>
ImageCIELab<T>& ImageCIELab<T>::operator=( const ImaVol<T,3,2>& copy )
{
    check_size_cielab(copy);

    (*this).Image<T,3>::operator=( copy );

    return *this;
}


template<typename T>
ImageCIELab<T>& ImageCIELab<T>::operator=( const Image<T,3>& copy )
{
    check_size_cielab(copy);

    (*this).Image<T,3>::operator=( copy );

    return *this;
}


template<typename T>
ImageCIELab<T>& ImageCIELab<T>::operator=( const ImageCIELab<T>& copy )
{
#ifndef NDEBUG
    check_size_cielab(copy);
#endif

    (*this).Image<T,3>::operator=( copy );

    return *this;
}


template<typename T>
const T& ImageCIELab<T>::operator=(const T& val)
{
    (*this).Image<T,3>::operator=( val );

    return val;
}

// ImageCIELab instantiations
namespace imageplus
{
    template class ImageCIELab<uint8>;
    template class ImageCIELab<uint16>;
    template class ImageCIELab<int16>;
    template class ImageCIELab<int64>;
    template class ImageCIELab<float64>;

}
