
// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------

//!
//!  \file random_generators.test
//!
//!  Tests for functions in circle_geometry.hpp
//!

#include <imageplus/core.hpp>
#include <imageplus/math/statistics/random_generators.hpp>
#include <imageplus/math/statistics/multiarray_statistics.hpp>

BOOST_AUTO_TEST_SUITE (Math_Statistics_Random_Generators_Suite );

using namespace std;
using namespace imageplus;
using namespace imageplus::math;
using namespace imageplus::math::statistics;

typedef boost::mpl::list< uint8, int32, int64 > types;

BOOST_AUTO_TEST_CASE ( Rand_Normal_Uncontrolled_Seed )
{

	float64 mu, estimated_mean, sigma, estimated_sigma;
	mu=1.0;
	sigma=2.0;
	int32 num_elements=100000;
	
	MultiArray<float64,1> gauss (num_elements);
	
	for (int32 i=0; i!=num_elements; ++i)
	{
		gauss[i]=rand_normal(mu, sigma);
	}
	estimated_mean=mean(gauss);
	estimated_sigma=std::sqrt(variance(gauss));
	
//	std::cout << mu << " vs " << estimated_mean << std::endl;
//	std::cout << sigma << " vs " << estimated_sigma << std::endl;
	
	BOOST_CHECK_CLOSE(mu, estimated_mean, 2.0);
	BOOST_CHECK_CLOSE(sigma, estimated_sigma, 1.0);	
}

BOOST_AUTO_TEST_CASE ( Rand_Normal_Controlled_Seed )
{

	float64 mu,  sigma;
	mu=1.0;
	sigma=2.0;
	boost::array<float64,2> gauss;
	
	boost::mt19937 rng1(3);
	boost::mt19937 rng2(3);
	
	gauss[0]=rand_normal(mu, sigma, rng1);
	gauss[1]=rand_normal(mu, sigma, rng2);
	
	BOOST_CHECK_CLOSE(gauss[0], gauss[1], 0.001);
	for (std::size_t i=0; i<10; ++i)
	{
		BOOST_CHECK_CLOSE(rand_normal(mu, sigma, rng1), rand_normal(mu, sigma, rng2), 1.0e-10);
	}
}

BOOST_AUTO_TEST_CASE ( Rand_Uniform_Uncontrolled_Seed )
{

	float64 mu, estimated_mean, sigma, estimated_sigma;
	mu=0.5;
	sigma=std::sqrt(1.0/3.0-1.0/4.0);
	int32 num_elements=100000;
	
	MultiArray<float64,1> randnum (num_elements);
	
	for (int32 i=0; i!=num_elements; ++i)
	{
		randnum[i]=rand_uniform();
	}
	estimated_mean=mean(randnum);
	estimated_sigma=std::sqrt(variance(randnum));
	
//	std::cout << mu << " vs " << estimated_mean << std::endl;
//	std::cout << sigma << " vs " << estimated_sigma << std::endl;
	
	BOOST_CHECK_CLOSE(mu, estimated_mean, 2.0);
	BOOST_CHECK_CLOSE(sigma, estimated_sigma, 1.0);	
}

BOOST_AUTO_TEST_CASE ( Rand_Uniform_Controlled_Seed )
{
	boost::array<float64,2> randnum;
	
	boost::mt19937 rng1(3);
	boost::mt19937 rng2(3);
	
	randnum[0]=rand_uniform(rng1);
	randnum[1]=rand_uniform(rng2);
	
	for (std::size_t i=0; i<10; ++i)
	{
		BOOST_CHECK_CLOSE(rand_uniform(rng1), rand_uniform(rng2), 1.0e-10);
	}
}

BOOST_AUTO_TEST_CASE ( Signed_Bounded_Int_Rand_Uniform_Uncontrolled_Seed  )
{

	float64 mu, estimated_mean, sigma, estimated_sigma;
	mu=0.0;
	sigma=std::sqrt(1.0/3.0);
	int32 num_elements=100000;
	
	MultiArray<float64,1> randnum (num_elements);
	
	for (int32 i=0; i!=num_elements; ++i)
	{
		randnum[i]=rand_uniform(-1, 1);
	}
	estimated_mean=mean(randnum);
	estimated_sigma=std::sqrt(variance(randnum));
	
//	std::cout << mu << " vs " << estimated_mean << std::endl;
//	std::cout << sigma << " vs " << estimated_sigma << std::endl;
	
	BOOST_CHECK(fabs(mu-estimated_mean) < 0.02);
	BOOST_CHECK_CLOSE(sigma, estimated_sigma, 1.0);	
}

BOOST_AUTO_TEST_CASE_TEMPLATE ( Bounded_Rand_Uniform_Int_Controlled_Seed, T, types )
{
	boost::array<T,2> randnum;
	
	boost::mt19937 rng1(3);
	boost::mt19937 rng2(3);
	
	randnum[0]=rand_uniform_int(static_cast<T>(2), static_cast<T>(24), rng1);
	randnum[1]=rand_uniform_int(static_cast<T>(2), static_cast<T>(24), rng2);
	
	BOOST_CHECK_EQUAL(randnum[0], randnum[1]);
}


BOOST_AUTO_TEST_CASE_TEMPLATE ( UnSigned_Bounded_Int_Rand_Uniform_Uncontrolled_Seed, T, types  )
{

	float64 mu, estimated_mean, sigma, estimated_sigma;
	mu=3.0;
	sigma=std::sqrt(56.0/6.0-9.0);
	int32 num_elements=100000;
	
	MultiArray<float64,1> randnum (num_elements);
	
	for (int32 i=0; i!=num_elements; ++i)
	{
		randnum[i]=rand_uniform(static_cast<T>(2), static_cast<T>(4));
	}
	estimated_mean=mean(randnum);
	estimated_sigma=std::sqrt(variance(randnum));
	
//	std::cout << mu << " vs " << estimated_mean << std::endl;
//	std::cout << sigma << " vs " << estimated_sigma << std::endl;
	
	BOOST_CHECK_CLOSE(mu, estimated_mean, 2.0);
	BOOST_CHECK_CLOSE(sigma, estimated_sigma, 1.0);	
}


BOOST_AUTO_TEST_CASE( Bounded_Rand_Uniform_Uncontrolled_Seeds  )
{

	float64 mu, estimated_mean, sigma, estimated_sigma;
	mu=3.0;
	sigma=std::sqrt(56.0/6.0-9.0);
	int32 num_elements=100000;
	
	MultiArray<float64,1> randnum (num_elements);
	
	for (int32 i=0; i!=num_elements; ++i)
	{
		randnum[i]=rand_uniform(2.0, 4.0);
	}
	estimated_mean=mean(randnum);
	estimated_sigma=std::sqrt(variance(randnum));
	
//	std::cout << mu << " vs " << estimated_mean << std::endl;
//	std::cout << sigma << " vs " << estimated_sigma << std::endl;
	
	BOOST_CHECK_CLOSE(mu, estimated_mean, 2.0);
	BOOST_CHECK_CLOSE(sigma, estimated_sigma, 1.0);	
}

BOOST_AUTO_TEST_SUITE_END ();
