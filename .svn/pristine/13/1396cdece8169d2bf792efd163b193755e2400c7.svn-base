// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------

//!
//!  \file norms.cpp
//!
//!  norm operations
//!

#include <imageplus/core.hpp>

#include <imageplus/math/numeric/norms.hpp>

#include <numeric/ublas_adaptors.hpp>

#include <boost/numeric/ublas/triangular.hpp>
#include <boost/numeric/ublas/lu.hpp>
#include <boost/numeric/ublas/io.hpp>

// for std::abs(int64)
#include <imageplus/math.hpp>

using namespace imageplus;
using namespace imageplus::math::numeric;

template<typename T>
float64 imageplus::math::numeric::norm( const MultiArray<T,1>& in )
{
    MultiArray<float64,1> inf;
    inf = convert<float64>(in);

    UblasAdaptionVector<float64> u(const_cast<float64*>(inf.data()), inf.dims(0));

    return boost::numeric::ublas::norm_2(u); //euclidean norm
}


template<typename T, std::size_t S>
float64 imageplus::math::numeric::norm( const boost::array<T,S>& in ) throw (ImagePlusError)
{
    boost::array<float64,S> inf;
    //TODO: AGIL: to change the data type we need to do a cast or a convert!!
    //inf = in;
    for(std::size_t i = 0; i < S; i++)
    {
    	inf[i] = static_cast<float64>(in[i]);
    }

    UblasAdaptionVector<float64> u(const_cast<float64*>(inf.data()), S);

    return boost::numeric::ublas::norm_2(u); //euclidean norm
}



template<typename T>
float64 imageplus::math::numeric::p_norm ( const MultiArray<T,1>& v1, float64 p )
{
    uint64 dim = v1.num_elements();

    float64 norm = 0.0;

    const T* p1 = v1.data();

    for (uint64 i = 0; i < dim; i++)
    {
        norm += std::pow( (std::abs(p1[i])), p );
    }

    return (std::pow (norm, 1.0 / static_cast<float64>(p)));
}

template<typename T, std::size_t S>
float64 imageplus::math::numeric::p_norm( const boost::array<T,S>& v1, float64 p )
{
    float64 norm = 0.0;

    const T* p1 = v1.data();

    for (uint64 i = 0; i < S; i++)
    {
        norm += std::pow( (std::abs(p1[i])), p );
    }

    return (std::pow (norm, 1.0 / static_cast<float64>(p)));
}


template<typename T>
float64 imageplus::math::numeric::manhattan_norm ( const MultiArray<T,1>& v1 )
{
    uint64 dim = v1.num_elements();

    float64 norm = 0.0;

    const T* p1 = v1.data();

    for (uint64 i = 0; i < dim; i++)
    {
        norm += std::abs(p1[i]);
    }

    return norm;
}

template<typename T, std::size_t S>
float64 imageplus::math::numeric::manhattan_norm( const boost::array<T,S>& v1 )
{
    float64 norm = 0.0;

    const T* p1 = v1.data();

    for (uint64 i = 0; i < S; i++)
    {
        norm += std::abs(p1[i]);
    }

    return norm;
}


template<typename T>
T imageplus::math::numeric::infinity_norm ( const MultiArray<T,1>& v1 )
{
    return *(std::max_element (v1.data(), v1.data()+v1.num_elements()));
}
            
template<typename T, std::size_t S>
T imageplus::math::numeric::infinity_norm ( const boost::array<T,S>& v1 )
{
    return *(std::max_element (v1.data(), v1.data()+S));
}


template float64  imageplus::math::numeric::norm(const MultiArray<uint8,1>&);
template float64  imageplus::math::numeric::norm(const MultiArray<int64,1>&);
template float64  imageplus::math::numeric::norm(const MultiArray<float64,1>&);




template float64 imageplus::math::numeric::norm( const boost::array<uint8,2>& in );
template float64 imageplus::math::numeric::norm( const boost::array<int64,2>& in );
template float64 imageplus::math::numeric::norm( const boost::array<float64,2>& in );

template float64 imageplus::math::numeric::norm( const boost::array<uint8,3>& in );
template float64 imageplus::math::numeric::norm( const boost::array<int64,3>& in );
template float64 imageplus::math::numeric::norm( const boost::array<float64,3>& in );

template float64  imageplus::math::numeric::p_norm(const MultiArray<uint8,1>&,   float64 );
template float64  imageplus::math::numeric::p_norm(const MultiArray<int64,1>&,   float64 );
template float64  imageplus::math::numeric::p_norm(const MultiArray<float64,1>&, float64 );

template float64  imageplus::math::numeric::p_norm(const boost::array<uint8,2>& ,   float64 );
template float64  imageplus::math::numeric::p_norm(const boost::array<int64,2>& ,   float64 );
template float64  imageplus::math::numeric::p_norm(const boost::array<float64,2>& , float64 );

template float64  imageplus::math::numeric::p_norm(const boost::array<uint8,3>& ,   float64 );
template float64  imageplus::math::numeric::p_norm(const boost::array<int64,3>& ,   float64 );
template float64  imageplus::math::numeric::p_norm(const boost::array<float64,3>& , float64 );

template float64  imageplus::math::numeric::manhattan_norm(const MultiArray<uint8,1>& );
template float64  imageplus::math::numeric::manhattan_norm(const MultiArray<int64,1>& );
template float64  imageplus::math::numeric::manhattan_norm(const MultiArray<float64,1>& );

template float64  imageplus::math::numeric::manhattan_norm(const boost::array<uint8,2>&  );
template float64  imageplus::math::numeric::manhattan_norm(const boost::array<int64,2>&  );
template float64  imageplus::math::numeric::manhattan_norm(const boost::array<float64,2>& );

template float64  imageplus::math::numeric::manhattan_norm(const boost::array<uint8,3>& );
template float64  imageplus::math::numeric::manhattan_norm(const boost::array<int64,3>& );
template float64  imageplus::math::numeric::manhattan_norm(const boost::array<float64,3>& );

template uint8  imageplus::math::numeric::infinity_norm(const MultiArray<uint8,1>& );
template int64  imageplus::math::numeric::infinity_norm(const MultiArray<int64,1>& );
template float64  imageplus::math::numeric::infinity_norm(const MultiArray<float64,1>& );

template uint8  imageplus::math::numeric::infinity_norm(const boost::array<uint8,2>&  );
template int64  imageplus::math::numeric::infinity_norm(const boost::array<int64,2>&  );
template float64  imageplus::math::numeric::infinity_norm(const boost::array<float64,2>& );

template uint8  imageplus::math::numeric::infinity_norm(const boost::array<uint8,3>& );
template int64  imageplus::math::numeric::infinity_norm(const boost::array<int64,3>& );
template float64  imageplus::math::numeric::infinity_norm(const boost::array<float64,3>& );

