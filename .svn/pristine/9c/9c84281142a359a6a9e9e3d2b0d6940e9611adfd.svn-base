/*
 * region_pruner.hpp
 *
 *  Created on: Dec 18, 2012
 *      Author: gpalou
 */

#ifndef REGION_PRUNER_HPP_
#define REGION_PRUNER_HPP_

#include <imageplus/bpt/pruning/bpt_pruner.hpp>

namespace imageplus {
	namespace bpt {

		//! Simple class that prunes the BPT at given regions with a maximum number of allowed regions
		//! \param BPT: tree type
		//! \param ImageModel : image type
		template<class BPT, class ImageModel>
		class RegionPruner : public BPTPruner<BPT,ImageModel> {

			//! Base class
			typedef BPTPruner<BPT,ImageModel> Pruner;

			//! Region IDs
			typedef typename Pruner::RegionsIDs RegionsIDs;

		public:

			//! Constructor
			//! \param[in] regions: regions to prune
			//! \param[in] max_regions: restrict the final number of regions (0 = no limit)
			RegionPruner(RegionsIDs& regions, uint64 max_regions = 0) : Pruner(regions), _max_regions(max_regions) {}

			//! Sets the regions to prune
			//! \param[in] regions: regions to prune
			void set_regions(RegionsIDs& regions) {
				Pruner::_regions = regions;

			}

			//! Sets the maximum number of regions
			//! \param[in] max_regions: restrict the final number of regions (0 = no limit)
			void set_max_regions(uint64 max_regions) {_max_regions = max_regions;}

			//! Functions that finds the regions to prune
			//! \param[in] bpt: tree
			//! \param[in] img: image
			//! \param[in] reg_id: id of the root to begin to count (normally the root of the tree)
			const RegionsIDs& find_pruned_regions(BPT& bpt, ImageModel& img, uint64 reg_id) {
				uint64 pruned = 1;
				if (_max_regions == 0) _max_regions = 1e9;

				/*Prune until _max_regions is reached*/
				std::deque<uint64> dq; dq.push_back(reg_id);
				RegionsIDs leaves;
				while (!dq.empty()) {
					int64 r = dq.front(); dq.pop_front();
					if (Pruner::_regions.find(r) != Pruner::_regions.end()) {
						leaves.insert(r);
					}
					else {
						if (pruned < _max_regions) {
							if (bpt[r].parts().size() == 0) continue;
							int64 son1 = bpt[r].parts()[0]->id();
							int64 son2 = bpt[r].parts()[1]->id();
							pruned++;
							dq.push_back(son1);
							dq.push_back(son2);
						} else	{ leaves.insert(r); }
					}
				}
				Pruner::_regions = leaves;
				return leaves;
			}

		private:

			//! maximum number of regions
			uint64 _max_regions;

		};

	}
}

#endif /* REGION_PRUNER_HPP_ */
