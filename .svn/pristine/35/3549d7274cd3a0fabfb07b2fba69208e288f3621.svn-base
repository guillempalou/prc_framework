// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------

//!
//!  \file camera_implementations.hpp
//!
//!
//!
#ifndef IMAGEPLUS_MULTIVIEW_CAMERA_IMPLEMENTATIONS_HPP
#define IMAGEPLUS_MULTIVIEW_CAMERA_IMPLEMENTATIONS_HPP

#include <imageplus/core.hpp>
#include <imageplus/math/numeric/interpolation.hpp>


namespace imageplus
{
    namespace multiview
    {
        //! \brief Maximum Pixel Distorsion error considered
        static const float64 MAX_PIXEL_DISTORSION_ERROR=3.0;

        //!
        //! \brief Returns the world camera position
        //!
        //! \author Oscar Garcia
        //! \author Adolfo López <alopez@gps.tsc.upc.edu>
        //!
        //! \date 12-02-2008
        //!
        //! \param[in] cam : Camera Parameters
        //! \return Point3D as the world coordinate of the camera.
        Point3D camera_position(const Camera& cam);
        
        //!
        //! \brief Transforms a point in the image plane from image reference system coordinates
        //! to world coordinates.
        //!
        //! \author Oscar Garcia
        //! \author Adolfo López <alopez@gps.tsc.upc.edu>
        //!
        //! \date 12-02-2008
        //!
        //! \param[in] cam : Camera Parameters
        //! \param[in] p : Image Plane Point
        //! \return Point3D as the world coordinate of the image plane point.
        Point3D image_coord_system_to_world_coord_system(const Camera& cam, const Point2D& p);
        
        //!
        //! \brief Computes the world projection ray passing through an image plane point.
        //!
        //! \author Oscar Garcia
        //! \author Adolfo López <alopez@gps.tsc.upc.edu>
        //!
        //! \date 12-02-2008
        //!
        //! \param[in] cam : Camera Parameters
        //! \param[in] image_point : Image Plane Point
        //! \param[out] world_point : World Point of application of the projected ray director vector.
        //! \param[out] director_vector : Direction of the Back Projected Ray.
        //!
        void back_projected_ray(const Camera& cam, const Point2D& image_point, Point3D& world_point, Point3D& director_vector);

        //!
        //! \brief Linearly interpolates the Camera parameters of two cameras 
        //!
        //! \author Jordi Salvador <jordi@gps.tsc.upc.edu>
        //!
        //! \date 07-March-2008
        //!
        //! \param[in] cam1 : Camera parameters of the origin camera
        //! \param[in] cam2 : Camera parameters of the destination camera
        //! \param[in] factor : Relative path between the two given cameras. Must be in the (0, 1) OPEN interval
        //! \return Returns the camera parameters of the interpolated camera
        //!        
        Camera interpolate_cameras(const Camera& cam1, const Camera& cam2, const float64 factor) throw (ImagePlusError);
        
        //!
        //! \brief Distort a point in image with given camera parameters
        //!
        //! \author JoseLuis Landabaso  <jl@gps.tsc.upc.es>
        //! \author Marcel Alcoverro <marcel@gps.tsc.upc.edu>
        //!
        //! \date 02-02-2008
        //!
        //! \param[in]  p   : the ideal point to distort.
        //! \param[in]  cam : camera parameters
        //! \param[out] out : result distorted point2d
        //!
        void ideal_to_distorted( const Point2D& p, const Camera& cam, Point2D & out);

        //!
        //! \brief Computes undistorted point from distorted image point and distortion parameters
        //!
        //! \author Oscar Garcia
        //! \author Adolfo López <alopez@gps.tsc.upc.edu>
        //!
        //! \date 12-02-2008
        //!
        //!  \param[in] p_distorted  : Distorted point
        //!  \param[in] dist : 4-vector of distortion parameters
        //!  \param[in] princ_point :  Principal point (center of distortion) of the image
        //!  \param[in] foc_length : Focal Length of the camera
        //!
        //!  \return Returns undistorted point
        //!
        Point2D undistorter(const Point2D& p_distorted, const MultiArray<float64,1>& dist, const Point2D& princ_point, const MultiArray<float64,1>& foc_length);
        
        //!
        //! \brief Computes distorted point from undistorted image point and distortion parameters
        //!
        //! \author Oscar Garcia
        //! \author Adolfo López <alopez@gps.tsc.upc.edu>
        //!
        //! \date 12-02-2008
        //!
        //!  \param[in] p_undistorted  : Undistorted point
        //!  \param[in] dist : 4-vector of distortion parameters
        //!  \param[in] princ_point :  Principal point (center of distortion) of the image
        //!  \param[in] foc_length : Focal Length of the camera
        //!
        //!  \return Returns distorted point
        //!
        Point2D distorter(const Point2D& p_undistorted, const MultiArray<float64,1>& dist, const Point2D& princ_point, const MultiArray<float64,1>& foc_length);
        
        //!
        //! \brief Check if distortion is important enough at image borders.
        //!
        //! \author Oscar Garcia
        //! \author Adolfo López <alopez@gps.tsc.upc.edu>
        //!
        //! \date 12-02-2008
        //!
        //!  \param[in] cam  : Camera parameters
        //!
        //!  \return Returns 1 if distorsion is relevant, 0 otherwise
        //!
        int significant_distortion(const Camera& cam);
        
        //!
        //! \brief Scale camera parameters to fit an image scaled by the given factor
        //!
        //! \author Jordi Salvador Marcos <jordi@gps.tsc.upc.edu>
        //!
        //! \date 08-Nov-2008
        //!
        //!  \param[in] cam  : original camera parameters
        //!  \param[in] scale  : scale factor per image side
        //!
        //!  \return Returns scaled camera parameters
        //!
        Camera scale_camera( const Camera & cam, const float64 scale );
        
        //!
        //! \brief Transform extrinsic parameters
        //!
        //! To go from the current coordinate system A to the new coordinate system B,
        //! transformations need to be provided in the destination coordinate system B 
        //! (that is, the rotations and translation applied to B that yield A).
        //! 
        //! \author Adolfo Lopez Mendez <alopez@gps.tsc.upc.edu>
        //!
        //! \date 27-Nov-2011
        //!
        //!  \param[in] cam  : original camera parameters
        //!  \param[in] rot_x : rotation in x axis (degrees)
        //!  \param[in] rot_y : rotation in y axis (degrees)
        //!  \param[in] rot_z : rotation in z axis (degrees)
        //!  \param[in] translation : translation vector
        //!
        //!  \return Returns transformed camera parameters
        //!
        imageplus::Camera transform_calibration (const imageplus::Camera & cam, 
                                                 float64 rot_x, 
                                                 float64 rot_y, 
                                                 float64 rot_z, 
                                                 const imageplus::Point3D & translation );
        
        //!
        //! \brief Computes the world projection ray passing through an image plane point
        //! with known center of projections and without considering distortion
        //!
        //! \author Oscar Garcia
        //! \author Jordi Salvador Marcos <jordi@gps.tsc.upc.edu>
        //!
        //! \date 14-Nov-2008
        //!
        //! \param[in] cam : Camera Parameters
        //! \param[in] image_point : Image Plane Point
        //! \param[in] cop : center of projections of the camera, from camera_position
        //! \param[out] director_vector : Direction of the Back Projected Ray. Its size must be 3
        //!
        void back_projected_ray_known_cop_undistorted( const Camera & cam, const Point2D & image_point, const Point3D & cop, Point3D & director_vector );
        
        //!
        //! \brief Transforms a point in the image plane from image reference system coordinates
        //! to world coordinates without considering distortion
        //!
        //! \author Oscar Garcia
        //! \author Jordi Salvador <jordi@gps.tsc.upc.edu>
        //!
        //! \date 14-Nov-2008
        //!
        //! \param[in] cam : Camera Parameters
        //! \param[in] p : Image Plane Point
        //! \param[out] world : world coordinate of the image plane point
        //!
        void image_coord_system_to_world_coord_system_undistorted( const Camera & cam, const Point2D & p, Point3D & world );
        
        //!
        //! \brief Undistorts an image, correcting radial and tangential distortion from camera lenses.
        //!
        //! \param[in] distorted : Input image RGB (distorted)
        //! \param[in] cam : Camera calibration parameters
        //!
        //! \return Undistorted ImageRGB<uint8>
        //!
        //! \author Oscar Garcia
        //! \author Jordi Salvador <jordi@gps.tsc.upc.edu>
        //! \date   06-Mar-08
        //!
//        ImageRGB<uint8> undistort_image( ImageRGB<uint8>& distorted, Camera cam);
        template< class ImageModel >
        ImageModel undistort_image( ImageModel& distorted, Camera cam)
        {
            uint64 w = distorted.size_x();
            uint64 h = distorted.size_y();

            ImageModel undistorted(w, h);

            MultiArray<float64,1> focalLength(2);
            focalLength.data()[0] = cam.k().data()[0 * 3 + 0];
            focalLength.data()[1] = cam.k().data()[1 * 3 + 1];

            Point2D principalPoint;
            principalPoint.x() = cam.k().data()[0 * 3 + 2];
            principalPoint.y() = cam.k().data()[1 * 3 + 2];

            math::numeric::Interpolator<2> interpolate( math::numeric::LINEAR);

            for (uint64 y = 0; y < h; y++)
            {
                for (uint64 x = 0; x < w; x++)
                {
                    Point2D undistPoint(x, y);
                    Point2D distPoint = multiview::distorter( undistPoint,
                                     cam.distortion(),
                                     principalPoint,
                                     focalLength);

                    undistorted(Coord2D<>(x,y)) = interpolate(distPoint, distorted);
        //            undistorted(0)[x][y] = interpolation(distorted(0), distPoint, LINEAR);
        //            undistorted(1)[x][y] = interpolation(distorted(1), distPoint, LINEAR);
        //            undistorted(2)[x][y] = interpolation(distorted(2), distPoint, LINEAR);
                        //distorted[static_cast<int32>(distPoint.x())][static_cast<int32>(distPoint.y())];
                }
            }
            return undistorted;
        }
    }
}

#endif /*CAMERA_IMPLEMENTATIONS_HPP_*/
