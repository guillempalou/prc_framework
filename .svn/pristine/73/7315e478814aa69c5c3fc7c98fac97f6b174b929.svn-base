// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------

//!
//!  \file canny.cpp
//!
//!  Implementation for Canny Edge Detection
//!

#include <imageplus/filters/canny.hpp>
#include <imageplus/math/numeric/transformations.hpp>
#include <imageplus/core/multiarray_arithmetic.hpp>
#include <imageplus/filters/gaussian.hpp>
#include <queue>
#include <utility>



using namespace imageplus;
using namespace imageplus::filters;
using namespace std;

MultiArray<float64, 2> imageplus::filters::suppression(const MultiArray<float64, 2> & grad, const MultiArray<int64,2> & directions)
{
	MultiArray<float64, 2> out(grad);
	uint64 im_width = grad.dims(0);
	uint64 im_height = grad.dims(1);

	int64 angle, ax, ay, bx, by;

	for (uint64 y=0; y < im_height; ++y)
	{
		for (uint64 x=0; x < im_width; ++x)
		{
			angle=directions[x][y];
			if (angle==0)
			{
				ax = x+1; ay = y;
				bx = x-1; by = y;
			}
			else if (angle==135)
			{
				ax = x+1; ay = y+1;
				bx = x-1; by = y-1;
			}
			else if (angle==90)
			{
				ax = x; ay = y+1;
				bx = x; by = y-1;
			}
			else if (angle==45)
			{
				ax = x-1; ay = y+1;
				bx = x+1; by = y-1;
			}
			else
			{
				throw ImagePlusError("Canny: Wrong angle value");
			}
			//Check pixels inside the image
			if (ax < 0 || ax >= (int)im_width || ay < 0 || ay >= (int)im_height) continue;
			else if(grad[ax][ay] > grad[x][y]) { out[x][y] = 0; continue; }
			if (bx < 0 || bx >= (int)im_width || by < 0 || by >= (int)im_height) continue;
			else if(grad[bx][by] > grad[x][y]) { out[x][y] = 0; continue; }
		}
	}

	return out;
}

template<typename T>
void imageplus::filters::hysteresis(const MultiArray<float64, 2> & grad, int32 upper_threshold, int32 lower_threshold, MultiArray<T, 2> & out)
{
	//MultiArray<T, 2> out(grad.dims(0), grad.dims(1)); out=0;
	out=static_cast<T>(0);
	queue< pair<int64, int64> > nodes;
	uint64 im_width = grad.dims(0);
	uint64 im_height = grad.dims(1);


	/*
	 * AGIL: This bucle has shadowed variables: x and y.
	 *       We should avoid this situation!
	 */
	for (uint64 y=0; y < im_height; ++y)
	{
		for (uint64 x=0; x < im_width; ++x)
		{
			if (grad[x][y] >=(float64)upper_threshold && out[x][y] ==0 )
			{
				nodes.push(pair<int64, int64>(x,y));
                while(!nodes.empty())
                {
                    pair<int64, int64> node = nodes.front();
                    nodes.pop();
                    int64 x = node.first, y = node.second;
                    if(x < 0 || x >= (int)im_width || y < 0 || y >= (int)im_height) continue;
                    if(grad[x][y] < lower_threshold) continue;
                    if(out[x][y] == 0)
                    {
                        out[x][y] = std::numeric_limits<T>::max();
                        nodes.push(pair<int64, int64>(x+1,y-1));
                        nodes.push(pair<int64, int64>(x+1,y  ));
                        nodes.push(pair<int64, int64>(x+1,y+1));
                        nodes.push(pair<int64, int64>(x  ,y+1));
                        nodes.push(pair<int64, int64>(x  ,y-1));
                        nodes.push(pair<int64, int64>(x-1,y-1));
                        nodes.push(pair<int64, int64>(x-1,y  ));
                        nodes.push(pair<int64, int64>(x-1,y+1));
                    }
                }
			}
		}
	}
}

template <typename T>
ImageGray<T> imageplus::filters::canny(const ImageGray<T> & im, int32 upper_threshold, int32 lower_threshold, float64 sigma)
{
	ImageGray<T> out(im), filtered(im);
	MultiArray<float64,2> GxMask(3,3), GyMask(3,3),gaussianMask, tmp_gm;
	uint64 im_x=im.size_x(), im_y=im.size_y();
	//const int32 upper_threshold=50;
	//const int32 lower_threshold=25;

	/* Declare Sobel masks */
	GxMask[0][0] = -1.0; GxMask[1][0] = 0.0; GxMask[2][0] = 1.0;
	GxMask[0][1] = -2.0; GxMask[1][1] = 0.0; GxMask[2][1] = 2.0;
	GxMask[0][2] = -1.0; GxMask[1][2] = 0.0; GxMask[2][2] = 1.0;

	GyMask[0][0] =  1.0; GyMask[1][0] =  2.0; GyMask[2][0] =  1.0;
	GyMask[0][1] =  0.0; GyMask[1][1] =  0.0; GyMask[2][1] =  0.0;
	GyMask[0][2] = -1.0; GyMask[1][2] = -2.0; GyMask[2][2] = -1.0;

	/* Declare Gaussian mask */
	gaussianMask=gaussian_mask(sigma);
	tmp_gm=	gaussianMask;
	float64 *p, *end;
	p=gaussianMask.data();
	end=gaussianMask.data()+gaussianMask.num_elements();
	float64 total=std::accumulate(p, end, 0.0);
	imageplus::division(gaussianMask, total, tmp_gm);

	LinearConvolution imf(tmp_gm);
	filtered=imf.filter(im);

	//Analyze gradient strength
	ImageGray<float64> grad(im_x, im_y);
	ImageGray<int64> directions(im_x, im_y);
	ImageGray<int64> component_x(im_x, im_y), component_y(im_x, im_y), im64(im_x, im_y);

	LinearConvolution sobx(GxMask), soby(GyMask);
	for (uint64 j=0; j<im_x*im_y; j++) im64(0).data()[j]=static_cast<int64>(im(0).data()[j]);
	component_x=sobx.filter(im64);
	component_y=soby.filter(im64);

	//Sobel derivatives
	int64 *X, *Y;
	float64 thisAngle;
	int64 newAngle=0;
	X=component_x(0).data();
	Y=component_y(0).data();

	for (uint64 j=0; j<im_y*im_x; j++)
	{
		grad(0).data()[j]=std::sqrt(static_cast<float64>((*X))*static_cast<float64>((*X))+
		static_cast<float64>((*Y))*static_cast<float64>((*Y)));

		thisAngle = (atan2(static_cast<float64>((*Y)),static_cast<float64>((*X)))/M_PI) * 180.0;		// Calculate actual direction of edge

		/* Convert actual edge direction to approximate value */
		if ( ( (thisAngle < 22.5) && (thisAngle > -22.5) ) || (thisAngle > 157.5) || (thisAngle < -157.5) )
			newAngle = 0;
		else if ( ( (thisAngle > 22.5) && (thisAngle < 67.5) ) || ( (thisAngle < -112.5) && (thisAngle > -157.5) ) )
			newAngle = 45;
		else if ( ( (thisAngle > 67.5) && (thisAngle < 112.5) ) || ( (thisAngle < -67.5) && (thisAngle > -112.5) ) )
			newAngle = 90;
		else if ( ( (thisAngle > 112.5) && (thisAngle < 157.5) ) || ( (thisAngle < -22.5) && (thisAngle > -67.5) ) )
			newAngle = 135;
		directions(0).data()[j]=newAngle;
		X++; Y++;
	}

	grad(0)=suppression(grad(0),directions(0));
	hysteresis(grad(0), upper_threshold, lower_threshold, out(0));
	return out;

}
namespace imageplus
{
	namespace filters
	{

//		template void find_edge(ImageGray<uint8> &, int64 , int64, const uint64, const uint64 , const float64 ,
//		const int32 , const MultiArray<float64,2> & , const MultiArray<int64,2> & );
//
//		template void suppress_non_max<uint8> (ImageGray<uint8> & , int64 , int64 , const uint64 , const uint64 , const float64 ,
//		const int32 , MultiArray<float64,2> & , const MultiArray<int64,2> & );
//
//		template ImageGray<uint8> canny_edge_detector(const ImageGray<uint8> &, const int32, const int32);
//		//template ImageGray<int64> canny_edge_detector(const ImageGray<int64> &);
//		//template ImageGray<float64> canny_edge_detector(const ImageGray<float64> &);
		
		template void hysteresis(const MultiArray<float64, 2> & , int32, int32, MultiArray<uint8, 2>&);

		template ImageGray<uint8> canny(const ImageGray<uint8> & , int32 , int32 , float64 );

	}
}

//Old code
//
//template <typename T>
//void imageplus::filters::find_edge(ImageGray<T> & out, int64 x_shift, int64 y_shift, const uint64 x, const uint64 y, const float64 dir, const int32 lower_threshold,
//const MultiArray<float64,2> & gradient, const MultiArray<int64,2> & directions)
//{
//
//	uint64 im_width=gradient.dims(0);
//	uint64 im_height=gradient.dims(1);
//	uint64 new_y=0;
//	uint64 new_x=0;
//	uint64 i;
//	//TODO: x=x, y=y, swap.
//	T *m_destination=out(0).data();
//	bool edge_end = false;
//
//	/* Find the y and x values for the next possible pixel on the edge */
//	if (x_shift < 0)
//	{
//		if (x > 0)
//			new_x = x + x_shift;
//		else
//			edge_end = true;
//	}
//	else if (x < im_width - 1)
//	{
//		new_x = x + x_shift;
//	}
//	else
//		edge_end = true;		// If the next pixel would be off image, don't do the while loop
//	if (y_shift < 0)
//	{
//		if (y > 0)
//			new_y = y + y_shift;
//		else
//			edge_end = true;
//	}
//	else if (y < im_height - 1)
//	{
//		new_y = y + y_shift;
//	}
//	else
//		edge_end = true;
//
//	/* Determine edge directions and gradient strengths */
//	while ( (directions[new_x][new_y]==dir) && !edge_end && (gradient[new_x][new_y] > lower_threshold) )
//	{
//		/* Set the new pixel as white to show it is an edge */
//		i = new_y*im_width + new_x;
//		*(m_destination + i) =
//		*(m_destination + i + 1) =
//		*(m_destination + i + 2) = 255;
//		if (x_shift < 0)
//		{
//			if (new_x > 0)
//				new_x = new_x + x_shift;
//			else
//				edge_end = true;
//		}
//		else if (new_x < im_width - 1)
//		{
//			new_x = new_x + x_shift;
//		}
//		else
//			edge_end = true;
//		if (y_shift < 0)
//		{
//			if (new_y > 0)
//				new_y = new_y + y_shift;
//			else
//				edge_end = true;
//		}
//		else if (new_y < im_height - 1)
//		{
//			new_y = new_y + y_shift;
//		}
//		else
//			edge_end = true;
//	}
//
//}
//template<typename T>
//void imageplus::filters::suppress_non_max(ImageGray<T> & out, int64 x_shift, int64 y_shift, const uint64 x, const uint64 y, const float64 dir,
//const int32 lower_threshold, MultiArray<float64,2> & gradient, const MultiArray<int64,2> & directions)
//{
//	uint64 im_width = gradient.dims(0);
//	uint64 im_height = gradient.dims(1);
//	uint64 new_y = 0;
//	uint64 new_x = 0;
//	uint64 i;
//	bool edge_end = false;
//	MultiArray<float64, 2> non_max(im_width,3);
//	//float64 non_max[im_width][3];		// Temporarily stores gradients and positions of pixels in parallel edges
//	uint64 pixelCount = 0;		// Stores the number of pixels in parallel edges
//	uint64 count;
//	uint64 max[3];			// Maximum point in a wide edge
//	//T *m_destinationBmp=out(0).data();
//
//	if (x_shift < 0)
//	{
//		if (x > 0)
//			new_x = x + x_shift;
//		else
//			edge_end = true;
//	}
//	else if (x < im_width - 1)
//	{
//		new_x = x + x_shift;
//	} else
//		edge_end = true;		// If the next pixel would be off image, don't do the while loop
//	if (y_shift < 0)
//	{
//		if (y > 0)
//			new_y = y + y_shift;
//		else
//			edge_end = true;
//	}
//	else if (y < im_height - 1)
//	{
//		new_y = y + y_shift;
//	} else
//		edge_end = true;
//
//	i = new_y*im_width + new_x;
//	/* Find non-maximum parallel edges tracing up */
//	while ((directions[new_x][new_y] == dir) && !edge_end && gradient[new_x][new_y]>lower_threshold)//(*(m_destinationBmp + i) == 255))
//	{
//		if (x_shift < 0)
//		{
//			if (new_x > 0)
//				new_x = new_x + x_shift;
//			else
//				edge_end = true;
//		} else if (new_x < im_width - 1)
//		{
//			new_x = new_x + x_shift;
//		} else
//			edge_end = true;
//		if (y_shift < 0)
//		{
//			if (new_y > 0)
//				new_y = new_y + y_shift;
//			else
//				edge_end = true;
//		} else if (new_y < im_height - 1)
//		{
//			new_y = new_y + y_shift;
//		} else
//			edge_end = true;
//
//		non_max[pixelCount][0] = new_x;
//		non_max[pixelCount][1] = new_y;
//		non_max[pixelCount][2] = gradient[new_x][new_y];
//		pixelCount++;
//		i = (unsigned long)(new_y*im_width + new_x);
//	}
//
//	/* Find non-maximum parallel edges tracing down */
//	edge_end = false;
//	x_shift *= -1;
//	y_shift *= -1;
//	if (x_shift < 0)
//	{
//		if (x > 0)
//			new_x = x + x_shift;
//		else
//			edge_end = true;
//	} else if (x < im_width - 1) {
//		new_x = x + x_shift;
//	} else
//		edge_end = true;
//	if (y_shift < 0) {
//		if (y > 0)
//			new_y = y + y_shift;
//		else
//			edge_end = true;
//	} else if (y < im_height - 1)
//	{
//		new_y = y + y_shift;
//	} else
//		edge_end = true;
//	i = new_y*im_width + new_x;
//	while ((directions[new_x][new_y] == dir) && !edge_end && gradient[new_x][new_y]>lower_threshold)//(*(m_destinationBmp + i) == 255))
//	{
//		if (x_shift < 0)
//		{
//			if (new_x > 0)
//				new_x = new_x + x_shift;
//			else
//				edge_end = true;
//		}
//		else if (new_x < im_width - 1)
//		{
//			new_x = new_x + x_shift;
//		} else
//			edge_end = true;
//		if (y_shift < 0)
//		{
//			if (new_y > 0)
//				new_y = new_y + y_shift;
//			else
//				edge_end = true;
//		} else if (new_y < im_height - 1)
//		{
//			new_y = new_y + y_shift;
//		} else
//			edge_end = true;
//		non_max[pixelCount][0] = new_x;
//		non_max[pixelCount][1] = new_y;
//		non_max[pixelCount][2] = gradient[new_x][new_y];
//		pixelCount++;
//		i = new_y*im_width + new_x;
//	}
//
//	/* Suppress non-maximum edges */
//	max[0] = 0;
//	max[1] = 0;
//	max[2] = 0;
//	for (count = 0; count < pixelCount; count++)
//	{
//		if (non_max[count][2] > max[2])
//		{
//			max[0] = static_cast<uint64>(non_max[count][0]);
//			max[1] = static_cast<uint64>(non_max[count][1]);
//			max[2] = static_cast<uint64>(non_max[count][2]);
//		}
//	}
//	for (count = 0; count < pixelCount; count++)
//	{
//		i = static_cast<uint64>(non_max[count][1]*im_width + non_max[count][0]);
////		*(m_destinationBmp + i) =
////		*(m_destinationBmp + i + 1) =
////		*(m_destinationBmp + i + 2) = 0;
//		gradient.data()[i]=0.0;
//	}
//	//Keep the maximum one
//	//i=max[1]*im_width+max[0];
//	//*(m_destinationBmp+i)=255;
//	gradient[max[0]][max[1]]=max[2];
//}
//
//template <typename T>
//ImageGray<T> imageplus::filters::canny_edge_detector(const ImageGray<T> & im, const int32 upper_threshold, const int32 lower_threshold)
//{
//	ImageGray<T> out(im), filtered(im);
//	MultiArray<float64,2> GxMask(3,3), GyMask(3,3),gaussianMask(5,5), tmp_gm(5,5); // tmp_sob(3,3
//	uint64 im_x=im.size_x(), im_y=im.size_y();
//	//const int32 upper_threshold=50;
//	//const int32 lower_threshold=25;
//	uint64 i;
//
//	/* Declare Sobel masks */
//	GxMask[0][0] = -1.0; GxMask[0][1] = 0.0; GxMask[0][2] = 1.0;
//	GxMask[1][0] = -2.0; GxMask[1][1] = 0.0; GxMask[1][2] = 2.0;
//	GxMask[2][0] = -1.0; GxMask[2][1] = 0.0; GxMask[2][2] = 1.0;
//	//imageplus::division(GxMask, 2.0, tmp_sob);
//	//tmp_sob=GxMask;
//	GxMask=imageplus::math::numeric::trans(GxMask);
//	GyMask[0][0] =  1.0; GyMask[0][1] =  2.0; GyMask[0][2] =  1.0;
//	GyMask[1][0] =  0.0; GyMask[1][1] =  0.0; GyMask[1][2] =  0.0;
//	GyMask[2][0] = -1.0; GyMask[2][1] = -2.0; GyMask[2][2] = -1.0;
//	//imageplus::division(GyMask, 2.0, tmp_sob);
//	//tmp_sob=GyMask;
//	GyMask=imageplus::math::numeric::trans(GyMask);
//	/* Declare Gaussian mask */
//	gaussianMask[0][0] = 2.0;	 gaussianMask[0][1] = 4.0;  gaussianMask[0][2] = 5.0;  gaussianMask[0][3] = 4.0;  gaussianMask[0][4] = 2.0;
//	gaussianMask[1][0] = 4.0;	 gaussianMask[1][1] = 9.0;  gaussianMask[1][2] = 12.0; gaussianMask[1][3] = 9.0;  gaussianMask[1][4] = 4.0;
//	gaussianMask[2][0] = 5.0;	 gaussianMask[2][1] = 12.0; gaussianMask[2][2] = 15.0; gaussianMask[2][3] = 12.0; gaussianMask[2][4] = 2.0;
//	gaussianMask[3][0] = 4.0;	 gaussianMask[3][1] = 9.0;  gaussianMask[3][2] = 12.0; gaussianMask[3][3] = 9.0;  gaussianMask[3][4] = 4.0;
//	gaussianMask[4][0] = 2.0;	 gaussianMask[4][1] = 4.0;  gaussianMask[4][2] = 5.0;  gaussianMask[4][3] = 4.0;  gaussianMask[4][4] = 2.0;
//	imageplus::division(gaussianMask, 159.0, tmp_gm);
//	//gaussianMask=tmp_gm;
//	//gaussianMask=trans(gaussianMask);
//
//	LinearConvolution imf(tmp_gm);
//	filtered=imf.filter(im);
//
//	//Analyze gradient strength
//	ImageGray<float64> grad(im_x, im_y);
//	ImageGray<int64> directions(im_x, im_y);
//	ImageGray<int64> component_x(im_x, im_y), component_y(im_x, im_y), im64(im_x, im_y);
//
//	LinearConvolution sobx(GxMask), soby(GyMask);
//	for (uint64 j=0; j<im_x*im_y; j++) im64(0).data()[j]=static_cast<int64>(im(0).data()[j]);
//	component_x=sobx.filter(im64);
//	component_y=soby.filter(im64);
//
//	//Sobel derivatives
//	int64 *X, *Y;
//	float64 thisAngle;
//	int64 newAngle=0;
//	X=component_x(0).data();
//	Y=component_y(0).data();
//
//	for (uint64 j=0; j<im_y*im_x; j++)
//	{
//		grad(0).data()[j]=std::sqrt(static_cast<float64>((*X))*static_cast<float64>((*X))+
//		static_cast<float64>((*Y))*static_cast<float64>((*Y)));
//		//thisAngle = (atan2(static_cast<float64>((*X)),static_cast<float64>((*Y)))/3.14159) * 180.0;		// Calculate actual direction of edge
//
//		thisAngle = (atan2(static_cast<float64>((*Y)),static_cast<float64>((*X)))/M_PI) * 180.0;		// Calculate actual direction of edge
//
//		/* Convert actual edge direction to approximate value */
//		if ( ( (thisAngle < 22.5) && (thisAngle > -22.5) ) || (thisAngle > 157.5) || (thisAngle < -157.5) )
//			newAngle = 0;
//		else if ( ( (thisAngle > 22.5) && (thisAngle < 67.5) ) || ( (thisAngle < -112.5) && (thisAngle > -157.5) ) )
//			newAngle = 45;
//		else if ( ( (thisAngle > 67.5) && (thisAngle < 112.5) ) || ( (thisAngle < -67.5) && (thisAngle > -112.5) ) )
//			newAngle = 90;
//		else if ( ( (thisAngle > 112.5) && (thisAngle < 157.5) ) || ( (thisAngle < -22.5) && (thisAngle > -67.5) ) )
//			newAngle = 135;
//		directions(0).data()[j]=newAngle;
//		X++; Y++;
//	}
//
//	bool edge_end;
//
//	/* Non-maximum Suppression */
//
//	for (uint64 y = 1; y < im_y - 1; y++)
//	{
//		for (uint64 x = 1; x < im_x - 1; x++)
//		{
//			i = y*im_x + x;
//			//if (*(out(0).data() + i) == 255)
//			if(grad[x][y]>upper_threshold)
//			{		// Check to see if current pixel is an edge
//				/* Switch based on current pixel's edge direction */
//				switch (directions[x][y])
//				{
//					case 0:
//						suppress_non_max(out, 0, 1, x, y, 0, lower_threshold, grad(0), directions(0));
//						break;
//					case 45:
//						suppress_non_max(out, -1, 1, x, y, 45, lower_threshold, grad(0), directions(0));
//						break;
//					case 90:
//						suppress_non_max(out, 1, 0, x, y, 90, lower_threshold, grad(0), directions(0));
//						break;
//					case 135:
//						suppress_non_max(out, 1, 1, x, y, 135, lower_threshold, grad(0), directions(0));
//						break;
//					default :
//						break;
//				}
//			}
//		}
//	}
//
//	for (uint64 y = 1; y < im_y - 1; y++)
//	{
//		for (uint64 x = 1; x < im_x - 1; x++)
//		{
//			edge_end = false;
//			if (grad[x][y] > upper_threshold)
//			{
//				/* Switch based on current pixel's edge direction */
//				//std::cout << "Gradient : " << grad[col][row] << " and dir " << directions[col][row] << std::endl;
//				switch (directions[x][y])
//				{
//					case 0:
//						find_edge(out, 1, 0, x, y, 0, lower_threshold, grad(0), directions(0));
//						break;
//					case 45:
//						find_edge(out, 1, 1, x, y, 45, lower_threshold, grad(0), directions(0)); //1,1
//						break;
//					case 90:
//						find_edge(out, 0, 1, x, y, 90, lower_threshold, grad(0), directions(0));
//						break;
//					case 135:
//						find_edge(out, -1, 1, x, y, 135, lower_threshold, grad(0), directions(0));
//						break;
//					default :
//						i = y*im_x + x;
//						*(out(0).data() + i) =
//						*(out(0).data() + i + 1) =
//						*(out(0).data() + i + 2) = 0;
//						break;
//					}
//				}
//			else
//			{
//				i = y*im_x + x;
//					*(out(0).data() + i) =
//					*(out(0).data() + i + 1) =
//					*(out(0).data() + i + 2) = 0;
//			}
//		}
//	}
//
//		/* Suppress any pixels not changed by the edge tracing */
//	for (uint64 l = 0; l < im_y; l++)
//	{
//		for (uint64 k = 0; k < im_x; k++)
//		{
//
//			i = im_x*l + k;
//			// If a pixel's grayValue is not black or white make it black
//			if( ((*(out(0).data() + i) != 255) && (*(out(0).data() + i) != 0))
//			 || ((*(out(0).data() + i + 1) != 255) && (*(out(0).data() + i + 1) != 0))
//			 || ((*(out(0).data() + i + 2) != 255) && (*(out(0).data() + i + 2) != 0)) )
//				*(out(0).data() + i) =
//				*(out(0).data() + i + 1) =
//				*(out(0).data() + i + 2) = 0;
//		}
//	}
//
//	return out;
//
//}
