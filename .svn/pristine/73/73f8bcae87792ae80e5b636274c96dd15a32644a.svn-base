/*
 * maximum_flow.hpp
 *
 *  Created on: Nov 9, 2011
 *      Author: guillem
 */

#ifndef MAXIMUM_FLOW_HPP_
#define MAXIMUM_FLOW_HPP_

#include <imageplus/math/graphs/graph.hpp>
#include <imageplus/math/graphs/algorithms/connected_components.hpp>
#include <boost/graph/kolmogorov_max_flow.hpp>
#include <boost/graph/push_relabel_max_flow.hpp>
#include <boost/graph/edmonds_karp_max_flow.hpp>

namespace imageplus {
	namespace math {
		namespace graphs {


	//! Class to compute the Max Flow and Min Cut of a directed graph
	//! \param Graph : BoostGraph. CAUTION the graph properties of the nodes/edges should not be the default properties!
	template<class Graph>
	class MaxFlowMinCut {

		//! Noe type
		typedef typename Graph::Node Node;

		//! Edge type
		typedef typename Graph::Edge Edge;

		//! Node pair
		typedef typename Graph::NodePair NodePair;

	public:
		//! Edge map to represent the edge composing the minimum cut
		typedef typename std::map<NodePair, typename Graph::EdgePropertiesType> EdgeMap;

		//! Calculates the maxflow min cut. The function used is the edmonds_karp_max_flow, but it can be changed
		//! \param[in] g :graph
		//! \param[in] source : source node from where the flow will start to flow
		//! \param[in] sink : sink node
		//! \param[in] cut_graph : true if the graph should be cut (edges of the minimum cut removed)
		//! \return max flow from the source to the sink
		float64 calculate(Graph& g, Node source, Node sink, bool cut_graph = false) {

			/*
			 * Augment the graph with all vertices (a,b) and (b,a) and construct the reverse edge map
			 */
			EdgeMap added_edges;

			for (typename Graph::edge_iterator e = g.edges_begin(); e != g.edges_end(); ++e) {
				Node a = g.source(*e);
				Node b = g.target(*e);
				Edge e2;

				if (!g.edge_exists(b,a)) {
					e2 = g.add_edge(b,a);
					g.edge_properties(e2).capacity = 0;
					added_edges[NodePair(b,a)] = g.edge_properties(e2); // The algorithm requires auxiliary edges
				} else
					e2 = g.edge(b,a);

				g.edge_properties(*e).reverse_edge = e2;
				g.edge_properties(e2).reverse_edge = *e;
			}

			typename Graph::GraphContainer& graph = g.graph();

			/*
			 * We must pass all the arguments to the function as Boost assumes that they are interior properties by default
			 */

			float64 flow = boost::edmonds_karp_max_flow(graph, source, sink ,  boost::capacity_map(			get(&Graph::EdgePropertiesType::capacity, 							graph)).
																					residual_capacity_map(	get(&Graph::EdgePropertiesType::residual_capacity, 					graph)).
																					reverse_edge_map(		get(&Graph::EdgePropertiesType::reverse_edge, 						graph)).
																					color_map(				get(&Graph::NodePropertiesType::color,				 				graph)));


			// Remove the auxiliary edges
			for (typename EdgeMap::iterator i = added_edges.begin(); i != added_edges.end(); i++)
				g.remove_edge(i->first.first, i->first.second);

			_find_min_cut(g, source, cut_graph);

			return flow;
		}

		//! Minimum cut
		//! \return Edge map with edges forming the minimum cut
		const EdgeMap& min_cut() {return _min_cut;}

	private:

		/*
		 * Class for the BFS to find the minimum cut
		 */

		//! \cond SKIP_DOC
		template <typename Node, typename BGraph >
		class bfs_visitor : public boost::default_bfs_visitor {

			std::map<Node,bool>& _reachable; // Since the visitor is passed by value, we must pass states by reference

		public:
			bfs_visitor(std::map<Node,bool>& reach) : _reachable(reach) {}

			void discover_vertex(Node u, const BGraph & g)
			{
				_reachable[u] = true;
			}


			inline std::map<Node,bool>& reachable() {return _reachable;}
		};

		void _find_min_cut(Graph& g, Node source, bool cut_graph = false) {

			EdgeMap cut;

			// Find all the edges with saturaded capacity
			for (typename Graph::edge_iterator e = g.edges_begin(); e != g.edges_end(); ++e) {
				if (g.edge_properties(*e).capacity > 0 && g.edge_properties(*e).residual_capacity == 0) {
					cut[NodePair(g.source(*e), g.target(*e))] = g.edge_properties(*e);
				}
			}

			// Remove the possible edges forming a cut
			for (typename EdgeMap::iterator k = cut.begin(); k != cut.end(); k++) g.remove_edge(k->first.first, k->first.second);

			//Find the nodes reachable from the source
			bfs_visitor<Node,typename Graph::GraphContainer> bfs(_reachable);
			boost::breadth_first_search(g.graph(), source, boost::visitor(bfs));

			// find the edge of cut that connect a reachable node and an unreachable one
			for (typename EdgeMap::iterator k = cut.begin(); k != cut.end(); k++) {
				Node a = k->first.first;
				Node b = k->first.second;

				if (_reachable[a] != _reachable[b]) { // The edge is from the mincut
					_min_cut[k->first] = k->second;
					if (!cut_graph) g.add_edge(a,b,k->second); // re-add the edge with the previous properties
				}
				else { // The edge is not from the min cut
					g.add_edge(a,b,k->second); // re-add the edge with the previous properties
				}
			}
		}
		//! \endcond

		//! min cut map
		EdgeMap _min_cut;

		//! reachable map
		std::map<Node,bool> _reachable;
	};

		}
	}
}


#endif /* MAXIMUM_FLOW_HPP_ */
