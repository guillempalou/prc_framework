/*
 * convexity.hpp
 *
 *  Created on: Mar 5, 2012
 *      Author: guillem
 */

#ifndef CONVEXITY_HPP_
#define CONVEXITY_HPP_

#include <imageplus/core.hpp>
#include <imageplus/filters/linear_convolution.hpp>

namespace imageplus {
	namespace descriptors {

		//! \brief Convexity detector parameters
		struct ConvexityParameters {

			//! Minimum contour length
			float64 min_contour_length;

			//! convexity weight
			float64 convexity;

			//! true if the contour measure should be weighted by the average boundary gradient strength
			bool weighted;

			//! Default constructor
			ConvexityParameters() : min_contour_length(100),
									convexity(1.0/12.0),
									weighted(true) {

			}
		};


		//!
		//! \brief Contour Convexity Detector
		//!
		//! \author Guillem Palou <guillem.palou@upc.edu>
		//!
		//! \date 10-05-2012
		template<class BPT>
		class ContourConvexity {

			//! Region Type
			typedef typename BPT::RegionType 				RegionType;

			//! Contours between two regions
			typedef typename RegionType::contour_container 	AllContours;

			//! Contour between two regions
			typedef typename RegionType::coords_container 	ContourType;

		public:

			//! Default constructor
			//! \param[in] pars : parameters for the detector
			ContourConvexity(ConvexityParameters pars) : _pars(pars) {

			}

			//! Default empty constructor
			ContourConvexity() {

			}

			//! Set weights for each contour pixel. Usually the weights are some sort of gradient operator
			void set_weights(MultiArray<float64,2> weights) {
				_weights = weights;
			}

			//! set weights according to the sobel gradient normalized of an image
			//! \param[in] img: image to calculate the sobel gradient
			//! \param ImageModel: type of image
			template<class ImageModel>
			void set_weights(ImageModel& img) {
				filters::Kernel<1> der(1);
				filters::Kernel<1> gaus(1);

				der[-1] = 1; der[0] = 0; der[1] = -1;
				gaus[-1] = 1; gaus[0] = 2; gaus[1] = 1;

				filters::SeparableLinearConvolution2D sobel_x(der,gaus);
				filters::SeparableLinearConvolution2D sobel_y(gaus,der);

				MultiArray<float64,2> Gx;
				MultiArray<float64,2> Gy;

				sobel_x.calculate(img(0),Gx);
				sobel_y.calculate(img(0),Gy);

				uint64 sx = img.size_x();
				uint64 sy = img.size_y();

				_weights = MultiArray<float64,2>(sx,sy);

				float64 mx = 0;
				for (uint64 x = 0; x < sx; x++)
					for (uint64 y = 0; y < sy; y++) {
						_weights[x][y] = Gx[x][y]*Gx[x][y] + Gy[x][y]*Gy[x][y];
						mx = (_weights[x][y] > mx) ? _weights[x][y] : mx;
					}
				for (uint64 x = 0; x < sx; x++)
					for (uint64 y = 0; y < sy; y++) {
						_weights[x][y] /= mx;
					}
			}

			//! Calculate the convexity measure between two regions of a partition
			//! \param[in] partition: partition
			//! \param[in] id1 : id of the first region
			//! \param[in] id2 : id of the second region
			//! \return A signed value between -1 and 1. fabs(value) is the confidence of the convexity relation. The sign (-) indicates id1 is convex, otherwise id2 is convex
			float64 calculate(BPT& partition, uint32 id1, uint32 id2) {
				const ImagePartition<>& part = partition.leaves_partition();

				RegionType& reg1 = partition[id1];
				RegionType& reg2 = partition[id2];

				typename RegionType::neighbor_iterator neighs = reg1.neighbors_find(&reg2);

				if (neighs == reg1.neighbors_end()) return 0.0;

				AllContours& contours = neighs.link_data()->neighbor_coords();

				uint32 ccs = 0;

				float64 accum = 0;
				float64 nnn = 0;
				float64 strength = 0;

				for (typename AllContours::iterator i = contours.begin(); i != contours.end(); i++) {
					ContourType& c = *i;
					ccs += c.size();

					float64 radius = std::max(5.0,0.05*c.size());

					if (c.size() < _pars.min_contour_length) continue;

					typename ContourType::iterator center = c.begin();

					for (; center != c.end(); center++) {
						float64 xp = (*center)[0]*0.5-0.5;
						float64 yp = (*center)[1]*0.5-0.5;

						std::pair<uint64,uint64> p = convexity_at_point(xp,yp,part,id1,id2, radius);

						//float64 th = 0.0;
						if (p.first + p.second != 0) {
							accum += (float64)p.first - (float64)p.second;
							nnn += p.first + p.second;
							if (_pars.weighted) strength+=_weights[(uint32)xp][(uint32)yp];
							//if (p.first/p.second > 1+th) {accum++; nnn++; } }
							//if (p.first/p.second < 1-th) {accum--; nnn++; if (_pars.weighted) {strength+=_weights[(uint32)xp][(uint32)yp];} }
						}
					}
				}

				if (nnn < _pars.min_contour_length) return 0.0;

				float64 conf = 0;
				if (_pars.weighted) {
					conf = 1-std::exp(-fabs((accum/nnn)*(strength/nnn))/_pars.convexity);
				} else {
					conf = 1-std::exp(-fabs((accum/nnn))/_pars.convexity);
				}
				return (accum < 0) ? -conf : conf;
			}

		private:

			//! Parameter structure
			ConvexityParameters _pars;

			//! Matrix of weights
			MultiArray<float64,2> _weights;

			//! Function calculating the convexity at a given point
			//! \param[in] xp : x coordinate
			//! \param[in] yp : y coordinate
			//! \param[in] part: image partition
			//! \param[in] id1 : id of the first region
			//! \param[in] id2 : id of the second region
			//! \param[in] radius: radius of the local window (normally a 5% of the contour length)
			//! \return Pair containing the number of points inside the local window for both regions
			std::pair<uint64,uint64> convexity_at_point(float64 xp, float64 yp,const ImagePartition<>& part, uint32 id1, uint32 id2, float64 radius) {

				uint32 sx = part.size_x();
				uint32 sy = part.size_y();

				bool possible = false;
				while (!possible && radius > 5) {

					std::pair<uint64,uint64> p;
					float64 xm = std::max(0.0, xp-radius);
					float64 ym = std::max(0.0, yp-radius);
					float64 xM,yM;
					float64 dx,dy;

					if ((uint32)xp != xp) {
						dy = 0; dx = 0.5;
						xM = std::min((float64)part.size_x()-1, (int)xp+radius+1);
						yM = std::min((float64)part.size_y()-1, (int)yp+radius);
					} else {
						dy=0.5; dx = 0;
						xM = std::min((float64)part.size_x()-1, (int)xp+radius);
						yM = std::min((float64)part.size_y()-1, (int)yp+radius+1);
					}

					if (xm == 0 || ym == 0 || xM > sx-2 || yM > sy-2) {radius /= std::sqrt(2); continue; }

					possible = true;

					for (float64 x = xm; x <= xM && possible; x++) {
						for (float64 y = ym; y <= yM && possible; y++) {

							if ((x-(xp+dx))*(x-(xp+dx))+(y-(yp+dy))*(y-(yp+dy)) > radius*radius) continue;

							int64 x1 = (int64)x;
							int64 y1 = (int64)y;

							if (part[x1][y1] == id1) { p.first++; }
							if (part[x1][y1] == id2) { p.second++; }
							if (part[x1][y1] != id1 && part[x1][y1] != id2) {possible = false; }
						}
					}
					if (!possible) return std::pair<uint64,uint64>(0,0);

					return p;
					radius /= std::sqrt(2);
					//if (possible || radius < 5) return p; // else break;
				}
				return std::pair<uint64,uint64>(0,0);
			}
		};

	}
}



#endif /* CONVEXITY_HPP_ */
