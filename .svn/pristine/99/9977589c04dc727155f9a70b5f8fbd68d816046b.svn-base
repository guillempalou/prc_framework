/*
 * image_flow_fitting.hpp
 *
 *  Created on: Mar 14, 2013
 *      Author: gpalou
 */

#ifndef IMAGE_FLOW_FITTING_HPP_
#define IMAGE_FLOW_FITTING_HPP_

#include <imageplus/bpt/energy_minimization/optimal_pruner.hpp>
#include <imageplus/math/algebra/robust_regression.hpp>
#include <imageplus/descriptors/geometry/area.hpp>

namespace imageplus {
	namespace bpt {

	template <class BPT, class OpticalFlowModel>
	class ImageProjectiveCost : public RegionCostFunction<BPT,OpticalFlowModel> {

		typedef RegionCostFunction<BPT,OpticalFlowModel> 	BaseClassType;
		typedef OpticalFlowModel							OpticalFlowType;

	public:

		ImageProjectiveCost(descriptors::DescriptorManager& manager, uint64 max_label, float64 lambda = 0.001) : BaseClassType(manager,max_label,lambda) {
		}

		void set_flow(OpticalFlowModel& flow) {
			_flow = &flow;
		}

		float64 region_cost(BPT& bpt, OpticalFlowModel& img, uint64 region_id) {

			typedef typename BPT::RegionType	RegionType;

			float64 e = 0; //region_id;

			if (_costs.find(region_id) == _costs.end()) {

				e += fit_flow_model(bpt, *_flow, region_id);

				_costs[region_id] = e;
			} else
				e = _costs[region_id];

			//std::cout << "Computing region cost " << region_id << " " << e << " " << BaseClassType::_lambda << std::endl;
			//std::cout << region_id << " from " << reg.frame_begin() << " to " << reg.frame_end() << std::endl;

			return e + BaseClassType::_lambda;
		}

	protected:

		float64 fit_flow_model(BPT& bpt, OpticalFlowModel& img, uint64 id) {

			uint64 N = 0;

			for (typename BPT::RegionType::iterator c = bpt(id).begin(); c != bpt(id).end(); ++c) {
				N++;
			}

			if (N < 9) return 0;

			typedef math::algebra::RobustRegression<math::numeric::L1Robust> RobustRegression; // We fit 8 parameters, hence the dimension is 8

			uint64 p = 0;
			math::Matrix A = math::Matrix::Zero(2*N,8);
			math::Vector b = math::Vector::Zero(2*N);

			for (typename BPT::RegionType::iterator c = bpt(id).begin(); c != bpt(id).end(); ++c) {
				uint64 x = (*c)(0);
				uint64 y = (*c)(1);

				// Each point contributes to 2 equations
				b(p)  = img(x,y)(0);
				b(p+1) = img(x,y)(1);

				A(p,0) = 1; A(p,1) = x; A(p,2) = y; A(p,6) = x*x; A(p,7) = x*y;
				A(p+1,3) = 1; A(p+1,4) = x; A(p+1,5) = y; A(p+1,6) = x*y; A(p+1,7) = y*y;

				p+=2;
			}

			//std::cout << b.transpose() << " " << std::endl;
			//std::cout << A << std::endl;

			//
			// Fitting:
			//
			// vx = a0 + a1 * x + a2 * y + a6 * x^2 +   a7 * x * y
			// vy = a3 + a4 * x + a5 * y + a6 * x * y + a7 * y * y
			//
			//

			math::numeric::L1Robust f;
			RobustRegression rr;
			rr.fit(A,b);

			math::Vector a = rr.solution();

			float64 e = 0;
			float64 tn = 0;
			// Compute the error
			for (typename BPT::RegionType::iterator c = bpt(id).begin(); c != bpt(id).end(); ++c) {
				uint32 x = (*c)(0);
				uint32 y = (*c)(1);

				float64 u = a(0) + a(1)*x + a(2)*y + a(6)*x*x + a(7)*x*y;
				float64 v = a(3) + a(4)*x + a(5)*y + a(6)*x*y + a(7)*y*y;

				float64 u0 = img(x,y)(0);
				float64 v0 = img(x,y)(1);

				float64 dx = img(x,y)(0)-u;
				float64 dy = img(x,y)(1)-v;

				float64 n = u0*u0+v0*v0;

				tn += std::sqrt(n);

				e += std::sqrt(dx*dx+dy*dy);
			}

			return e;
		}

	private:

		std::map<uint64,float64> _costs;

		OpticalFlowModel*		_flow;
	};

	}
}

#endif /* IMAGE_FLOW_FITTING_HPP_ */
