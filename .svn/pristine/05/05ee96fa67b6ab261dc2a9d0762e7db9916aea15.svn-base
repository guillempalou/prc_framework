// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------

//!
//!  \file readimage.hpp
//!
//!  Interface for ReadImage class, used to read images from disk
//!


#ifndef IMAGEPLUS_IO_READIMAGE_HPP
#define IMAGEPLUS_IO_READIMAGE_HPP


#ifdef USE_IMAGEMAGICK
#include <Magick++.h>
#endif

#include <string>

#include <imageplus/core.hpp>
#include <imageplus/io/readmultiarray.hpp>
#include <imageplus/io/io_types.hpp>


namespace imageplus
{
    namespace io
    {
        /*!
         * \brief Class for reading images
         *
         * This class is mainly a wrapper to other libraries to read images from disk.
         *
         * By default it uses Boost.GIL and you will be able to read only JPEG, PNG and TIFF formats.
         * If you enable the USE_IMAGEMAGICK flag then you will use ImageMagick and you will be
         * able to read almost any format.
         *
         * Note that both, Boost.GIL and ImageMagick use the libjpeg, libpng and libtiff libraries.
         *
         * \warning Note that some codecs (e.g. libjpeg) do not guarantee that the same file read
         *          from different computers give the same images but, because some quantization
         *          issues, the two images will have differences of +-1 in some pixels.
         *
         * \author Josep Ramon Morros <morros@gps.tsc.upc.edu>
         * \author Albert Gil Moreno <albert.gil@upc.edu>
         *
         * \date  2008-1-10
         */
        class ReadImage
        {

    public:

        //!
        //! \brief Default constructor
        //!
        ReadImage();

        //!
        //! \brief Constructor from file name
        //!
        //! \param[in] filename  : File name
        //! \param[in] format    : Image format that will be read. The class checks that the extension and the header are consistent with it.
        //!                        No check is done if no format is provided
        //!
        explicit ReadImage( const std::string& filename, ImageFormat format=UNKNOWN_IMAGE_FORMAT );

        //!
        //! \brief Destructor
        //!
        ~ReadImage();


        //!
        //! \brief Set image file name
        //!
        //! \param[in] filename  : File name
        //! \param[in] format    : Image format that will be read. The class checks that the extension and the header are consistent with it.
        //!                        No check is done if no format is provided
        //!
        void open( const std::string& filename, ImageFormat format=UNKNOWN_IMAGE_FORMAT );

        //!
        //! \brief Operator to read an image
        //!
        //! ImageType template should be ImageRGB<T>, or ImageGray<T>.
        //! Data types supported (template T) are: uint8 and uint16
        //!
        //! \param[in] image  : Destination image
        //!
        template<class ImageType>
        void operator>>( ImageType& image) const
        {
            // TODO: This assert should be done also in release?
#ifndef MSVC
            ASSERT( _filename != "", "Reading before openning any file.")
            ASSERT( _format != UNKNOWN_IMAGE_FORMAT, "Reading an unsupported image type (unknown extension).")
#endif            
            return _read(image);
        }

        //!
        //! \brief Access format of image
        //!
        //! \return ImageFormat enumerate with the format information of the image
        //!
        ImageFormat format() const
        {
            return _format;
        }


    private:

        //!
        //! \brief Private and overloaded method to read an ImageRGB<uint8>
        //!
        //! \param[in] image  : Destination image
        //!
        void _read( ImageRGB<uint8>& image) const;

        //!
        //! \brief Private and overloaded method to read an ImageYUV<uint8>
        //!
        //! \param[in] image  : Destination image
        //!
        void _read( ImageYUV<uint8>& image) const;

        //!
        //! \brief Private and overloaded method to read an ImageRGB<uint16>
        //!
        //! \param[in] image  : Destination image
        //!
        void _read( ImageRGB<uint16>& image) const;

        //!
        //! \brief Private and overloaded method to read an ImageGray<uint8>
        //!
        //! \param[in] image  : Destination image
        //!
        void _read( ImageGray<uint8>& image) const;

        //!
        //! \brief Private and overloaded method to read an ImageGray<uint16>
        //!
        //! \param[in] image  : Destination image
        //!
        void _read( ImageGray<uint16>& image) const;


        //!
        //! \brief Private and overloaded method to read an ImageMask
        //!
        //! \param[in] image  : Destination image
        //!
        void _read( ImageMask& image) const;

        //!
        //! \brief Private and overloaded method to read an ImagePartition<uint32>
        //!
        //! \param[in] image  : Destination partition
        //!
        void _read( ImaVol<uint32,1,2>& image) const;

        //!
        //! \brief Private fuction for RGB images
        //!
        //! \param[in] image  : Destination image
        //!
#ifndef USE_IMAGEMAGICK
        template<typename T, typename BoostImage, typename BoostIterator>
#else
#if MagickLibVersion >= 0x640
                template<typename T, Magick::StorageType MagickPixelType >
#else
                template<typename T, MagickLib::StorageType MagickPixelType >
#endif
#endif
        void _read_rgb( ImageRGB<T>& image ) const;

        //!
        //! \brief Private fuction for GRAY images
        //!
        //! \param[in] image  : Destination image
        //!
#ifndef USE_IMAGEMAGICK
        template<typename T, typename BoostImage, typename BoostIterator>
#else
#if MagickLibVersion >= 0x640
                template<typename T, Magick::StorageType MagickPixelType >
#else
                template<typename T, MagickLib::StorageType MagickPixelType >
#endif
#endif
        void _read_gray( ImageGray<T>& image ) const;

#ifndef USE_IMAGEMAGICK
        //!
        //! \brief Private fuction for read a boost::gil image from the filesystem
        //!
        //! \param[in] boost_img : destination image
        //!
        template<typename BoostImage>
        void _read_boost(BoostImage& boost_img) const;
#endif

        //! Stores the file name of the image to read
        std::string _filename;

        //! Image format or extension (jpeg, png...)
        ImageFormat _format;
        };

    } // namespace io

} //namespace imageplus

#endif
