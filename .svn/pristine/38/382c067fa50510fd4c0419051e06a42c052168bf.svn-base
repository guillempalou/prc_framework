// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------

//!
//!  \file camera_implementations.cpp
//!
//! \brief Implementation of routines involving a single camera
//!
//!
//!

#include <imageplus/multiview/camera_implementations.hpp>

#include <imageplus/math/numeric/products.hpp>
#include <imageplus/math/numeric/derivative.hpp>
#include <imageplus/math/numeric/norms.hpp>
#include <imageplus/math/numeric/transformations.hpp>
#include <imageplus/math/geometry/rotations.hpp>
#include <imageplus/math/numeric/matrices.hpp>
#include <imageplus/math/numeric/interpolation.hpp>

#include <imageplus/math/geometry/point_geometry.hpp>

using namespace imageplus::multiview;
using namespace imageplus::math::numeric;
using namespace imageplus::math::geometry;
using namespace imageplus;

Point3D imageplus::multiview::camera_position(const Camera& cam)
{
    // TODO: Do not use MultiArray
    MultiArray<float64,1> tfinal(3);

    tfinal=(-1.0)*prod(trans(cam.rot()),cam.trans());
    Point3D out(tfinal);
    return out;
}


Point3D imageplus::multiview::image_coord_system_to_world_coord_system(const Camera& cam, const Point2D& p)
{
    //Point 2D p has to be coord2D???????
    MultiArray<float64,1> tp(3);
    MultiArray<float64,1> tr(3);
    MultiArray<float64,1> tfinal(3);
    MultiArray<float64,2> RotTransposed(3,3);
    Point2D aux(p);

    if (significant_distortion(cam))
    {
        Point2D princPoint(cam.k()[2][0],cam.k()[2][1]); //matrix must be referenced in a transposed way!!
        MultiArray<float64,1> focLength(2);
        focLength[0]=cam.k()[0][0];
        focLength[1]=cam.k()[1][1];
        aux = undistorter(p, cam.distortion(), princPoint, focLength);
    }

    tp[0] = (aux.x() - (cam.k()[2][0]))/(cam.k()[0][0]);
    tp[1] = (aux.y() - (cam.k()[2][1]))/(cam.k()[1][1]);
    tp[2] = 1.0;

    //transposeMatrix(cam->Rot, RotTransposed, 3, 3);
    //sumMatrix(tp, cam->trans, tr, 3, 1, 1.0, -1.0);
    //multMatrix(RotTransposed, tr, tfinal, 3, 3, 1, 1.0);
    tfinal=prod(trans(cam.rot()),tp-cam.trans());

    Point3D p3(tfinal);
    return p3;
}

void imageplus::multiview::back_projected_ray(const Camera& cam,const Point2D& image_point, Point3D& world_point, Point3D& director_vector)
{
    float64 normr;

    Point3D aux=image_coord_system_to_world_coord_system(cam,image_point);
    world_point=camera_position(cam);

    director_vector=aux-world_point;
    normr=imageplus::math::numeric::norm(director_vector);
    director_vector=(1.0/normr)*(director_vector);
}

Camera imageplus::multiview::interpolate_cameras(const Camera& cam1, const Camera& cam2, const float64 factor) throw (ImagePlusError)
{
    if( factor <= 0 || factor >= 1 )
    {
        throw ImagePlusError( "Interpolation factor must be larger than 0 and smaller than 1" );
    }

    Camera out;

    out.im_width() = cam1.im_width();
    out.im_height() = cam1.im_height();

    MultiArray<float64,1> v1 = rot_matrix_to_vector( cam1.rot() );
    MultiArray<float64,1> v2 = rot_matrix_to_vector( cam2.rot() );
    MultiArray<float64,1> vout( 4 );

    for(int32 i = 0; i < 3; i++ )
    {
        out.trans().data()[i] = cam1.trans().data()[i] * (1 - factor) + cam2.trans().data()[i] * factor;
        vout.data()[i] = v1.data()[i] * (1 - factor) + v2.data()[i] * factor;
        out.distortion().data()[i] = cam1.distortion().data()[i] * (1 - factor) + cam2.distortion().data()[i] * factor;
    }
    vout.data()[3] = v1.data()[3] * (1 - factor) + v2.data()[3] * factor;
    out.distortion().data()[3] = cam1.distortion().data()[3] * (1 - factor) + cam2.distortion().data()[3] * factor;

    for(int32 i = 0; i < 3 * 3; i++ )
    {
        out.k().data()[i] = cam1.k().data()[i] * (1 - factor) + cam2.k().data()[i] * factor;
    }

    out.rot() = rot_vector_to_matrix( vout );

    for( int32 i = 0; i < 3; i++ )
    {
        for( int32 j = 0; j < 3; j++ )
        {
            out.p().data()[i * 4 + j] = 0;
            for( int32 k = 0; k < 3; k++ )
            {
                out.p().data()[i * 4 + j] += out.k().data()[i * 3 + k] * out.rot().data()[k * 3 + j];
            }
        }
        out.p().data()[i * 4 + 3] = 0;
        for( int32 j = 0; j < 3; j++ )
        {
            out.p().data()[i * 4 + 3] += out.k().data()[i * 3 + j] * out.trans().data()[j];
        }
    }

    return out;
}


//Global variables: to avoid changing numerical recipes routines
MultiArray<float64,1> distortion(4);
MultiArray<float64,1> focal_length(2);
Point2D principal_point;
Point2D Tp;


//RayDistanceErrorParameters
//double *directorVectors, *rayPoints;

//Distorsion function.
//If its only needed by undistorter then keep it as private.
//Its defined as Point (and not Point2D) to keep compatibility with numeric functions.
void t_inv(Point<2> x, Point<2> *f)
{
    float64 r2,cdist,tmpx,tmpy;
    Point2D acum(0,0);
    Point2D p_distorted((x[0] - principal_point.x())/focal_length[0] , (x[1] - principal_point.y())/focal_length[1] );

    r2 = p_distorted.x() * p_distorted.x() + p_distorted.y() * p_distorted.y();

    /* Radial distortion  */
    cdist = 1.0f + distortion[0] * r2 + distortion[1] * r2 * r2;
    acum.x()+=cdist*p_distorted.x();
    acum.y()+=cdist*p_distorted.y();

    /* Tangential distortion */
    tmpx = p_distorted.x();
    tmpy = p_distorted.y();

    acum.x() += 2.0 * tmpx * tmpy * distortion[3];
    acum.x() += distortion[2] * (r2 + 2 * tmpx * tmpx);

    acum.y() += 2.0 * tmpx * tmpy * distortion[2];
    acum.y() += distortion[3] * (r2 + 2 * tmpy * tmpy);

    /* Error function */
    (*f)[0] = acum.x() * focal_length[0] + principal_point.x() - Tp.x();
    (*f)[1] = acum.y() * focal_length[1] + principal_point.y() - Tp.y();
}
//Kind of function required by newton_rhapson method
//It returns the value of the function at the given point and its jacobian.
void t_inv_func(Point<2> x, Point<2> *f, MultiArray<float64,2> *fjac)
{
    t_inv(x,f);
    (*fjac)=fd_jacobian(x,(*f),t_inv);
}

Point2D imageplus::multiview::undistorter(const Point2D& p_distorted, const MultiArray<float64,1>& dist, const Point2D& princ_point, const MultiArray<float64,1>& foc_length)
{
    int64 max_iter_newton=30;
    int64 i;
    float64 tolzero=1.0e-8;
    MultiArray<float64,1> x(2);


    for (i = 0; i < 4; i++)
    {
        distortion[i]=dist[i];
    }

    principal_point.x()=princ_point[0];
    principal_point.y()=princ_point[1];

    TRACE("Principal point:" << principal_point.x() << " " << principal_point.y())

    focal_length[0]=foc_length[0];
    focal_length[1]=foc_length[1];

    TRACE("Focal length: " << focal_length[0] << " " <<  focal_length[1])

    TRACE("Distorted point:" << p_distorted.x() << " " << p_distorted.y())

    //Initial guess for undistorted point is distorted point
    Point<2> p_undistorted;
    Tp=p_distorted;

    p_undistorted=newton_rhapson(max_iter_newton,p_distorted,tolzero,tolzero,t_inv_func);

    TRACE("Unistorted point:" << p_undistorted[0] << " " << p_undistorted[1])

    Point2D pfinal(p_undistorted[0], p_undistorted[1]);
    return(pfinal);
}

Point2D imageplus::multiview::distorter(const Point2D& p_undistorted, const MultiArray<float64,1>& dist, const Point2D& princ_point,  const MultiArray<float64,1>& foc_length)
{
    float64 tmp,r2,r4;
    float64 cdist, delta_x, delta_y;
    float64 tmpx, tmpy, a1, a2, a3;
    Point2D xd1, p_distorted;

    tmpx = (p_undistorted[0] - princ_point[0]) / foc_length[0];
    tmpy = (p_undistorted[1] - princ_point[1]) / foc_length[1];
    tmp = tmpx * tmpx + tmpy * tmpy;
    r2 = tmp;
    r4 = tmp * tmp;

    /* Radial distortion  */

    cdist = 1.0 + dist[0] * r2 + dist[1] * r4;
    xd1[0] = tmpx * cdist;
    xd1[1] = tmpy * cdist;

    /* Tangential distortion */
    a1 = 2 * tmpx * tmpy;
    a2 = r2 + 2 * tmpx * tmpx;
    a3 = r2 + 2 * tmpy * tmpy;
    delta_x = dist[2] * a1 + dist[3] * a2;
    delta_y = dist[2] * a3 + dist[3] * a1;

    /*Total distortion*/

    xd1[0] = xd1[0] + delta_x;
    xd1[1] = xd1[1] + delta_y;

    /* Pixel coordinates */

    p_distorted[0] = xd1[0] * foc_length[0] + princ_point[0];
    p_distorted[1] = xd1[1] * foc_length[1] + princ_point[1];

    return(p_distorted);
}

// TODO: Use exceptions instaed of "error codes"
int32 imageplus::multiview::significant_distortion(const Camera& cam)
{
    Point2D princPoint(cam.k()[2][0],cam.k()[2][1]);
    MultiArray<float64,1> focLength(2);
    Point2D pDistorted;
    float64 aux;

    focLength[0]=cam.k()[0][0];
    focLength[1]=cam.k()[1][1];
    Point2D p(0.0,0.0);
    pDistorted = distorter(p, cam.distortion(), princPoint, focLength);

    if ( (aux = imageplus::math::geometry::distance(p, pDistorted)) > MAX_PIXEL_DISTORSION_ERROR )
    {
        TRACE("WARNING: distortion could be important at image borders. About " << aux << " pixels")
        return(1);
    }
    else
    {
        return(0);
    }
}


void imageplus::multiview::ideal_to_distorted( const Point2D& p, const Camera& cam, Point2D & out)
{
    float64 a1, a2, a3, delta_x, delta_y, dx,dy;

    float64 ix   = p[0];
    float64 iy   = p[1];
    float64 k1   = cam.distortion()[0];
    float64 k2   = cam.distortion()[1];
    float64 tau1 = cam.distortion()[2];
    float64 tau2 = cam.distortion()[3];
    float64 cx   = cam.k()[2][0];
    float64 cy   = cam.k()[2][1];
    float64 fx   = cam.k()[0][0];
    float64 fy   = cam.k()[1][1];


    float64 r2 = (ix-cx)*(ix-cx)/(fx*fx) + (iy-cy)*(iy-cy)/(fy*fy);
    float64 r4 = r2 * r2;

    a1 = 2. * (ix-cx) * (iy-cy)/ (fx*fy);
    a2 = r2 + 2. * (ix-cx) * (ix-cx)/ (fx*fx);
    a3 = r2 + 2. * (iy-cy) * (iy-cy)/ (fy*fy);
    delta_x = tau1 * a1 + tau2 * a2;
    delta_y = tau1 * a3 + tau2 * a1;

    delta_x = delta_x * fx;
    delta_y = delta_y * fy;

    dx = ix + (ix-cx)*(k1*r2 + k2*r4) + delta_x;
    dy = iy + (iy-cy)*(k1*r2 + k2*r4) + delta_y;

    out.set(dx,dy);
}

Camera imageplus::multiview::scale_camera( const Camera & cam, const float64 scale )
{
    Camera res;

    res.im_width()=static_cast<int64>( static_cast<float64>( cam.im_width() )*scale );
    res.im_height()=static_cast<int64>( static_cast<float64>( cam.im_height() )*scale );

    res.rot()=cam.rot();
    res.trans()=cam.trans();

    res.k()=cam.k()*scale;
    res.k().data()[8]=1.0;

    res.p()=cam.p()*scale;
    const float64 * p1=&cam.p().data()[8];
    float64 * p2=&res.p().data()[8];
    for( int64 i=0; i < 4; ++i )
    {
        *p2++=*p1++;
    }

    //Normalized distortion parameters: do not modify their values!!!!
    res.distortion()=cam.distortion();

    return res;
}

//Method to convert any given coordinate system in UPC format into another coordinate system
imageplus::Camera imageplus::multiview::transform_calibration (const imageplus::Camera & cam, 
                                         float64 rot_x, 
                                         float64 rot_y, 
                                         float64 rot_z, 
                                         const imageplus::Point3D & translation )
{
    MultiArray<float64, 2> RotAbs (3,3), Rx(3,3), Ry(3,3), Rz(3,3);
    MultiArray<float64, 1> transAbs (3);
    MultiArray<float64, 1> pattern_position(3);

    imageplus::Camera out_cam;
    out_cam=cam;

    //Define rotation matrices
    rot_x=rot_x*M_PI/180; rot_y=rot_y*M_PI/180; rot_z=rot_z*M_PI/180;

    Rx=imageplus::math::numeric::identity_matrix<float64>(3);
    Ry=imageplus::math::numeric::identity_matrix<float64>(3); 
    Rz=imageplus::math::numeric::identity_matrix<float64>(3);

    double c=cos(rot_x);
    double s=sin(rot_x);

    Rx[1][1]=c; Rx[2][1]=s; 
    Rx[1][2]=-s; Rx[2][2]=c;

    c=cos(rot_y);
    s=sin(rot_y);

    Ry[0][0]=c; Ry[2][0]=-s;
    Ry[0][2]=s; Ry[2][2]=c;

    c=cos(rot_z);
    s=sin(rot_z);

    Rz[0][0]=c; Rz[1][0]=s; 
    Rz[0][1]=-s; Rz[1][1]=c;

    //Conversion as in room to Office
    RotAbs=prod(Rx,prod(Ry, Rz));
    pattern_position[0]=translation[0]; pattern_position[1]=translation[1]; pattern_position[2]=translation[2]; 

    transAbs = -1.0*prod(RotAbs,pattern_position );
   
    RotAbs = prod(cam.rot() , RotAbs);
    transAbs = prod(cam.rot(), transAbs) + cam.trans();

    out_cam.rot()=RotAbs; out_cam.trans()=transAbs;

    float64 *p; 
    float64 *r, *t;
    p=out_cam.p().data();
    r=out_cam.rot().data();
    t=out_cam.trans().data();
    std::size_t modulus=3;
    for (std::size_t i=0; i < 12 ; ++i, ++p)
    {
        if (i!=modulus)
        {   
            *p=*r; r++;
        }
        else
        {
            *p=*t; t++; modulus+=4;
        }
    }

    out_cam.p()=prod(out_cam.k(), out_cam.p());
    

    return out_cam;
}

void imageplus::multiview::back_projected_ray_known_cop_undistorted( const Camera & cam, const Point2D & image_point, const Point3D & cop, Point3D & director_vector )
{
    Point3D aux;
    image_coord_system_to_world_coord_system_undistorted( cam, image_point, aux );
    director_vector=aux-cop;
    director_vector=(1.0/std::sqrt((director_vector.x()*director_vector.x())+(director_vector.y()*director_vector.y())+(director_vector.z()*director_vector.z())))*director_vector;
}

void imageplus::multiview::image_coord_system_to_world_coord_system_undistorted( const Camera & cam, const Point2D & p, Point3D & world )
{
    MultiArray<float64,1> tp( 3 );
    tp[0]=(p.x()-(cam.k()[2][0]))/(cam.k()[0][0]);
    tp[1]=(p.y()-(cam.k()[2][1]))/(cam.k()[1][1]);
    tp[2]=1.0;
    world=Point3D( prod( trans( cam.rot() ), tp-cam.trans() ) );
}
