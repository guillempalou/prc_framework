// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------

//!
//!  \file erosion.cpp
//!
//!  Implementation for Erosion operations on MultiArray and ImageGray objects
//!

#include <imageplus/math/morphology/erosion.hpp>

using namespace imageplus;
using namespace imageplus::math::morphology;


template<std::size_t N>
Erosion<N>::Erosion() :
        Filter< Erosion<N> >("Erosion"), _se()
{
}

template<std::size_t N>
Erosion<N>::Erosion(uint64 connectivity, uint64 size) throw (ImagePlusError) :
        Filter< Erosion<N> >("Erosion"), _se(size, connectivity)
{
}

template<std::size_t N>
Erosion<N>::Erosion(const StructuringElement<N>& se) throw (ImagePlusError) :
        Filter< Erosion<N> >("Erosion"), _se(se)
{
}


template<std::size_t N>
template<typename T, std::size_t D>
MultiArray<T,D> Erosion<N>::implementation( const MultiArray<T,D>& ma ) const throw (ImagePlusError, ImagePlusNotImplemented)
{
    ASSERT (std::numeric_limits<T>::is_integer, "Erosion is only valid for integral types")
    ASSERT ((D == 2 || D == 3), "Erosion is only valid for 2D or 3D multiarrays")

    switch(_se.iterations())
    {
        case 0:
            break;
        case 1:
            if (_se.simple())
            {
                return do_simple_erosion(ma,_se);
            }
            else
            {
                //throw ImagePlusNotImplemented("Erosion: Not implemented for non-simple structuring elements. See documentation in class StructuringElement");
                return do_erosion(ma,_se);
            }
            break;
        default:
            MultiArray<T,D> tmp(ma);
            

            for (uint32 i=0; i < _se.iterations(); i++)
            {
                if (_se.simple())
                {
                    tmp = do_simple_erosion(tmp, _se);
                }
                else
                {
                    throw ImagePlusNotImplemented("Erosion: Not implemented for non-simple structuring elements. See documentation in class StructuringElement");
                    //tmp = do_erosion(tmp, _se);
                }
            }

            return tmp;
            break;
    }

    return ma;
}


template<std::size_t N>
template<typename T, std::size_t CHANNELS>
ImaVol<T,CHANNELS,N> Erosion<N>::implementation( const ImaVol<T, CHANNELS,N>& m) const throw (ImagePlusError)
{
    ImaVol<T,CHANNELS,N> o(m.dims());

    for (uint64 i=0; i < CHANNELS; ++i)
    {
        o(i) = this->implementation(m(i));
    }

    return o;
}

namespace imageplus
{
    namespace math
    {
        namespace morphology
        {
            template<typename T>
            inline MultiArray<T,2> do_simple_erosion( const MultiArray<T,2>& ma, const StructuringElement<2>& se ) throw (ImagePlusError)
            {
                uint64 inc = (se.connectivity() == 4) ? 1 : 2;

                const int64 bigval = std::numeric_limits<int64>::max();

                MultiArray<T,2> o(ma);

                T* oval     = o.data();
                const T* r  = ma.data();


                int64* t = new int64[ma.dims(0) + 2];
                int64* m = new int64[ma.dims(0) + 2];
                int64* b = new int64[ma.dims(0) + 2];


                int64* xs;
                int64* pt;
                int64* pm;
                int64* pb;
                int64* tmp;

                xs = t + ma.dims(0) + 2;
                for (pt = t;pt != xs; pt++)
                {
                    *pt = bigval; /*Init. top line.*/
                }


                /*Init. middle line and read pointer.*/
                r = ma.data();
                for (pm = m + 1; pm != m + ma.dims(0) + 1; pm++,r++)
                {
                    *pm = *r;
                }

                *m = *(m + ma.dims(0) + 1) = bigval;

                int64 ac,a0=0,a1=0,a2=0,a3=0,a4=0,a5=0,a6=0,a7=0,a8=0;

                uint64 stopy = ma.dims(1) - 1;
                uint64 y;

                for (y = 0; y != ma.dims(1); y++)
                {
                    xs = b + ma.dims(0) + 1;
                    if (y != stopy)
                    {
                        /*Read a line.*/
                        for (pb = b + 1;pb != xs; pb++)
                        {
                            *pb = *r;
                            r++;
                        }
                        *b = *(b + ma.dims(0) + 1) = bigval;
                    }
                    else
                    {
                        for (pb = b;pb != b + ma.dims(0) + 2; pb++)
                        {
                            *pb = bigval; /*Last line.*/
                        }
                    }
                    a3 = *(t + 1); a4 = *t;
                    a0 = *(m + 1); a5 = *m;
                    a7 = *(b + 1); a6 = *b;
                    pt = t + inc; pm = m + 2; pb = b + inc;
                    xs = m + ma.dims(0) + 2;

                    while (pm != xs)
                    {
                        ac = a0;

                        if (se.connectivity() == 8)
                        {
                            a2 = *pt; pt++;
                            a1 = *pm; pm++;
                            a8 = *pb; pb++;
                        }
                        else
                        {
                            a3 = *pt; pt++;
                            a1 = *pm; pm++;
                            a7 = *pb; pb++;
                        }

                        if (ac > a1)
                        {
                            ac = a1;
                        }
                        if (ac > a2 && se.connectivity() == 8)
                        {
                            ac = a2;
                        }
                        if (ac > a3)
                        {
                            ac = a3;
                        }
                        if (ac > a4 && se.connectivity() == 8)
                        {
                            ac = a4;
                        }
                        if (ac > a5)
                        {
                            ac = a5;
                        }
                        if (ac > a6 && se.connectivity() == 8)
                        {
                            ac = a6;
                        }
                        if (ac > a7)
                        {
                            ac = a7;
                        }
                        if (ac > a8 && se.connectivity() == 8)
                        {
                            ac = a8;
                        }

                        *oval = static_cast<T>(ac); oval++;
                        if (se.connectivity() == 8)
                        {
                            a4 = a3; a3 = a2;
                        }

                        a5 = a0; a0 = a1;

                        if (se.connectivity() == 8)
                        {
                            a6 = a7; a7 = a8;
                        }
                    }
                    tmp = t; t = m; m = b; b = tmp; /*Next line.*/
                }

                delete[] t;
                delete[] m;
                delete[] b;

                return o;
            }


            inline MultiArray<bool,2> do_simple_erosion( const MultiArray<bool,2>& ma, const StructuringElement<2>& se ) throw (ImagePlusError)
            {
                uint64 inc = (se.connectivity() == 4) ? 1 : 2;

                const bool bigval = true;

                MultiArray<bool,2> o(ma);

                bool* oval     = o.data();
                const bool* r  = ma.data();


                bool* t = new bool[ma.dims(0) + 2];
                bool* m = new bool[ma.dims(0) + 2];
                bool* b = new bool[ma.dims(0) + 2];


                bool* xs;
                bool* pt;
                bool* pm;
                bool* pb;
                bool* tmp;

                xs = t + ma.dims(0) + 2;
                for (pt = t;pt != xs; pt++)
                {
                    *pt = bigval; /*Init. top line.*/
                }


                /*Init. middle line and read pointer.*/
                r = ma.data();
                for (pm = m + 1; pm != m + ma.dims(0) + 1; pm++,r++)
                {
                    *pm = *r;
                }

                *m = *(m + ma.dims(0) + 1) = bigval;

                uint64 stopy = ma.dims(1) - 1;
                uint64 y;

                for (y = 0; y != ma.dims(1); y++)
                {
                    xs = b + ma.dims(0) + 1;
                    if (y != stopy)
                    {
                        /*Read a line.*/
                        for (pb = b + 1;pb != xs; pb++)
                        {
                            *pb = *r;
                            r++;
                        }
                        *b = *(b + ma.dims(0) + 1) = bigval;
                    }
                    else
                    {
                        for (pb = b;pb != b + ma.dims(0) + 2; pb++)
                        {
                            *pb = bigval; /*Last line.*/
                        }
                    }

                    bool ac;
                    bool a1=false;
                    bool a2=false;
                    bool a8=false;

                    bool a3 = *(t + 1); 
                    bool a4 = *t;
                    bool a0 = *(m + 1);
                    bool a5 = *m;
                    bool a7 = *(b + 1);
                    bool a6 = *b;

                    pt = t + inc; 
                    pm = m + 2; 
                    pb = b + inc;
                    xs = m + ma.dims(0) + 2;

                    while (pm != xs)
                    {
                        ac = a0;

                        if (se.connectivity() == 8)
                        {
                            a2 = *pt; pt++;
                            a1 = *pm; pm++;
                            a8 = *pb; pb++;
                        }
                        else
                        {
                            a3 = *pt; pt++;
                            a1 = *pm; pm++;
                            a7 = *pb; pb++;
                        }

                        if ( a1 == false || a3 == false || a5 == false || a7 == false ||
                            (a2 == false && se.connectivity() == 8) || (a4 == false && se.connectivity() == 8) ||
                            (a6 == false && se.connectivity() == 8) || (a8 == false && se.connectivity() == 8))
                        {
                            ac = false;
                        }

                        *oval = ac; 
                        oval++;

                        if (se.connectivity() == 8)
                        {
                            a4 = a3; a3 = a2;
                        }

                        a5 = a0; a0 = a1;

                        if (se.connectivity() == 8)
                        {
                            a6 = a7; a7 = a8;
                        }
                    }
                    tmp = t; t = m; m = b; b = tmp; /*Next line.*/
                }

                delete[] t;
                delete[] m;
                delete[] b;

                return o;
            }


            template<typename T>
            inline MultiArray<T,3> do_simple_erosion( const MultiArray<T,3>& vol, const StructuringElement<3>& se ) throw (ImagePlusError)
            {
                if (se.connectivity()!=6 && se.connectivity()!=18 && se.connectivity()!=26)
                {
                    throw ImagePlusError("Volume erosion requires 6, 18 or 26 connectivities.");
                }

                register T ac,acenter,a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15,a16,a17,a18,
                    a19,a20,a21,a22,a23,a24,a25;
                register T *xs;
                register T *r, *oval,*dataVoxel;
                register T *plb,*pmb,*prb,*plm,*pmm,*prm,*plt,*pmt,*prt;
                uint16 y,z;
                T *lb,*mb,*rb,*lm,*mm,*rm,*lt,*mt,*rt;
                T *tmpt,*tmpm,*tmpb;

                MultiArray<T,3> out(vol); //output array
                uint16 cubesX=vol.shape()[0]+2;
                uint16 cubesY=vol.shape()[1]+2;
                uint16 cubesZ=vol.shape()[2]+2;
                uint32 XxY=cubesX*cubesY;

                //PutBorders
                MultiArray<T,3> tmp(cubesX,cubesY,cubesZ);

                T pad_val;

                if (typeid(T) == typeid(uint8)) pad_val=255;
                else if (typeid(T) == typeid(int8))  pad_val=128;
                else if (typeid(T) == typeid(uint16)) pad_val=2^16;
                else if (typeid(T) == typeid(int16)) pad_val=2^15;
                else if (typeid(T) == typeid(uint32)) pad_val=2^32;
                else if (typeid(T) == typeid(int32)) pad_val=2^31;
                else if (typeid(T) == typeid(uint64)) pad_val=2^64;
                else if (typeid(T) == typeid(int64)) pad_val=2^63;        

                padding(vol,1,pad_val,tmp);
            
                lb = new T[cubesX];
                mb = new T[cubesX];
                rb = new T[cubesX];
                lm = new T[cubesX];
                mm = new T[cubesX];
                rm = new T[cubesX];
                lt = new T[cubesX];
                mt = new T[cubesX];
                rt = new T[cubesX];
                //dataVoxel=new T[cubesX*cubesY*cubesZ];

                oval=out.data();
                dataVoxel=tmp.data();

                for (z=2;z!=cubesZ;z++)
                {

                    /* Direct Access to memory of a volume data block of cubesX*2*3 (in X,Y,Z).
                     * The l(left) refers to the lowest y coordinate, while m denotes medium and r right.
                     * For Z coordinate b(bottom), m(mid), and t (top) are used*/

                    for (plb=lb,r=dataVoxel+(XxY*(z-2)); plb!=lb+cubesX; plb++,r++)
                    {
                        *plb=*r;
                    }
                    for (pmb=mb; pmb!=mb+cubesX; pmb++,r++)
                    {
                        *pmb=*r;
                    }
                    for (plm=lm,r=dataVoxel + (XxY*(z-1)); plm!=lm+cubesX; plm++,r++)
                    {
                        *plm=*r;
                    }
                    for (pmm=mm; pmm!=mm+cubesX; pmm++,r++)
                    {
                        *pmm=*r;
                    }
                    for (plt=lt,r=dataVoxel + (XxY*z); plt!=lt+cubesX; plt++,r++)
                    {
                        *plt=*r;
                    }
                    for (pmt=mt; pmt!=mt+cubesX; pmt++,r++)
                    {
                        *pmt=*r;
                    }

                    for (y=2;y!=cubesY;y++)
                    {
                        /* Direct Access to memory of a volume data block of cubesX*1*3 which, altogether with
                         * the prior block, makes a cubesX*3*3 block*/

                        for (prb=rb,r=dataVoxel+(XxY*(z-2))+(cubesX*y); prb!=rb+cubesX; prb++,r++) *prb=*r;
                        for (prm=rm,r=dataVoxel+(XxY*(z-1))+(cubesX*y); prm!=rm+cubesX; prm++,r++) *prm=*r;
                        for (prt=rt,r=dataVoxel+(XxY*z)+(cubesX*y); prt!=rt+cubesX; prt++,r++) *prt=*r;

                        //Get the values on the zone of influence of the EE
                        a2=*(rt);a3=*(mt);a4=*(lt);a10=*(rm);a11=*(mm);a12=*(lm);a19=*(rb);a20=*(mb);a21=*(lb);
                        a1=*(rt+1);a0=*(mt+1);a5=*(lt+1);a9=*(rm+1);acenter=*(mm+1);a13=*(lm+1);a18=*(rb+1);a17=*(mb+1);a22=*(lb+1);
                        //Move the pointers along X (positions which values still haven't been gotten)
                        plt=lt+2;pmt=mt+2;prt=rt+2;plm=lm+2;pmm=mm+2;prm=rm+2;plb=lb+2;pmb=mb+2;prb=rb+2;

                        xs=mm+cubesX; //Gets the position of the center in next Y

                        while (pmm!=xs)
                        {
                            ac=acenter;
                            a6=*(plt);a7=*(pmt);a8=*(prt);a14=*(plm);a15=*(pmm);
                            a16=*(prm);a23=*(plb);a24=*(pmb);a25=*(prb);
                            plt++;pmt++;prt++;plm++;pmm++;prm++;plb++;pmb++;prb++;

                            //Evaluate erosion condition for 6 conn

                            if (ac>a0) ac=a0;
                            if (ac>a13) ac=a13;
                            if (ac>a17) ac=a17;
                            if (ac>a9) ac=a9;
                            if (ac>a11) ac=a11;
                            if (ac>a15) ac=a15;

                            if (se.connectivity()==18||se.connectivity()==26)
                            {
                                //evaluate erosion condition for 18 conn
                                if (ac>a1) ac=a1;
                                if (ac>a3) ac=a3;
                                if (ac>a5) ac=a5;
                                if (ac>a7) ac=a7;
                                if (ac>a10) ac=a10;
                                if (ac>a12) ac=a12;
                                if (ac>a14) ac=a14;
                                if (ac>a16) ac=a16;
                                if (ac>a18) ac=a18;
                                if (ac>a20) ac=a20;
                                if (ac>a22) ac=a22;
                                if (ac>a24) ac=a24;

                            }
                            if (se.connectivity()==26)
                            {
                                //evaluate erosion condition for 26 conn
                                if (ac>a8) ac=a8;
                                if (ac>a2) ac=a2;
                                if (ac>a4) ac=a4;
                                if (ac>a6) ac=a6;
                                if (ac>a25) ac=a25;
                                if (ac>a19) ac=a19;
                                if (ac>a21) ac=a21;
                                if (ac>a23) ac=a23;
                            }
                            //Set the result in the output Volume
                            *oval=ac; oval++;

                            a2=a1;a3=a0;a4=a5;a10=a9;a11=acenter;a12=a13;a19=a18;a20=a17;a21=a22;
                            a1=a8;a0=a7;a5=a6;a9=a16;acenter=a15;a13=a14;a18=a25;a17=a24;a22=a23;
                        }
                        //Move pointers along X in order to complete the next iteration
                        tmpt=lt;tmpm=lm;tmpb=lb;lt=mt;lm=mm;lb=mb;mt=rt;mm=rm;mb=rb;rt=tmpt;rm=tmpm;rb=tmpb;
                    }
                }
                delete[] lb;
                delete[] mb;
                delete[] rb;
                delete[] lm;
                delete[] mm;
                delete[] rm;
                delete[] lt;
                delete[] mt;
                delete[] rt;

                return(out);
            }
        

            template<typename T>
            inline MultiArray<T,2> do_erosion( const MultiArray<T,2>& ma, const StructuringElement<2>& se ) throw (ImagePlusError)
            {
                uint64 num_active_elements = se.num_active_elements();

                if (num_active_elements == 0)
                {
                    throw ImagePlusError ("Structuring element must contain at least one active position");
                }

                const int64 bigval = std::numeric_limits<int64>::max();

                MultiArray<T,2> out(ma.dims());

                for (uint64 j=0; j < out.dims(1); ++j)
                for (uint64 i=0; i < out.dims(0); ++i)
                {
                    // Construct a coordinate for current position
                    Coord<int64,2> cur_pos(i,j);

                    int64 min = bigval;

                    // Loop for all active elements in the se 
                    for (uint64 k=0; k < num_active_elements; ++k)
                    {
                        // Compute the coordinate of ...
                        Coord<int64,2> coord_element (cur_pos + se.element_coord(k));

                        // Check if final coordinate is inside the multiarray
                        if (check_coordinate(coord_element, ma))
                        {
                            if (ma(coord_element) < min)
                            {
                                min = ma(coord_element);
                            }
                        }
                    }

                    out(cur_pos) = min;
                }

                return out;
            }

            inline MultiArray<bool,2> do_erosion( const MultiArray<bool,2>& ma, const StructuringElement<2>& se ) throw (ImagePlusError)
            {

                uint64 num_active_elements = se.num_active_elements();

                if (num_active_elements == 0)
                {
                    throw ImagePlusError ("Structuring element must contain at least one active position");
                }

                MultiArray<bool,2> out(ma.dims());

                for (uint64 j=0; j < out.dims(1); ++j)
                for (uint64 i=0; i < out.dims(0); ++i)
                {
                    // Construct a coordinate for current position
                    Coord<int64,2> cur_pos(i,j);

                    bool min = true;

                    // Loop for all active elements in the se 
                    for (uint64 k=0; k < num_active_elements; ++k)
                    {
                        // Compute the coordinate of ...
                        Coord<int64,2> coord_element (cur_pos + se.element_coord(k));

                        // Check if final coordinate is inside the multiarray
                        if (check_coordinate(coord_element, ma))
                        {
                            if (ma(coord_element) == false)
                            {
                                min = false;
                                break;
                            }
                        }
                    }

                    out(cur_pos) = min;
                }

                return out;
            }


            template<typename T>
            inline MultiArray<T,3> do_erosion( const MultiArray<T,3>& ma, const StructuringElement<3>& se ) throw (ImagePlusNotImplemented)
            {
                MultiArray<T,3> out(ma.dims());

                if (1)
                {
                    throw ImagePlusNotImplemented("3D Erosion not implemented with arbitrary structring element");
                }
                return out;
            }



            template class Erosion<2>;
            template class Erosion<3>;

            template MultiArray<uint8,2> Erosion<2>::implementation(const MultiArray<uint8,2>&) const;
            template MultiArray<int64,2> Erosion<2>::implementation(const MultiArray<int64,2>&) const;
            template MultiArray<bool,2>  Erosion<2>::implementation(const MultiArray<bool,2>&) const;
            template MultiArray<uint8,3> Erosion<3>::implementation(const MultiArray<uint8,3>&) const;
            template MultiArray<int64,3> Erosion<3>::implementation(const MultiArray<int64,3>&) const;

            // Instantiation for ImaVols
            template ImaVol<uint8,1,2>    Erosion<2>::implementation(const ImaVol<uint8,1,2>&) const;
            template ImaVol<int64,1,2>    Erosion<2>::implementation(const ImaVol<int64,1,2>&) const;
            template ImaVol<bool,1,2>     Erosion<2>::implementation(const ImaVol<bool,1,2>&)  const;

            template ImaVol<uint8,1,3>    Erosion<3>::implementation(const ImaVol<uint8,1,3>&) const;
            template ImaVol<int64,1,3>    Erosion<3>::implementation(const ImaVol<int64,1,3>&) const;

            // Instantiation of private functions
            template MultiArray<uint8,2> do_simple_erosion(const MultiArray<uint8,2>& , const StructuringElement<2>& );
            template MultiArray<uint8,3> do_simple_erosion(const MultiArray<uint8,3>& , const StructuringElement<3>& );
            template MultiArray<int64,2> do_simple_erosion(const MultiArray<int64,2>&, const StructuringElement<2>& );
            template MultiArray<int64,3> do_simple_erosion(const MultiArray<int64,3>&, const StructuringElement<3>& );

            template MultiArray<uint8,2> do_erosion(const MultiArray<uint8,2>&, const StructuringElement<2>& );
            template MultiArray<int64,2> do_erosion(const MultiArray<int64,2>&, const StructuringElement<2>& );
            template MultiArray<uint8,3> do_erosion(const MultiArray<uint8,3>&, const StructuringElement<3>& );
            template MultiArray<int64,3> do_erosion(const MultiArray<int64,3>&, const StructuringElement<3>& );
        }
    }
}
