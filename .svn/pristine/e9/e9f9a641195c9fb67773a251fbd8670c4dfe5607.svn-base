/*
 * objects_and_parts.hpp
 *
 *  Created on: Mar 22, 2013
 *      Author: gpalou
 */

#ifndef OBJECTS_AND_PARTS_HPP_
#define OBJECTS_AND_PARTS_HPP_

#include <imageplus/math/math_types.hpp>
#include <vector>

namespace imageplus {
	namespace segmentation {

	/*! Constants identifying each type of intances classification of the Hoover measures.
	 *
	 *  Defined in:
	 *  Hoover, A.; Jean-Baptiste, G.; Jiang, X.; Flynn, P. J.; Bunke, H.; Goldgof, D. B.; Bowyer, K.; Eggert, D. W.; Fitzgibbon, A. & Fisher, R. B.
	 *  An Experimental Comparison of Range Image Segmentation Algorithms
	 *  IEEE Transactions on Pattern Analysis and Machine Intelligence, 1996, 18, 673-689
	 *
	 *  \author Jordi Pont Tuset <jordi.pont@upc.edu>
	 */
		enum RegionClassificationTypes
		{
			NOT_CLASSIFIED,
			OBJECT,
			PART
		};

		/*!
         *  \author Jordi Pont Tuset <jordi.pont@upc.edu>
         *
         *  \date 10-11-2012
         */
		template<typename PartitionType>
        class ObjectsAndPartsF
        {
            //! Resulting Precision
            float64               _precision;
            //! Resulting Recall
            float64                  _recall;
            //! Resulting F
            float64               _f_measure;

            //! Threshold for a region to be classified as object
            float64                  _obj_th;
            //! Threshold for a region to be classified as part
            float64                 _part_th;
            //! Area percentile considered
            float64                 _area_percentile;
            //! Weight given to parts
            float64                 _gamma;
        public:

            /*! Default constructor
             *
             *  \author Jordi Pont Tuset <jordi.pont@upc.edu>
             */
            ObjectsAndPartsF(): _precision(), _recall(), _f_measure(), _obj_th(0.9), _part_th(0.25), _area_percentile(0.99), _gamma(0.1)
            {
            }

            /*! Constructor for a non-default gamma and thresholds
             *
             *  \author Jordi Pont Tuset <jordi.pont@upc.edu>
             *
             *  \param[in] gamma : Factor to weight over and undersegmentations (see paper)
             *  \param[in] thresholds : Thresholds to compute the Area Under the Curve (AUC) (see paper)
             */
            ObjectsAndPartsF(float64 object_threshold, float64 part_threshold, float64 area_percentile, float64 gamma)
               : _precision(), _recall(), _f_measure(), _obj_th(object_threshold), _part_th(part_threshold), _area_percentile(area_percentile), _gamma(gamma)
            {
            }

            math::Matrix intersection_matrix(PartitionType& partition1,PartitionType& partition2)
            {

                uint64 num_reg_1 = partition1.max_label()+1;
                uint64 num_reg_2 = partition2.max_label()+1;

                //std::cout << "Labels " << num_reg_1 << " " <<  num_reg_2 << " " << partition1.sizes().transpose() << " " << partition2.sizes().transpose() << std::endl;

                math::Matrix intersect_matrix = math::Matrix::Zero(num_reg_1, num_reg_2);

                // from the reference partition and region "j" from the fine partition
                typename PartitionType::iterator p = partition1.begin();
                typename PartitionType::iterator end = partition1.end();
                for (; p != end; ++p) {
                	typename PartitionType::coord_type pos = p.pos();
                	intersect_matrix(partition1(pos)(0),partition2(pos)(0)) +=1;
                }

                return intersect_matrix;
            }

            /*!
             *  \author Jordi Pont Tuset <jordi.pont@upc.edu>
             *
             *  \tparam T : Type of data of both ImagePartitions
             *  \param[in]  partition  : Assessed partition
             *  \param[in]  ground_truth  : Ground-truth partition
             */

            void calculate(PartitionType& partition, std::vector<PartitionType>& ground_truth) {
            	std::vector<math::Matrix> int_matrices;
            	//std::cout << "Calculating for " << ground_truth.size() << std::endl;
            	for (uint64 i = 0; i < ground_truth.size(); i++) {
            		int_matrices.push_back(intersection_matrix(partition, ground_truth[i]));
            	}
            	//std::cout << "Calculating" << std::endl;
            	calculate(int_matrices);
            }

            /*!
             *
             *  \author Jordi Pont Tuset <jordi.pont@upc.edu>
             *
             *  \param[in] intersect_matrix : Intersection matrices between the partition and the set of GT partitions
             */
            void calculate(const std::vector<math::Matrix>& intersect_matrices) {
            	_clear();
            	uint32 num_reg_part = intersect_matrices[0].rows();
            	std::size_t n_gts = intersect_matrices.size();

            	_classification_part.resize(num_reg_part); // Allocate
            	_prec_part.resize(num_reg_part); // Allocate
            	_classification_gt.resize(n_gts); // Allocate
            	_mapping_gt.resize(n_gts); // Allocate
            	_recall_gt.resize(n_gts); // Allocate

            	std::vector<uint64> region_areas_part(num_reg_part,0);
            	std::vector<std::vector<uint64> > region_areas_gt(n_gts);
            	std::vector<uint32> num_reg_gt(n_gts);
            	uint64 image_area=0;

            	// Get areas and intersections
            	for(std::size_t part_id=0; part_id<n_gts; ++part_id)
            	{
            		num_reg_gt[part_id]  = intersect_matrices[part_id].cols();

            		_classification_gt[part_id].resize(num_reg_gt[part_id]); // Allocate
            		_recall_gt[part_id].resize(num_reg_gt[part_id]); // Allocate

            		region_areas_gt[part_id].resize(num_reg_gt[part_id],0); // Allocate and set to zero

            		if(part_id==0)
            		{
            			for(std::size_t ii=0; ii<num_reg_gt[part_id]; ii++)
            			{
            				for(std::size_t jj=0; jj<num_reg_part; jj++)
            				{
            					image_area += intersect_matrices[part_id](jj,ii);
            					region_areas_part[jj] = region_areas_part[jj] + intersect_matrices[part_id](jj,ii);
            					region_areas_gt[part_id][ii]   = region_areas_gt[part_id][ii]   + intersect_matrices[part_id](jj,ii);
            				}
            			}
            		}
            		else
            		{
            			for(std::size_t ii=0; ii<num_reg_gt[part_id]; ii++)
            			{
            				for(std::size_t jj=0; jj<num_reg_part; jj++)
            				{
            					region_areas_gt[part_id][ii]   = region_areas_gt[part_id][ii]   + intersect_matrices[part_id](jj,ii);
            				}
            			}
            		}
            	}

            	/* Get part candidates */
            	_candidate_part.resize(num_reg_part);
            	std::multimap<float64, uint32> area_map; // Mapping between each region area and its id
            	for(std::size_t ii=0; ii<num_reg_part; ++ii)
            	{
            		area_map.insert(std::pair<float64, uint32>(((float64)region_areas_part[ii])/((float64)image_area),ii));
            	}
            	float64 curr_pct = 0;
            	for(std::multimap<float64, uint32>::const_reverse_iterator rit = area_map.rbegin(); rit != area_map.rend(); ++rit)
            	{
            		if(curr_pct<_area_percentile)
            			_candidate_part[rit->second] = 1;
            		else
            			_candidate_part[rit->second] = 0;

            		curr_pct += rit->first;
            	}

            	_candidate_gt.resize(n_gts);
            	for(std::size_t part_id=0; part_id<n_gts; ++part_id)
            	{
            		_candidate_gt[part_id].resize(num_reg_gt[part_id]);
            		area_map.clear();
            		for(std::size_t ii=0; ii<num_reg_gt[part_id]; ++ii)
            		{
            			area_map.insert(std::pair<float64, uint32>(((float64)region_areas_gt[part_id][ii])/((float64)image_area),ii));
            		}
            		curr_pct = 0;
            		for(std::multimap<float64, uint32>::const_reverse_iterator rit = area_map.rbegin(); rit != area_map.rend(); ++rit)
            		{
            			if(curr_pct<_area_percentile)
            				_candidate_gt[part_id][rit->second] = 1;
            			else
            				_candidate_gt[part_id][rit->second] = 0;

            			curr_pct += rit->first;
            		}
            	}


            	/* Scan table */
            	for(std::size_t part_id=0; part_id<n_gts; ++part_id)
            	{
            		/* Scan through table and find all OBJECT mappings */
            		for(uint32 ii=0; ii<num_reg_gt[part_id]; ii++)
            		{
            			for(uint32 jj=0; jj<num_reg_part; jj++)
            			{
            				float64 recall    = (float64)intersect_matrices[part_id](jj,ii)/(float64)region_areas_gt[part_id][ii];
            				float64 precision = (float64)intersect_matrices[part_id](jj,ii)/(float64)region_areas_part[jj];

            				if(_candidate_gt[part_id][ii]==1 && _candidate_part[jj]==1)
            				{
            					if(recall >= _obj_th  &&  precision >= _obj_th)
            					{
            						_classification_gt[part_id][ii]  = OBJECT;
            						_classification_part[jj]         = OBJECT;

            						_mapping_gt[part_id][ii]   = jj;
            						_mapping_part[jj] = ii;
            					}
            					else if(recall >= _part_th  &&  precision >= _obj_th)
            					{
            						if(_classification_part[jj] == NOT_CLASSIFIED) /* Does not have a classification yet */
            								{
            							_classification_part[jj] = PART;
            							_mapping_part[jj] = ii;
            								}
            					}
            					else if(recall >= _obj_th  &&  precision >= _part_th)
            					{
            						/* Cannot have a classification already */
            						_classification_gt[part_id][ii] = PART;
            						_mapping_gt[part_id][ii] = jj;
            					}
            				}

            				// Get _recall_gt and _prec_part (no matter if candidates of not), discarding objects
            				if(precision >= _obj_th && recall < _obj_th)
            					_recall_gt[part_id][ii] += recall;
            				else if (recall >= _obj_th && precision < _obj_th)
            					_prec_part[jj] += precision;
            			}
            		}
            	}

            	// Count everything
            	num_objects_part = 0;
            	num_objects_gt = 0;
            	num_parts_part = 0;
            	num_parts_gt = 0;
            	num_underseg_part = 0;
            	num_overseg_gt = 0;
            	num_candidates_part = 0;
            	num_candidates_gt = 0;

            	for(uint32 jj=0; jj<num_reg_part; jj++)
            	{
            		num_candidates_part += _candidate_part[jj];

            		if(_classification_part[jj]==PART)
            			num_parts_part++;
            		else if(_classification_part[jj]==OBJECT)
            			num_objects_part++;
            		else if (_candidate_part[jj])// Compute degree of undersegmentation
            			num_underseg_part += _prec_part[jj];
            	}
            	num_underseg_part = num_underseg_part/(float64)n_gts;
            	for(std::size_t part_id=0; part_id<n_gts; ++part_id)
            	{
            		for(uint32 ii=0; ii<num_reg_gt[part_id]; ii++)
            		{
            			num_candidates_gt += _candidate_gt[part_id][ii];
            			if(_classification_gt[part_id][ii]==PART)
            				num_parts_gt++;
            			else if(_classification_gt[part_id][ii]==OBJECT)
            				num_objects_gt++;
            			else if(_candidate_gt[part_id][ii])// Compute degree of oversegmentation
            					num_overseg_gt += _recall_gt[part_id][ii];
            		}
            	}

            	// Precision and recall
            	_precision = (num_objects_part + num_underseg_part + _gamma*num_parts_part)/num_candidates_part;
            	_recall    = (num_objects_gt   + num_overseg_gt    + _gamma*num_parts_gt  )/num_candidates_gt;

            	// F-measure for Region Detection
            	if(_precision==0 && _recall==0)
            		_f_measure = 0;
            	else
            		_f_measure = 2*_precision*_recall/(_precision+_recall);
            }

            /*!
             * ObjectsAndParts precision
             *
             * \return ObjectsAndParts precision
             */
            float64 precision()
            {
                return _precision;
            }

            /*!
             * ObjectsAndParts recall
             *
             * \return ObjectsAndParts recall
             */
            float64 recall()
            {
                return _recall;
            }


            /*!
             * ObjectsAndParts F measure
             *
             * \return ObjectsAndParts F measure
             */
            float64 f_measure()
            {
                return _f_measure;
            }

        private:

            //! Clears everything
            void _clear()
            {
                _classification_gt.resize(0);
                _classification_part.resize(0);
                _mapping_gt.resize(0);
                _mapping_part.clear();
                _candidate_part.resize(0);
                _candidate_gt.resize(0);
            }

            //! Map between each region index in scanning order of partition and its RegionClassificationTypes
            std::vector<RegionClassificationTypes>                _classification_part;
            //! Map between each region index in scanning order of ground_truth and its RegionClassificationTypes
            std::vector<std::vector<RegionClassificationTypes> >    _classification_gt;
            //! Mapping between the regions in partition to those in ground_truth
            std::map<uint32,uint32>                         _mapping_part;
            //! Mapping between the regions in ground_truth to those in partition
            std::vector<std::map<uint32,uint32> >             _mapping_gt;
            //! Is each region in the partition a candidate?
            std::vector<uint8>                            _candidate_part;
            //! Is each region in the GT a candidate?
            std::vector<std::vector<uint8> >                _candidate_gt;
            //! Degree of fragmentation for GT regions
            std::vector<std::vector<float64> >                 _recall_gt;
            //! Degree of fragmentation for partition regions
            std::vector<float64>                               _prec_part;

        private:
            //! Number of candidates in partition
            uint32 num_candidates_part;
            //! Number of candidates in GT
            uint32 num_candidates_gt;
            //! Number of objects in the partition
            uint32 num_objects_part;
            //! Number of objects in the GT
            uint32 num_objects_gt;
            //! Number of parts in the partition
            uint32 num_parts_part;
            //! Number of parts in the GT
            uint32 num_parts_gt;
            //! Degree of fragmentation in partition
            float64 num_underseg_part;
            //! Degree of fragmentation in GT
            float64 num_overseg_gt;
        };

	}
}

#endif /* OBJECTS_AND_PARTS_HPP_ */
