// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------

//!
//!  \file derivative.test
//!
//!  \brief Testing of derivative routines
//!
#include <imageplus/math/numeric/derivative.hpp>
#include <imageplus/core.hpp>


BOOST_AUTO_TEST_SUITE ( derivativeSuite );

using namespace imageplus;
using namespace imageplus::math::numeric;
using namespace std;


// y=f[x];
void f(float64 x, float64 *y)
{
	(*y)=x*x; //consider 1 dimension function
}

void f2(Point<2> x, Point<2> *f)
{
	//R²->R² function
	(*f)[0]=x[0]*x[0]-2*x[0]+1;
	(*f)[1]=3*x[1]+x[0];
	
}
void fa(Point<2> x, Point<3> *f)
{
	//R²->R³ function
	(*f)[0]=x[0]*x[0]-2*x[0]+1;
	(*f)[1]=3*x[1]+x[0];
	(*f)[2]=x[1]*x[0];
}
void fb(Point<2> x, Point<2> *f)
{
    //R²->R² (stupid) function
    (*f)[0]=x[0]*x[0]-4;
    (*f)[1]=x[1]*x[1]-4;
}
void dfb(Point<2> x, Point<2> *f, MultiArray<float64,2> *df)
{
    fb(x,f);
    (*df)=fd_jacobian(x,(*f),fb);
}

BOOST_AUTO_TEST_CASE ( derivativeMethod )
{
	MultiArray<float64,1> x(10);
	MultiArray<float64,1> dx;
	//MultiArray<float64,1> fvec(10);
	
	//MultiArray 1D function derivative
	for (uint64 i=0; i<10; i++) 
	{
		x[i]=i;
		//f(x[i],fvec.data()+i);
	}
	
	dx=derivative(x, f); 
	
	//check samples of x² derivative 
	BOOST_CHECK_EQUAL(static_cast<int64>(dx[0]),0);
	BOOST_CHECK_EQUAL(static_cast<int64>(dx[1]),2);
	BOOST_CHECK_EQUAL(static_cast<int64>(dx[2]),4);
	BOOST_CHECK_EQUAL(static_cast<int64>(dx[4]),8);
}

BOOST_AUTO_TEST_CASE ( derivative_symmetric_jacobian )
{
    //Point2D forward difference jacobian
	Point2D r, func; //r=(x,y) and func=Fxy(x,y) at a single point
	MultiArray<float64,2> jcb(2,2);
	r[0]=2; //x=2
	r[1]=1; //y=1
	f2(r,&func);
	
	jcb=fd_jacobian(r,func, f2);
	
	//Point2D jacobian of f(x²-2x +1, 3y+x) at x=2, y=1;
	BOOST_CHECK_EQUAL(static_cast<int64>(jcb[0][0]+0.5),2);
	BOOST_CHECK_EQUAL(static_cast<int64>(jcb[1][0]+0.5),0);
	BOOST_CHECK_EQUAL(static_cast<int64>(jcb[0][1]+0.5),1);
	BOOST_CHECK_EQUAL(static_cast<int64>(jcb[1][1]+0.5),3);
}
BOOST_AUTO_TEST_CASE ( derivative_asymmetric_jacobian )
{
	//Assymetric forward difference jacobian
    Point2D r;
    r[0]=2; //x=2
    r[1]=1; //y=1
	Point3D func3; 
	MultiArray<float64,2> jcb3(3,2); //R²->R³ declaration of m(3,2)

	fa(r,&func3);
	
	jcb3=fd_jacobian(r,func3, fa);
	
	//R²->R³ jacobian of f(x²-2x +1, 3y+x, xy) at x=2, y=1 ;
	BOOST_CHECK_EQUAL(static_cast<int64>(jcb3[0][0]+0.5),2);
	BOOST_CHECK_EQUAL(static_cast<int64>(jcb3[0][1]+0.5),1);
	BOOST_CHECK_EQUAL(static_cast<int64>(jcb3[1][0]+0.5),0);
	BOOST_CHECK_EQUAL(static_cast<int64>(jcb3[1][1]+0.5),3);
	BOOST_CHECK_EQUAL(static_cast<int64>(jcb3[0][2]+0.5),1);
	BOOST_CHECK_EQUAL(static_cast<int64>(jcb3[1][2]+0.5),2);
}

BOOST_AUTO_TEST_CASE ( derivative_newton_rhapson )
{
    Point2D initial;
    Point<2> root(initial);
    
    initial[0]=4; //Initial guess
    initial[1]=3; //Initial guess
    
    root=newton_rhapson(5, initial, 0.0001,0.0001,dfb);
    
    BOOST_CHECK_EQUAL(static_cast<int64>(root[0]), 2);
    BOOST_CHECK_EQUAL(static_cast<int64>(root[1]), 2);

}

BOOST_AUTO_TEST_SUITE_END ();
