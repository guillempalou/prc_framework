// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------

//!
//!  \file portablefloat.hpp
//!
//!  Class for writing floats in a protable manner
//!

#ifndef IMAGEPLUS_IO_PORTABLEFLOAT_HPP
#define IMAGEPLUS_IO_PORTABLEFLOAT_HPP

#include <imageplus/core.hpp>

namespace imageplus
{
    namespace io
    {
        //!
        //! \brief class for writing floats into disk
        //!
        //! \author Javier Ruiz Hidalgo <j.ruiz@upc.edu>
        //!
        //! \date 22-4-2008
        //!
        //! Code extracted from http://stevehollasch.com/cgindex/coding/portfloat.html
        //!
        //! Portable Encoding of Floating-Point Values by Jens Moeller, comp.lang.c, 24 May 1994
        //! 
        //! In de.comp.lang.c there was recently a thread about storing doubles in a machine independent way; the usual solution (converting to a string via atof or a similar function) results in a loss in accuracy, much need of storage, and, furthermore, takes much time. As it happend, I was currently working on this problem when I found the initial request of Steffani at Karlsruhe Univerity in the article. I think this issue is interesting not only in Germany, and so I decided to post this message to comp.lang.c.
        //!
        //! At first we have to ask why the usual convertion via atof results in losses of accurracy. The reason is that the reals are converted from a (usually used) binary representation to a decimal one. But if you, for example, consider the value 0.1, you perceive that this number cannot be exactly represented as a binary value. As a consequence, dividing a real value by 10 will often cause the result to be rounded, but something like that is always done by atof when converting a real to its decimal string representation.
        //!
        //! A much better solution in my eyes is to convert the given number into its representation to a basis of a power of 2; my choice is 256, which allows to store one digit in exactly one byte. The convertion can be performed without any losses in accurracy regarded that the underlying representation of floats is a binary one. (Of course, if floating points are represented by BCD digits, its exactly the wrong thing we do.)
        //!
        //! The function Norm256 first splits the real into its sign, the mantissa and the exponent; note that the exponent is to the basis 256. The mantissa is normalized, i. e. lies within the range 1.0 and 256.0 exclusively. The value 0.0 is the only exception; this value yields a mantissa of 0.0.
        //! 
        //! In a second step, the function EncodeReal encodes the sign, the exponent and the mantissa separately. The first byte of the code contains the sign in the most siginificant bit and the total length of the coded number. As a consequence, the mantissa may use up to 124 * 8 bits for its representation. The exponent is coded in one or two bytes; the most significant bit of the second byte of code informs about which format is used. The one byte format uses a bias of 64; the two byte format a bias of 16383. The mantissa is coded a single byte per loop; at most sizeof (double) bytes may be taken to code the mantissa since further bytes will never contain any reasonable information. However, the loop will in most cases stop because the mantissa becomes 0.0. The function returns the number of bytes needed for the coded value. The range of reals converted in this way is approximately -2^130904 to +2^130904.
        //!
        //! The function DecodeReal is used to decode a real that was perhaps coded on a different machine. The result is the decoded number. If the value does not fit in the real representation of the current machine, errno is set to ERANGE and the result is HUGE_VAL or -HUGE_VAL in the case of an overflow or 0.0 in the case of an underflow.
        //! 
        //! The function Init must be called before any conversation is performed; it mainly computes the numbers 256^(2^i) and 1/256^(2^i), which are used within all other routines.
        //! 
        //! Experiments have shown that reals are normally coded and decoded without any losses of accurracy. The code is relatively compact; at most three additional bytes are generated in comparison to the underlying representation of the C compiler. Very often, the code can be guaranteed to require only two additional bytes: the IEEE standard format for single precision can always be coded in six bytes, the IEEE standard format for extended precision in only twelve.
        //! 
        //! Maybe the code above was able to help someone. I know that some statements could be rewritten using bit manipulations, so dont complain about that. The code does not use these or other special language facilities of C to allow a convinient translation into other languages.
        //! P.S. Does anyone know the difference between the constants HUGE_VAL defined within math.h and DBL_MAX declared in float.h? The ANSI standard seems to require both to be defined (as does the code above). 
        //! 
        class PortableFloat
        {
            public:
             
                //!
                //! \brief Constructor
                //!
                PortableFloat();

                //!
                //! \brief encodes a float64 into 11 bytes
                //!
                //! \param[in]    f : float to encode
                //! \param[out] buf : buffer where float will be written (at most 11 bytes are needed)
                //
                //! \return number of bytes written
                //!
                uint64 encode(float64 f, uint8 *buf);

                //!
                //! \brief dencodes a float64 from 11 bytes
                //!
                //! \param[in] buf : buffer where float is stored
                //
                //! \return decoded float64
                //!
                float64 decode(uint8 *buf) throw (ImagePlusError);

            private:

                //! \brief maximum exp
                static const uint32 MAX_EXP256  = 16383;

                //! \brief length of vectors
                static const uint32 LD_MAX_EXP256 = 14;

                //! \brief Pow256 [i] == pow (256, pow (2, i + 1))
                float64 _Pow256[LD_MAX_EXP256];         

                //! \brief OneOverPow256 [i] == 1.0 / Pow256 [i]
                float64 _OneOverPow256[LD_MAX_EXP256];  

                //! \brief  SQR (Pow256 [MaxPow256Index]) > DBL_MAX                
                uint32 _MaxPow256Index;

                
                //! \brief Mantissa and exponent of maximum float64 
                float64 _MaxMantissa;

                //! \brief Exponent of maximum float64
                int32 _MaxExp; 

                //!
                //! \brief check if value is odd
                //!
                //! \param[in] x : value to check
                //!
                //! \return true for odd value
                IMAGEPLUS_INLINE bool _floatodd(int32 x)
                {
                    return ( (uint32) (x) % 2 != 0 );
                }
                
                //!
                //! \brief normalize float64
                //!
                //! \param[in]         Real : float to normalize
                //! \param[out]     SignOut : Returns sign
                //! \param[out] MantissaOut : returns mantissa
                //! \param[out]      ExpOut : returns exponent
                //!
                void _Norm256Float64 (float64 Real,
                                      int16 *SignOut,
                                      float64 *MantissaOut,
                                      int32 *ExpOut);
        };
    } // namespace io
} //namespace imageplus

#endif
