// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------

/*!
 * \file ortho_basis_codec.hpp
 *
 * Orthonormal basis texture codec
 */

#ifndef IMAGEPLUS_CODING_TEXTURE_ORTHO_BASIS_CODEC_HPP
#define IMAGEPLUS_CODING_TEXTURE_ORTHO_BASIS_CODEC_HPP

#include <imageplus/core.hpp>
#include <imageplus/coding.hpp>
#include <imageplus/coding/texture/texture_codec.hpp>
#include <imageplus/coding/texture/texture_types.hpp>
#include <imageplus/compress/arithmetic_codec.hpp>

namespace imageplus
{
namespace coding
{
namespace texture
{
    //!
    //! \brief Region-based texture coding using decomposition with a orthogonal basis
    //!
    //! This is a region-based encoder. It uses a set of (order+1)^2 coefficients per
    //! each image region (defined in label). The coefficients can be quantized independently
    //! for each region. Quantized coefficients are stored using a maximum of 11 bits (Q=1). \n
    //! The resulting coefficients are stored in a 3D MultiArray where coeffs[chan][reg][c] returns the
    //! \f$c_{th}\f$ coefficients of region reg in color channel chan. Region labels *should* be consecutive, otherwise
    //! some values of the MultiArray won't be filled.
    //!
    class OrthoBasisCodec : public TextureCodec<OrthoBasisCodec>
    {
    public:
        /*!
         * Type of basis functions
         */
        enum Model
        {
            POL_ORT, //!< ???
            COS_ORT  //!< ???
        };

        //!
        //! \brief Default constructor, and constructor by parameters
        //!
        //! \param[in] order           : Order of the basis function
        //! \param[in] ac_model        : Type of arithmetic coding (0: none, 1: 1 unique model for all coeffs, 2: 1 model for each coeff position)
        //! \param[in] gop_size        : GoP size, used to reset AC models
        //! \param[in] q               : Quantization value for all regions. Accepted values are 1-10 (1: 11 bits ... 4: 8 bits ... 10: 2 bits per coefficient)
        //! \param[in] model           : Model of basis functions (POL_ORT or COS_ORT)
        //! \param[in] frame           : Encoding mode --> FRAME_INTRA or FRAME_INTER coding. At the moment, only FRAME_INTRA is supported
        //! \param[in] min_size_region : Minimum size of regions to be considered for encoding. If size < _min_size_region, regions are coded using its mean value.
        //! \param[in] llinda          : Small value. Use 0.05
        //!
        OrthoBasisCodec (int64           order           = 0,
                         uint8           ac_model        = 2,
                         uint64          gop_size        = 12,
                         uint8           q               = 4,
                         Model           model           = COS_ORT,
                         FrameType       frame           = INTRA_FRAME,
                         uint64          min_size_region = 10,
                         float64         llinda          = 0.05);

        //!
        //! \todo are we sure we can use type image_type in images or only uint8?
        //!
        //! \brief Overloading of method encoding() for an Image object
        //!
        //! \warning: Never use this method. Use encode() instead.
        //!
        //! \tparam image_type     : Type of the data
        //! \tparam num_channels   : Number of color channels
        //! \tparam partition_type : Data type for the partition image
        //!
        //! \param[in]  ori           : Image object to be encoded
        //! \param[in]  label         : Partition of the image
        //! \param[in]  qmap          : MultiArray defining the quantizer value for each region. Accepted values are 1-10 (1: 11 bits ... 4: 8 bits ... 10: 2 bits per coefficient)
        //! \param[out] coeffs        : Coded coefficients in a 3D multiarray, coeffs[chan][reg][c] returns the cth coefficient for region reg anc color channel chan
        //!
        //! \return Reconstructed (decoded) image
        //!
        template< typename    image_type,
                  std::size_t num_channels,
                  typename    partition_type >
        Image<image_type,num_channels> encoding(const Image<image_type,num_channels>& ori,
                                                const ImagePartition<partition_type>& label,
                                                const MultiArray<uint8,1>&            qmap,
                                                QTextureCoeffs<num_channels>&         coeffs ) const throw (ImagePlusError);

        //!
        //! \brief Decoding of orthobasis coefficients
        //!
        //! \tparam image_type     : Type of the data
        //! \tparam num_channels   : Number of color channels
        //! \tparam partition_type : Data type for the partition image
        //!
        //! \param[in]   label        : Partition of image
        //! \param[in]  coeffs        : Coded coefficients in a 3D multiarray, coeffs[chan][reg][c] with the cth coefficient for region reg anc color channel chan
        //! \param[out] rec           : Reconstructed image
        //!
        //! \return Decoded image
        //!
        template< typename    image_type,
                  std::size_t num_channels,
                  typename    partition_type >
        void decoding(const ImagePartition<partition_type>& label,
                      const QTextureCoeffs<num_channels>&   coeffs,
                      Image<image_type,num_channels>&       rec) const throw (ImagePlusError);

        //!
        //! \brief Compress method
        //!
        //! \tparam num_channels   : Number of color channels
        //! \tparam partition_type : Data type for the partition image
        //!
        //! \param[in]  label     : Partition of image
        //! \param[out] coeffs    : Quantized texture coefficients coeffs[reg][chan][c] returns the cth coefficient for region reg anc color channel chan
        //! \param[out] bs        : Bitstream to write data
        //!
        //! \return Size of compressed data (in bits)
        //!
        template<std::size_t num_channels, typename partition_type>
        uint64 compressing(const ImagePartition<partition_type>& label,
                           const QTextureCoeffs<num_channels>&   coeffs,
                           io::WriteBitStream&                   bs ) throw (ImagePlusError);

        //!
        //! \brief Decompress method
        //!
        //! \tparam num_channels   : Number of color channels
        //! \tparam partition_type : Data type for the partition image
        //!
        //! \param[in]  label     : Partition of image
        //! \param[out] coeffs    : Quantized texture coefficients coeffs[reg][chan][c] returns the cth coefficient for region reg anc color channel chan
        //! \param[out] bs        : Bitstream to write data
        //!
        template<std::size_t num_channels, typename partition_type>
        void decompressing(const ImagePartition<partition_type>& label,
                           io::ReadBitStream&                    bs,
                           QTextureCoeffs<num_channels>&         coeffs) throw (ImagePlusError);

    private:

        //! Order of the basis function
        uint64 _order;

        //! Type of AC models
        uint8 _ac_model;

        //! Total number of AC models
        uint8 _ac_num_models;

        //! GoP size
        uint64 _gop_size;

        //! GoP size counter
        uint64 _gop_size_counter;

        //! Min q used (affects alphabet of AC models)
        uint8 _min_q;

        //! Type of basis functions (POL_ORT or COS_ORT)
        //! \see  OrthoBasisModel
        Model _type; // POL_ORT, COS_ORT

        //! Encoding mode --> INTRA_FRAME or INTER_FRAME
        //! \see  FrameType
        FrameType       _frame;

        //! Minimum size of regions to be considered for encoding.
        //! If size < _min_size_region, regions are coded using its mean value.
        const uint64    _min_size_region ;

        //! Small value. Use 0.05
        float64 _llinda;

        //! AC models
        std::vector<compress::Adaptive_Data_Model> _amodels;

        //! Reset AC codec if gop size is reached
        void _reset_amodels_if_needed();

        /*!
         * \returns bits for each coefficient
         *
         * \param[in] q : ???
         */
        uint8 _bits(uint8 q)
        {
            return (uint8)((int64)12 - (int64)q);
        }

    };
} // ns texture
} // ns coding
} // ns imageplus

#endif // IMAGEPLUS_CODING_TEXTURE_ORTHO_BASIS_CODEC_HPP
