/*
 * mumford_shah.cpp
 *
 *  Created on: Mar 7, 2013
 *      Author: gpalou
 */

#include <imageplus/core/image_signal.hpp>
#include <imageplus/core/video_signal.hpp>
#include <imageplus/core/colorspace_converter.hpp>

#include <imageplus/segmentation/partition/partition.hpp>
#include <imageplus/segmentation/partition/hierarchical_region_partition.hpp>
#include <imageplus/segmentation/visualization/false_color.hpp>

#include <imageplus/descriptors/descriptor_manager.hpp>
#include <imageplus/descriptors/color/color_mean.hpp>


#include <imageplus/bpt/energy_minimization/merging_sequence_optimum_pruner.hpp>
#include <imageplus/bpt/energy_minimization/mumford_shah.hpp>

#include <boost/filesystem.hpp>
#include <iomanip>
#include <iostream>

using namespace imageplus;

#define uint64 imageplus::uint64
#define int64 imageplus::int64

typedef ImageSignal<float64,3> 																		ImageType;

typedef ImageType::coord_type																		coord2d;
typedef ImageType::value_type																		rgb_type;

typedef HierarchicalRegion<coord2d>																	Region2D;
typedef segmentation::HierarchicalRegionPartition<Region2D>											BPT;
typedef BPT::PartitionType																			PartitionType;


int main(int argc, char *argv[]) {

	std::string image_path 		= argv[1];
	std::string tree_path 		= argv[2];
	std::string result_path 	= argv[3];

	std::vector<float64> list;

	for (int64 i = 4; i < argc; i++) {
		std::string a = argv[i];
		std::cout << a << " ";
		std::istringstream is(a);
		float64 n;
		is >> n;
		list.push_back(n); //*1000);
	}

	// create the necessary paths
	boost::filesystem::path result_path_p(result_path);
	boost::filesystem::create_directories(result_path_p / "segmentations_ms");
	boost::filesystem::create_directories(result_path_p / "segmentations_pruning");
	boost::filesystem::create_directories(result_path_p / "mean_color");
	boost::filesystem::create_directories(result_path_p / "mean_color_ms");

	std::cout << "Reading tree" << std::endl;
	BPT bpt;
	bpt.load_from_prl(tree_path);

	coord2d sizes = bpt.leaves_partition().sizes();

	ImageType img;
	img.read(image_path);

	ColorSpaceConverter<ImageType> converter;
	converter.convert(img,ColorSpaceLAB);

	descriptors::DescriptorManager manager;

	// estimate flow models (too costly)
	typedef bpt::MumfordShahCost<BPT, ImageType>			 							MumfordShahCostFunction;
	typedef bpt::BinaryPruner<BPT,ImageType,MumfordShahCostFunction>					Pruner;
	typedef bpt::MergingSequenceOptimumPruner<BPT,ImageType,MumfordShahCostFunction>			MSPruner;

	//descriptors::DescriptorManager manager;

	std::set<uint64> regs,ms_regs;

	MumfordShahCostFunction cost_function(manager, bpt.max_label());
	Pruner    pruner(cost_function,false);
	MSPruner  ms_pruner(cost_function,false);
	PartitionType partition(sizes);

	sort(list.begin(), list.end());

	std::ofstream ofs((result_path + "/costs.txt").c_str());

	for (uint64 i = 0; i < list.size(); i++) {

		std::cout << "Approximate pruning with " << list[i] << " regularizer " << std::endl;

		cost_function.set_lambda(0);
		cost_function.set_regularizer(list[i]);

		regs = pruner.find_pruned_regions(bpt, img, bpt.max_label()); //regularizer acts as the number of regions
		ms_regs = ms_pruner.find_pruned_regions(bpt, img, bpt.max_label());

		std::set<uint64> regs = pruner.regions(); //optical_flow_pruner.regions();
		std::set<uint64> msregs = ms_pruner.regions(); //optical_flow_pruner.regions();

		float64 cost = pruner.cost();
		float64 ms_cost = ms_pruner.cost();

		ofs << cost << " " << ms_cost << std::endl;

		descriptors::DescriptorManager manager;
		manager.set_max_number_of_regions(bpt.max_label());
		ImageType mean_color_partition(img.sizes());
		mean_color_partition.set_color_space(ColorSpaceLAB);
		for (std::set<uint64>::iterator r = regs.begin(); r != regs.end(); ++r) {
			ImageType::value_type mean_color = manager.calc_descriptor<descriptors::ColorMean<ImageType> >(img,bpt(*r));
			for (BPT::RegionType::iterator p = bpt(*r).begin(); p != bpt(*r).end(); ++p) {
				partition(*p)(0) = *r;
				mean_color_partition(*p) = mean_color;
			}
		}

		std::ostringstream os; os << i << ".png";

		ImageType segmentation = segmentation::to_false_color<ImageType>(partition);
		segmentation.write((result_path_p / "segmentations_pruning/").string() + os.str());
		converter.convert(mean_color_partition,ColorSpaceRGB);
		mean_color_partition.write((result_path_p / "mean_color/").string() + os.str());

		manager.set_max_number_of_regions(bpt.max_label());

		for (std::set<uint64>::iterator r = msregs.begin(); r != msregs.end(); ++r) {
			ImageType::value_type mean_color = manager.calc_descriptor<descriptors::ColorMean<ImageType> >(img,bpt(*r));
			for (BPT::RegionType::iterator p = bpt(*r).begin(); p != bpt(*r).end(); ++p) {
				partition(*p)(0) = *r;
				mean_color_partition(*p) = mean_color;
			}
		}

		os.str(""); os << i << ".png";

		segmentation = segmentation::to_false_color<ImageType>(partition);
		segmentation.write((result_path_p / "segmentations_ms/").string() + os.str());
		converter.convert(mean_color_partition,ColorSpaceRGB);
		mean_color_partition.write((result_path_p / "mean_color_ms/").string() + os.str());

	}
}
