// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------
//!
//!  \file pf_basic.hpp
//!
//!  Interface for the ParticleFilter and the Particle class, a standard and the most simple way to implement a particle filter for
//!  any desired application.
//!

#ifndef IMAGEPLUS_PARTICLEFILTERS_PF_BASIC_HPP
#define IMAGEPLUS_PARTICLEFILTERS_PF_BASIC_HPP

#include <imageplus/core.hpp>
#include<imageplus/math/statistics/random_generators.hpp>

namespace imageplus 
{
    namespace particlefilters 
    {
        //!
        //! \brief Base class of the ParticleFilter
        //!
        //! For a more detailed explanation about particlefilters refer to <a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.16.3641">
        //! A tutorial on particle filters for online nonlinear/non-Gaussian Bayesian tracking</a>.
        //!
	    //! This class is used as a base class for particlefilters. \n
	    //! It can be instantiated if the Particle class is correctly defined.
        //!
        //! See the \ref particlefilter_example.cpp to see how to use this class.
        //!
    	//! If you want to create your own filter, you can inherit from this and overload all the virtaul functions: \n
        //! init_particles(), resample(), propagate(), evaluate(), normalize(), estimate().
        //!
    	//! This basic filter just call to the Particle.init_particle(), propagate() and evaluate() functions implemented 
        //! by your particle. 
    	//!
        //! This BasicParticleFilter uses a MEAN criteria for the estimation of the OutputData obtained from the filter use.
        //! 3 operators must be defined in the Particle for the estimate to work correctly (+, * and =).
	    //!
        //! \tparam ParticleType defines the class of the Particle used in the ParticleFilter current implementation.
        //!
        //! \author Ramon Llorca Queralt <allorca@gps.tsc.upc.edu>
        //! \date 25-7-2008
        //!
	    template < class ParticleType >
	    class ParticleFilter
	    {    	
	        public:
	
		    	// Types defined in particle
		    	typedef typename ParticleType::init_data_type init_data_type; //!< Defines the initialization data type specified by the particle type of the filter
		    	typedef typename ParticleType::input_data_type input_data_type; //!< Defines the input data type specified by the particle type of the filter
		    	
	            //!
	            //! \brief Default constructor, only number of particles. <br>
	        	//! Particles initialized with default weight.
		    	//!
	        	//! \param[in] num_particles : Number of particles that the particlefilter has
	            //!
	            ParticleFilter( const uint64 num_particles );
	             
	            //!
	            //! \brief Default Destructor
	            //!
	            virtual ~ParticleFilter() {}
	
	            //!
	            //! \brief Initialization of all particles. <br>
	            //! User should define the initial state of particles here.
	            //! Particles will be initialized with the InitDataType defined in the application.
	            //! Particles are guaranteed to already be created with default weight when calling this function.
	            //!
	            //! \param[in] initialization_data : The initialization data type that particles use to initialize
	            //!
	            void init_particles( const init_data_type& initialization_data );
	           
	            //!
	            //! \brief Prints Particles information for debug
	            //!	            
	            void print_particles();
	            
	            //!
	            //! \brief Describes the way the particle filter works. <br>
	            //! Function for debugging particle filter.
	            //!
	            //! \param[in] input_data : The input data type specified by the particle type of the filter
	            //!
	            void filter_debug( const input_data_type& input_data );
	            
	            //!
	            //! \brief Describes the way the particle filter works.
	            //!
	            //! \param[in] input_data : The input data type specified by the particle type of the filter
	            //!	            
	            virtual void filter( const input_data_type& input_data );
	            
	            //!
	            //! \brief Estimates the value that the particle filter desires to estimate <br>
	            //! In this function we obtain the results of the particle filter iteration.
	            //! Depending of the particle filter, the data of interest for estimation varies, so 
	            //! the data obtained depends directly of the ParticleType.
	            //! The default implementation returns the estimated Particle using the MEAN Criteria.
	            //! Operators +, * and = must be defined in the ParticleType as they are being used in the mean.
	            //! The estimation criteria can be modified or redefined in future ParticleFilters developed if desired.
	            //!
	            //! \return A ParticleType with the estimated data
	            //!
	            virtual ParticleType estimate();	            
	            
	            //!
	            //! \brief Return the survival rate of the particle filter <br>
	            //!
	            //! \return Value of the survival rate.
	            //!
	            float64 survival_rate() const;
	            
	            //!
	            //! \brief Return the number of particles in the particle filter.
	            //!
	            //! \return Value of number of particles.
	            //!
	            uint64 number_of_particles() const;
	            
	            //!
	            //! \brief Return the default weight for each particle.
	            //!
	            //! \return Value of the default weight for each particle.
	            //!
	            float64 default_particle_weight() const;
	                        
	            //!
	            //! \brief Return the particle vector.
	            //!
	            //! \return The entire vector of particles of the particle filter
	            //!
	            std::vector< ParticleType >& particles();
	            
	            //!
	            //! \brief Return the particle vector.
	            //!
	            //! \return The entire vector of particles of the particle filter
	            //!
	            const std::vector< ParticleType > particles() const;
	            
	       // protected:
	        	
	            //!
	            //! \brief Propagate of all particles. <br>
	            //! Method to be implemented for each particle filter subclass.
	        	//! Each particle filter subclass must specify its propagation scheme.
	        	//!
	            virtual void propagate();
	            
	            //!
	            //! \brief Evaluate weights of all particles in the particle filter.
	            //!
	            //! \param[in] input_data : The input data used to calculate the particles weight
	            //!
	            //! \return Value of total weights of particles
	            //!
	            virtual float64 evaluate( const input_data_type& input_data );
	            
	            //!
	            //! \brief Normalize weights of all particles in the particle filter 
	            //! so all weights are equal to 1. <br>
	            //! It also calculates the survival rate of the particle filter.
	            //!
	            //! \param[in] total_weight : The total weight of all the particles.
	            //!
	            void normalize( const float64 total_weight );
	            
	            //!
	            //! \brief Resamples all particles depending on their weight. <br>
	            //! Typical resample algorithm implemented here.
	            //! Overwrite the function if a different behaviour is desired.
	            //!
	            virtual void resample();           
	            
	        private:
	        	
	           	float64 _survival_rate; //!< Stores the survival rate
	           	std::vector< ParticleType > _particles; //!< Vector to store all the particles in the particle filter
	        	float64 _default_particle_weight; //!< Stores the default weight for each particle
	    };
	    

        //!
        //! \brief Base class of any particle of any ParticleFilter
        //!
	    //! - Abstract class: 
	    //!   - Used as a base class for all particles 
	    //!   - <b> Not use this class directly </b>, but create your own Particle inheriting from it (see \ref particlefilter_example.cpp)
	    //! - It only defines the methods refering to its weight.
	    //!
	    //! \tparam Derived defines the class of the Particle used in the Particle and necessary for the operators definition.
	    //! \tparam _input_data_type defines the data used for the evaluation function, it must be defined in the Particle used.
	    //! \tparam _init_data_type defines the parameters that are initialized for each Particle, it must be defined in the Particle used.
    	//! The _input_data_type and _init_data_type should be defined in the Particle and specified in its constructor.
	    //!
	    //!
	    //! Design rationale:
	    //!
	    //!   Base class Particle is a class template based on the Filter class of ImagePlus core. 
	    //!   It has a template of the derived class because it is one way to implement virtual function templates in C++. 
	    //!   Check the wikipedia <a href="http://en.wikipedia.org/wiki/Curiously_recurring_template_pattern">article</a> for
	    //!   a more detailed explanation about this solution.
	    //!
        //! \author Ramon Llorca Queralt <rllorca@gps.tsc.upc.edu>
        //! \date 25-7-2008
        //!
	    template < class Derived, typename _input_data_type, typename _init_data_type >
	    class Particle
	    {
	    	public:
	    		
	    		typedef _init_data_type init_data_type;   //!< Defines the initialization data type specified by the particle type of the filter
	    		typedef _input_data_type input_data_type; //!< Defines the input data type specified by the particle type of the filter
	    			
	            //!
	            //! \brief Default constructor, only number of particles
	    		//!
	        	//! \param[in] weight : Weight with which particles are created
	            //!
	            Particle( const float64 weight = 0 );
	            
	            //!
	            //! \brief Default Destructor
	            //!
	            virtual ~Particle() {}
	            
	            //!
	            //! \brief Get weight of each particle
	            //!
	            //! \return Value of the weight of the current particle
	            //!
	            const float64& weight() const;
	            //!
	            //! \brief Full access to the particle's weight
	            //!
	            //! \return Value of the weight of the current particle
	            //!
	            float64 & weight();
	            //!
	            //! \brief Set weight of each particle
	            //!
	            //! \param[in] weight : Weight which particle is set to
	            //!
	            void weight( const float64 weight );

	            //!
	            //! \brief Const access to the particle's random generator
	            //!
	            //! \return Random generator
	            //!
	            boost::mt19937* rng() const  {return _rng;};

	            //!
	            //! \brief Full access to the particle's random generator
	            //!
	            //! \return Random generator
	            //!
	            boost::mt19937* & rng() {return _rng;};
	            
	            //!
	            //! \brief Init_particle of each particle <br>
	            //! Method to be implemented for each particle subclass.
	            //! It depends of the InitializationDataType.
	            //!
	            //! \param[in] initialization_data : The initialization data type that a particle use to initialize
	            //!
	            virtual void init_particle( const init_data_type& initialization_data ) = 0;
	            
	            //!
	            //! \brief Propagate of each particle <br>
	            //! Method to be implemented for each particle subclass.
	            //!
	            virtual void propagate( ) = 0;
	                                   
	            //!
	            //! \brief Evaluate of each particle <br>
	            //! Method to be implemented for each particle subclass.
	            //! It depends on the InputDataType.
	            //!
	            //! \param[in] input_data : The input data used to calculate the particles weight
	            //!
	            virtual void evaluate( const input_data_type& input_data ) = 0;         
	            
	            //!
	            //! \brief operator +
	            //! This function must be overwrite in the Derived class and adapted for its parameters.
	            //! In this basic Particle it returns the param[in] weight.
	            //!
	            //! \param[in] other_particle : The Particle added to the current one
	            //!
	            //! \return this
	            //!
	            virtual Derived operator + ( const Derived& other_particle ) const;
	            	            
	            //!
	            //! \brief operator *
	            //! This function must be overwrite in the Derived class and adapted for its parameters.
	            //! In this basic Particle it modifies the particle's weight.
	            //!
	            //! \param[in] weight : Used to multiply the Particle's parameters
	            //!
	            //! \return this
	            //!
	            virtual Derived operator * ( float64 weight ) const;
	            
	            //!
	            //! \brief operator =
	            //! This function must not be overwrite in the Derived class.
	            //! Modify the copy function instead.
	            //!
	            //! \param[in] other_particle : The Particle copied to the current one
	            //!
	            //! \return this
	            //!
	            const Derived& operator = ( const Derived& other_particle );
	            
	            //!
	            //! \brief Copies the parameters of one particle to another <br>
	            //! Used in operator =.
	            //! Modify the copy function in the class Derived.
	            //!
	            //! \param[in] other_particle : The Particle copied to the current one
	            //!
	            virtual void copy( const Derived& other_particle );
	            
	        private:
	        	   	
	        	float64 _weight; //!< Stores the weight for each particle  		
	        	boost::mt19937* _rng;//!< random genarator  
	    };

	    //! \brief Logical functor for particle comparison based on the weight comparison
	    template < class ParticleType >
		struct less_particle : public std::binary_function< ParticleType, ParticleType, bool > 
		{
		    /*!
		     * the functor operator
		     *
		     * \param[in] x : first particle to compare
		     * \param[in] y : second particle to compare
		     *
		     * \return true if weight of y is bigger than the weight of x, false otherwise
		     */
			bool operator()( const ParticleType& x, const ParticleType& y)
			{ 
				if (x.weight()<y.weight()) return true;
				return false;
			}
		};
    }
}

	    

//
// ParticleFilter methods implementation
//
namespace imageplus 
{
    namespace particlefilters 
    {
	    template < class ParticleType >
	    ParticleFilter< ParticleType >::ParticleFilter( const uint64 num_particles )
            : _survival_rate( 1.0 ) 
        {
        	assert( 0 < num_particles );
        	
        	_default_particle_weight = 1.0 / num_particles;
        	
            _particles.resize( num_particles, ParticleType( _default_particle_weight ) );
        }
	    
	    template < class ParticleType >
        void ParticleFilter< ParticleType >::init_particles( const init_data_type& initialization_data )
        {	        	
        	for ( uint64 i = 0; i < number_of_particles(); i++ )
        	{
        		_particles[ i ].init_particle( initialization_data );
        	}
        }
	    
	    template < class ParticleType >
        void ParticleFilter< ParticleType >::print_particles()
        {
        	for ( uint64 i = 0; i < number_of_particles(); i++ )
        	{
        		std::cout << "Particle[" << i << "] " << _particles[i] << std::endl;
        	}
        	std::cout << std::endl;
        }
	    
	    template < class ParticleType >
	    void ParticleFilter< ParticleType >::filter_debug( const input_data_type& input_data )
        {	            	
        	resample();

        	std::cout << " Resample ... \n" << std::endl;
        	
        	print_particles();
        	
        	propagate();
        	
        	std::cout << " Propagate ... \n" << std::endl;
        	
        	print_particles();
        	
        	float64 total_weight = evaluate( input_data );
        	
        	std::cout << " Evaluate ... \n" << std::endl;
        	
        	print_particles();
        	        	
        	normalize( total_weight );
        	
        	std::cout << " Normalize & TotalWeight = " << total_weight << "\n" << std::endl;
        	
        	print_particles();
        }
	    
	    template < class ParticleType >
        void ParticleFilter< ParticleType >::filter( const input_data_type& input_data )
        {	            	
        	resample();  	
        	
        	propagate();
    	
        	float64 total_weight = evaluate( input_data );
        	        	
        	normalize( total_weight );    	
        }
	    
	    template < class ParticleType >
	    ParticleType ParticleFilter< ParticleType >::estimate()
        {
        	ParticleType particle_tmp( 0 );
        	
        	for ( uint64 i = 0; i < number_of_particles(); i++ )
        	{
        		particle_tmp = particle_tmp + _particles[ i ] * _particles[ i ].weight(); 
        	}
        	
        	return particle_tmp;
        }
	    
	    template < class ParticleType >
        float64 ParticleFilter< ParticleType >::survival_rate() const
     	{
     	  	return _survival_rate;
     	}
	    
	    template < class ParticleType >
        uint64 ParticleFilter< ParticleType >::number_of_particles() const
        {
        	return _particles.size();
        }
	    
	    template < class ParticleType >
        float64 ParticleFilter< ParticleType >::default_particle_weight() const
     	{
     	  	return _default_particle_weight;
     	}
        
	    template < class ParticleType >
        std::vector< ParticleType >& ParticleFilter< ParticleType >::particles() 
     	{
     	  	return _particles;
     	}
	    
	    template < class ParticleType >
        const std::vector< ParticleType > ParticleFilter< ParticleType >::particles() const 
     	{
     	  	return _particles;
     	}
	    
	    template < class ParticleType >
        void ParticleFilter< ParticleType >::propagate()
        {
        	for ( uint64 i = 0; i < number_of_particles(); i++ )
        	{
        		_particles[ i ].propagate();
        	}
        }
	    
	    template < class ParticleType >
	    float64 ParticleFilter< ParticleType >::evaluate( const input_data_type& input_data ) 
        {
        	float64 total_weight = 0.0;
        	
        	for ( uint64 i = 0; i < number_of_particles(); i++ )
        	{
        		ParticleType& current_particle = _particles[ i ];
        		
        		current_particle.evaluate( input_data );
        		
        		total_weight += current_particle.weight();
        	}
        	
        	return total_weight;	
        }
	    
	    template < class ParticleType >
	    void ParticleFilter< ParticleType >::normalize( const float64 total_weight ) 
        {
        	ASSERT( 0 <= total_weight, "Total Weight is equal to 0\n" );

        	if ( total_weight == 0.0 )
        	{
        		_survival_rate = 0.0;
        		return; // All weights are 0, no need for normalize
        	}
        	
        	float64 cumulative_weight = 0;
        	
//        	for ( uint64 i = 0; i < number_of_particles(); i++ )
//        	{
//        		ParticleType& current_particle = _particles[ i ];
//        		
//        		float64 normalized_weight = current_particle.weight() / total_weight;
//        		
//        		current_particle.weight( normalized_weight );
//        		
//        		cumulative_weight += normalized_weight * normalized_weight;
//        	}	    
        	
        	for (uint64 i=0; i<number_of_particles();++i)
        	{
        		_particles[i].weight()/=total_weight;
        		cumulative_weight += _particles[i].weight()*_particles[i].weight();
        	}
        	
        	float64 efficiency = 1.0 / cumulative_weight;
        	
        	_survival_rate = efficiency / number_of_particles();
        }
	    
	    template < class ParticleType >
	    void ParticleFilter< ParticleType >::resample()
        {
        	std::vector< float64 > accummulated_weight_list( number_of_particles() );
        	    	
        	float64 accumulated_weight = 0;

        	for ( uint64 i = 0; i < number_of_particles(); i++ )
        	{
        		//const ParticleType& current_particle = _particles[ i ];

        		//accumulated_weight += current_particle.weight();
        		accumulated_weight += _particles[i].weight();
        		accummulated_weight_list[ i ] = accumulated_weight;
        	}

        	float64 random_value = static_cast< float64 >( rand() ) / RAND_MAX;
        	float64 random_particle_weight = random_value / number_of_particles();
        	
        	std::vector< ParticleType > particles_work_copy = _particles;
        	
        	uint64 index = 0;
        	for ( uint64 i = 0; i < number_of_particles(); i++ )
        	{
        		float64 expected_accumulated_weight_for_this_particle = i * default_particle_weight();

        		float64 threshold = random_particle_weight + expected_accumulated_weight_for_this_particle;
        		
        		while ( accummulated_weight_list[ index ] < threshold && index < number_of_particles() )
        		{
        			// find the index of a particle that has an acumulative weight greater than the threshold.
        			index++;
        		}
        		
        		if( index == number_of_particles() ) index = number_of_particles() - 1;
        		
        		_particles[ i ] = particles_work_copy[ index ];
        		_particles[ i ].weight( default_particle_weight() );
        	}
        }              
	    
	    // Particle methods implementation   
	    template < class Derived, typename _input_data_type, typename _init_data_type >
	    Particle< Derived, _input_data_type, _init_data_type >::Particle( const float64 weight )
    		: _weight( weight )
    	{}
        
        template < class Derived, typename _input_data_type, typename _init_data_type >
        const float64& Particle< Derived, _input_data_type, _init_data_type >::weight() const
        {
        	return _weight;
        }
        
        template < class Derived, typename _input_data_type, typename _init_data_type >
        float64& Particle< Derived, _input_data_type, _init_data_type >::weight()
        {
        	return _weight;
        }
        
        template < class Derived, typename _input_data_type, typename _init_data_type >
        void Particle< Derived, _input_data_type, _init_data_type >::weight( const float64 weight )
        {
        	ASSERT( 0 <= weight, "Not negative weights permited\n" );
        	
        	_weight = weight;
        }	
        
        template < class Derived, typename _input_data_type, typename _init_data_type >
        Derived Particle< Derived, _input_data_type, _init_data_type >::operator + ( const Derived& other_particle ) const
        {
        	Derived current_particle( 1 );
        	
        	current_particle.weight( other_particle.weight() ); 
        	
        	return current_particle;
        }
        
        template < class Derived, typename _input_data_type, typename _init_data_type >
        Derived Particle< Derived, _input_data_type, _init_data_type >::operator * ( float64 weight ) const
        {	            	
        	Derived current_particle( 1 );
        	
        	current_particle.weight( weight ); //! \todo : Weight = 1 for this case, otherwise it has no sense
        	
        	return current_particle;
        }
        
        template < class Derived, typename _input_data_type, typename _init_data_type >
        const Derived& Particle< Derived, _input_data_type, _init_data_type >::operator = ( const Derived& other_particle )
        {	            	  
        	if ( this != &other_particle )
        	{
        		copy( other_particle );
        	}
                	
        	return other_particle;
        }
        
        template < class Derived, typename _input_data_type, typename _init_data_type >
        void Particle< Derived, _input_data_type, _init_data_type >::copy( const Derived& other_particle ) 
        {
        	_weight = other_particle._weight;            	
        }
	    
    }//namespace particlefilter
}//namespace imageplus

#endif /*PF_BASIC_HPP_*/
