// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------

//!
//!  \file readmultiarray.cpp
//!
//!  Implementation of classes for reading multiarrays from disk
//!

#include <typeinfo>
#include <fstream>

#include <boost/smart_ptr.hpp>

#include <imageplus/compress/rle.hpp>

#include <imageplus/io/readmultiarray.hpp>
#include <imageplus/io/readbitstream.hpp>
#include <imageplus/io/portablefloat.hpp>

using namespace imageplus;
using namespace imageplus::io;

ReadMultiArray::ReadMultiArray( const std::string& filename )
        : _filename( filename )
{
}

ReadMultiArray::ReadMultiArray()
{
}

ReadMultiArray::~ReadMultiArray()
{
}

void ReadMultiArray::open( const std::string& filename )
{
    _filename = filename;
}

template<int D>
void ReadMultiArray::_read_multiarray(std::ifstream& fp,
                                      DataType dt,
                                      CompressType compress,
                                      std::vector<uint64>& dims,
                                      MultiArray<uint8,D>& m ) const throw (ImagePlusFileNotFound, ImagePlusError)
{
    // check data type
    if (dt != UINT8)
    {
        throw ImagePlusError("Datatype is not uint8 in file");
    }

    // check number of dimensions
    if (dims.size() != D)
    {
        throw ImagePlusError("Dimensions in the file do not correspond to templated dimensions");
    }


    MultiArray<uint8,D> mm(dims);

    switch (compress)
    {

        case BYTE_RUNLENGTH:
        {
            // read data
            uint64 csize;
            fp.read((char*)&csize,sizeof(csize));

            boost::shared_array<uint8> cdata = boost::shared_array<uint8>(new uint8[csize]);
            fp.read(reinterpret_cast<char*>(cdata.get()),csize);

            // uncompress
            imageplus::compress::Rle rle;
            rle.uncompress(cdata.get(),
                           reinterpret_cast<uint8 *>(mm.data()),
                           csize);
        }
        break;
        
        case NONE:
        {
            // read data
            uint64 csize;
            fp.read((char*)&csize,sizeof(csize));
            fp.read((char*)mm.data(),csize);
        }
        break;
                
        default:
        {
            throw ImagePlusError("Unknown compress type");
            break;
        }
    }

    // finished
    fp.close();

    // Copy data back to multiarray
    m = mm;
}


template<int D>
void ReadMultiArray::_read_multiarray(std::ifstream& fp,
                                      DataType dt,
                                      CompressType compress,
                                      std::vector<uint64>& dims,
                                      MultiArray<uint32,D>& m ) const throw (ImagePlusFileNotFound, ImagePlusError)
{
    // check data type
    if (dt != UINT32)
    {
        throw ImagePlusError("Datatype is not uint32 in file");
    }

    // check number of dimensions
    if (dims.size() != D)
    {
        throw ImagePlusError("Dimensions in the file do not correspond to templated dimensions");
    }


    MultiArray<uint32,D> mm(dims);

    switch (compress)
    {
        case BYTE_RUNLENGTH:
        {
            // read data
            uint64 csize;
            fp.read((char*)&csize,sizeof(csize));

            boost::shared_array<uint8> cdata = boost::shared_array<uint8>(new uint8[csize]);
            fp.read(reinterpret_cast<char*>(cdata.get()),csize);

            // uncompress
            imageplus::compress::Rle rle;
            rle.uncompress(cdata.get(),
                           reinterpret_cast<uint8 *>(mm.data()),
                           csize);
        }
        break;
        case PARTITION_RUNLENGTH:
        {
            uint32 *pointer = mm.data();
            
            // Read  num_bits
            uint8 num_bits;
            fp.read((char*)&num_bits,  1);
            
            // Close the file to read it in binary
            fp.close();
            
            ReadBitStream rbs(_filename.c_str());
            
            // Skip the header
            rbs.seekg(112+64*D);         
                
            std::size_t total_elem = mm.num_elements();
            std::size_t num_read_elem = 0;
            uint64 read_bits = 0;
            uint32 max_label = 0;
            uint32 current_label;
            uint16 current_length;  // It should be uint8 but we had problems with GCC 4.3
            std::size_t  width = mm.dims(0);
            
            while(num_read_elem < total_elem)
            {
                // Label casuistics
                read_bits = rbs.read(1);
                
                if(read_bits == 0) // "Up" value
                {
                    current_label = *(pointer - width); 
                }
                else
                {
                    read_bits = rbs.read(1);
                    
                    if(read_bits == 0) // "Up-one-right" value
                    {
                        const uint32 *up_value = pointer - width;
                        uint32 *up_right_value = pointer - width + 1;
                        while(*up_value == *up_right_value)
                        {
                            up_right_value++;
                        }
                        current_label = *up_right_value; 
                    }
                    else
                    {
                        read_bits = rbs.read(1);
                        
                        if(read_bits == 0) // "Max+1" value
                        {
                            max_label = max_label + 1;
                            current_label = max_label;
                        }
                        else
                        {
                            read_bits = rbs.read(num_bits);
                            current_label = (uint32)read_bits;
                            if(current_label>max_label)
                            {
                                max_label = current_label;
                            }
                        }
                    }
                }
                
                //Length casuistics
                read_bits = rbs.read(1);
                
                if(read_bits == 1) // 8 bits length
                {
                    read_bits = rbs.read(8);
                    current_length = static_cast<uint8>(read_bits); 
                }
                else
                {
                    read_bits = rbs.read(2);
                    current_length = static_cast<uint8>(read_bits) + 1;
                }
                
                for(uint8 ii=0; ii<current_length; ii++)
                {
                    *pointer++ = current_label;
                }
                
                num_read_elem += current_length;
            }
            
        }
        break;
        default:
        {
            throw ImagePlusError("Unknown compress type");
            break;
        }
    }

    // finished
    fp.close();

    // Copy data back to multiarray
    m = mm;
}

template<int D>
void ReadMultiArray::_read_multiarray(std::ifstream& fp,
                                      DataType dt,
                                      CompressType compress,
                                      std::vector<uint64>& dims,
                                      MultiArray<int64,D>& m ) const throw (ImagePlusFileNotFound, ImagePlusError)
{
    // check data type
    if (dt != INT64)
    {
        throw ImagePlusError("Datatype is not uint32 in file");
    }

    // check number of dimensions
    if (dims.size() != D)
    {
        throw ImagePlusError("Dimensions in the file do not correspond to templated dimensions");
    }


    MultiArray<int64,D> mm(dims);

    switch (compress)
    {
        case BYTE_RUNLENGTH:
        {
            // read data
            uint64 csize;
            fp.read((char*)&csize,sizeof(csize));

            boost::shared_array<uint8> cdata = boost::shared_array<uint8>(new uint8[csize]);
            fp.read(reinterpret_cast<char*>(cdata.get()),csize);

            // uncompress
            imageplus::compress::Rle rle;
            rle.uncompress(cdata.get(),
                           reinterpret_cast<uint8 *>(mm.data()),
                           csize);
        }
        break;
        default:
        {
            throw ImagePlusError("Unknown compress type");
            break;
        }
    }

    // finished
    fp.close();

    // Copy data back to multiarray
    m = mm;
}


template<int D>
void ReadMultiArray::_read_multiarray(std::ifstream& fp,
                                      DataType dt,
                                      CompressType compress,
                                      std::vector<uint64>& dims,
                                      MultiArray< float64, D >& m ) const throw (ImagePlusFileNotFound, ImagePlusError)
{
    // check data type
    if (dt != FLOAT64)
    {
        throw ImagePlusError("Datatype is not float64 in file");
    }

    // check number of dimensions
    if (dims.size() != D)
    {
        throw ImagePlusError("Dimensions in the file do not correspond to templated dimensions");
    }
   
    // Uncompress 
    switch ( compress )
    {

        case BYTE_RUNLENGTH:
        {       	
            // read data
            uint64 csize;

            fp.read( (char*)&csize, sizeof( csize ) );

            boost::shared_array< uint8 > cdata = boost::shared_array< uint8 >( new uint8[csize] );
            fp.read( reinterpret_cast< char* >( cdata.get() ), csize );

            // uncompress
            imageplus::compress::Rle rle;
         
		    if( dims != m.dims() )
		    {
		    	m.resize( dims );
		    }

		    uint64 s = m.num_elements()*11;
		    
		    boost::shared_array<uint8> data = boost::shared_array<uint8>( new uint8[s] );
		    
		    rle.uncompress( cdata.get(),
            				data.get(),
                            csize );
		    
		    PortableFloat pf;
		    for (uint64 i = 0; i < s/11; i++)
		    {
		        m.data()[i] = pf.decode( data.get()+(11*i) );
		    }           
        }
        break;
        default:
        {
            throw ImagePlusError("Unknown compress type");
            break;
        }
    }	
    
    // finished
    fp.close();
}

template void imageplus::io::ReadMultiArray::_read_multiarray<1>(std::ifstream& fp,
                                                                 DataType dt,
                                                                 CompressType compress,
                                                                 std::vector<uint64>& dims,
                                                                 MultiArray<uint8,1>& m) const throw (ImagePlusFileNotFound, ImagePlusError);
template void imageplus::io::ReadMultiArray::_read_multiarray<2>(std::ifstream& fp,
                                                                 DataType dt,
                                                                 CompressType compress,
                                                                 std::vector<uint64>& dims,
                                                                 MultiArray<uint8,2>& ) const throw (ImagePlusFileNotFound, ImagePlusError);
template void imageplus::io::ReadMultiArray::_read_multiarray<3>(std::ifstream& fp,
                                                                 DataType dt,
                                                                 CompressType compress,
                                                                 std::vector<uint64>& dims,
                                                                 MultiArray<uint8,3>& ) const throw (ImagePlusFileNotFound, ImagePlusError);


template void imageplus::io::ReadMultiArray::_read_multiarray<1>(std::ifstream& fp,
                                                                 DataType dt,
                                                                 CompressType compress,
                                                                 std::vector<uint64>& dims,
                                                                 MultiArray<uint32,1>& m) const throw (ImagePlusFileNotFound, ImagePlusError);
template void imageplus::io::ReadMultiArray::_read_multiarray<2>(std::ifstream& fp,
                                                                 DataType dt,
                                                                 CompressType compress,
                                                                 std::vector<uint64>& dims,
                                                                 MultiArray<uint32,2>& ) const throw (ImagePlusFileNotFound, ImagePlusError);
template void imageplus::io::ReadMultiArray::_read_multiarray<3>(std::ifstream& fp,
                                                                 DataType dt,
                                                                 CompressType compress,
                                                                 std::vector<uint64>& dims,
                                                                 MultiArray<uint32,3>& ) const throw (ImagePlusFileNotFound, ImagePlusError);

template void imageplus::io::ReadMultiArray::_read_multiarray<2>(std::ifstream& fp,
                                                                 DataType dt,
                                                                 CompressType compress,
                                                                 std::vector<uint64>& dims,
                                                                 MultiArray<int64,2>& ) const throw (ImagePlusFileNotFound, ImagePlusError);


template void imageplus::io::ReadMultiArray::_read_multiarray<3>(std::ifstream& fp,
                                                                 DataType dt,
                                                                 CompressType compress,
                                                                 std::vector<uint64>& dims,
                                                                 MultiArray<int64,3>& ) const throw (ImagePlusFileNotFound, ImagePlusError);


template void imageplus::io::ReadMultiArray::_read_multiarray<1>(std::ifstream& fp,
                                                                 DataType dt,
                                                                 CompressType compress,
                                                                 std::vector<uint64>& dims,
                                                                 MultiArray<float64,1>& m) const throw (ImagePlusFileNotFound, ImagePlusError);
template void imageplus::io::ReadMultiArray::_read_multiarray<2>(std::ifstream& fp,
                                                                 DataType dt,
                                                                 CompressType compress,
                                                                 std::vector<uint64>& dims,
                                                                 MultiArray<float64,2>& ) const throw (ImagePlusFileNotFound, ImagePlusError);
template void imageplus::io::ReadMultiArray::_read_multiarray<3>(std::ifstream& fp,
                                                                 DataType dt,
                                                                 CompressType compress,
                                                                 std::vector<uint64>& dims,
                                                                 MultiArray<float64,3>& ) const throw (ImagePlusFileNotFound, ImagePlusError);
