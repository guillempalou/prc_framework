// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------

//!
//!  \file writemultiarray.hpp
//!
//!  Class for writing MultiArrays to disk
//!

#ifndef IMAGEPLUS_IO_WRITEMULTIARRAY_HPP
#define IMAGEPLUS_IO_WRITEMULTIARRAY_HPP

#include <string>
#include <fstream>

#include <imageplus/core.hpp>

#include <imageplus/io/io_types.hpp>

namespace imageplus
{

    namespace io
    {


        //!
        //! \brief class for writing a MultiArray to disk
        //!
        //! \author Javier Ruiz Hidalgo <j.ruiz@upc.edu>
        //!
        //! \date 18-4-2008
        //!
        //! CAREFUL!! This code only works if writing and reading are done in the same
        //! little/big endian machine! as there are no little-endian big endian conversions.
        //!
        //! Usage:
        //! \code
        //!    MultiArray<int64,2> m;
        //!    ...
        //!    io::WriteMultiArray writeMultiArray("prova.mult");
        //!    writeMultiArray << m;
        //! \endcode
        //!

        class WriteMultiArray
        {

            public:

                //!
                //! \brief Default Constructor
                //!
                WriteMultiArray();

                //!
                //! \brief Constructor from file name
                //!
                //! \param[in] filename : File name
                //! \param[in]        c : compression type
                //!
                explicit WriteMultiArray( const std::string& filename, CompressType c = BYTE_RUNLENGTH);

                //!
                //! \brief Set file name
                //!
                //! \param[in] filename : File name
                //! \param[in]        c : compression type
                //!
                void open( const std::string& filename, CompressType c = BYTE_RUNLENGTH );

                //!
                //! \brief Destructor
                //!
                ~WriteMultiArray();

                //!
                //! \brief Overloading of operator<< to write a MultiArray
                //!
                //! \tparam M : template must be a MultiArray<T,D>
                //!
                //! \param[in] m : MultiArray to write to disk
                //!
                template<class M>
                void operator<<(M& m)
                {
                    // Open file to write
                    std::ofstream fp (_filename.c_str(), std::ios::out | std::ios::binary);
                    if (!fp.is_open())
                    {
                        throw ImagePlusFileNotFound(_filename);
                    }

                    // write magic number to start of file
                    fp.write((char*)&MULT_MAGIC_NUMBER,sizeof(MULT_MAGIC_NUMBER));
                    if (!fp.good())
                    {
                        throw ImagePlusFileError(_filename, "Cannot write magic number into file");
                    }

                    // write filetype to start of file
                    fp.write((char*)&MULT_FILETYPE,sizeof(MULT_FILETYPE));
                    if (!fp.good())
                    {
                        throw ImagePlusFileError(_filename, "Cannot write filetype into file");
                    }

                    uint8 c = _compress;
                    fp.write((char*)&c,sizeof(c));
                    if (!fp.good())
                    {
                        throw ImagePlusFileError(_filename, "Cannot write compress type into file");
                    }

                    // write multiarray
                    _write(m,fp);

                    // finished
                    fp.close();
                }

            private:
            	
                //!
                //! \brief Private method to code a "run-length" in the ELEMENT_RUNLENGTH compression method
                //!
                //! \param[in]   length         : Length to code
                //! \param[in]   to_write       : Coded binary stream
                //! \param[in]   n_bits_to_write: Number of bits to be written
            	//!
            	void _code_length(const uint8& length, uint64& to_write, uint8& n_bits_to_write);
            	
                //!
                //! \brief Private and overloaded method to write a MultiArray<uint8,1>
                //!
                //! This is one big hack to avoid using templates inside multiarrays in the operator<< function. This way one can use
                //! writemultiarray << m instead of writemultiarray.operator<<<uint8,1>( m )
                //!
                //! So operator<< calls directly a function *without* templates (_write)
                //!
                //! After that _write can call any templated function but it must use <uint8,1> in the code.
                //! See the example. If you want to use more dimensions you must add more lines of code here.
                //!
                //! \param[in]        m : multiarray to write
                //! \param[in]       fp : File pointer to write data
                //!
                void _write(const MultiArray<uint8,1>& m, std::ofstream& fp) { _append_multiarray<1>(m,fp); }

                //!
                //! \brief Private and overloaded method to write a MultiArray<uint8,2>
                //!
                //! \param[in]        m : multiarray to write
                //! \param[in]       fp : File pointer to write data
                //!
                void _write(const MultiArray<uint8,2>& m, std::ofstream& fp) { _append_multiarray<2>(m,fp); }

                //!
                //! \brief Private and overloaded method to write a MultiArray<uint8,3>
                //!
                //! \param[in]        m : multiarray to write
                //! \param[in]       fp : File pointer to write data
                //!
                void _write(const MultiArray<uint8,3>& m, std::ofstream& fp) { _append_multiarray<3>(m,fp); }
                
                //!
                //! \brief Private and overloaded method to write a MultiArray<uint32,1>
                //!
                //! \param[in]        m : multiarray to write
                //! \param[in]       fp : File pointer to write data
                //!
                void _write(const MultiArray<uint32,1>& m, std::ofstream& fp) { _append_multiarray<1>(m,fp); }
                //!
                //! \brief Private and overloaded method to write a MultiArray<uint32,2>
                //!
                //! \param[in]        m : multiarray to write
                //! \param[in]       fp : File pointer to write data
                //!
                void _write(const MultiArray<uint32,2>& m, std::ofstream& fp) { _append_multiarray<2>(m,fp); }
                //!
                //! \brief Private and overloaded method to write a MultiArray<uint32,3>
                //!
                //! \param[in]        m : multiarray to write
                //! \param[in]       fp : File pointer to write data
                //!
                void _write(const MultiArray<uint32,3>& m, std::ofstream& fp) { _append_multiarray<3>(m,fp); }
                
                //!
                //! \brief Private and overloaded method to write a MultiArray<int64,1>
                //!
                //! \param[in]        m : multiarray to write
                //! \param[in]       fp : File pointer to write data
                //!
                void _write(const MultiArray<int64,1>& m, std::ofstream& fp) { _append_multiarray<1>(m,fp); }
                //!
                //! \brief Private and overloaded method to write a MultiArray<int64,2>
                //!
                //! \param[in]        m : multiarray to write
                //! \param[in]       fp : File pointer to write data
                //!
                void _write(const MultiArray<int64,2>& m, std::ofstream& fp) { _append_multiarray<2>(m,fp); }
                //!
                //! \brief Private and overloaded method to write a MultiArray<int64,3>
                //!
                //! \param[in]        m : multiarray to write
                //! \param[in]       fp : File pointer to write data
                //!
                void _write(const MultiArray<int64,3>& m, std::ofstream& fp) { _append_multiarray<3>(m,fp); }

                //!
                //! \brief Private and overloaded method to write a MultiArray<float64,1>
                //!
                //! \param[in]        m : multiarray to write
                //! \param[in]       fp : File pointer to write data
                //!
                void _write(const MultiArray<float64,1>& m, std::ofstream& fp) { _append_multiarray<1>(m,fp); }
                //!
                //! \brief Private and overloaded method to write a MultiArray<float64,2>
                //!
                //! \param[in]        m : multiarray to write
                //! \param[in]       fp : File pointer to write data
                //!
                void _write(const MultiArray<float64,2>& m, std::ofstream& fp) { _append_multiarray<2>(m,fp); }
                //!
                //! \brief Private and overloaded method to write a MultiArray<float64,3>
                //!
                //! \param[in]        m : multiarray to write
                //! \param[in]       fp : File pointer to write data
                //!
                void _write(const MultiArray<float64,3>& m, std::ofstream& fp) { _append_multiarray<3>(m,fp); }

                //!
                //! \brief Appends multiarray data to filestream
                //!
                //! \tparam D : Number of dimensions of the multiarray
                //!
                //! \param[in]  m : Multiarray to write to
                //! \param[in] fp : filestream to append data
                //!
                template<int D>
                void _append_multiarray(const MultiArray<uint8,D>& m, std::ofstream& fp);

                //!
                //! \brief Appends multiarray data to filestream
                //!
                //! \tparam D : Number of dimensions of the multiarray
                //!
                //! \param[in]  m : Multiarray to write to
                //! \param[in] fp : filestream to append data
                //!
                template<int D>
                void _append_multiarray(const MultiArray<uint32,D>& m, std::ofstream& fp);
                
                //!
                //! \brief Appends multiarray data to filestream
                //!
                //! \tparam D : Number of dimensions of the multiarray
                //!
                //! \param[in]  m : Multiarray to write to
                //! \param[in] fp : filestream to append data
                //!
                template<int D>
                void _append_multiarray(const MultiArray<int64,D>& m, std::ofstream& fp);

                //!
                //! \brief Appends multiarray data to filestream
                //!
                //! \tparam D : Number of dimensions of the multiarray
                //!
                //! \param[in]  m : Multiarray to write to
                //! \param[in] fp : filestream to append data
                //!
                template<int D>
                void _append_multiarray(const MultiArray<float64,D>& m, std::ofstream& fp);

                //!
                //! \brief Appends multiarray header to filestream
                //!
                //! \param[in] dims : dimensions of multiarray data
                //! \param[in]   dt : Data type of the multiarray
                //! \param[in]   fp : filestream to append data
                //!
                void _append_multiarray_header(std::vector<uint64> dims, DataType dt, std::ofstream& fp);

                //! Stores the file name in disk
                std::string _filename;

                //! compression type
                CompressType _compress;
        };


    } // namespace io

} //namespace imageplus

#endif
