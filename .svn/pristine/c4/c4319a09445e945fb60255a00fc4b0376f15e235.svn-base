// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------
//!
//!  \file pf_tumult.cpp
//!
//!  Interface for the TumultParticleFilter class used in tumult_detector.cpp.
//!  TumultParticle class is defined.
//!

#include <imageplus/particlefilters/pf_tumult.hpp>
#include <imageplus/core/coord3d.hpp>
#include <imageplus/math/statistics/histogram.hpp>

using namespace imageplus;
using namespace imageplus::particlefilters;



std::ostream& imageplus::particlefilters::operator << ( std::ostream& os, const TumultParticle& p )
{
	os << "X:" << p.position().x() << " Y:" << p.position().y() << " Y':" << p.position().z() << " Weight:" << p.weight();
	return os;
}

//
// TRACKING FUNCTIONS
//
namespace imageplus
{

    namespace particlefilters
    {

	    void create_particle_filter( std::vector< TumultParticleFilter >& tumult_filters, const TumultInputData& input_data, struct TumultInitData initialization_data, uint64 number_of_particles, float64 beta )
	    {
	    	Coord2D< float64 > centroid_position;
	    	ImageMask creation_mask( input_data.fg_mask.size_x(), input_data.fg_mask.size_y() );
	    	int64 blob_size = 0;
	    	bool blob_ok = false, no_pf = false;
	    	uint64 count = 0;

	    	// Calulating the maximum & minimum values of the initialization area
	    	uint64 xi = input_data.environment.ini_area_x - input_data.environment.ini_area_w/2;
	    	uint64 xf = input_data.environment.ini_area_x + input_data.environment.ini_area_w/2;
	    	uint64 yi = input_data.environment.ini_area_y - input_data.environment.ini_area_h/2;
	    	uint64 yf = input_data.environment.ini_area_y + input_data.environment.ini_area_h/2;

	    	// Error control for xi, xf, yi & yf to not exceed the limits of the image
	    	if ( xi < 0 ) xi = 0; else if ( xi >= input_data.current_image.size_x() ) xi = input_data.current_image.size_x() - 1;
	    	if ( xf < 0 ) xf = 0; else if ( xf >= input_data.current_image.size_x() ) xf = input_data.current_image.size_x() - 1;
	    	if ( yi < 0 ) yi = 0; else if ( yi >= input_data.current_image.size_y() ) yi = input_data.current_image.size_y() - 1;
	    	if ( yf < 0 ) yf = 0; else if ( yf >= input_data.current_image.size_y() ) yf = input_data.current_image.size_y() - 1;

	    	creation_mask = false; // Initialized to black

	    	for( uint64 i = xi; i <= xf ; i++)
	    	{
	    		for( uint64 j = yi; j <= yf ; j++)
	    		{
	    			if( input_data.fg_mask( GRAY_CHANNEL )[ i ][ j ] == 255 )
	    			{	
	    				centroid_position.x() += i;
	    				centroid_position.y() += j;
	    				blob_size++;
		    			creation_mask[ i ][ j ] = true; // Creating mask to initialize histogram
	    			}		
	    			// The blob has the necessary minimum size		
	    			if( ( i == xf ) && ( j == yf ) && ( blob_size >= ( input_data.environment.ini_blob_w * input_data.environment.ini_blob_h ) ) )
	    			{
	    				blob_ok = true;
	    			}
	    		} 
	    	}

	    	// Search if there is a PF in the inicialization area
	    	if ( tumult_filters.size() == 0 )
	    	{
	    		no_pf = true;
	    	}
	    	else
	    	{
	    		for( uint64 i = 0; i < tumult_filters.size(); i++ )
	    		{
	    			// The center of the PF should be out of the inicialization area
	    			if( ( static_cast< uint64 >( tumult_filters[ i ].position().x() ) <= xi ) || ( static_cast< uint64 >( tumult_filters[ i ].position().x() ) >= xf ) || ( static_cast< uint64 >( tumult_filters[ i ].position().y() ) <= yi ) || ( static_cast< uint64 >( tumult_filters[ i ].position().y() ) >= yf ) )
	    			{
	    				count++;
	    			}
	    			
	    			// If ALL the PF are out of the inicialization area
	    			if( count == static_cast< uint64 > ( tumult_filters.size() ) )
	    			{
	    				no_pf = true;
	    			}
	    		}
	    	}
	    	// If there is a blob of size bigger than INI_BLOB_W x INI_BLOB_H initialize filter
	    	// There should be only 1 PF filters in the INITIALIZATION AREA, one per blob
	    	if( blob_ok && no_pf )
	    	{	
	    		// Initialize the PF with the centroid of the pixels of FG
	    		centroid_position.x() /= blob_size;
	    		centroid_position.y() /= blob_size;

	    		// Increase the number of PF if Maximum is not exceeded
	    		ASSERT( tumult_filters.size() < tumult_filters.max_size(), " Exceeded vector filters capacity" );
	    		
	    		// Create PF
	    		TumultParticleFilter pf( number_of_particles );

	    		// Initializing initialization_data
	    		uint64 k = static_cast< uint64 >( centroid_position.y() );
	    		
	    		if( k >= input_data.current_image.size_y() )
	    		{
	    			k = input_data.current_image.size_y() - 1;
	    		}
	    		
	    		if( k < 0 )
	    		{
	    			k = 0;
	    		}

	    		initialization_data.initial_position.x() = centroid_position.x();
	    		initialization_data.initial_position.y() = centroid_position.y();
	    		
	    		initialization_data.initial_size.x() = input_data.environment.w[ k ];	    		
	    		initialization_data.initial_size.y() = input_data.environment.h[ k ];
	    		
	    		initialization_data.variance = input_data.environment.var[ k ];	    			    		
	    		initialization_data.beta = beta;
	    		
	    		pf.initialize_filter( initialization_data, input_data, creation_mask ); 
	    		
	    		// Initializing id
	    		uint64 id = 0;
	    		if( tumult_filters.size() == 0 )
	    		{
	    			id = 0;
	    		}
	    		else
	    		{
	    			for ( uint64 it = 0; it < tumult_filters.size(); it++ )// For each filter in the vector
			    	{
	    				if( it != tumult_filters[ it ].id() )
	    				{
	    					id = it;
	    				}
			    	}
	    			if( id == 0 )
	    			{
	    				id = tumult_filters.size();
	    			}
	    		}
	    		
	    		pf.id( id ); // Assign id
	    		
	    		tumult_filters.push_back( pf ); // INSERT NEW FILTER	
	    		std::cout << "Created particle filter: " << pf.id() << std::endl;		
	    	}	
	    }
    
	    void tracking( std::vector< TumultParticleFilter >& tumult_filters, const TumultInputData& input_data, struct TumultInitData initialization_data, float64 survival_rate_threshold )
	    {   
	    	TumultParticle result;
	
	    	for ( uint64 it = 0; it < tumult_filters.size(); it++ )// For each filter in the vector
	    	{		
	    		// Filter
	    		tumult_filters[it].filter( input_data ); 
	    //		tumult_filters[it].filter_debug( input_data );
	    		
	    		// Blocks
	    		tumult_filters[ it ].block_particles_out_ramp( input_data );
	    		tumult_filters[ it ].block_particles_far_from_ramp( input_data );
	    		tumult_filters[ it ].block_particles_too_far( input_data );
	    		
	    		// DestroyPFsBadAlpha	
	    		float64 alpha = tumult_filters[ it ].survival_rate();
	    		std::cout << "PF[" << tumult_filters[ it ].id() << "].Alpha = " << alpha << std::endl;
	
	    		if( ( alpha <= survival_rate_threshold ) || ( alpha > 1.0 ) )
	    		{
	    			tumult_filters[ it ].destruction_efficiency( tumult_filters[ it ].destruction_efficiency() + 1 );
	    			// If the PF has an Efficiency really bad in 2 frames it is destroyed
	    			if ( tumult_filters[ it ].destruction_efficiency() >= 2 )
	    			{
	    				std::cout << "Filter " << tumult_filters[ it ].id() << " destroyed because of low efficiency" << std::endl;
	
	    				// Destruir filtro
	    				if(	tumult_filters.size()== 1 )
	    				{
	    					tumult_filters.clear();
	    				}
	    				else if( it == 0 && tumult_filters.size()== 1 )
	    				{
	    					tumult_filters.clear();
	    				}
	    				else if( it == (tumult_filters.size() - 1) )
	    				{
	    					tumult_filters.pop_back();
	    				}
	    				else
	    				{
	    					tumult_filters[ it ] = tumult_filters.back();
	    					tumult_filters.pop_back();
	    				}											
	    				if( it != 0 )
	    				{
	    					it--;
	    				}
	    			}			
	    		}
	    		else
	    		{
	    			// Estimate
	    			result = tumult_filters[ it ].estimate();
//	    			std::cout << "Estimate" << std::endl;
	    			
	    			tumult_filters[ it ].update_filter( input_data, result ); // UpatePF
//	    			std::cout << "Update" << std::endl;
	    			
	    			tumult_filters[ it ].history().push_back( result );// Store history of filter (position and size)
	    			std::cout << "History size filter[ " << tumult_filters[ it ].id() << " ]: " << tumult_filters[ it ].history().size() << std::endl;
	    		}
	    	}
	    }
	
	    // DroppingParticleFilter
	    void dropping_pf( std::vector< TumultParticleFilter >& tumult_filters, const TumultInputData& input_data )
	    {	
	    	// Calulating the maximum & minimum values of the initialization area
	    	uint64 min_x = input_data.environment.des_area_x - input_data.environment.des_area_w/2;
	    	uint64 max_x = input_data.environment.des_area_x + input_data.environment.des_area_w/2;
	    	uint64 min_y = input_data.environment.des_area_y - input_data.environment.des_area_h/2;
	    	uint64 max_y = input_data.environment.des_area_y + input_data.environment.des_area_h/2;
	    	
	    	// Error control for min_x, mas_x, min_y & max_y to not exceed the limits of the image
	    	if ( min_x < 0 ) min_x = 0; else if ( min_x >= input_data.current_image.size_x() ) min_x = input_data.current_image.size_x() - 1;
	    	if ( max_x < 0 ) max_x = 0; else if ( max_x >= input_data.current_image.size_x() ) max_x = input_data.current_image.size_x() - 1;
	    	if ( min_y < 0 ) min_y = 0; else if ( min_y >= input_data.current_image.size_y() ) min_y = input_data.current_image.size_y() - 1;
	    	if ( max_y < 0 ) max_y = 0; else if ( max_y >= input_data.current_image.size_y() ) max_y = input_data.current_image.size_y() - 1;	
	    	
	    	// Calulating the maximum & minimum values of the initialization area
	    	uint64 xi = input_data.environment.ini_area_x - input_data.environment.ini_area_w/2;
	    	uint64 xf = input_data.environment.ini_area_x + input_data.environment.ini_area_w/2;
	    	uint64 yi = input_data.environment.ini_area_y - input_data.environment.ini_area_h/2;
	    	uint64 yf = input_data.environment.ini_area_y + input_data.environment.ini_area_h/2;
	    	
	    	// Error control for xi, xf, yi & yf to not exceed the limits of the image
	    	if ( xi < 0 ) xi = 0; else if ( xi >= input_data.current_image.size_x() ) xi = input_data.current_image.size_x() - 1;
	    	if ( xf < 0 ) xf = 0; else if ( xf >= input_data.current_image.size_x() ) xf = input_data.current_image.size_x() - 1;
	    	if ( yi < 0 ) yi = 0; else if ( yi >= input_data.current_image.size_y() ) yi = input_data.current_image.size_y() - 1;
	    	if ( yf < 0 ) yf = 0; else if ( yf >= input_data.current_image.size_y() ) yf = input_data.current_image.size_y() - 1;
	    	
	    	// For each PF
	    	for ( uint64 it = 0; it < tumult_filters.size(); it++ )
	    	{
	    		
	    		// If the PF center is in the Initializations area in 10 frames eliminate it 
	    		if( tumult_filters.size() > 0 )
	    		{
	    			if( ( ( static_cast< uint64 >( tumult_filters[ it ].position().x() ) >= xi ) && ( static_cast< uint64 >( tumult_filters[ it ].position().x() ) <= xf ) ) && ( ( static_cast< uint64 >( tumult_filters[ it ].position().y() ) >= yi  ) && ( static_cast< uint64 >( tumult_filters[ it ].position().y() ) <= yf ) ) )
	    			{
	    				tumult_filters[ it ].destruction_in( tumult_filters[ it ].destruction_in() + 1 );
	    				
	    				// If the PF stays in the Initialization zone more than 25 frames it is destroyed
	    				if ( tumult_filters[ it ].destruction_in() >= 25 )
	    				{
	    					std::cout << "Filter " << tumult_filters[ it ].id() << " destroyed because of too much time in Initialization zone" << std::endl;
	    					
	    					// Destruir filtro
	    					if(	tumult_filters.size()== 1 )
	    					{
	    						tumult_filters.clear();
	    					}
	    					else if( it == 0 && tumult_filters.size()== 1 )
	    					{
	    						tumult_filters.clear();
	    					}
	    					else if( it == (tumult_filters.size() - 1) )
	    					{
	    						tumult_filters.pop_back();
	    					}
	    					else
	    					{
	    						tumult_filters[ it ] = tumult_filters.back();
	    						tumult_filters.pop_back();
	    					}											
	    					if( it != 0 )
	    					{
	    						it--;
	    					}
	    				}
	    			}
	    		}
	
	    		// If the PF center is on top of the Initialization area in 5 frames eliminate it 
	    		if( ( static_cast< uint64 >( tumult_filters[ it ].position().y() ) < yi  ) && ( tumult_filters.size() > 0 )	)
	    		{
	    			tumult_filters[ it ].destruction_in( tumult_filters[ it ].destruction_in() + 1 );
	    			// If the PF goes over the Initialization zone more than 5 frames it is destroyed
	    			if ( tumult_filters[ it ].destruction_in() >= 5 )
	    			{
	    				std::cout << "Filter " << tumult_filters[ it ].id() << " destroyed because is over the Initialization zone" << std::endl;
	    				
	    				// Destruir filtro
	    				if(	tumult_filters.size()== 1 )
	    				{
	    					tumult_filters.clear();
	    				}
	    				else if( it == 0 && tumult_filters.size()== 1 )
	    				{
	    					tumult_filters.clear();
	    				}
	    				else if( it == (tumult_filters.size() - 1) )
	    				{
	    					tumult_filters.pop_back();
	    				}
	    				else
	    				{
	    					tumult_filters[ it ] = tumult_filters.back();
	    					tumult_filters.pop_back();
	    				}											
	    				if( it != 0 )
	    				{
	    					it--;
	    				}
	    			}					
	    		}
	    		
	    		// First time we enter the Destruction zone we intialize destructionOut
	    		if( tumult_filters.size() > 0 )
	    		{
	    			if ( ( tumult_filters[ it ].destruction_out() == -1 ) && ( static_cast< uint64 >( tumult_filters[ it ].position().x() ) >= min_x ) && ( static_cast< uint64 >( tumult_filters[ it ].position().x() ) <= max_x ) && ( static_cast< uint64 >( tumult_filters[ it ].position().y() ) >= min_y  ) && ( static_cast< uint64 >( tumult_filters[ it ].position().y() ) <= max_y ) )
	    			{
	    				tumult_filters[ it ].destruction_out( 0 );
	    			}
	    		}
	    		
	    		// If the PF center is out of the image we should destroy it
	    		if ( ( tumult_filters.size() > 0 ) && ( tumult_filters[ it ].destruction_out() != -1 ) && ( ( static_cast< uint64 >( tumult_filters[ it ].position().x() ) >= input_data.current_image.size_x() ) || ( static_cast< uint64 >( tumult_filters[ it ].position().y() ) >= input_data.current_image.size_y() ) ) )
	    		{
	    			tumult_filters[ it ].destruction_out( tumult_filters[ it ].destruction_out() + 1 );
	    			
	    			std::cout << "Filter " << tumult_filters[ it ].id() << " destroyed because the PF's centroid is out of the image" << std::endl;
	    			
	    			// Destruir filtro
	    			if(	tumult_filters.size()== 1 )
	    			{
	    				tumult_filters.clear();
	    			}
	    			else if( it == 0 && tumult_filters.size()== 1 )
	    			{
	    				tumult_filters.clear();
	    			}
	    			else if( it == (tumult_filters.size() - 1) )
	    			{
	    				tumult_filters.pop_back();
	    			}
	    			else
	    			{
	    				tumult_filters[ it ] = tumult_filters.back();
	    				tumult_filters.pop_back();
	    			}											
	    			if( it != 0 )
	    			{
	    				it--;
	    			}
	    		}
	    		// If the PF center is out of the Destruction zone eliminate it
	    		else if (  ( tumult_filters.size() > 0 )  &&
	    		               ( tumult_filters[ it ].destruction_out() != -1 )  && 
	    		               (  ( static_cast< uint64 >( tumult_filters[ it ].position().x() ) < min_x ) ||
	    		                  ( static_cast< uint64 >( tumult_filters[ it ].position().x() ) > max_x ) || 
	    		                  ( static_cast< uint64 >( tumult_filters[ it ].position().y() ) < min_y  ) || 
	    		                  ( static_cast< uint64 >( tumult_filters[ it ].position().y() ) > max_y )  ) )
	    		{
	    			tumult_filters[ it ].destruction_out( tumult_filters[ it ].destruction_out() + 1 );
	    			
	    			if ( tumult_filters[ it ].destruction_out() >= 20 )
	    			{
	    				std::cout << "Filter " << tumult_filters[ it ].id() << " destroyed because of too much time OUT of the Destruction zone" << std::endl;
	    			
	    				// Destruir filtro
	    				if(	tumult_filters.size()== 1 )
	    				{
	    					tumult_filters.clear();
	    				}
	    				else if( it == 0 && tumult_filters.size()== 1 )
	    				{
	    					tumult_filters.clear();
	    				}
	    				else if( it == (tumult_filters.size() - 1) )
	    				{
	    					tumult_filters.pop_back();
	    				}
	    				else
	    				{
	    					tumult_filters[ it ] = tumult_filters.back();
	    					tumult_filters.pop_back();
	    				}											
	    				if( it != 0 )
	    				{
	    					it--;
	    				}
	    			}					
	    		}
	    		// If the PF center is in the Destruction zone for more than 10 frames it is destroyed
	    		else if ( ( tumult_filters.size() > 0 ) && ( tumult_filters[ it ].destruction_out() != -1 ) && ( ( static_cast< uint64 >( tumult_filters[ it ].position().x() ) >= min_x ) && ( static_cast< uint64 >( tumult_filters[ it ].position().x() ) <= max_x ) && ( static_cast< uint64 >( tumult_filters[ it ].position().y() ) >= min_y  ) && ( static_cast< uint64 >( tumult_filters[ it ].position().y() ) <= max_y ) ) )
	    		{
	    			tumult_filters[ it ].destruction_out( tumult_filters[ it ].destruction_out() + 1 );
	    			
	    			if ( tumult_filters[ it ].destruction_out() >= 100)
	    			{						
	    				std::cout << "Filter " << tumult_filters[ it ].id() << " destroyed because of too much time IN the Destruction zone" << std::endl;
	    			
	    				// Destruir filtro
	    				if(	tumult_filters.size()== 1 )
	    				{
	    					tumult_filters.clear();
	    				}
	    				else if( it == 0 && tumult_filters.size()== 1 )
	    				{
	    					tumult_filters.clear();
	    				}
	    				else if( it == (tumult_filters.size() - 1) )
	    				{
	    					tumult_filters.pop_back();
	    				}
	    				else
	    				{
	    					tumult_filters[ it ] = tumult_filters.back();
	    					tumult_filters.pop_back();
	    				}											
	    				if( it != 0 )
	    				{
	    					it--;
	    				}
	    			}					
	    		}
	    		// If the PF center has been in the Destruction and the PF is going back to ramp (on top the destruction zone) for more than 2 frames the PF is destroyed 
	    		if ( ( tumult_filters.size() > 0 ) && ( tumult_filters[ it ].destruction_out() != -1 ) && ( ( static_cast< uint64 >( tumult_filters[ it ].position().y() ) < min_y ) ) )
	    		{
	    			tumult_filters[ it ].destruction_on_top( tumult_filters[ it ].destruction_on_top() + 1 );
	    			
	    			if ( tumult_filters[ it ].destruction_on_top() >= 3 )
	    			{
	    				std::cout << "Filter " << tumult_filters[ it ].id() << " destroyed because of going ON TOP the Destruction zone" << std::endl;
	    				
	    				// Destruir filtro
	    				if(	tumult_filters.size()== 1 )
	    				{
	    					tumult_filters.clear();
	    				}
	    				else if( it == 0 && tumult_filters.size()== 1 )
	    				{
	    					tumult_filters.clear();
	    				}
	    				else if( it == (tumult_filters.size() - 1) )
	    				{
	    					tumult_filters.pop_back();
	    				}
	    				else
	    				{
	    					tumult_filters[ it ] = tumult_filters.back();
	    					tumult_filters.pop_back();
	    				}											
	    				if( it != 0 )
	    				{
	    					it--;
	    				}
	    			}					
	    		}
	    	
	    		uint64 centroid_error_value = 2;
	    		
	    		// Looking for another PF with its centroid too close (2 pixels) from the current PF
	    		uint64 max_centroid_x_error = static_cast< uint64 >( tumult_filters[ it ].position().x() ) + centroid_error_value;
	    		uint64 max_centroid_y_error = static_cast< uint64 >( tumult_filters[ it ].position().y() ) + centroid_error_value;
	    		uint64 min_centroid_x_error = static_cast< uint64 >( tumult_filters[ it ].position().x() ) - centroid_error_value;
	    		uint64 min_centroid_y_error = static_cast< uint64 >( tumult_filters[ it ].position().y() ) - centroid_error_value;
	    		
	    		if ( max_centroid_x_error < 0 ) max_centroid_x_error = 0; else if ( max_centroid_x_error >= input_data.current_image.size_x() ) max_centroid_x_error = input_data.current_image.size_x() - 1;
	    		if ( max_centroid_y_error < 0 ) max_centroid_y_error = 0; else if ( max_centroid_y_error >= input_data.current_image.size_x() ) max_centroid_y_error = input_data.current_image.size_x() - 1;
	    		if ( min_centroid_x_error < 0 ) min_centroid_x_error = 0; else if ( min_centroid_x_error >= input_data.current_image.size_y() ) min_centroid_x_error = input_data.current_image.size_y() - 1;
	    		if ( min_centroid_y_error < 0 ) min_centroid_y_error = 0; else if ( min_centroid_y_error >= input_data.current_image.size_y() ) min_centroid_y_error = input_data.current_image.size_y() - 1;
	
	    		// We look for another PF with its centroid in the error margin, if it exists we destroy the current PF
	    		if( tumult_filters.size() > 0 )
	    		{
	    			for( uint64 index = it; index != 0 && index >= 0; index-- )
	    			{
	    				if ( index != it )
	    				{
	    					if( ( min_centroid_x_error < tumult_filters[ index ].position().x() ) && ( tumult_filters[ index ].position().x() < max_centroid_x_error ) )
	    					{
	    						if( ( min_centroid_y_error < tumult_filters[ index ].position().y() ) && ( tumult_filters[ index ].position().y() < max_centroid_y_error ) ) 
	    						{
	    							tumult_filters[ it ].destruction_double( tumult_filters[ it ].destruction_double() + 1 );
	    							// If the PF goes over another PF an it stays in 3 or more it is destroyed
	    							if ( tumult_filters[ it ].destruction_double() >= 3 )
	    							{
	    								std::cout << "Filter " << tumult_filters[ it ].id() << " destroyed because its too close to Filter " << index << std::endl;
	    								// Destruir filtro
	    								if(	tumult_filters.size()== 1 )
	    								{
	    									tumult_filters.clear();
	    								}
	    								else if( it == 0 && tumult_filters.size()== 1 )
	    								{
	    									tumult_filters.clear();
	    								}
	    								else if( it == (tumult_filters.size() - 1) )
	    								{
	    									tumult_filters.pop_back();
	    								}
	    								else
	    								{
	    									tumult_filters[ it ] = tumult_filters.back();
	    									tumult_filters.pop_back();
	    								}											
	    								if( it != 0 )
	    								{
	    									it--;
	    								}
	    							}								
	    						}
	    					}
	    				}
	    			}
	    		}
	    	}
	    }
	
	    bool detecting_tumult( std::vector< TumultParticleFilter >& tumult_filters, uint64 resolution_speed, uint64 resolution_y, uint64 detection_threshold, uint64 detection_histeresis, uint64& tumult_detection_histeresis )
	    {
	    	bool there_is_a_tumult = false;
	    	int32 max_z = std::numeric_limits< int32 >::min(), min_z = 0;
	    	int32 max_speed = std::numeric_limits< int32 >::min(), min_speed = std::numeric_limits< int32 >::max();
	    	    	
	    	// Finding MaxSpeed
	    	for ( uint64 it = 0; it < tumult_filters.size(); it++ )
	    	{
	    		ASSERT( tumult_filters[ it ].position().z() > 0, "Z should be positive\n" );
	    		
	    		if( tumult_filters[ it ].position().z() > max_z )
	    		{
	    			max_z = static_cast< int32 > ( tumult_filters[ it ].position().z() );
	    		}
	    		
	    		if( tumult_filters[ it ].speed() > max_speed )
	    		{
	    			max_speed = static_cast< int32 > ( tumult_filters[ it ].speed() );
	    		}
	    		
	    		if( tumult_filters[ it ].speed() < min_speed )
	    		{
	    			min_speed = static_cast< int32 > ( tumult_filters[ it ].speed() );
	    		}
	    	}

//			std::cout << "Max Z = " << max_z << " & Min Z = " << min_z << std::endl;
//			std::cout << "Max speed = " << max_speed << " & Min speed = " << min_speed << std::endl;
	    	uint64 max_number_of_z_bins = static_cast< uint64 > ( std::ceil( ( max_z - min_z ) / static_cast< float64 >(resolution_y) ) + 1 ); // MinZ fixed in 0 
	    	uint64 max_number_of_speed_bins = 1;
	
	    	if ( min_speed >= 0 )
	    	{
	    		max_number_of_speed_bins = static_cast< uint64 > ( std::ceil( ( max_speed + min_speed ) / static_cast< float64 >(resolution_speed) ) + 1 );
	    	}
	    	else
	    	{
	    		max_number_of_speed_bins = static_cast< uint64 > ( std::ceil( ( max_speed - min_speed ) / static_cast< float64 >(resolution_speed) ) + 1 );
	    	}
	    	   	
	    	std::vector< uint64 > detection_grid;
//	    	std::cout << "max_number_of_speed_bins = " << max_number_of_speed_bins << std::endl;
//	    	std::cout << "max_number_of_z_bins = " << max_number_of_z_bins << std::endl;
	    	// Allocate memory for the detection grid (similar to Histogram)
	    	detection_grid.resize( max_number_of_z_bins * max_number_of_speed_bins, 0 );

	    	// Fill the Detection Grid 
	    	for ( uint64 it = 0; it < tumult_filters.size(); it++ )
	    	{
	    		int32 current_speed = static_cast< uint64 > ( tumult_filters[ it ].speed() ) - min_speed;
	    		
	    		uint64 bin_speed = static_cast< uint64 > ( std::floor( current_speed / static_cast< float64 >(resolution_speed) ) );
	    		uint64 bin_z = static_cast< uint64 > ( std::floor( tumult_filters[ it ].position().z() / resolution_y ) );
	    		
	    		ASSERT( bin_speed < max_number_of_speed_bins, "Size of bins not adequate\n" );
	    		ASSERT( bin_z < max_number_of_z_bins, "Size of bins not adequate\n" );
	    	
	    		uint64 index = bin_z * max_number_of_speed_bins + bin_speed;
	    		detection_grid[ index ]++;			
	    	}

	    	// Decide if there are more PF's in a Bin than the TUMULT_THRESHOLD
	    	for( uint64 i = 0; i < max_number_of_z_bins; i++ )
	    	{
	    		for( uint64 j = 0; j < max_number_of_speed_bins; j++ )
	    		{
	    			uint64 index = i * max_number_of_speed_bins + j;
	    			
	    			if( detection_grid[ index ] >= detection_threshold )
	    			{
	    				there_is_a_tumult = true;
	    				tumult_detection_histeresis ++;
	    				
	    				if( tumult_detection_histeresis >= detection_histeresis )
	    				{
	    					std::cout << "Possible Tumult Detected!!!" << std::endl; 
	    					return true;
	    				}
	    			}
	    		}
	    	}

	    	// Reseting the histeresis counter because there are not two consecutives possible tumults
	    	if( !there_is_a_tumult )
	    	{
	    		tumult_detection_histeresis = 0;
	    	}
	    	
	    	return false;	
	    }    
    }
}

//
// Methods of the TumultParticle
//
namespace imageplus 
{

    namespace particlefilters
    {
	    
	    void TumultParticle::init_particle( const init_data_type& initialization_data )
	    {
	        _position = initialization_data.initial_position;
	        _size = initialization_data.initial_size;
	        _variance = initialization_data.variance;
	        _beta = initialization_data.beta;
	
	        _fg_pixels = 0;
	    }
    
        void TumultParticle::evaluate( const input_data_type& input_data )
        {
            // Update particles info for evaluate
            update_particles_in_filter( input_data );

            if ( static_cast< uint64 > ( _position.x() ) <= 0 ) // If Particle out of image weight zero
            {
                weight( 0.0 );
            }
            else if ( static_cast< uint64 > ( _position.y() ) <= 0 )
            {
                weight( 0.0 );
            }
            else if ( static_cast< uint64 > ( _position.x() ) >= input_data.fg_mask.size_x() )
            {
                weight( 0.0 );
            }
            else if ( static_cast< uint64 > ( _position.y() ) >= input_data.fg_mask.size_y() )
            {
                weight( 0.0 );
            }
            else
            {
                // TODO: For color info (need to update to new Histogram)
                // Color information to evalute
                // Checking for especial cases of empty histograms
//                      ASSERT( input_data.hist_ref_UV.num_points() > 0, "ERROR(Histogram of the PF is empty): Following an empty histogram!\n" );
//
//                      float64 b_distance = 1.0;
//                      if ( _hist_particle.num_points() == 0 )
//                      {
//                          b_distance = 1.0;
//                      }
//                      else
//                      {
//                          b_distance = batt_distance( input_data.hist_ref_UV, _hist_particle );
//                      }

                // FG information for evaluate
                number_of_fg_pixels( input_data );

//                      float64 lambda_c = 0.5, lambda_f = 0.5;
//                      float64 score = lambda_c * ( 1 - _fg_pixels ) + lambda_f * b_distance; // FG & Color info
                float64 score = ( 1 - _fg_pixels ); // Only FG info
//                      float64 score = b_distance; // Only Color Info

//                      if( _fg_pixels == 0.0 && b_distance == 1.0 ) // TODO: For color info
                if( _fg_pixels == 0.0 )
                {
                    weight( 0.0 );
                }
                else
                {
                    float64 pseudo_likelihood = std::exp( - _beta * score );
                    weight( pseudo_likelihood );
                }
            }
        }

	    
	    float64 TumultParticle::rand_gauss( float64 value )
	    {
	    	const float64 PI = 3.14159265;
			float64 u1 = static_cast< float64 >( rand() ) / RAND_MAX;
			float64 u2 = static_cast< float64 >( rand() ) / RAND_MAX;
			float64 z = std::sqrt( -2.0 * std::log( u1 ) ) * std::cos( 2 * PI * u2 );
			
			return value + _variance * z ;
	    }
    
	    void TumultParticle::propagate()
	    {
			_position.x() = rand_gauss( _position.x() );
			_position.y() = rand_gauss( _position.y() );		
	    } 
    
    	void TumultParticle::propagate( const input_data_type& input_data)
	    {
			_position.x() = rand_gauss( _position.x() );
			_position.y() = rand_gauss( _position.y() );
	//    				_position.z() = rand_gauss( _position.z() ); // Not necessary to propagate
			
			// Control that doesn't exceeds image size
			if ( _position.x() < 0 ) 
			{
				_position.x() = 0; 
			}
			else if ( _position.x() >= input_data.current_image.size_x() ) 
			{
				_position.x() = input_data.current_image.size_x() - 1;
			}
			
			if ( _position.y() < 0 )
			{
				_position.y() = 0; 
			}
			else if ( _position.y() >= input_data.current_image.size_y() ) 
			{
				_position.y() = input_data.current_image.size_y() - 1;
			}
			
			ASSERT( ( _position.x() >= 0 ) && ( _position.x() < input_data.current_image.size_x() ), " Propagation X exceeds image size\n" );
			ASSERT( ( _position.y() >= 0 ) && ( _position.y() < input_data.current_image.size_y() ), " Propagation Y exceeds image size\n" );		
	    }
    
        TumultParticle TumultParticle::operator + ( const TumultParticle& other_particle ) const
        {
            TumultParticle result_particle( 1 );

            result_particle._position = _position + other_particle._position;
            result_particle._variance = _variance;

            return result_particle;
        }
        
        TumultParticle TumultParticle::operator * ( float64 weight ) const
        {
            TumultParticle result_particle( 1 );

            result_particle._position = _position * weight;
            result_particle._variance = _variance;

            return result_particle;
        }
        
        void TumultParticle::copy( const TumultParticle& other_particle )
        {
            weight ( other_particle.weight() );
            _position = other_particle._position;
            _variance = other_particle._variance;
        }
    
	    const Coord3D< float64 >& TumultParticle::position() const
	    {
	    	return _position;
	    }    
	          
		Coord3D< float64 >& TumultParticle::position()
		{
			return _position;
		}
        
        const float64& TumultParticle::position_x( ) const
        {
        	return _position.x();
        }
    
        const float64& TumultParticle::position_y( ) const
        {
        	return _position.y();
        }
        
        const float64& TumultParticle::position_z( ) const
        {
        	return _position.z();
        }
               
        const Coord2D< float64 > TumultParticle::size( ) const
        {
        	return _size;
        }
        
        const TumultParticle::HistogramType& TumultParticle::hist_particle() const
        {
        	return( _hist_particle );
        }
        
        TumultParticle::HistogramType& TumultParticle::hist_particle()
        {
        	return( _hist_particle );
        }
        
	    void TumultParticle::number_of_fg_pixels( const input_data_type& input_data )
	    {	      
	    	uint64 count = 0;
	    	
	    	// Calulating the maximum & minimum values of the initialization area
	    	uint64 xi = static_cast< uint64 > ( _position.x() - _size.x()/2 );
	    	uint64 xf = static_cast< uint64 > ( _position.x() + _size.x()/2 );
	    	uint64 yi = static_cast< uint64 > ( _position.y() - _size.y()/2 );
	    	uint64 yf = static_cast< uint64 > ( _position.y() + _size.y()/2 );
	    	
	    	// Error control for xi, xf, yi & yf to not exceed the limits of the image 
	    	if ( xi < 0 ) xi = 0; else if ( xi > input_data.fg_mask.size_x() ) xi = input_data.fg_mask.size_x();
	    	if ( xf < 0 ) xf = 0; else if ( xf > input_data.fg_mask.size_x() ) xf = input_data.fg_mask.size_x();
	    	if ( yi < 0 ) yi = 0; else if ( yi > input_data.fg_mask.size_y() ) yi = input_data.fg_mask.size_y();
	    	if ( yf < 0 ) yf = 0; else if ( yf > input_data.fg_mask.size_y() ) yf = input_data.fg_mask.size_y();         	
	
	   		// Search the dimensions of the blobs in the initialization area
	    	for( uint64 i = xi; i < xf ; i++ )
	    	{
	    		for( uint64 j = yi; j < yf ; j++ )
	    		{
	    			if( input_data.fg_mask( GRAY_CHANNEL )[ i ][ j ] == 255 )
	    			{
	    				count++;
	    			}
	    		}
	    	}
	    	
	    	float64 TotalNumberOfPixels = _size.x() * _size.y();
	    		            	
	    	if ( count > TotalNumberOfPixels )
	    	{
	    		_fg_pixels = 1.0;
	    	}
	    	else if ( count == 0 ) 
	    	{
	    		_fg_pixels = 0.0;
	    	}
	    	else
	    	{
	    		_fg_pixels = static_cast< float64 > ( count / TotalNumberOfPixels );        
	    	}
	    }
    
		float64 TumultParticle::batt_distance( const HistogramType& hist_ref_UV, const HistogramType& hist_particle )
		{	                        	
			float64 Ro = 0;
			            
			// Check if both histograms are comparable
			ASSERT( hist_particle.num_bins()[0] == hist_ref_UV.num_bins()[0], "ERROR(histogram not same number of bins): histograms are not comparable!\n" );
			ASSERT( hist_particle.num_bins()[1] == hist_ref_UV.num_bins()[1], "ERROR(histogram not same number of bins): histograms are not comparable!\n" );
			ASSERT( hist_particle.num_elements() == hist_ref_UV.num_elements(), "ERROR(histogram not same number of elements): histograms are not comparable!\n" );
			
			// Check if one histogram is null(empty)
			ASSERT( hist_ref_UV.num_points() > 0, "ERROR(hist_ref is empty): treat the case before using the function!\n" );	
			ASSERT( hist_particle.num_points() > 0, " ERROR(hist_particle is empty): treat the case before using the function!\n" );
		
			// Compute distance	            						
			for( uint64 i = 0; i < hist_ref_UV.num_elements(); i++ )
			{	
				float64 p_in = hist_ref_UV.data()[i];
				float64 p_out = hist_particle.data()[i];
				Ro += std::sqrt( p_in * p_out );
			}
																
			float64 distance = 1 - Ro;					
			return ( distance );	            	
		}
    
	    void TumultParticle::update_particles_in_filter( const input_data_type& input_data )
	    {
	    	uint64 k = static_cast< uint64 >( _position.y() );
	    	
	    	if( k >= input_data.current_image.size_y() )
	    	{
	    		k = input_data.current_image.size_y() - 1;
	    	}
	    	if( k < 0 )
	    	{
	    		k = 0;
	    	}
	    	
	    	_size.x() = input_data.environment.w[ k ];
	    	_size.y() = input_data.environment.h[ k ];
	    	_variance = input_data.environment.var[ k ];
	    	
	    	// Update Histogram
	    	ImageMask tmp_mask( input_data.fg_mask.size_x(), input_data.fg_mask.size_y() );	            	
	    	tmp_mask = 0;
	    	
	    	uint64 xi = static_cast< uint64 > ( _position.x() - _size.x()/2 );
	    	uint64 xf = static_cast< uint64 > ( _position.x() + _size.x()/2 );
	    	uint64 yi = static_cast< uint64 > ( _position.y() - _size.y()/2 );
	    	uint64 yf = static_cast< uint64 > ( _position.y() + _size.y()/2 );
	
	    	// Error control for xi, xf, yi & yf to not exceed the limits of the image
			if ( xi < 0 ) xi = 0; else if ( xi >= input_data.fg_mask.size_x() ) xi = input_data.fg_mask.size_x() - 1;
			if ( xf < 0 ) xf = 0; else if ( xf >= input_data.fg_mask.size_x() ) xf = input_data.fg_mask.size_x() - 1;
			if ( yi < 0 ) yi = 0; else if ( yi >= input_data.fg_mask.size_y() ) yi = input_data.fg_mask.size_y() - 1;
			if ( yf < 0 ) yf = 0; else if ( yf >= input_data.fg_mask.size_y() ) yf = input_data.fg_mask.size_y() - 1;
	    	
	    	for( uint64 i = xi; i < xf; i++ )
	    	{
	    		for( uint64 j = yi; j < yf; j++ )
	    		{
	    			if( input_data.fg_mask( GRAY_CHANNEL )[i][j] == 255 ) //FG
	    			{
	    				tmp_mask[i][j] = true;
	    			}
	    		}
	    	}
	
	    	CollaborativeDescriptors coll_vd;
	    	_hist_particle.calculate( input_data.current_image.colors_begin(tmp_mask),
	    	                          input_data.current_image.colors_end(tmp_mask),
	    	                          &(tmp_mask.coll_vd()));
	    	
//	    	_hist_particle.mask( tmp_mask ); // Set mask: FG + Particle size
//	    	_hist_particle.calculate( input_data.current_image );
	    }	
    }
}

//
// Methods of the TumultParticleFilter
//
namespace imageplus 
{

    namespace particlefilters
    {

	    void TumultParticleFilter::filter( const input_data_type& input_data )
	    {	            	
	    	resample();  	
	    	
	    	propagate( input_data );
//        	propagate_with_morphing( input_data );
//	    	std::cout << "Propagate con input_data" << std::endl;
	    	float64 total_weight = evaluate( input_data );
	    	        	
	    	normalize( total_weight );    	
	    }
    
    	void TumultParticleFilter::propagate( const input_data_type& input_data )
	    {
	    	for ( uint64 i = 0; i < number_of_particles(); i++ )
	    	{
	    		particles()[ i ].propagate( input_data );
	    	}
	    }
    
	    void TumultParticleFilter::propagate_with_morphing( const input_data_type& input_data)
	    {    				            				
			// Calutation of the angle (alpha) of rotation
			float64 opposite_side = input_data.environment.ini_point_x - input_data.environment.final_point_x;
			float64 next_side = input_data.environment.block_final_point_y - input_data.environment.block_ini_point_y; 
			
			//float64 pi = 3.14159265;
			float64 scaling_factor = 2.0;
			float64 alpha = atan( opposite_side / next_side ); // The alpha obtained is in RADIANS
			
			//float64 result = alpha * 180 / pi;
			//printf ("The arc tangent of %lf is %lf degrees\n", ( opposite_side / next_side ), result );
			
			for ( uint64 i = 0; i < number_of_particles(); i++ )
			{
				float64 pos_x_old = particles()[i].rand_gauss( particles()[i].position().x() );
				float64 pos_y_old = particles()[i].rand_gauss( particles()[i].position().y() );
			
				// Traslation to the center of coordinates (0,0) from the PF's centroid
				float64 pos_x = pos_x_old - _position.x();
				float64 pos_y = pos_y_old - _position.y();
			
				// Scaling x2 the y value (if yNew is bigger than yOld) 
				if ( pos_y_old >= particles()[i].position().y() )
				{
					pos_y = scaling_factor * pos_y;
				}
			
				// Rotating the point with alpha (alpha is been given by the ramp inclination)
				float64 pos_x_new = std::cos(alpha) * pos_x - std::sin(alpha) * pos_y; 
				float64 pos_y_new = std::sin(alpha) * pos_x + std::cos(alpha) * pos_y;
			
				// Traslation from the center of coordinates (0,0) to the PF's centroid
				pos_x_new += _position.x();
				pos_y_new += _position.y();
				
				particles()[i].position().x() = pos_x_new;
				particles()[i].position().y() = pos_y_new;
				
				// Control that doesn't exceeds image size
				if ( particles()[i].position().x() < 0 ) 
				{
					particles()[i].position().x() = 0; 
				}
				else if ( particles()[i].position().x() >= input_data.current_image.size_x() )
				{
					particles()[i].position().x() = input_data.current_image.size_x() - 1;
				}
				
				if ( particles()[i].position().y() < 0 )
				{
					particles()[i].position().y() = 0; 
				}
				else if ( particles()[i].position().y() >= input_data.current_image.size_y() )
				{
					particles()[i].position().y() = input_data.current_image.size_y() - 1;
				}
				
				ASSERT( ( _position.x() >= 0 ) && ( _position.x() < input_data.current_image.size_x() ), " Propagation X exceeds image size\n" );
				ASSERT( ( _position.y() >= 0 ) && ( _position.y() < input_data.current_image.size_y() ), " Propagation Y exceeds image size\n" );
			}
	    }

    	void TumultParticleFilter::initialize_filter( const init_data_type& initialization_data, const input_data_type& input_data, ImageMask& creation_mask )
	    {
	    	_position = initialization_data.initial_position;
	    	_old_position.x() = 0;
	    	_old_position.y() = 0;
	    	_old_position.z() = 0;
	    	_variance = initialization_data.variance;
	    	_size = initialization_data.initial_size;
	    	
	    	_destruction_in = 0; 
	    	_destruction_out = -1; 
	    	_destruction_double = 0; 
	    	_destruction_on_top = 0;
	    	_destruction_efficiency = 0;
	    	
	    	_ready_to_update_pf = 0;   	

	    	// Store history of particle filter         	
	    	_history.resize( 0, TumultParticle( 1.0 ) );
	    	
	    	// Initializing tumult particle filter histogram only with the color of the blob
            _hist_ref.calculate( input_data.current_image.colors_begin(creation_mask),
                                 input_data.current_image.colors_end(creation_mask),
                                 &(creation_mask.coll_vd()));

//	    	_hist_ref.mask( creation_mask );
//        	_hist_ref.calculate( input_data.current_image );
        	
	    	init_particles( initialization_data );
	    }
       
	    void TumultParticleFilter::update_filter( const input_data_type& input_data, const TumultParticle& result_particle )
	    {    	
	    	_old_position = _position;
	    	_position = result_particle.position();
	    	
	    	uint64 k = static_cast< uint64 >( _position.y() );
	    	
	    	if( k >= input_data.current_image.size_y() )
	    	{
	    		k = input_data.current_image.size_y() - 1;
	    	}
	    	if( k < 0 )
	    	{
	    		k = 0;
	    	}
	    	
	    	_size.x() = input_data.environment.w[ k ];
	    	_size.y() = input_data.environment.h[ k ];
	    	_variance = input_data.environment.var[ k ];
	    	
	    	// Calculate new Z
	    	adding_perspective_to_z( input_data );
	    	
	    	// Update speed
	    	speed_calculation_with_z( input_data );
	    	
	    	// TODO: Update Histogram from filter need histogram + and * (float64) operators
//        	float64 alpha = 0.5;
//    		_hist_ref = _hist_ref * ( 1 - alpha );
//    		_hist_ref = _hist_ref + result_particle.hist_particle() * alpha;
	    }	
    
	    void TumultParticleFilter::block_particles_out_ramp( const input_data_type& input_data )
	    {	            	
	    	for ( uint64 i = 0; i < number_of_particles(); i++ )
	    	{
	    		// The particle is inside the ramp margin 
	    		if( ( static_cast< int64 >( particles()[ i ].position().y() ) >= input_data.environment.block_ini_point_y ) 
	    				&& ( static_cast< int64 >( particles()[ i ].position().y() ) <= input_data.environment.block_final_point_y )  )
	    		{
	    			int64 estimated_position_y = static_cast< int64 >( ( input_data.environment.block_ramp_model_m * particles()[ i ].position().x() + input_data.environment.block_ramp_model_n ) );
	    			
//        			std::cout << "Estimated _position = " << estimated_position_y << " X_position = " << particles()[ i ].position().x() << " Y_position = " << particles()[ i ].position().y() << std::endl;
	    			
	    			if( estimated_position_y < 0 )
	    			{
	    				estimated_position_y = 0;
	    			}
	    			
	    			// If the estimated position in smaller than the actual position destroy particle
	    			if( input_data.environment.block_ramp_model_m < 0 )
	    			{		
	    				if( estimated_position_y < static_cast< int64 >( particles()[ i ].position().y() ) )
	    				{
	    					particles()[ i ].weight( 0.0 );
	    				}
	    			}
	    			else
	    			{
	    				if( estimated_position_y > static_cast< int64 >( particles()[ i ].position().y() ) )
	    				{
	    					particles()[ i ].weight( 0.0 );
	    				}
	    			}
	    		}    			          		
	    	}
	    }
    
	    void TumultParticleFilter::block_particles_far_from_ramp( const input_data_type& input_data )
	    {           		       	            	
	    	for ( uint64 i = 0; i < number_of_particles(); i++ )
	    	{
	    		// The particle is inside the ramp margin
	    		if( ( static_cast< int64 >( particles()[ i ].position().y() ) >= input_data.environment.block_ini_point_y ) 
	    				&& ( static_cast< int64 >( particles()[ i ].position().y() ) <= input_data.environment.block_final_point_y )  )
	    		{
	    			int64 estimated_position_x = static_cast< int64 >( ( static_cast< int64 >( particles()[ i ].position().y() ) - input_data.environment.ramp_model_n ) / input_data.environment.ramp_model_m );
	    				            			                      	           			
	    			int64 max_error = static_cast< int64 >( 2 * _size.x() );
	    			
	    			int64 max_far_from_ramp_x =  estimated_position_x + max_error;
	    			
	    			// If the estimated position in bigger than the particle maximum far position destroy particle
	    			if( input_data.environment.ramp_model_m < 0 )
	    			{	
	    				if( max_far_from_ramp_x < static_cast< int64 >( particles()[ i ].position().x() ) )
	    				{
	    					particles()[ i ].weight( 0.0 );
	    				}
	    			}
	    			else
	    			{
	    				std::cout << "ERROR(RAMP MODEL): Ramp model incorrect, it should be increasing, not decreasing!\n" << std::endl;
	    			}
	    		}
	    	}
	    }
    
	    void TumultParticleFilter::block_particles_too_far( const input_data_type& input_data )
	    {
			uint64 far_error_value = 150; // Modify if it is desired to increase how far the filters will be destroyed            	
	    		            	
	    	for ( uint64 i = 0; i < number_of_particles(); i++ )
	    	{
	        	// Calculating the Far max margin the particle can get to be allowed as good in X & Y
	    		uint64 x_centroid_max_far = static_cast< uint64 >( ( ( far_error_value * _size.x() ) / 100 ) );
	    		uint64 y_centroid_max_far = static_cast< uint64 >( ( ( far_error_value * _size.y() ) / 100 ) );
	        		
	    		uint64 max_centroid_x_far = static_cast< uint64 >( _position.x() ) + x_centroid_max_far;
	    		uint64 max_centroid_y_far = static_cast< uint64 >( _position.y() ) + y_centroid_max_far;
	    		uint64 min_centroid_x_far = static_cast< uint64 >( _position.x() - x_centroid_max_far );
	    		uint64 min_centroid_y_far = static_cast< uint64 >( _position.y() - y_centroid_max_far );
	        		
	        	if ( max_centroid_x_far < 0 )
	        	{
	        		max_centroid_x_far = 0; 
	        	}
	        	else if ( max_centroid_x_far >= input_data.current_image.size_x() )
	        	{
	        		max_centroid_x_far = input_data.current_image.size_x() - 1;
	        	}
	        	if ( max_centroid_y_far < 0 )
	        	{
	        		max_centroid_y_far = 0; 
	        	}
	        	else if ( max_centroid_y_far >= input_data.current_image.size_y() )
	        	{
	        		max_centroid_y_far = input_data.current_image.size_y() - 1;
	        	}
	        	if ( min_centroid_x_far < 0 )
	        	{
	        		min_centroid_x_far = 0; 
	        	}
	        	else if ( min_centroid_x_far >= input_data.current_image.size_x() )
	        	{
	        		min_centroid_x_far = input_data.current_image.size_x() - 1;
	        	}
	        	if ( min_centroid_y_far < 0 )
	        	{
	        		min_centroid_y_far = 0; 
	        	}
	        	else if ( min_centroid_y_far >= input_data.current_image.size_y() )
	        	{
	        		min_centroid_y_far = input_data.current_image.size_y() - 1;
	        	}
	
	    		// If the actual position of the particle is outside the margin we destroy it
	    		if( ( particles()[ i ].position().x() < min_centroid_x_far ) || ( particles()[ i ].position().x() > max_centroid_x_far ) 
	    				|| ( particles()[ i ].position().y() < min_centroid_y_far ) || ( particles()[ i ].position().y() > max_centroid_y_far ) ) 
	    		{
	    			particles()[ i ].weight( 0.0 );			
	    		}	
	    	}
	    }    
    
		const uint64& TumultParticleFilter::id() const
		{
			return( _id );
		}
		
		void TumultParticleFilter::id( const uint64 id )
		{
			_id = id;
		}
		
		const Coord3D< float64 >& TumultParticleFilter::position() const
		{
			return _position;
		}
			
		Coord3D< float64 >& TumultParticleFilter::position()
		{
			return _position;
		}
		
		const Coord3D< float64 >& TumultParticleFilter::old_position() const
		{
			return _old_position;
		}
		
		const float64& TumultParticleFilter::speed() const
		{
			return _speed;
		}
		
		const Coord2D< float64 >& TumultParticleFilter::size() const
		{
			return _size;
		}
		
		std::vector< TumultParticle >& TumultParticleFilter::history()
		{
		  	return _history;
		}
		
		const int64& TumultParticleFilter::destruction_in() const
		{
			return( _destruction_in );
		}
		
		void TumultParticleFilter::destruction_in( const int64 value )
		{
			_destruction_in = value;
		}
		
		const int64& TumultParticleFilter::destruction_out() const
		{
			return( _destruction_out );
		}
		
		void TumultParticleFilter::destruction_out( const int64 value )
		{
			_destruction_out = value;
		}
		
		const int64& TumultParticleFilter::destruction_double() const
		{
			return( _destruction_double );
		}
		
		void TumultParticleFilter::destruction_double( const int64 value )
		{
			_destruction_double = value;
		}
		
		const int64& TumultParticleFilter::destruction_on_top() const
		{
			return( _destruction_on_top );
		}
		
		void TumultParticleFilter::destruction_on_top( const int64 value )
		{
			_destruction_on_top = value;
		}
		
		const int64& TumultParticleFilter::destruction_efficiency() const
		{
			return( _destruction_efficiency );
		}
		
		void TumultParticleFilter::destruction_efficiency( const int64 value )
		{
			_destruction_efficiency = value;
		}
		
		const int64& TumultParticleFilter::ready_to_update_pf() const
		{
			return( _ready_to_update_pf );
		}
		
		void TumultParticleFilter::ready_to_update_pf( const int64 value )
		{
			_ready_to_update_pf = value;
		}		
		
	    void TumultParticleFilter::adding_perspective_to_z( const input_data_type& input_data )
	    {           	
	    	float64 blob_height_cm = 180;
	    		
	    	// Inverting Z so ZERO is at the bottom of the ramp
	    	float64 inveterd_z = input_data.current_image.size_y() - 1 - position().y();
	    		
	    	if( inveterd_z < 0.0 )
	    	{
	    		inveterd_z = 0.0;
	    	}
	    	else if ( inveterd_z >= input_data.current_image.size_y() )
	    	{
	    		inveterd_z = input_data.current_image.size_x() - 1;
	    	}
	             	
	    	// Calculating the scale factor that depends on perspective (ENVIRONMENT)
	    	uint64 k = static_cast< uint64 > ( position().y() );
	    	
	    	if( k >= input_data.current_image.size_y() )
	    	{
	    		k = input_data.current_image.size_y() -1;
	    	}
	    	if( k < 0 )
	    	{
	    		k = 0;
	    	}
	    	
	    	int64 height = input_data.environment.h[ k ];
	    	
	    	// Calculating the relation in cm/pixels of a blob in the current position
	    	float64 scale_factor = blob_height_cm / height; 
	
	    	float64 new_z = inveterd_z * scale_factor;
	    	
	    	// Projecting the expanded axis to the ramp
	    	uint64 opposite_side = input_data.environment.ini_point_x - input_data.environment.final_point_x;
	    	uint64 next_side = input_data.environment.final_point_y - input_data.environment.ini_point_y; 
	    	
	    	// Calculation of the angle (alpha) of rotation
	    	float64 alpha = atan( opposite_side / static_cast< float64 > ( next_side ) ); // The alpha obtained is in RADIANS
	    	
	    	float64 real_z = new_z / cos( alpha );
	
	    	_position.z() = real_z;
	    }
    
	    void TumultParticleFilter::speed_calculation_with_z( const input_data_type& input_data )
	    {	            	
	    	uint64 frames_per_second = 2;
	
	    	// With the Z value 
	    	if( _old_position.z() != 0.0 ) // So that the PF has at least 2 points
	    	{
	    		// As the Z is Inverted we calculate the speed as a negative distance to obtain a positive speed
	    		float64 distance_z = _old_position.z() - position().z();
	    	
	    		_speed = distance_z * frames_per_second;
	    	}		            	
	    }	
	}
}
