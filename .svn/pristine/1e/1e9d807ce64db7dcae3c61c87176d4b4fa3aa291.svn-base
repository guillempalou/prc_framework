// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------

//!
//!  \file imageplus/core/colorspace_descriptors.hpp
//!

#ifndef IMAGEPLUS_CORE_COLORSPACE_DESCRIPTORS_HPP
#define IMAGEPLUS_CORE_COLORSPACE_DESCRIPTORS_HPP


#include <imageplus/core/visual_descriptors.hpp>
#include <imageplus/core/bounding_box.hpp>
#include <imageplus/core/convert_colorspace.hpp>
#include <imageplus/core/imagegray.hpp>
#include <imageplus/core/imagecielab.hpp>
#include <imageplus/core/imageyuv.hpp>



namespace imageplus
{
    //!
    //! \brief Class for visual descriptor that contains the image in the original color space.
    //!
    //! \note In principle, this descriptor should be computed only for the whole image and then reused for each region for efficiency purposes
    //!
    //! Template InputModel refers to the model of the input: ImageRGB<uint8>, ImageGray<uint8>, etc.
    //!
    //! \author Carles Ventura <alcarles@gps.tsc.upc.edu>
    //!
    //! \date 28-7-2009
    template<class InputModel>
    class VDOriginalImage : public DescriptorBase,
                            public InputModel
    {
    public:

        //!
        //! \brief Default constructor
        VDOriginalImage() : DescriptorBase("VDOriginalImage",false), InputModel()
        {
        }

        //! \brief It transforms the image or region to YUV color space.
        //!
        //! \param[in] first : Iterator to the beginning of the image
        //! \param[in] last : Iterator to the end of the image
        //! \param[in] peer_descs : Pointer to CollaborativeDescriptors, in principle is never 0x0 but it is a good idea to ASSERT it
        template< class IteratorModel >
        void calculate(IteratorModel first, IteratorModel last, CollaborativeDescriptors* peer_descs)
        {
            ASSERT(peer_descs!=0x0, "VDOriginalImage calculate: peer_descs must be non null");

            const BoundingBox<typename InputModel::CoordType>& bb_coord = peer_descs->calculate(new BoundingBox<typename InputModel::CoordType>(), first, last);

            this->resize(bb_coord.sides());
            this->reindex(bb_coord.origin());
            for(; first!=last; ++first)
            {
                (*this)((*first).position()) = (*first).value();
            }
        }
    };



    //!
    //! \brief Class for visual descriptor that contains the image in the gray color space.
    //!
    //! \note In principle, this descriptor should be computed only for the whole image and then reused for each region for efficiency purposes
    //!
    //! Template InputModel refers to the model of the input: ImageRGB<uint8>, ImageGray<uint8>, etc.
    //!
    //! \author Carles Ventura <alcarles@gps.tsc.upc.edu>
    //!
    //! \date 28-7-2009
    template<class InputModel>
    class VDImageGray : public DescriptorBase,
                        public ImageGray<typename InputModel::data_type>
    {
    public:

        //!
        //! \brief Default constructor
        //!
        VDImageGray() : DescriptorBase("VDImageGray",false),
                        ImageGray<typename InputModel::data_type>()
        {
        }

        //! \brief Transforms the image to gray.
        //!
        //! \param[in] first : Iterator to the beginning of the image
        //! \param[in] last : Iterator to the end of the image
        //! \param[in] peer_descs : Pointer to CollaborativeDescriptors, in principle is never 0x0 but it is a good idea to ASSERT it
        template< class IteratorModel >
        void calculate(IteratorModel first, IteratorModel last, CollaborativeDescriptors* peer_descs)
        {
            if((InputModel::channels == 3)||(InputModel::channels == 1))
            {
                const BoundingBox<typename InputModel::CoordType>& bb_coord = peer_descs->calculate(new BoundingBox<typename InputModel::CoordType>(), first, last);

                this->resize(bb_coord.sides());
                InputModel image(bb_coord.side(0), bb_coord.side(1));
                image.reindex(bb_coord.origin());
                for(; first!=last; ++first)
                {
                    image((*first).position()) = (*first).value();
                }
                *(static_cast<ImageGray<typename InputModel::data_type>*>(this)) = to_gray(image);
                this->reindex(bb_coord.origin());  // This should not be necessary, but the functions to convert colorspace do not propagate indexes
            }
            else
            {
                throw ImagePlusError("Number of channels must be 1 or 3");
            }
        }
    };




    //!
    //! \brief Class for visual descriptor that contains the image or region in the YUV color space.
    //!
    //! \note In principle, this descriptor should be computed only for the whole image and then reused for each region for efficiency purposes
    //!
    //! Template InputModel refers to the model of the input: ImageRGB<uint8>, ImageGray<uint8>, etc.
    //!
    //! \author Carles Ventura <alcarles@gps.tsc.upc.edu>
    //!
    //! \date 28-7-2009
    template<class InputModel>
    class VDImageYUV : public DescriptorBase,
                       public ImageYUV<typename InputModel::data_type>
    {
    public:

        //!
        //! \brief Default constructor
        VDImageYUV() : DescriptorBase("VDImageYUV",false),
                       ImageYUV<typename InputModel::data_type>()
        {
        }

        //! \brief It transforms the image or region to YUV color space.
        //!
        //! \param[in] first : Iterator to the beginning of the image
        //! \param[in] last : Iterator to the end of the image
        //! \param[in] peer_descs : Pointer to CollaborativeDescriptors, in principle is never 0x0 but it is a good idea to ASSERT it
        template< class IteratorModel >
        void calculate(IteratorModel first, IteratorModel last, CollaborativeDescriptors* peer_descs)
        {
            if(InputModel::channels == 3)
            {
                const BoundingBox<typename InputModel::CoordType>& bb_coord = peer_descs->calculate(new BoundingBox<typename InputModel::CoordType>(), first, last);

                this->resize(bb_coord.sides());
                InputModel image(bb_coord.side(0), bb_coord.side(1));
                image.reindex(bb_coord.origin());
                for(; first!=last; ++first)
                {
                    image((*first).position()) = (*first).value();
                }
                ImageYUV<typename InputModel::data_type> tmp = to_yuv(image);
                *(static_cast<ImageYUV<typename InputModel::data_type>*>(this)) = to_yuv(image);
                this->reindex(bb_coord.origin());  // This should not be necessary, but the functions to convert colorspace do not propagate indexes
            }
            else
            {
                throw ImagePlusError("Number of channels must be 3");
            }
        }
    };




    //!
    //! \brief Class for visual descriptor that contains the image or region in the CIE Lab color space.
    //!
    //! \note In principle, this descriptor should be computed only for the whole image and then reused for each region for efficiency purposes
    //!
    //! Template InputModel refers to the model of the input: ImageRGB<uint8>, ImageGray<uint8>, etc.
    //!
    //! \author Carles Ventura <cventura@gps.tsc.upc.edu>
    //!
    //! \date 17-3-2010
    template<class InputModel>
    class VDImageCIELab : public DescriptorBase,
                          public ImageCIELab<typename InputModel::data_type>
    {
    public:

        //!
        //! \brief Default constructor
        VDImageCIELab() : DescriptorBase("VDImageCIELab",false),
                          ImageCIELab<typename InputModel::data_type>()
        {
        }

        //! \brief It transforms the image or region to CIE Lab color space.
        //!
        //! \param[in] first : Iterator to the beginning of the image
        //! \param[in] last : Iterator to the end of the image
        //! \param[in] peer_descs : Pointer to CollVD, in principle is never 0x0 but it is a good idea to ASSERT it
        template< class IteratorModel >
        void calculate(IteratorModel first, IteratorModel last, CollaborativeDescriptors* peer_descs)
        {
            if(InputModel::channels == 3)
            {
                const BoundingBox<typename InputModel::CoordType>& bb_coord = peer_descs->calculate(new BoundingBox<typename InputModel::CoordType>(), first, last);

                this->resize(bb_coord.sides());
                InputModel image(bb_coord.side(0), bb_coord.side(1));
                image.reindex(bb_coord.origin());
                for(; first!=last; ++first)
                {
                    image((*first).position()) = (*first).value();
                }
                *(static_cast<ImageCIELab<typename InputModel::data_type>*>(this)) = to_cielab(image);
                this->reindex(bb_coord.origin());  // This should not be necessary, but the functions to convert colorspace do not propagate indexes
            }
            else
            {
                throw ImagePlusError("Number of channels must be 3");
            }
        }
    };
}
#endif

