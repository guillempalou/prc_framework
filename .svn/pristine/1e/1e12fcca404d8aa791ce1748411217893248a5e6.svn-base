// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------

//!
//!  \file trainer.cpp
//!
//!  Trainer
//!

#include <string>

#include <boost/assign.hpp>
#include <boost/filesystem.hpp>
#include <boost/foreach.hpp>
#include <boost/format.hpp>

#include <imageplus/core.hpp>

#include <imageplus/descriptors/color/color_structure.hpp>

#include <imageplus/io/readimage.hpp>

#include <imageplus/machine_learning/svm/svm_adaptors.hpp>

#include <imageplus/semantic/annotatedsemanticclass.hpp>
#include <imageplus/semantic/instance.hpp>
#include <imageplus/semantic/models.hpp>
#include <imageplus/semantic/model.hpp>
#include <imageplus/semantic/modelpart.hpp>
#include <imageplus/semantic/observation.hpp>
#include <imageplus/semantic/readwriteannotation.hpp>
#include <imageplus/semantic/readwritemodels.hpp>
#include <imageplus/semantic/trainer.hpp>
#include <imageplus/semantic/trainset.hpp>

#ifdef USE_XML
#include <imageplus/io/xml_auxiliar.hpp>
XERCES_CPP_NAMESPACE_USE
#endif

using namespace imageplus;
using namespace imageplus::descriptors;
using namespace imageplus::io;
using namespace imageplus::machine_learning::svm;
using namespace imageplus::semantic;

Trainer::Trainer(const std::string& annotation_filename, const std::string& output_dir) throw (ImagePlusError)
{
	_annotation_filename = annotation_filename;
    ReadWriteAnnotation rw_annotation(_annotation_filename);
    rw_annotation >> _annotation;

    _output_dir = output_dir;
	boost::filesystem::path output_path = _output_dir;
    if (!boost::filesystem::is_directory(output_path))
        throw ImagePlusError("Trainer: Output directory " + output_path.string() + " not found.");
}

void Trainer::train()
{
	// FIXME better as a parameter?
	std::list<std::string> visual_descriptors = boost::assign::list_of("ColorStructure");

	Ontology ontology = _annotation.get_ontology();
	Models<SVM> models;
	models.set_ontology(ontology);
	BOOST_FOREACH(int semantic_class_id, ontology)
	{
		if (_annotation.semantic_class_is_annotated(semantic_class_id))
		{
			AnnotatedSemanticClass asc = _annotation.get_annotated_semantic_class(semantic_class_id);

			TrainSet train_set;
			_build_trainset(train_set, asc, visual_descriptors);

			ModelPart<SVM> model_part;
			_train_model_part(model_part, train_set, visual_descriptors);

			models.get_model(semantic_class_id).add_part(model_part);
		}
	}

	// save trained models to disk
	boost::filesystem::path models_path = _output_dir;
    models_path /= "index.xml";
	ReadWriteModels rw_models(models_path.string());
	rw_models << models;
}

void Trainer::_build_trainset(TrainSet& train_set, const AnnotatedSemanticClass& asc, const std::list<std::string>& visual_descriptors)
{
	for (size_t instance_type=0; instance_type<Instance::NUM_INSTANCE_TYPES; instance_type++)
	{
		AnnotatedSemanticClass::AnnotationInstancesType instances;
		instances = asc.get_instances(static_cast<Instance::InstanceType>(instance_type));
		BOOST_FOREACH(Instance instance, instances)
		{
			Observation obs;
			BOOST_FOREACH(std::string vd_name, visual_descriptors)
				obs.add_vd_featurevector(vd_name, _read_descriptor(instance.get_media_uri(), vd_name));
			train_set.add_observation(obs, static_cast<Instance::InstanceType>(instance_type));
		}
	}
}

void Trainer::_train_model_part(ModelPart<SVM>& model_part, const TrainSet& train_set, const std::list<std::string>& visual_descriptors)
{
	BOOST_FOREACH(std::string vd_name, visual_descriptors)
	{
		LabelsType labels;
		InputDataType input_data;

		for (int instance_type=0; instance_type<Instance::NUM_INSTANCE_TYPES; instance_type++)
		{
			TrainSet::ObservationsType observations;
			observations = train_set.get_observations(static_cast<Instance::InstanceType>(instance_type));
			BOOST_FOREACH(Observation observation, observations)
			{
				// add features vector for this observation and visual descriptor
				input_data.push_back(observation.get_vd_featurevector(vd_name));

				// add label (positive/negative) of this features vector
				labels.push_back(static_cast<float64>(instance_type));
			}
		}
		SVM svm_trainer;
		svm_trainer.input_data(input_data, labels);
		svm_trainer.search_parameters();
		svm_trainer.train();
		model_part.add_vd_classifier(vd_name, svm_trainer);
	}
}

Observation::FeatureVector Trainer::_read_descriptor(const std::string& filename, const std::string& vd_name) const throw (ImagePlusError)
{
#ifdef USE_XML
	/* This definition will be useful in this case*/
	typedef ImageRGB<uint8> ImageType;

	/* It will contain the uris related to the previous XML file ("ImageFile", "ThumbnailFile", "PartitionSearchFile", "BinaryPartitionTree") */
	std::map<std::string, std::string> uris;
	/* The XML header is read. The uris explained before are saved */
	boost::filesystem::path full_filename = boost::filesystem::current_path() / filename;
	XERCES_CPP_NAMESPACE::DOMNode *image_node = bpt_xml_read_header(full_filename.string(), uris);

	/* The read operator is used for reading the Image, which is saved in my_image */
	ReadImage ri(uris["ImageFile"]);
	ImageType my_image;
    ri >> my_image;

    /* First, we have to obtain the pointer to the XML node corresponding to the region Region1 (this is an image, only 1 region) */
	XERCES_CPP_NAMESPACE::DOMNode *region_node = bpt_xml_search_region(image_node, my_image);

	// READ VISUAL DESCRIPTOR FROM XML
	read_descriptor(new ColorStructure<ImageType>(), region_node, my_image);

	/* We get the descriptors from my_reg by using the function get_descriptor. The identifier of the descriptor we want to get must be given. */
	ColorStructure<ImageType> color_structure_vd = get_descriptor<ColorStructure<ImageType> > ("ColorStructure", my_image);

	/* Return de FeatureVector for the descriptor */
	return color_structure_vd.fv();
#else // No USE_XML
	throw ImagePlusError("Enable the flag USE_XML for _read_descriptor.");
#endif
}
