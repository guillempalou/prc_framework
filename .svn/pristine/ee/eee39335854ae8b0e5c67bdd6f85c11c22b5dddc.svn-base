/*
 * occlusion_cost.hpp
 *
 *  Created on: Dec 20, 2012
 *      Author: gpalou
 */

#ifndef OCCLUSION_COST_HPP_
#define OCCLUSION_COST_HPP_

#include <imageplus/bpt/energy_minimization/optimal_pruner.hpp>

namespace imageplus {
	namespace bpt {

	template<class BPT, class InputModel>
	class OcclusionCost : public RegionCostFunction<BPT,InputModel> {

		typedef RegionCostFunction<BPT,InputModel> 		BaseClassType;
		typedef typename InputModel::coord_type			coord_type;

	public:

		OcclusionCost(descriptors::DescriptorManager& manager, uint64 max_label, float64 lambda = 0.001) : BaseClassType(manager,max_label,lambda), _computed(false) {
		}

		float64 region_cost(BPT& bpt, InputModel& video, uint64 region_id) {

			if (_computed)
				return _precomputed[region_id] + BaseClassType::_lambda;

			_computed = true;

			//if (region_id == bpt.max_label())  {
			//	_precomputed[region_id] = 1e3;
			//	return _precomputed[region_id];
			//}

			uint64 N = _relations.size();

			for (uint64 i = 0; i < N; i++) {
				coord_type a = _relations[i].first;
				coord_type b = _relations[i].second;

				std::set<uint64> sa = get_regions_for_point(bpt,a);
				std::set<uint64> sb = get_regions_for_point(bpt,b);

				std::vector<uint64> regions(std::min(sa.size(),sb.size()));
				std::vector<uint64>::iterator fin = std::set_intersection(sa.begin(), sa.end(), sb.begin(), sb.end(), regions.begin());

				for (std::vector<uint64>::iterator k = regions.begin(); k != fin; k++) {
					_precomputed[*k]+= 1.0/N;
				}
			}

			//for (std::map<uint32,float64>::iterator it = _precomputed.begin(); it != _precomputed.end(); ++it) {
			//	std::cout << it->first << " " << it->second << std::endl;
			//}

			return _precomputed[region_id] + BaseClassType::_lambda;
		}


		std::set<uint64> get_regions_for_point(BPT& bpt, coord_type p) {
			std::set<uint64> regs;

			uint64 r = bpt.leaves_partition()(p)(0);

			do {
				regs.insert(r);
				r = bpt(r).parent()->label();
			} while (bpt(r).parent() != NULL);
			regs.insert(r);

			return regs;
		}

		void set_occlusion_relations(std::vector<std::pair<coord_type,coord_type> >& relations) {
			_relations = relations;
		}

	public:

		std::vector<std::pair<coord_type,coord_type> > _relations;
		std::map<uint32,float64> _precomputed;
		bool _computed;

	};


	}
}



#endif /* OCCLUSION_COST_HPP_ */
