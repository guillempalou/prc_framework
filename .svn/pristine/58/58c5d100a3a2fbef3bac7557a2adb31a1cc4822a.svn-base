// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------

//!
//!  \file readwriteannotation.cpp
//!
//!  Implementation of classes for reading and writing Annotations to/from disk
//!

#include <list>
#include <map>
#include <string>

#include <boost/foreach.hpp>
#include <boost/lexical_cast.hpp>

#include <imageplus/core.hpp>

#include <imageplus/io/pugixml/pugixml.hpp>
#include <imageplus/io/pugixml/foreach.hpp>
#include <imageplus/io/readwritepartition.hpp>

#include <imageplus/semantic/annotatedsemanticclass.hpp>
#include <imageplus/semantic/annotation.hpp>
#include <imageplus/semantic/instance.hpp>
#include <imageplus/semantic/ontology.hpp>
#include <imageplus/semantic/readwriteannotation.hpp>
#include <imageplus/semantic/readwriteontology.hpp>

using namespace imageplus;
using namespace imageplus::semantic;

imageplus::semantic::ReadWriteAnnotation::ReadWriteAnnotation(const std::string& filename) throw (ImagePlusError)
{
	open(filename);
}

void imageplus::semantic::ReadWriteAnnotation::open(const std::string& filename) throw (ImagePlusError)
{
	_filename = filename;
	if (_filename.find("file:") == 0)
	{
		 // FIXME IT'S AN URI! ("file:/path/to/file.xml" -> "/path/to/file.xml")
		_filename.erase(0, 5);
	}

    boost::filesystem::path file_path(_filename);
    boost::filesystem::path filename_branch(file_path.branch_path());
    if (!boost::filesystem::exists(filename_branch) && filename_branch.string()!="")
        throw ImagePlusError( "ReadWriteAnnotation: Directory " + filename_branch.string() + " not found." );
}

void imageplus::semantic::ReadWriteAnnotation::read(Annotation& annotation) const throw (ImagePlusError)
{
	pugi::xml_document doc;
	pugi::xml_parse_result result = doc.load_file(_filename.c_str());

	if (! result)
	{
		std::stringstream error;
		error << "XML [" << _filename << "] parsed with errors." << std::endl;
		error << "XML Error description: " << result.description() << std::endl;
		error << "XML Error offset: " << result.offset << std::endl;
		throw ImagePlusError(error.str());
	}

	if (! doc.child("Mpeg7"))
		throw ImagePlusError("XML reading: 'Mpeg7' node not found");

	// Mpeg7
	pugi::xml_node mpeg7_node = doc.child("Mpeg7");

	// Ontology
	pugi::xml_node ont_desc_node = mpeg7_node.find_child_by_attribute("Description", "xsi:type", "urn:SemanticDescriptionType");
	pugi::xml_node ont_node = ont_desc_node.child("ConceptCollection").child("ConceptCollectionRef");

	Ontology ontology;
    ReadWriteOntology rw_ontology(ont_node.attribute("href").value());
    rw_ontology >> ontology;
    annotation.set_ontology(ontology);

    // Semantic classes
    pugi::xml_node model_desc_node = mpeg7_node.find_child_by_attribute("Description", "xsi:type", "urn:ModelDescriptionType");

    BOOST_FOREACH(pugi::xml_node model_node, model_desc_node)
    {
    	if (strcmp(model_node.name(), "Model") == 0)
    	{
			// Model[id]
			uint32 semantic_class_id = model_node.attribute("id").as_int();
			AnnotatedSemanticClass& asc = annotation.annotate(semantic_class_id);

			// Model/Semantics/Label/Name < already loaded in the ontology
			std::string semantic_class_name = model_node.child("Semantics").child("Label").child_value("Name");

			// Model/Collection{id=positive,neutral,negative}
			for (size_t instance_type=0; instance_type<Instance::NUM_INSTANCE_TYPES; instance_type++)
            {
            	const char *instance_type_name = Instance::instance_type_names[instance_type];

            	pugi::xml_node collection_node = model_node.find_child_by_attribute("Collection", "id", instance_type_name);
            	if (collection_node)
            	{
            	    BOOST_FOREACH(pugi::xml_node content_node, collection_node)
            	    {
            	    	pugi::xml_node image_node = content_node.child("Image");

						// Content/Image[id]
            	    	std::string image_id = image_node.attribute("id").value();

						// Content/Image/MediaLocator/{MediaUri,StreamID}
            	    	pugi::xml_node ml_node = image_node.child("MediaLocator");
            	    	std::string media_uri = ml_node.child_value("MediaUri");
            	    	uint32 stream_id = boost::lexical_cast<uint32>(ml_node.child_value("StreamID"));

						// Content/Image/Relation
            	    	float32 relation_strength = image_node.child("Relation").attribute("strength").as_float();

						// Content/Image/SpatialDecomposition/StillRegionRef[idref=*]
						std::list<std::string> still_regions;
            	    	BOOST_FOREACH(pugi::xml_node still_region_node, image_node.child("SpatialDecomposition"))
            	    	{
            	    		std::string still_region = still_region_node.attribute("idref").value();
            	    		still_regions.push_back(still_region);
            	    	}

						Instance instance = Instance(image_id, media_uri, stream_id, relation_strength, still_regions);
						asc.add_instance(instance, static_cast<Instance::InstanceType>(instance_type));

            	    } // foreach(collection_node)
            	}
            } // foreach(instance_types)
    	}
    } // foreach(model_desc_node)
}

void imageplus::semantic::ReadWriteAnnotation::operator>>(Annotation& annotation) const throw (ImagePlusError)
{
	read(annotation);
}

bool imageplus::semantic::ReadWriteAnnotation::write(const Annotation& annotation) const throw (ImagePlusError)
{
	pugi::xml_document doc;

	// Mpeg7
	pugi::xml_node mpeg7_node = doc.append_child("Mpeg7");
	mpeg7_node.append_attribute("xmlns") = "urn:mpeg:mpeg7:schema:2001";
	mpeg7_node.append_attribute("xmlns:xsi") = "http://www.w3.org/2001/XMLSchema-instance";


	// Ontology
	pugi::xml_node ont_desc_node = mpeg7_node.append_child("Description");
	ont_desc_node.append_attribute("xsi:type") = "urn:SemanticDescriptionType";
	ont_desc_node.append_attribute("xmlns:urn") = "urn:mpeg:mpeg7:schema:2001";

	pugi::xml_node ont_node = ont_desc_node.append_child("ConceptCollection").append_child("ConceptCollectionRef");
	ont_node.append_attribute("href") = annotation._ontology.get_file_uri().c_str();


	// Annotated Semantic classes
	pugi::xml_node model_desc_node = mpeg7_node.prepend_child("Description");
	model_desc_node.append_attribute("xsi:type") = "urn:ModelDescriptionType";
	model_desc_node.append_attribute("xmlns:urn") = "urn:mpeg:mpeg7:schema:2001";

	pugi::xml_node instrument_node = model_desc_node.append_child("DescriptionMetadata").append_child("Instrument");
	pugi::xml_node tool_name_node = instrument_node.append_child("Tool").append_child("Name");
	tool_name_node.append_child(pugi::node_pcdata).set_value("imageplus");

	BOOST_FOREACH(const AnnotatedSemanticClass& asc, annotation)
	{
		// Model[id]
		pugi::xml_node model_node = model_desc_node.append_child("Model");
		model_node.append_attribute("xsi:type") = "urn:CollectionModelType";
		model_node.append_attribute("id") = boost::lexical_cast<std::string>(asc._semantic_class).c_str();

		// Model/Semantics/Label/Name
		pugi::xml_node asc_name_node = model_node.append_child("Semantics").append_child("Label").append_child("Name");
		std::string semantic_class = annotation._ontology.get_semantic_class_name(asc._semantic_class);
		asc_name_node.append_child(pugi::node_pcdata).set_value(semantic_class.c_str());

		// Model/Collection{id=positive,neutral,negative}
		for (size_t instance_type=0; instance_type<Instance::NUM_INSTANCE_TYPES; instance_type++)
		{
			if (asc._instances[instance_type].size() > 0)
			{
				pugi::xml_node collection_node = model_node.append_child("Collection");
				collection_node.append_attribute("xsi:type") = "urn:ContentCollectionType";
				collection_node.append_attribute("id") = Instance::instance_type_names[instance_type];
				BOOST_FOREACH(Instance instance, asc._instances[instance_type])
				{
					pugi::xml_node content_node = collection_node.append_child("Content");
					content_node.append_attribute("xsi:type") = "urn:ImageType";

					// Content/Image[id]
					pugi::xml_node image_node = content_node.append_child("Image");
					image_node.append_attribute("id") = instance._image_id.c_str();

					// Content/Image/MediaLocator/{MediaUri,StreamID}
					pugi::xml_node ml_node = image_node.append_child("MediaLocator");
					pugi::xml_node media_uri_node = ml_node.append_child("MediaUri");
					media_uri_node.append_child(pugi::node_pcdata).set_value(instance._media_uri.c_str());
					pugi::xml_node stream_id_node = ml_node.append_child("StreamID");
					stream_id_node.append_child(pugi::node_pcdata).set_value(boost::lexical_cast<std::string>(instance._stream_id).c_str());

					// Content/Image/Relation
					image_node.append_child("Relation").append_attribute("strength") = instance._relation_strength;

					// Content/Image/SpatialDecomposition/StillRegionRef[idref=*]
					if (instance._spatial_decomposition.size() > 0)
					{
						pugi::xml_node spatial_decomposition_node = image_node.append_child("SpatialDecomposition");
						spatial_decomposition_node.append_attribute("id") = "Roots";
						BOOST_FOREACH(std::string still_region, instance._spatial_decomposition)
						{
							pugi::xml_node still_region_node = spatial_decomposition_node.append_child("StillRegionRef");
							still_region_node.append_attribute("idref") = still_region.c_str();
						} // foreach(still_region)
					}
				} // foreach(content_node)
			}
		} // foreach(instance_types)
	} // foreach(annotated_semantic_class)

	// save document to file
	return doc.save_file(_filename.c_str(), "  ", pugi::format_default, pugi::encoding_utf8);
}

bool imageplus::semantic::ReadWriteAnnotation::operator<<(Annotation& annotation) const throw (ImagePlusError)
{
	return write(annotation);
}
