// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------

//!
//!  \file room.cpp
//!
//! \author Josep Ramon Morros <morros@gps.tsc.upc.edu>
//! \author Marcel Alcoverro Vidal <marcel@gps.tsc.upc.edu>
//!  Implementation for Room class
//!

#include <cassert>
#include <imageplus/core/room.hpp>

using namespace imageplus;


template<typename T, int N>
Room<T,N>::Room ()
//: _volume(0,0,0), _offset(0,0,0)
{
}

template<typename T, int N>
Room<T,N>::Room (uint64 sizeX, uint64 sizeY, uint64 sizeZ, float64 voxel_size, Point3D offset)
//: _volume(sizeX,sizeY,sizeZ)
{
    std::vector<uint64> shape(3);
    shape[0] = sizeX; shape[1]=sizeY; shape[2]=sizeZ;
    for (uint64 c=0; c<N; c++)
    {
        this->_volume(c).resize(shape);
    }
    this->_offset = offset;
    this->_voxel_size = voxel_size;
}

template<typename T, int N>
Room<T,N>::Room (uint64 sizeX, uint64 sizeY, uint64 sizeZ, float64 voxel_size)
        : _offset(0,0,0)
{
    std::vector<uint64> shape(3);
    shape[0] = sizeX; shape[1]=sizeY; shape[2]=sizeZ;
    for (uint64 c=0; c<N; c++)
    {
        this->_volume(c).resize(shape);
    }
    this->_voxel_size = voxel_size;
}

template<typename T, int N>
Room<T,N>::Room (const Grid3D& grid3d)
        : _voxel_size(grid3d.voxel_size()), _offset(grid3d.offset())
{
    for (uint64 c=0; c<N; c++)
    {
        this->_volume(c).resize(grid3d.dims());
    }

}


//template<typename T, int N>
//Room<T,N>:: Room(const std::vector< std::vector<uint64> >& dims,float64 voxel_size)
////:  _volume(dims), _offset(0,0,0)
//{
//this->_voxel_size = voxel_size;
//}

template<typename T, int N>
Room<T,N>::Room(const Room<T,N>& copy)
		:_voxel_size(copy._voxel_size), _offset(copy._offset), _volume(copy._volume) 
{   
}

template<typename T, int N>
Room<T,N>::~Room()
{
}

template<typename T, int N>
const Room<T,N>& Room<T,N>::operator=( const Room<T,N>& copy ) throw (ImagePlusError)
{
	ASSERT( &copy != this, "Room<T,N>::operator=: Self Assignment" )
    
    (*this)._volume = copy._volume;
    (*this)._offset = copy._offset;
    (*this)._voxel_size = copy._voxel_size;
    return *this;
}

template<typename T, int N>
inline uint64 Room<T,N>::size_x() const
{
    return (*this)._volume(0).dims(0);
}

template<typename T, int N>
inline uint64 Room<T,N>::size_y() const
{
    return (*this)._volume(0).dims(1);
}

template<typename T, int N>
inline uint64 Room<T,N>::size_z() const
{
    return (*this)._volume(0).dims(2);
}

template<typename T, int N>
inline float64 Room<T,N>::voxel_size() const
{
    return (*this)._voxel_size;
}

template<typename T, int N>
inline Point3D  Room<T,N>::offset() const
{
    return (_offset);
}

// Acces to data channels
template<typename T, int N>
inline Volume<T,N> & Room<T,N>::volume()
{
    return (_volume);
}
//Acces to const members of the volume
template<typename T, int N>
inline const Volume<T,N> & Room<T,N>::volume() const
{
    return (_volume);
}


//// Room instantiations
namespace imageplus
{
    template class Room<uint8,1>;
    template class Room<uint32,1>;
    template class Room<int32,1>;
    template class Room<int64,1>;
    template class Room<float64,1>;

    template class Room<uint8,3>;
    template class Room<uint32,3>;
    template class Room<int32,3>;
    template class Room<int64,3>;
    template class Room<float64,3>;
}
