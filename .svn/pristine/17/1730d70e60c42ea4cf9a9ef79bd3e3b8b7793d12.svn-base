// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------
//!
//!  \file tumult_detector.hpp
//!
//!  Auxiliar functions for the TumutlsDetector tool
//! 

#include <imageplus/particlefilters/pf_tumult.hpp> 
#include <imageplus/io/readsequence.hpp>
#include <imageplus/io/writeimage.hpp>
#include <imageplus/math/statistics/histogram.hpp>
#include <imageplus/foreground2d/pixel_model.hpp>
#include <imageplus/foreground2d/onegaussian_pm.hpp>
#include <imageplus/foreground2d/foreground2d.hpp>
#include <imageplus/foreground2d/frame_model.hpp>
#include <imageplus/math/morphology/opening.hpp>
#include <imageplus/toolbox/draw_in_image.hpp>

/*
 * STL includes
 */
#include <iostream>
#include <fstream>

/*
 * Namespaces
 */
using namespace std;
using namespace imageplus;
using namespace imageplus::particlefilters;
using namespace imageplus::foreground2d;
using namespace imageplus::toolbox;

//!
//! \brief Convert tumult particle filter id to color (RGB) <br>
//! Following the color sequence of MATLAB: CYAN (0), MAGENTA (1), YELLOW (2), BLACK (3), RED (4), GREEN (5), BLUE(6) & WHITE(7)
//!
//! \param[in]     color : Related with the id of the Particle Filter
//! \param[in] intensity : Determines the intensity of the color, ranged from 0 to 255
//!
//! \return Vector with the RGB values
//!
std::vector< uint8 > id2color( uint64 color, uint64 intensity );

//!
//! \brief Adds mixture color to one of the RGB component with the FG component
//!
//! \param[in] output_image : Output image where the FG is added
//! \param[in]      fg_mask : FG mask that will be drawn on the output image
//! \param[in]        color : Desired color, that fixes the RGB Channel where the FG will be drawn
//!
void add_mixture_color( ImageRGB< uint8 >& output_image, const ImageGray< uint8 >& fg_mask, uint64 color );

//!
//! \brief General function that writes the image results depending on the selected mode
//!
//! \param[in]  tumult_filters : Vector with the Tumult Particle Filters
//! \param[in]      input_data : Information of the input data of the Tumult Particle Filters
//! \param[in]   current_frame : The frame number to write
//! \param[in] tumult_detected : Boolean that determines if a Tumult has been detected
//! \param[in]            mode : If 0: draws FG images, if 1: draws only Particle Filters, if 2: draws Particles, if 3: draws Particle filters and their path and if 4: writes all previous ones
//!
void write_result_images( std::vector< TumultParticleFilter >& tumult_filters, 
                          TumultInputData&                     input_data, 
                          uint64                               current_frame, 
                          bool                                 tumult_detected,
                          uint64					           mode );

//!
//! \brief Initializes the Input Data structure used by the Tumult Particle Filters in the tracking
//!
//! \param[in] input_data : Information of the input data of the Tumult Particle Filters
//! \param[in]        cfg : Tool Config Class that contains the some of the information to write in the output file
//!
template< typename ToolConfigClass >
void initialize_input_data( TumultInputData& input_data, const ToolConfigClass& cfg );

//!
//! \brief Writes output data file with information of the detection results of tumults
//!
//! \param[in]               f : Output FilesStream where the data is written
//! \param[in]  tumult_filters : Vector with the Tumult Particle Filters
//! \param[in]   current_frame : Current frame of the sequence that is been read
//! \param[in] tumult_detected : Boolean that determines if a Tumult has been detected
//! \param[in]             cfg : Tool Config Class that contains the some of the information to write in the output file
//!
template< typename ToolConfigClass >
void write_output_data( std::fstream&                              f, 
                        const std::vector< TumultParticleFilter >& tumult_filters, 
                        const uint64&                              current_frame, 
                        const bool&                                tumult_detected, 
                        const ToolConfigClass&                     cfg);  

//!
//! \brief Reads the configuration file: environment.conf to configure the structure ENVIRONMENT inside the Tool Config
//!
//! \param[in]  cfg : Tool Config Class where the environment information is being stored
//!
template< typename ToolConfigClass >
void read_environment( ToolConfigClass& cfg );

//
// Implementation
//
std::vector< uint8 > id2color( uint64 color, uint64 intensity )
{
    std::vector< uint8 > rgb;
    
        ASSERT( ( color == 0 ) || ( color == 1 ) || ( color == 2 ) || ( color == 3 ) || ( color == 4 ) || ( color == 5 ) || ( color == 6 ) || ( color == 7 ), "Color not adequate" );
    
    ASSERT( intensity < 256, "Intensity should be smaller than 256 (images uint8)" );
    
    // Following the color sequence of MATLAB: CYAN (0), MAGENTA (1), YELLOW (2), BLACK (3), RED (4), GREEN (5), BLUE(6) & WHITE(7)
    switch( color )
    {
        case 0: // CYAN
        { 
            rgb.push_back( 0 ); // RED_CHANNEL
            rgb.push_back( intensity ); // GREEN_CHANNEL
            rgb.push_back( intensity ); // BLUE_CHANNEL
            break;
        }
        case 1: // MAGENTA
        { 
            rgb.push_back( intensity ); // RED_CHANNEL
            rgb.push_back( 0 ); // GREEN_CHANNEL
            rgb.push_back( intensity ); // BLUE_CHANNEL
            break;
        }
        case 2: // YELLOW
        { 
            rgb.push_back( intensity ); // RED_CHANNEL
            rgb.push_back( intensity ); // GREEN_CHANNEL
            rgb.push_back( 0 ); // BLUE_CHANNEL
            break;
        }
        case 3: // BLACK 
        { 
            rgb.push_back( 0 ); // RED_CHANNEL
            rgb.push_back( 0 ); // GREEN_CHANNEL
            rgb.push_back( 0 ); // BLUE_CHANNEL
            break;
        }
        case 4: // RED
        { 
            rgb.push_back( intensity ); // RED_CHANNEL
            rgb.push_back( 0 ); // GREEN_CHANNEL
            rgb.push_back( 0 ); // BLUE_CHANNEL
            break;
        }
        case 5: // GREEN
        { 
            rgb.push_back( 0 ); // RED_CHANNEL
            rgb.push_back( intensity ); // GREEN_CHANNEL
            rgb.push_back( 0 ); // BLUE_CHANNEL
            break;
        }
        case 6: // BLUE
        { 
            rgb.push_back( 0 ); // RED_CHANNEL
            rgb.push_back( 0 ); // GREEN_CHANNEL
            rgb.push_back( intensity ); // BLUE_CHANNEL
            break;
        }
        case 7: // WHITE
        { 
            rgb.push_back( intensity ); // RED_CHANNEL
            rgb.push_back( intensity ); // GREEN_CHANNEL
            rgb.push_back( intensity ); // BLUE_CHANNEL
            break;
        }
    }
    
    return rgb;
}

void add_mixture_color( ImageRGB< uint8 >& output_image, const ImageGray< uint8 >& fg_mask, uint64 color )
{
    // Mixture Code: add util.h (Roound) & statistics_histogram.h (maxval & mean)
    
    for( uint64 i = 0; i < fg_mask.size_x() ; i++ )
    {
        for( uint64 j = 0; j < fg_mask.size_y() ; j++ )
        {
            if( fg_mask( GRAY_CHANNEL )[ i ][ j ] == 255 )
            {
                output_image( color ) [ i ][ j ] = 255;
            }
        }
    }
}

void write_result_images( std::vector< TumultParticleFilter >& tumult_filters, TumultInputData& input_data, uint64 current_frame, bool tumult_detected, uint64 mode )
{
    int8 frame_number[10];
	
	if( mode == 0 || mode == 4 ) // Write FG images
	{
	    std::cout << "Writing FG image " << current_frame << std::endl;
	    
	    sprintf( frame_number, "%06d", static_cast< int32 > ( current_frame ) );
	    io::WriteImage writeImage( "fg/fg_" + string(frame_number) + ".png" );
	    writeImage << input_data.fg_mask;      // write result file
	}
	
	if( mode == 1 || mode == 4 ) // Write Particle filters in images
	{
	    std::cout << "Writing Result image " << current_frame << std::endl;
	    
	    sprintf( frame_number, "%06d", static_cast< int32 > ( current_frame ) );
	    
	    for ( uint64 it = 0; it < tumult_filters.size(); it++ )
	    {
	        // Drawing particle filter
	        uint64 cxi = static_cast< uint64 > ( tumult_filters[ it ].position().x() );
	        uint64 cyi = static_cast< uint64 > ( tumult_filters[ it ].position().y() );
	        uint64 width = static_cast< uint64 > ( tumult_filters[ it ].size().x() );
	        uint64 height = static_cast< uint64 > ( tumult_filters[ it ].size().y() );

	        std::vector< uint8 > color = id2color( tumult_filters[ it ].id(), 255 );
	        Coord2D< > center( cxi, cyi );
	        draw_rectangle( input_data.output_image, center, width, height, color[ RED_CHANNEL ], color[ GREEN_CHANNEL ], color[ BLUE_CHANNEL ] );
	    }
	    
	    // Adding red color to foreground
	    ImageRGB< uint8 > temp_output_image( input_data.output_image.size_x(), input_data.output_image.size_y() );
	    temp_output_image = input_data.output_image;
	    
	    add_mixture_color( temp_output_image, input_data.fg_mask, RED_CHANNEL );
	    io::WriteImage writeImage( "res/res_" + string(frame_number) + ".jpg" );
	    writeImage << temp_output_image; // write result file
	}
	
	if( mode == 2 || mode == 4 ) // Write Particles of each filter in images
	{	    
		std::cout << "Writing Particles image " << current_frame << std::endl;
		
	    sprintf( frame_number, "%06d", static_cast< int32 > ( current_frame ) );
	    
	    // Adding red color to foregound
	    ImageRGB< uint8 > temp_output_image( input_data.output_image.size_x(), input_data.output_image.size_y() );

	    temp_output_image = input_data.output_image;

	    add_mixture_color( temp_output_image, input_data.fg_mask, RED_CHANNEL ); // To see fg detection in output image

	    for ( uint64 it = 0; it < tumult_filters.size(); it++ )
	    {
	        std::vector< uint8 > color = id2color( tumult_filters[ it ].id(), 255 );

	        // Drawing particle filter
	        for ( uint64 i = 0; i < tumult_filters[ it ].number_of_particles(); i++ )
	        {           
	            uint64 cxi = static_cast< uint64 > ( tumult_filters[ it ].particles()[ i ].position().x() );
	            uint64 cyi = static_cast< uint64 > ( tumult_filters[ it ].particles()[ i ].position().y() );
	            uint64 width = static_cast< uint64 > ( tumult_filters[ it ].particles()[ i ].size().x() );
	            uint64 height = static_cast< uint64 > ( tumult_filters[ it ].particles()[ i ].size().y() );
	            
	            Coord2D< > center( cxi, cyi );
	            draw_cross ( temp_output_image, center, width, height, color[ RED_CHANNEL ], color[ GREEN_CHANNEL ], color[ BLUE_CHANNEL ] );
	        }
	    }
	    
	    io::WriteImage writeImage( "res/res_particles_" + string(frame_number) + ".jpg" );
	    writeImage << temp_output_image; // write result file
	}
	
	if( mode == 3 || mode == 4 ) // Write Particle Filters and their path
	{    
	    std::cout << "Writing Path image " << current_frame << std::endl;       
	    sprintf( frame_number, "%06d", static_cast< int32 > ( current_frame ) );
	    
	    for ( uint64 it = 0; it < tumult_filters.size(); it++ )
	    {
	        uint64 max_colors = 8;
	        uint64 color = tumult_filters[ it ].id() % max_colors;
	        uint64 intensity = 255;
	        std::vector< uint8 > color_rgb = id2color( color, intensity );
	        if( tumult_filters[ it ].history().size() >= 2 ) // At leat 2 point fot drawing path
	        {
	            // Drawing path
	            for ( uint64 i = 1; i < tumult_filters[ it ].history().size(); i++ )
	            {   
	                intensity = ( ( 255 - i ) < 0 ) ? 0 : 255 - i;
	                            
	                uint64 xi = static_cast< uint64 > ( tumult_filters[ it ].history()[ i - 1 ].position().x() );
	                uint64 yi = static_cast< uint64 > ( tumult_filters[ it ].history()[ i - 1 ].position().y() );
	                uint64 xf = static_cast< uint64 > ( tumult_filters[ it ].history()[ i ].position().x() );
	                uint64 yf = static_cast< uint64 > ( tumult_filters[ it ].history()[ i ].position().y() );    
	                                
	                Coord2D< > origin( xi, yi ), end( xf, yf );
	                
	                draw_line( input_data.output_image, origin, end, color_rgb[ RED_CHANNEL ], color_rgb[ GREEN_CHANNEL ], color_rgb[ BLUE_CHANNEL ] );
	            }        
	        }

	        // Drawing particle filter
	        Coord2D< > center( static_cast< uint64 > ( tumult_filters[ it ].position().x() ), static_cast< uint64 > ( tumult_filters[ it ].position().y() ) );
	        draw_rectangle( input_data.output_image, center, tumult_filters[ it ].size().x(), tumult_filters[ it ].size().y(), color_rgb[ RED_CHANNEL ], color_rgb[ GREEN_CHANNEL ], color_rgb[ BLUE_CHANNEL ] );
	    }
	    
	    if( tumult_detected ) // Draw red rectangle
	    {
	        Coord2D< > alarm_center( 500, 80 );
	        uint64 size = 40;
	        std::vector< uint8 > color_rgb = id2color( 4, 255 );
	        // Draw full rectangle (full_mode =true)
	        draw_rectangle( input_data.output_image, alarm_center, size, size, color_rgb[ RED_CHANNEL ], color_rgb[ GREEN_CHANNEL ], color_rgb[ BLUE_CHANNEL ], 1, true );
	    }
	    
	    io::WriteImage writeImage( "res/res_path_" + string(frame_number) + ".jpg" );
	    writeImage << input_data.output_image;      // write result file   
	}
}

template<typename ToolConfigClass>
void initialize_input_data( TumultInputData& input_data, const ToolConfigClass& cfg )
{
    // Initialize environment
    input_data.environment.ini_blob_w = cfg.environment.ini_blob_w; 
    input_data.environment.ini_blob_h = cfg.environment.ini_blob_h; 
    
    input_data.environment.ini_area_x = cfg.environment.ini_area_x; 
    input_data.environment.ini_area_y = cfg.environment.ini_area_y; 
    input_data.environment.ini_area_w = cfg.environment.ini_area_w; 
    input_data.environment.ini_area_h = cfg.environment.ini_area_h; 
    
    input_data.environment.des_area_x = cfg.environment.des_area_x; 
    input_data.environment.des_area_y = cfg.environment.des_area_y; 
    input_data.environment.des_area_w = cfg.environment.des_area_w; 
    input_data.environment.des_area_h = cfg.environment.des_area_h; 

    input_data.environment.ramp_model_m = cfg.environment.ramp_model_m; 
    input_data.environment.ramp_model_n = cfg.environment.ramp_model_n;
    
    input_data.environment.ini_point_x = cfg.environment.ini_point_x; 
    input_data.environment.ini_point_y = cfg.environment.ini_point_y; 
    input_data.environment.final_point_x = cfg.environment.final_point_x;
    input_data.environment.final_point_y = cfg.environment.final_point_y;
    
    input_data.environment.block_ramp_model_m = cfg.environment.block_ramp_model_m; 
    input_data.environment.block_ramp_model_n = cfg.environment.block_ramp_model_n;
    
    input_data.environment.block_ini_point_x = cfg.environment.block_ini_point_x; 
    input_data.environment.block_ini_point_y = cfg.environment.block_ini_point_y; 
    input_data.environment.block_final_point_x = cfg.environment.block_final_point_x;
    input_data.environment.block_final_point_y = cfg.environment.block_final_point_y;
    
    input_data.environment.x = cfg.environment.x;
    input_data.environment.y = cfg.environment.y;
    input_data.environment.w = cfg.environment.w;
    input_data.environment.h = cfg.environment.h;   
    input_data.environment.var = cfg.environment.var; 
//  input_data.environment.ramp_w = cfg.environment.ramp_w;
}

template<typename ToolConfigClass>
void write_output_data( std::fstream&                              f, 
                        const std::vector< TumultParticleFilter >& tumult_filters, 
                        const uint64&                              current_frame, 
                        const bool&                                tumult_detected, 
                        const ToolConfigClass&                     cfg)  
{
    int8 frame_number[10];  
        
    sprintf( frame_number, "%06d", static_cast< int32 > ( current_frame ) );
    
    if( current_frame == 0 )
    {
        f << "Information of tumult detection: " << cfg.input_sequence << std::endl;
        f << "Y accuracy: " << cfg.resolution_y << std::endl;
        f << "Speed accuracy: " << cfg.resolution_speed << std::endl;
        f << "Number of filters for detection: " << cfg.detection_threshold << std::endl;
        f << "Histeresis of possible tumults for detection: " << cfg.detection_histeresis << std::endl;
    }
    
    if( tumult_detected )
    {
        f << "Tumult detected in frame: " << current_frame << std::endl;
    } 
}

template<typename ToolConfigClass>
void read_environment(ToolConfigClass& cfg)
{           
    fstream environment_file;
    
    environment_file.open ( cfg.environment_file_name.c_str(), fstream::in );
     
    // Control if file exists
    if ( environment_file.is_open() )
    {
        std::cout << "File successfully open. Reading file ... " <<  cfg.environment_file_name << std::endl;                
    }
    else
    {
        std::cout << "Error opening file:" << cfg.environment_file_name << std::endl;
    }            
    
    // Reading info     
    // Read 2 comments
    environment_file.ignore( 1000,'\n');
    environment_file.ignore( 1000,'\n');
    environment_file >> cfg.environment.ini_blob_w;
                
    environment_file.ignore( 1000,'.');
    environment_file >> cfg.environment.ini_blob_h;
                
    environment_file.ignore( 1000,'.');
    environment_file >> cfg.environment.ini_area_x; 

    environment_file.ignore( 1000,'.');
    environment_file >> cfg.environment.ini_area_y; 
    
    environment_file.ignore( 1000,'.');
    environment_file >> cfg.environment.ini_area_w;
      
    environment_file.ignore( 1000,'.');
    environment_file >> cfg.environment.ini_area_h;
          
    environment_file.ignore( 1000,'.');
    environment_file >> cfg.environment.des_area_x;
    
    environment_file.ignore( 1000,'.');
    environment_file >> cfg.environment.des_area_y;
    
    environment_file.ignore( 1000,'.');
    environment_file >> cfg.environment.des_area_w;
    
    environment_file.ignore( 1000,'.');
    environment_file >> cfg.environment.des_area_h;

    environment_file.ignore( 1000,'.');
    environment_file >> cfg.environment.ramp_model_m;
    
    environment_file.ignore( 1000,'.');
    environment_file >> cfg.environment.ramp_model_n;
    
    environment_file.ignore( 1000,'.');
    environment_file >> cfg.environment.ini_point_x;
    environment_file.ignore( 1000,'.');
    environment_file >> cfg.environment.ini_point_y;
    environment_file.ignore( 1000,'.');
    environment_file >> cfg.environment.final_point_x;
    environment_file.ignore( 1000,'.');
    environment_file >> cfg.environment.final_point_y;
    
    environment_file.ignore( 1000,'.');
    environment_file >> cfg.environment.block_ramp_model_m;
    environment_file.ignore( 1000,'.');
    environment_file >> cfg.environment.block_ramp_model_n;
    
    environment_file.ignore( 1000,'.');
    environment_file >> cfg.environment.block_ini_point_x;
    environment_file.ignore( 1000,'.');
    environment_file >> cfg.environment.block_ini_point_y;
    environment_file.ignore( 1000,'.');
    environment_file >> cfg.environment.block_final_point_x;
    environment_file.ignore( 1000,'.');
    environment_file >> cfg.environment.block_final_point_y;
    
    uint64 i_MAX = cfg.image_height;
    
    environment_file.ignore( 1000,'.');
        
    cfg.environment.x.resize( i_MAX, 0 ); cfg.environment.y.resize( i_MAX, 0 ); cfg.environment.w.resize( i_MAX, 0 );
    cfg.environment.h.resize( i_MAX, 0 ); cfg.environment.var.resize( i_MAX, 0 ); cfg.environment.ramp_w.resize( i_MAX, 0 );
    
    int32 value_x, value_y, value_w, value_h, value_var;
    
    for ( uint64 i = 0; i < i_MAX; i++ )
    {
        environment_file >> value_x >> std::ws >> value_y >> std::ws >> value_w >> std::ws >> value_h  >> std::ws >> value_var;
        
        cfg.environment.x[i] = value_x; cfg.environment.y[i] = value_y;
        cfg.environment.w[i] = value_w; cfg.environment.h[i] = value_h;
        cfg.environment.var[i] = value_var;
    }         

    // add more parameters if needed
    
    std::cout << "Environment file read." << std::endl;
    environment_file.close();
}

