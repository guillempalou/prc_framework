// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------

//!
//!  \file readsequenceffmpeg.hpp
//!
//!  Interface class for reading sequences from disk using ffmpeg
//!

#ifdef USE_FFMPEG

#ifndef IMAGEPLUS_IO_READSEQUENCEFFMPEG_HPP
#define IMAGEPLUS_IO_READSEQUENCEFFMPEG_HPP

#include <string>

extern "C" 
{
#   include <libavcodec/avcodec.h>
#   include <libavformat/avformat.h>
#   include <libswscale/swscale.h>
}
	
#include <imageplus/core.hpp>

namespace imageplus
{

    namespace io
    {

        //!
        //! \brief class to read sequences from disk using ffmpeg
        //!
        //! \author Javier Ruiz Hidalgo <j.ruiz@upc.edu>
        //!
        //! \date 13-3-2008
        //!
        //! Class for reading sequences from local disk using 
        //! <A HREF="http://ffmpeg.mplayerhq.hu">ffmpeg</A> to capture frames from a video source.
        //! For this class to be compiled in you need to have the ffmpeg library installed in your 
        //! system
        //! 
        //! Note, that this is not an efficient way to just display a video as 
        //! the frames are converted to ImagePlus image classes and for displaying,
        //! they need to undergo another colorspace conversion.
        //! 
        class ReadSequenceFfmpeg
        {
                
            public:

                //!
                //! \brief Default contructor
                //!
                ReadSequenceFfmpeg();

                //!
                //! \brief Default destructor
                //!
                ~ReadSequenceFfmpeg();

                //!
                //! \brief Contructor for easy open
                //!
                //! This constructor also opens a single file sequence
                //!
                //! \param[in] filename : string with filename of the sequence in disk
                //! \param[in]     skip : Number of frames to skip (default 0 so no skipping)
                //!
                //! \sa open()
                //!
                explicit ReadSequenceFfmpeg( const std::string& filename, uint64 skip );

                //!
                //! \brief Opens single file sequence for reading
                //!
                //! \param[in] filename : string with filename of the sequence in disk
                //! \param[in]     skip : Number of frames to skip (default 0 so no skipping)
                //!
                void open( const std::string& filename, uint64 skip ) throw (ImagePlusError,ImagePlusFileNotFound,ImagePlusFileError);
                
                //!
                //! \brief Reads next gray image from sequence
                //!
                //! \param[out] image : ImageGray where the read frame will be stored
                //!
                template<typename T>
                void operator>>( ImageGray<T>& image );

                //!
                //! \brief Reads next rgb image from sequence
                //!
                //! \param[out] image : Image where the read frame will be stored
                //!
                template<typename T>
                void operator>>( ImageRGB<T>& image );

                //!
                //! \brief Reads next yuv image from sequence
                //!
                //! \param[out] image : ImageYUV where the read frame will be stored
                template<typename T>
                void operator>>( ImageYUV<T>& image );

                //!
                //! \brief Reads next yuv420 image from sequence
                //!
                //! \param[out] image : Image where the read frame will be stored
                //!
                template<typename T>
                void operator>>( ImageYUV420<T>& image );

                //!
                //! \brief Sets specific frame to read next time operator>> is called
                //!
                //! \param[in] frame : Frame number to read
                //!
                //! \returns this, just for convenience
                //!
                ReadSequenceFfmpeg& operator[]( uint64 frame ) throw (ImagePlusError);

                //!
                //! \brief Signals if the end of sequence has been reached
                //!
                //! \returns true if end of file is found (so next read will be an error) else it returns false
                //!
                bool eof();

                //!
                //! \brief Access to the width in pixels of the sequence
                //! 
                //! \returns the width in pixels of the sequence
                //!
                uint64 size_x() const;

                //!
                //! \brief Access to the height of the sequence
                //! 
                //! \returns the height in pixels of the sequence
                //!
                uint64 size_y() const;

                //!
                //! \brief Access to the frames per second of the sequence
                //! 
                //! \returns the frames per second of the sequence
                //!
                float64 fps() const;

                //!
                //! \brief Access to the startframe of the sequence
                //! 
                //! \returns the start frame of the sequence (always 0)
                //!                
                uint64 startframe() const;

                //!
                //! \brief Access to the endframe of the sequence
                //! 
                //! This value is not reliable so always 0
                //!
                //! \returns the end frame of the sequence (always 0)
                //!                
                uint64 endframe() const;

            private:

                //! Stores filename of the sequence on disk
                std::string _filename;
                
                //! Variable to keep track of the frame to be read next
                uint64 _framecont;

                //! Pointer to ffmpeg struct with format context information 
                AVFormatContext *_format_ctx;
                
                //! Pointer to ffmpeg struct with codec context information
                AVCodecContext *_codec_ctx;

                //! Pointer to ffmpeg struct with codec information                
                AVCodec *_codec;

                //! Pointer to ffmpeg struct with frame info. This is where the frame from disk will be read
                AVFrame *_frame;

                //! ID of the video stream in the file
                int32 _video_stream;
                
                //! Signals if the _frame struct is filled with the last frame read from disk
                bool _frame_already_read;
                
                //! Vector with the pixel format to convert the _frame (0:gray,1:rgb,2:yuv,3:yuv420)
                PixelFormat _frame_format[4];

                //! FFmpeg frame struct where frame data will be converted (0:gray,1:rgb,2:yuv,3:yuv420)
                AVFrame *_frame_conv[4];

                //! Array with pixels values (will be attached to each _frame_conv) (0:gray,1:rgb,2:yuv,3:yuv420)
                uint8_t *_frame_buffer[4];

                //! FFmpeg frame struct with conversion data to be used with swscale (0:gray,1:rgb,2:yuv,3:yuv420)
                struct SwsContext *_img_convert_ctx[4];

                //!
                //! \brief reads and decodes a frame from disk and writes it to _frame struct
                //!
                //! This private function reads packets from disk and decodes the frame into the _frame
                //! struct. The format of the _frame struct (rgb,yuv,etc.) is based on the sequence format
                //! If no more packets are found this functions throws an ImagePlusError
                //!
                //! If no more packets are found this functions throws an ImagePlusError
                //! 
                void read_next_frame() throw (ImagePlusError);

                /*!
                 * Internal function to skip a given number of frames
                 *
                 * \param[in] skip : the number of frames to skip
                 *
                 * \throws ImagePlusError if no more packets are found.
                 */
                void skip_frames(uint64 skip)  throw (ImagePlusError);

                //!
                //! \brief converts frame decoded into a specified format
                //!
                //! This private function reads packets from disk and decodes the frame into the _frame
                //! struct. The format of the _frame struct (rgb,yuv,etc.) is based on the sequence format
                //!
                //! If _frame_already_read is false this function will call read_next_frame() to read a frame
                //! from the video stream
                //!
                //! \param[in] opt: Convert to type (0:gray, 1:rgb, 2:yuv444, 3:yuv420)
                //!
                void convert_frame(uint64 opt);

                //!
                //! \brief frees all private data dinamically allocated
                //!
                void free_private_data();

        };




        //
        // Implementation of inline functions
        //

        inline uint64 ReadSequenceFfmpeg::size_x() const
        {
            return _codec_ctx->width;
        }

        inline uint64 ReadSequenceFfmpeg::size_y() const
        {
            return _codec_ctx->height;
        }

        inline float64 ReadSequenceFfmpeg::fps() const
        {
            return (float64)_codec_ctx->time_base.den / (float64)_codec_ctx->time_base.num;
        }

        inline uint64 ReadSequenceFfmpeg::startframe() const
        {
            return 0;
        }

        inline uint64 ReadSequenceFfmpeg::endframe() const
        {
            return 0;
        }
        
        
    } // namespace io
    
} //namespace imageplus

#endif

#endif
