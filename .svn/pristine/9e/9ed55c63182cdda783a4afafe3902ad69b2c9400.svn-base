/*
 * merging_sequence_pruner.hpp
 *
 *  Created on: Mar 21, 2013
 *      Author: gpalou
 */

#ifndef MERGING_SEQUENCE_PRUNER_HPP_
#define MERGING_SEQUENCE_PRUNER_HPP_

/*
 * binary_pruner.hpp
 *
 *  Created on: Mar 7, 2013
 *      Author: gpalou
 */

#include <imageplus/bpt/pruning/bpt_pruner.hpp>
#include <imageplus/descriptors/descriptor_manager.hpp>
#include <boost/multi_array.hpp>

namespace imageplus {
	namespace bpt {

		//! Base class of minimizer of a cost function in the BPT. Each region should have a cost depending ONLY in its characteristics (e.g. mean color, region perimeter...)
		//! \param BPT : tree type
		//! \param InputModel : image type
		//! \param RegionCostFunction : cost function type
		template<class BPT, class ImageModel, class RegionCostFunction>
		class MergingSequenceOptimumPruner : public BPTPruner<BPT,ImageModel> {

			//! Pruner base class
			typedef BPTPruner<BPT,ImageModel> Pruner;

			//! Region ids
			typedef typename Pruner::RegionsIDs RegionsIDs;

			typedef typename BPT::PartitionType	PartitionType;

		public:

			MergingSequenceOptimumPruner(RegionCostFunction& region_cost_function, bool prune_tree) : Pruner(prune_tree), _cost_function(&region_cost_function) {

			}

			//! Gets the optimal subtree given the number of regionsa
			//! \param[in] bpt : tree
			//! \param[in] r : region acting as root of the minimization (normally the root of the tree)
			//! \param[in] N: number of regions
			std::pair<std::set<uint64>,float64> minimum_cost(BPT& bpt, ImageModel& img, uint64 r) {
				uint64 n_process = 1;

				std::set<uint64> regions;
				std::pair<std::set<uint64>,float64> s;

				regions.insert(bpt.max_label());

				//PartitionType partition(bpt.leaves_partition().sizes());
				//for (typename PartitionType::iterator p = partition.begin(); p != partition.end(); ++p) (*p)(0) = bpt.max_label();

				_costs[bpt.max_label()] = _cost_function->region_cost(bpt,img,r);

				float64 cost = _costs[bpt.max_label()];

				s.second = 1e200;
				while (regions.size()!=0) {
					// find the largest index and divide it
					std::set<uint64>::reverse_iterator max_element = regions.rbegin();
					uint64 r = *max_element;
					regions.erase(--max_element.base());

					n_process--;
					if (bpt(r).children().size() > 0) {
						uint64 son1 = bpt(r).child(0)->label();
						uint64 son2 = bpt(r).child(1)->label();
						regions.insert(son1);
						regions.insert(son2);
						n_process+=2;
						_costs[son1] = _cost_function->region_cost(bpt,img,son1);
						_costs[son2] = _cost_function->region_cost(bpt,img,son2);

						// Evaluate the sons
						cost -= _costs[r];
						cost += _costs[son1];
						cost += _costs[son2];

						if (cost < s.second) {
							s.first = regions;
							s.second = cost;
						}

					} else {
					}
				}
				//std::cout << "minimum cost ms " << s.second << std::endl;
				return s;
			}

			//! Functions that finds the regions to prune
			//! \param[in] bpt: tree
			//! \param[in] img: image
			//! \param[in] reg_id: id of the root to begin to count (normally the root of the tree)
			const RegionsIDs& find_pruned_regions(BPT& bpt, ImageModel& img, uint64 reg_id, uint64 region_objective = 0) {

				std::pair<std::set<uint64>,float64> s = minimum_cost(bpt,img,reg_id);

				_cost = s.second;

				Pruner::_regions = s.first;

				return Pruner::_regions;
			}

			float64 cost() {
				return _cost;
			}

		private:

			//! cost function
			RegionCostFunction* _cost_function;

			//! index of regions
			std::map<uint64, uint64> index;

			//! map of the region costs
			std::map<uint64,float64 > _costs;

			//! minimum cost
			float64 _cost;

		};
	}
}

#endif /* MERGING_SEQUENCE_PRUNER_HPP_ */
