/*
 * reverse_endpoint.hpp
 *
 *  Created on: Dec 5, 2012
 *      Author: guillem
 */

#ifndef REVERSE_ENDPOINT_HPP_
#define REVERSE_ENDPOINT_HPP_

#include <imageplus/core/image_signal.hpp>

namespace imageplus {
namespace optical_flow {


	template<class OpticalFlowType>
	ImageSignal<float64,1> reverse_endpoint_error(OpticalFlowType& forward, OpticalFlowType& backward) {

		ImageSignal<float64,1> reverse(forward.sizes());

		for (typename OpticalFlowType::iterator v = forward.begin(); v != forward.end(); ++v) {

			ImageSignal<float64,1>::coord_type pos = v.pos();

			typename OpticalFlowType::coord_float_type pos_float = pos.template cast<float64>();
			typename OpticalFlowType::value_type displacement = forward.interpolate_value(pos_float);
			typename OpticalFlowType::coord_float_type new_pos = pos_float + displacement;

			for (uint64 i = 0; i < 2; i++) pos(i) = round(new_pos(i));

			ImageSignal<float64,1>::coord_type a = pos - forward.lower_point();
			ImageSignal<float64,1>::coord_type b = forward.upper_point() - pos;

			//Check if the trajectory falls inside the video
			if (a.minCoeff() < 0 || b.minCoeff() < 0) {
				reverse(v.pos())(0) = -1;
				continue;
			}

			// Check if the point should be tracked
			// check forward/backward consistency

			typename OpticalFlowType::value_type  uv_fwd  	= displacement;
			typename OpticalFlowType::value_type  uv_bkwd 	= backward.interpolate_value(new_pos);
			float64 error = (uv_fwd + uv_bkwd).squaredNorm() / ((uv_fwd.squaredNorm() + uv_fwd.squaredNorm()) * 0.01 + 0.5);

			reverse(v.pos())(0) = 1-std::exp(-error);
		}

		return reverse;
	}

}
}

#endif /* REVERSE_ENDPOINT_HPP_ */
