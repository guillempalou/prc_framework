// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------

//!
//!  \file pca.cpp
//!
//!
//!
#include <iostream>
#include <fstream>
#include <stdexcept>
#include <string>
#include <imageplus/core.hpp>
#include <imageplus/core/exceptions.hpp>
#include <imageplus/math/transforms/pca.hpp>
#include <imageplus/math/numeric/eigenvalues.hpp>
#include <imageplus/math/numeric/normalization.hpp>
#include <imageplus/math/statistics/multiarray_statistics.hpp>
#include <imageplus/math/numeric/transformations.hpp>
#include <imageplus/math/numeric/products.hpp>


namespace mn = imageplus::math::numeric;
namespace ms = imageplus::math::statistics;


namespace imageplus
{
    namespace math
    {
        namespace transforms
        {
            //!
            //! \brief Small value (represents zero).
            //!
            const float64 EPSILON = 1.e-15;
            //!
            //! \brief Big value (represents infinity).
            //!
            const float64 INFTY = 1.e15;


            template <typename T, typename T2>
            PCA<T, T2>::PCA ( )
            {
            }


            template <typename T, typename T2>
            PCA<T, T2>::PCA (const MultiArray<T2,2>& image, uint64 dim_x, uint64 dim_y) :
                _x(dim_x), _y(dim_y), _discarded_eval_mean(0.0), 
                _mean_im(image.dims(1)), _eval(image.dims(0)),
                _basis(image.dims(0), image.dims(1))  
            {
                ASSERT (dim_x*dim_y == image.dims(1), "PCA(): Dimensions are not ok")
                _sel_evec    = _eval.dims(0);
                _number_eval = _eval.dims(0);
                _compute_pca(image);
            }


            template <typename T, typename T2>
            PCA<T,T2>::PCA (std::string classn)
            {
            	load (classn);
            }
            
            template <typename T, typename T2>
            void PCA<T,T2>::load (std::string classn) 
            {
                int32 n;
                float32 ro, tchi2;
                float32 d;

                std::ifstream clfile;
                clfile.open (classn.c_str(),std::ifstream::binary);
                if( !clfile.is_open() )
                {
                    throw imageplus::ImagePlusFileNotFound(classn);
                }

                clfile.read( (char *)(&n), sizeof(int32) );
                if( !clfile.good() )
                {
                    throw imageplus::ImagePlusFileError(classn,"Cannot read class size n.");
                }
                int32 x;
                clfile.read( (char *)(&x), sizeof(int32) );
                if( !clfile.good() )
                {
                    throw imageplus::ImagePlusFileError(classn,"Cannot read class size x.");
                }
                _x = x;
                int32 y;
                clfile.read( (char *)(&y), sizeof(int32) );
                if( !clfile.good() )
                {
                    throw imageplus::ImagePlusFileError(classn,"Cannot read class size y.");
                }
                _y = y;
                int32 sel_evec;
                clfile.read( (char *)(&sel_evec), sizeof(int32) );
                if( !clfile.good() )
                {
                    throw imageplus::ImagePlusFileError(classn,"Cannot read class size _sel_evec");
                }
                _sel_evec = sel_evec;
                int32 number_eval;
                clfile.read( (char *)(&number_eval), sizeof(int32) );
                if( !clfile.good() )
                {
                    throw imageplus::ImagePlusFileError(classn,"Cannot read class size _number_eval");
                }
                _number_eval = number_eval;
                float32 discarded_eval_mean;
                clfile.read( (char *)(&discarded_eval_mean), sizeof(float32) );
                if( !clfile.good() )
                {
                    throw imageplus::ImagePlusFileError(classn,"Cannot read class size _discarded_eval_mean");
                }
                _discarded_eval_mean = discarded_eval_mean;
                clfile.read( (char *)(&ro), sizeof(float32) );
                if( !clfile.good() )
                {
                    throw imageplus::ImagePlusFileError(classn,"Cannot read class size ro");
                }
                clfile.read( (char *)(&tchi2), sizeof(float32) );
                if( !clfile.good() )
                {
                    throw imageplus::ImagePlusFileError(classn,"Cannot read class size tchi2");
                }
                std::vector<size_type> v(1);
                v[0] = n;
                _mean_im.resize(v);
                v[0] = _sel_evec;
                _eval.resize(v);
                v.push_back(n);
                 _basis.resize(v);

                //     read mean 
                for(uint64 j=0; j< static_cast<uint64>(n); j++) 
                {
                    clfile.read( (char *)(&d), sizeof(float32) );
                    if( !clfile.good() )
                    {
                        throw imageplus::ImagePlusFileError(classn,"cannot read mean");
                    }
                    _mean_im[j] = d;
                }

                // read eval 
                for(uint64 j=0; j<_sel_evec; j++) 
                {
                    clfile.read( (char *)(&d), sizeof(float32) );
                    if( !clfile.good() )
                    {
                        throw imageplus::ImagePlusFileError(classn,"cannot read eigenvalues");
                    }
                    _eval[j] = d;
                 }

            //  read evec
                 float64* p = _basis.data();
                 for(uint64 j=0; j<(_sel_evec * static_cast<uint64>(n)); j++) 
                {
                     clfile.read( (char *)(&d), sizeof(float32) );
                    if( !clfile.good() )
                    {
                        throw imageplus::ImagePlusFileError(classn,"cannot read projection basis");
                    }
                     *p = d;
                     p++;
                 }

                 clfile.close();

                 _sortevv(_eval, _basis);
            }

            template <typename T, typename T2>
            uint64 PCA<T,T2>::size_x() const
            {
                return (_x);
            }

            template <typename T, typename T2>
            uint64 PCA<T,T2>::size_y() const
            {
                return (_y);
            }

            template <typename T, typename T2>
            uint64 PCA<T,T2>::selected_eigenvectors() const
            {
                return (_sel_evec);
            }

            template <typename T, typename T2>
            uint64 PCA<T,T2>::total_number_eigenvalues() const
            {
                return (_number_eval);
            }

            template <typename T, typename T2>
            float64 PCA<T,T2>::discarded_eigenvalues_mean() const
            {
                return (_discarded_eval_mean);
            }

            template <typename T, typename T2>
            MultiArray<T,1> PCA<T,T2>::mean_image() const
            {
                return (_mean_im);
            }

            template <typename T, typename T2>
            MultiArray<T,1> PCA<T,T2>::eigenvalues() const
            {
                return (_eval);
            }

            template <typename T, typename T2>
            MultiArray<T,2> PCA<T,T2>::projection_basis() const
            {
                return (_basis);
            }

            template <typename T, typename T2>
            void PCA<T,T2>::reduce_class(uint64 num_sel) 
            {
                // find _discarded_eval_mean
                float64 sum = 0.0;
                uint64 n = _x * _y; 

                MultiArray<T,1> Veval(num_sel);
                MultiArray<T,2> Vevec(num_sel, n);

                // Sum discarded eigenvalues: from M+1 to _number_eval
                for(uint64 j = num_sel; j<_number_eval; j++)  
                {
                    sum += _eval[j];  
                }

                // Discarded eigenvalues: from M+1 to _number_eval 
                // divide by the number of discarded eigenvalues (_number_eval)-(M+1)
                if(num_sel >= _number_eval || sum < EPSILON)
                {
                    _discarded_eval_mean = INFTY; 
                }
                else
                {
                    _discarded_eval_mean = sum/(_number_eval - num_sel); 
                }

                // reduce eigenvalues
                for(uint64 j = 0; j<num_sel; j++)
                {
                    Veval[j] = _eval[j];
                }
                std::vector<size_type> v1(1);
                v1[0] = num_sel;
                _eval.resize(v1);
                _eval = Veval;

                // reduce eigenvectors 
                for(uint64 j=0; j<n; j++)
                {
                    for(uint64 i=0; i<num_sel; i++)
                    {
                        Vevec[i][j] = _basis[i][j];
                    }
                }
                std::vector<size_type> v2(2);
                v2[0] = num_sel;
                v2[1] = n;
                _basis.resize(v2);
                _basis = Vevec;

                // # of selected eigenvectors
                _sel_evec = num_sel;  
            }

            template <typename T, typename T2>
            void PCA<T,T2>::_compute_pca (const MultiArray<T2,2>& xmat)
            {
                // _num_im is the number of observations -images- 
                uint64 num_im = xmat.dims(0);

                // dim_im is the number of variables -dimension of images- 
                uint64 dim_im = xmat.dims(1);

                //Array for internal storage of image.
                MultiArray<T,2> fxmat(num_im, dim_im); 

                // Array for internal storage of matrix's rows.
                MultiArray<T,1> d(num_im);

                // Array for internal storage of normalizated matrix.
                MultiArray<T,2> xnorm(num_im, dim_im);

                // Array for internal storage of X * X*.
                MultiArray<T,2> Vmat(num_im, num_im);

                // Array for internal storage of eigenvalues.
                MultiArray<T,1> Veval(num_im);

                // Array for internal storage of eigenvectors.
                MultiArray<T,2> Vevec(num_im,num_im);

                // Array for internal storage of covariance matrix.
                MultiArray<T,1> SqVeval(num_im);

                // normalizing each image (each column in xmat) 
                fxmat = mn::mean_var_normalization<float64>(xmat, mn::COLUMNWISE_NORMALIZATION);

                // calculate mean, var, std of image _fxmat 
                for (uint64 j=0; j<dim_im; j++) 
                {
                    for (uint64 i=0; i<num_im; i++) 
                    {
                        d[i] = fxmat[i][j];
                    }
                    _mean_im[j] = ms::mean(d);
                }

                // form normalized matrix  _xnorm = _fxmat - _mean_im 
                xnorm = mn::mean_normalization<float64>(fxmat, mn::ROWWISE_NORMALIZATION);

                // compute _Vmat = _xnorm' * _xnorm 
                Vmat = mn::prod(mn::trans( xnorm ), xnorm);


                // find eigenvectors and eigenvalues of V 
                mn::Eigenvalues<float64> ei(Vmat);
                Veval = ei.real_eigenvalues();
                Vevec = ei.eigenvectors();

                // compute eigenvectors of xnorm (and of the covariance matrix of xmat)
                // compute SqVevec 
                for(uint64 j=0; j<num_im; j++) 
                {
                    if(Veval[j] != 0)
                    {
                        SqVeval[j] = 1./std::sqrt(fabs(Veval[j]));
                    }
                    else 
                    {
                        SqVeval[j] = std::numeric_limits<float64>::max();
                    }
                }

                // construct evec = _xnorm * _Vevec * _SqVeval
                for (uint64 j=0; j < dim_im; j++)
                {
                    for (uint64 i=0; i < num_im; i++) 
                    {
                        float64 sum = 0.;
                        for (uint64 n=0; n < num_im; n++)
                        {
                            sum += xnorm[n][j] * Vevec[i][n];
                        }
                        _basis[i][j] = sum * SqVeval[i];
                    }
                }

                // compute eigenvalues of the covariance matrix of xmat
                for (uint64 i=0; i<num_im; i++) 
                {
                    _eval[i] = Veval[i] / num_im;
                }

                // sort eigenvalues and eigenvectors 
                _sortevv(_eval,_basis);

            }

            template <typename T, typename T2>
            void PCA<T,T2>::_sortevv(MultiArray<T,1>& eigenvalues, MultiArray<T,2>& _basis)
            {
                uint64 k = eigenvalues.dims(0);
                uint64 n = _basis.dims(1);

                MultiArray<T,1> rrb(n);

                uint64 l = k/2+1;
                uint64 ir = k;
                float64 rra;

                for (;;)
                {
                    if (l > 1)
                    {
                        l -= 1;
                        rra = eigenvalues[l-1];
                        for(uint64 t=0; t < n; t++)
                        {
                            rrb[t] = _basis[l-1][t];
                        }
                    }
                    else 
                    {
                        rra = eigenvalues[ir-1];
                        for(uint64 t=0 ; t < n; t++)
                        {
                            rrb[t] = _basis[ir-1][t];
                        }
                        eigenvalues[ir-1] = eigenvalues[0];
                        for(uint64 t=0; t < n; t++)
                        {
                            _basis[ir-1][t] = _basis[0][t];
                        }
                        if (--ir == 1) 
                        {
                            eigenvalues[0] = rra;
                            for(uint64 t=0; t < n; t++)
                            {
                                _basis[0][t] = rrb[t];
                            }
                            return;
                        }
                    }
                    uint64 i=l;
                    uint64 j = l*2;
                    while (j < ir)    
                    {
                        if (j < ir && eigenvalues[j-1] > eigenvalues[j])
                        {
                            ++j;
                        }
                        if (rra > eigenvalues[j-1]) 
                        {
                            eigenvalues[i-1] = eigenvalues[j-1];
                            for(uint64 t=0; t < n; t++)
                            {
                                _basis[i-1][t] = _basis[j-1][t];
                            }
                            j += (i=j);
                        }
                        else 
                        {
                            j = ir+1;
                        }
                    }
                    eigenvalues[i-1] = rra;
                    for(uint64 t=0;t < n; t++)
                    {
                        _basis[i-1][t] = rrb[t];
                    }
                }
            }

            template <typename T, typename T2>
            void PCA<T,T2>::save(std::string classn) const
            {

                int32 n;
                float32 ro=0.0;
                float32 tchi2 = 0.0;
                float32 d;

                n= _x * _y;

                std::ofstream clfile(classn.c_str());

                clfile.write( (char *)(&n), sizeof(int32) );
                if( !clfile.good() )
                {
                    throw imageplus::ImagePlusFileError(classn,"cannot write class size n");
                }
                int32 x = _x;
                clfile.write( (char *)(&x), sizeof(int32) );
                if( !clfile.good() )
                {
                    throw imageplus::ImagePlusFileError(classn,"cannot write class size x");
                }
                int32 y = _y;
                clfile.write( (char *)(&y), sizeof(int32) );
                if( !clfile.good() )
                {
                    throw imageplus::ImagePlusFileError(classn,"cannot write class size y");
                }
                int32 sel_evec = _sel_evec;
                clfile.write( (char *)(&sel_evec), sizeof(int32) );
                if(!clfile.good() )
                {
                    throw imageplus::ImagePlusFileError(classn,"cannot write class size _sel_evec");
                }
                int32 number_eval = _number_eval;
                clfile.write( (char *)(&number_eval), sizeof(int32) );
                if(!clfile.good() )
                {
                    throw imageplus::ImagePlusFileError(classn,"cannot write class size _number_eval");
                }
                float32 discarded_eval_mean = _discarded_eval_mean;
                clfile.write( (char *)(&discarded_eval_mean), sizeof(float32) );
                if(!clfile.good())
                {
                    throw imageplus::ImagePlusFileError(classn,"cannot write class size _discarded_eval_mean");
                }
                clfile.write( (char *)(&ro), sizeof(float32) );
                if( !clfile.good() )
                {
                    throw imageplus::ImagePlusFileError(classn,"cannot write class size ro");
                }
                clfile.write( (char *)(&tchi2), sizeof(float32) );
                if(!clfile.good() )
                {
                    throw imageplus::ImagePlusFileError(classn,"cannot write class size tchi2");
                }

                //saving mean
                uint64 k = _mean_im.dims(0);
                for(uint64 j=0; j < k; j++) 
                {
                     d = static_cast<float32>(_mean_im[j]);
                     clfile.write( (char *)(&d), sizeof(float32) );
                    if( !clfile.good() )
                    {
                        throw imageplus::ImagePlusFileError(classn,"cannot write mean data");
                    }
                }

                //saving eigenvalues
                k = _eval.dims(0);
                for(uint64 j=0; j < k; j++) 
                {
                     d = static_cast<float32>(_eval[j]);
                     clfile.write( (char *)(&d), sizeof(float32) );
                    if(!clfile.good())
                    {
                        throw imageplus::ImagePlusFileError(classn,"cannot write eigenvalues data");
                    }
                }

                //saving projection basis
                const float64* p = _basis.data();
                for(uint64 j=0; j < _basis.num_elements(); j++) 
                {
                     d= static_cast<float32>(*p);
                     clfile.write( (char *)(&d), sizeof(float32) );
                    if( !clfile.good() )
                    {
                        throw imageplus::ImagePlusFileError(classn,"cannot write projection basis data");
                    }
                    p++;
                }
                clfile.close();
            }

            template <typename T, typename T2>
            MultiArray<T,1> PCA<T,T2>::projection(const MultiArray<T,1>& image) const
            {
                return (mn::prod(mn::trans(_basis),image));
            }

            template <typename T, typename T2>
            MultiArray<T,2> PCA<T,T2>::projection(const MultiArray<T,2>& images) const
            {
                return (mn::prod(mn::trans(_basis),images));
            }
        }
    }
}

namespace imageplus
{
    namespace math
    {
        namespace transforms
        {
            template class PCA<float64, int64>;
            template class PCA<float64, uint8>;
        }
    }
}
