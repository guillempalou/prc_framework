// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------

//!
//!  \file imavol_arithmetic.hpp
//!
//!  Overloaded arithmetic operators for imavols
//!

#ifndef IMAGEPLUS_CORE_IMAVOL_ARITHMETIC_HPP
#define IMAGEPLUS_CORE_IMAVOL_ARITHMETIC_HPP

#include <imageplus/core/imageplus_types.hpp>
#include <imageplus/core/imavol.hpp>
#include <imageplus/core/imavolmask.hpp>


namespace imageplus
{
    //!
    //! \brief Overloading of operator + for two imavols or derived classes
    //!
    //! \tparam T: Type of the data 
    //! \tparam N: Number of channels in the image 
    //! \tparam D: Number of dimensions (2 for images, 3 for volumes) 
    //!
    //! \param[in] input1 : First operand (imavol)
    //! \param[in] input2 : Second operand (imavol)
    //!
    //! \return Element by element sum of the input operands (imavol)
    //!
    //! \author Josep Ramon Morros <morros@gps.tsc.upc.edu>
    //!
    //! \date 10-1-2008
    //!
    template<typename T, std::size_t N, std::size_t D>
    ImaVol<T,N,D> operator+( const ImaVol<T,N,D>& input1, const ImaVol<T,N,D>& input2);

    //!
    //! \brief Overloading of operator + for one imavol (or derived class) and an scalar type
    //!
    //! \tparam T: Type of the data 
    //! \tparam N: Number of channels in the image 
    //! \tparam D: Number of dimensions (2 for images, 3 for volumes) 
    //!
    //! \param[in] input1 : First operand (imavol)
    //! \param[in] val    : Second operand (scalar)
    //!
    //! \return Element by element sum of the input operands (imavol)
    //!
    //! \author Josep Ramon Morros <morros@gps.tsc.upc.edu>
    //!
    //! \date 10-1-2008
    //!
    template<typename T, std::size_t N, std::size_t D>
    ImaVol<T,N,D> operator+( const ImaVol<T,N,D>& input1, T val);

    //!
    //! \brief Overloading of operator + for one scalar type and one imavol (or derived class)
    //!
    //! \tparam T: Type of the data 
    //! \tparam N: Number of channels in the image 
    //! \tparam D: Number of dimensions (2 for images, 3 for volumes) 
    //!
    //! \param[in] val    : First operand (scalar)
    //! \param[in] input1 : Second operand (imavol)
    //!
    //! \return Element by element sum of the input operands (imavol)
    //!
    //! \author Josep Ramon Morros <morros@gps.tsc.upc.edu>
    //!
    //! \date 10-1-2008
    //!
    template<typename T, std::size_t N, std::size_t D>
    ImaVol<T,N,D> operator+( T val, const ImaVol<T,N,D>& input1);

    //!
    //! \brief Overloading of operator - for two imavols or derived classes
    //!
    //! \tparam T: Type of the data 
    //! \tparam N: Number of channels in the image 
    //! \tparam D: Number of dimensions (2 for images, 3 for volumes) 
    //!
    //! \param[in] input1 : First operand (imavol)
    //! \param[in] input2 : Second operand (imavol)
    //!
    //! \return Element by element difference between the input operands (imavol)
    //!
    //! \author Josep Ramon Morros <morros@gps.tsc.upc.edu>
    //!
    //! \date 10-1-2008
    //!
    template<typename T, std::size_t N, std::size_t D>
    ImaVol<T,N,D> operator-( const ImaVol<T,N,D>& input1, const ImaVol<T,N,D>& input2);

    /*!
     * Subtraction Operator for ImaVols of Booleans (Abjunction)
     *
     * Truth Table:
     *
     * false - false = false
     * false - true  = false
     * true  - false = true
     * true  - true  = false
     *
     * Note that this operation is not commutative.
     * You are subtracting the "true" elements of the second mask to the first one.
     *
     * \tparam N: Number of channels in the image
     * \tparam D: Number of dimensions (2 for images, 3 for volumes)
     *
     * \param[in] input1 : First operand
     * \param[in] input2 : Second operand
     *
     * \return Element by element abjuction between the input operands
     *
     * \author Albert Gil <albert.gil@upc.edu>
     * \date   2011-06
     *
     */
    template<std::size_t N, std::size_t D>
    ImaVol<bool,N,D> operator-( const ImaVol<bool,N,D>& input1, const ImaVol<bool,N,D>& input2 );

    /*!
     * Addition Operator (+) for ImaVols of Booleans (Union)
     *
     * Truth Table:
     *
     * false + false = false
     * false + true  = true
     * true  + false = true
     * true  + true  = true
     *
     * \tparam N: Number of channels in the image
     * \tparam D: Number of dimensions (2 for images, 3 for volumes)
     *
     * \param[in] input1 : First operand
     * \param[in] input2 : Second operand
     *
     * \return Element by element union between the input operands
     *
     * \author Albert Gil <albert.gil@upc.edu>
     * \date   2011-09
     *
     */
    template<std::size_t N, std::size_t D>
    ImaVol<bool,N,D> operator+( const ImaVol<bool,N,D>& input1, const ImaVol<bool,N,D>& input2 );

    //!
    //! \brief Overloading of operator - for one imavol (or derived class) and an scalar type
    //!
    //! \tparam T: Type of the data 
    //! \tparam N: Number of channels in the image 
    //! \tparam D: Number of dimensions (2 for images, 3 for volumes) 
    //!
    //! \param[in] input1 : First operand (imavol)
    //! \param[in] val    : Second operand (scalar)
    //!
    //! \return Element by element difference between the input operands (imavol)
    //!
    //! \author Josep Ramon Morros <morros@gps.tsc.upc.edu>
    //!
    //! \date 10-1-2008
    //!
    template<typename T, std::size_t N, std::size_t D>
    ImaVol<T,N,D> operator-( const ImaVol<T,N,D>& input1, T val);

    //!
    //! \brief Overloading of operator - for one scalar type and one imavol (or derived class)
    //!
    //! \tparam T: Type of the data 
    //! \tparam N: Number of channels in the image 
    //! \tparam D: Number of dimensions (2 for images, 3 for volumes) 
    //!
    //! \param[in] val    : First operand (scalar)
    //! \param[in] input1 : Second operand (imavol)
    //!
    //! \return Element by element difference between the input operands (imavol)
    //!
    //! \author Josep Ramon Morros <morros@gps.tsc.upc.edu>
    //!
    //! \date 10-1-2008
    //!
    template<typename T, std::size_t N, std::size_t D>
    ImaVol<T,N,D> operator-( T val, const ImaVol<T,N,D>& input1);

    //!
    //! \brief Overloading of operator * for two imavols (or derived class)
    //!
    //! \tparam T: Type of the data 
    //! \tparam N: Number of channels in the image 
    //! \tparam D: Number of dimensions (2 for images, 3 for volumes) 
    //!
    //! \param[in] input1 : First operand (imavol)
    //! \param[in] input2 : Second operand (imavol)
    //!
    //! \return Element by element product of the input operands (imavol)
    //!
    //! \author Josep Ramon Morros <morros@gps.tsc.upc.edu>
    //!
    //! \date 02-4-2008
    //!
    template<typename T, std::size_t N, std::size_t D>
    ImaVol<T,N,D> operator*( const ImaVol<T,N,D>& input1, const ImaVol<T,N,D>& input2);

    //!
    //! \brief Overloading of operator / for two imavols (or derived class)
    //!
    //! \tparam T: Type of the data (booleans not allowed)
    //! \tparam N: Number of channels in the ImaVol
    //! \tparam D: Number of dimensions (2 for images, 3 for volumes) 
    //!
    //! \param[in] input1 : First operand (imavol)
    //! \param[in] input2 : Second operand (imavol)
    //!
    //! \return Element by element quotient of the input operands (imavol)
    //!
    //! \warning booleans not allowed
    //!
    //! \author Josep Ramon Morros <morros@gps.tsc.upc.edu>
    //!
    //! \date 02-4-2008
    //!
    template<typename T, std::size_t N, std::size_t D>
    ImaVol<T,N,D> operator/( const ImaVol<T,N,D>& input1, const ImaVol<T,N,D>& input2);

    /*!
     * Overloaded division operator of two boolean ImaVols
     *
     * It just throws an ImagePlusInternalError, because this operation (division)
     * is not defined for booleans.
     *
     * \tparam N: Number of channels in the ImaVol
     * \tparam D: Number of dimensions (2 for images, 3 for volumes)
     *
     * \param[in] input1 : First operand
     * \param[in] input2 : Second operand
     *
     * \return always an ImagePlusInternalError exception
     *
     * \author Albert Gil Moreno <albert.gil@upc.edu>
     * \date   2011-06
     */
    template<std::size_t N, std::size_t D>
    ImaVol<bool,N,D> operator/( const ImaVol<bool,N,D>& input1, const ImaVol<bool,N,D>& input2 );

    //!
    //! \brief Overloading of operator * for one imavol (or derived class) and an scalar type
    //!
    //! \tparam T: Type of the data 
    //! \tparam N: Number of channels in the image 
    //! \tparam D: Number of dimensions (2 for images, 3 for volumes) 
    //!
    //! \param[in] input1 : First operand (imavol)
    //! \param[in] val    : Second operand (scalar)
    //!
    //! \return Element by element product between the input operands (imavol)
    //!
    //! \author Josep Ramon Morros <morros@gps.tsc.upc.edu>
    //!
    //! \date 18-1-2008
    //!
    template<typename T, std::size_t N, std::size_t D>
    ImaVol<T,N,D> operator*( const ImaVol<T,N,D>& input1, T val);

    //!
    //! \brief Overloading of operator * for one scalar type and one imavol (or derived class)
    //!
    //! \tparam T: Type of the data 
    //! \tparam N: Number of channels in the image 
    //! \tparam D: Number of dimensions (2 for images, 3 for volumes) 
    //!
    //! \param[in] val    : First operand (scalar)
    //! \param[in] input1 : Second operand (imavol)
    //!
    //! \return Product between the input operands (imavol)
    //!
    //! \author Josep Ramon Morros <morros@gps.tsc.upc.edu>
    //!
    //! \date 18-1-2008
    //!
    template<typename T, std::size_t N, std::size_t D>
    ImaVol<T,N,D> operator*( T val, const ImaVol<T,N,D>& input1);

    //!
    //! \brief Overloading of operator * for one imavol (or derived class) and one mask (boolean imavol)
    //!
    //! \tparam T: Type of the data 
    //! \tparam N: Number of channels in the imavol 
    //! \tparam D: Number of dimensions in the imavol
    //!
    //! \param[in] ima  : First operand (imavol)
    //! \param[in] mask : Second operand (mask)
    //!
    //! \return Product between the input operands (imavol)
    //!
    //! \author Josep Ramon Morros <ramon.morros@upc.edu>
    //!
    //! \date 12-2-2008
    //!
    template<typename T, std::size_t N, std::size_t D>
    ImaVol<T,N,D> operator*( const ImaVol<T,N,D>& ima, const ImaVol<bool,1,D>& mask);


    //!
    //! \brief Overloading of operator * for one mask (boolean imavol) and one imavol (or derived class)
    //!
    //! \tparam T: Type of the data 
    //! \tparam N: Number of channels in the image 
    //! \tparam D: Number of dimensions in the imavol
    //!
    //! \param[in] mask : First operand (mask)
    //! \param[in] ima  : Second operand (imavol)
    //!
    //! \return Product between the input operands (imavol)
    //!
    //! \author Josep Ramon Morros <ramon.morros@upc.edu>
    //!
    //! \date 12-2-2008
    //!
    template<typename T, std::size_t N, std::size_t D>
    ImaVol<T,N,D> operator*( const ImaVol<bool,1,D>& mask, const ImaVol<T,N,D>& ima);

}

//
//  Implementation of template functions
//
namespace imageplus
{

    template<typename T, std::size_t N, std::size_t D>
    ImaVol<T,N,D> operator+( const ImaVol<T,N,D>& input1, const ImaVol<T,N,D>& input2 )
    {
        // Create sum with same dimensions as input1
        ImaVol<T,N,D> sum( input1.dims() );

        for (std::size_t i = 0; i < N; i++)
        {
            sum(i) = input1(i) + input2(i);
        }

        return sum;
    }

    template<std::size_t N, std::size_t D>
    ImaVol<bool,N,D> operator+( const ImaVol<bool,N,D>& input1, const ImaVol<bool,N,D>& input2 )
    {
        ASSERT( input1.size_x() == input2.size_x() &&
                input1.size_y() == input2.size_y(), "Dimensions mismatch" );

        // Create sum with same dimensions as input1
        ImaVol<bool,N,D> sum( input1.dims() );

        for (std::size_t ch = 0; ch < N; ++ch)
        {
            const bool* p1 = input1(ch).data();
            const bool* p2 = input2(ch).data();
            bool* ps =    sum(ch).data();

            for(std::size_t ii=0; ii<sum(ch).num_elements(); ++ii)
            {
                *ps = ( (*p1) || (*p2) );

                ++p1;
                ++p2;
                ++ps;
            }
        }

        return sum;
    }




    template<typename T, std::size_t N, std::size_t D>
    ImaVol<T,N,D> operator+( const ImaVol<T,N,D>& input1, T val )
    {
        // Create sum with same dimensions as input1
        ImaVol<T,N,D> sum( input1.dims() );


        // If label is not present
        for (std::size_t i = 0; i < N; i++)
        {
            sum(i) = input1(i) + val;
        }

        return sum;
    }


    template<typename T, std::size_t N, std::size_t D>
    inline ImaVol<T,N,D> operator+( T val, const ImaVol<T,N,D>& input1)
    {
        return imageplus::operator+(input1,val);
    }


    template<typename T, std::size_t N, std::size_t D>
    ImaVol<T,N,D> operator-( const ImaVol<T,N,D>& input1, const ImaVol<T,N,D>& input2 )
    {
        // Create sum with same dimensions as input1
        ImaVol<T,N,D> sum( input1.dims() );


        for (std::size_t i = 0; i < N; i++)
        {
            sum(i) = input1(i) - input2(i);
        }

        return sum;
    }

    template<std::size_t N, std::size_t D>
    ImaVol<bool,N,D> operator-( const ImaVol<bool,N,D>& input1, const ImaVol<bool,N,D>& input2 )
    {
        ASSERT( input1.size_x() == input2.size_x() &&
                input1.size_y() == input2.size_y(), "Dimensions mismatch" );

        // Create sum with same dimensions as input1
        ImaVol<bool,N,D> sum( input1.dims() );

        for (std::size_t ch = 0; ch < N; ++ch)
        {
            const bool* p1 = input1(ch).data();
            const bool* p2 = input2(ch).data();
            bool* ps =    sum(ch).data();

            for(std::size_t ii=0; ii<sum(ch).num_elements(); ++ii)
            {
                if(*p2) *ps = false;
                else    *ps =   *p1;

                ++p1;
                ++p2;
                ++ps;
            }
        }

        return sum;
    }

    template<typename T, std::size_t N, std::size_t D>
    ImaVol<T,N,D> operator-( const ImaVol<T,N,D>& input1, T val )
    {
        // Create sum with same dimensions as input1
        ImaVol<T,N,D> sum( input1.dims() );


        for (uint32 i = 0; i < N; i++)
        {
            sum(i) = input1(i) - val;
        }

        return sum;
    }


    template<typename T, std::size_t N, std::size_t D>
    ImaVol<T,N,D> operator-( T val, const ImaVol<T,N,D>& input1)
    {
        // Create sum with same dimensions as input1
        ImaVol<T,N,D> sum( input1.dims() );


        for (uint32 i = 0; i < N; i++)
        {
            sum(i) = val - input1(i);
        }

        return sum;
    }


    template<typename T, std::size_t N, std::size_t D>
    ImaVol<T,N,D> operator*( const ImaVol<T,N,D>& input1, const ImaVol<T,N,D>& input2 )
    {
        // Create prod with same dimensions as input1
        ImaVol<T,N,D> prod( input1.dims() );


        for (std::size_t i = 0; i < N; i++)
        {
            prod(i) = input1(i) * input2(i);
        }

        return prod;
    }


    template<typename T, std::size_t N, std::size_t D>
    ImaVol<T,N,D> operator*( const ImaVol<T,N,D>& input1, T val )
    {
        // Create prod with same dimensions as input1
        ImaVol<T,N,D> prod( input1.dims() );


        for (std::size_t i = 0; i < N; i++)
        {
            prod(i) = input1(i) * val;
        }

        return prod;
    }


    template<typename T, std::size_t N, std::size_t D>
    inline ImaVol<T,N,D> operator*( T val, const ImaVol<T,N,D>& input1)
    {
        return imageplus::operator*(input1,val);
    }


    template<typename T, std::size_t N, std::size_t D>
    inline ImaVol<T,N,D> operator*( const ImaVol<T,N,D>& ima, const ImaVol<bool,1,D>& mask)
    {
        // Create prod with same dimensions as input1
        ImaVol<T,N,D> prod( ima.dims() );


        for (std::size_t i = 0; i < N; i++)
        {
            prod(i) = ima(i) * mask(0);
        }

        return prod;
    }

    template<typename T, std::size_t N, std::size_t D>
    inline ImaVol<T,N,D> operator*( const ImaVol<bool,1,D>& mask, const ImaVol<T,N,D>& ima)
    {
        // Create prod with same dimensions as input1
        ImaVol<T,N,D> prod( ima.dims() );


        for (uint32 i = 0; i < N; i++)
        {
            prod(i) = ima(i) * mask(0);
        }

        return prod;

    }

    template<typename T, std::size_t N, std::size_t D>
    ImaVol<T,N,D> operator/( const ImaVol<T,N,D>& input1, const ImaVol<T,N,D>& input2 )
    {
        // Create prod with same dimensions as input1
        ImaVol<T,N,D> prod( input1.dims() );


        for (std::size_t i = 0; i < N; i++)
        {
            prod(i) = input1(i) / input2(i);
        }

        return prod;
    }

    template<std::size_t N, std::size_t D>
    ImaVol<bool,N,D> operator/( const ImaVol<bool,N,D>& input1, const ImaVol<bool,N,D>& input2 )
    {
        throw ImagePlusInternalError("operator/ not defined for booleans");
    }
}

#endif
