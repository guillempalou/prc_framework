// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------

//!
//!  \file readimage.cpp
//!
//!  Implementation for ReadImage class, used to read images in ImagePlus
//!

#ifdef USE_IMAGEMAGICK
#include <Magick++.h>
#else

/*
 * To solve linking problems with new versions of libpng
 * (from http://stackoverflow.com/questions/2442335/libpng-boostgil-png-infopp-null-not-found)
 */
#ifndef png_infopp_NULL
#define png_infopp_NULL (png_infopp)NULL
#endif

#ifndef int_p_NULL
#define int_p_NULL (int*)NULL
#endif

#include <boost/gil/extension/io/jpeg_dynamic_io.hpp>
#include <boost/gil/extension/io/png_dynamic_io.hpp>
#include <boost/gil/extension/io/tiff_dynamic_io.hpp>
#endif

#include <typeinfo>
#include <imageplus/io/readimage.hpp>

// auxiliar methods for io module
#include <io_auxiliar.hpp>
#include <bayer.hpp>

// To check files
#include <boost/filesystem.hpp>


imageplus::io::ReadImage::ReadImage() :
        _filename( "" ), _format( imageplus::io::UNKNOWN_IMAGE_FORMAT )
{
}

imageplus::io::ReadImage::ReadImage( const std::string& filename, ImageFormat format )
{
    open(filename, format);
}

imageplus::io::ReadImage::~ReadImage()
{
}

void imageplus::io::ReadImage::open( const std::string& filename, ImageFormat format )
{
    // TODO: Move this check to io_auxiliar as a method
    boost::filesystem::path file_path( filename );

    if ( ! boost::filesystem::is_regular( file_path ) )
    {
        if ( boost::filesystem::is_directory( file_path ) )
        {
            throw ImagePlusFileError( filename, " Not a valid file, is a directory." );
        }
        else
        {
            throw ImagePlusFileNotFound( filename );
        }
    }
    else
    {
        _filename = filename;

        ImageFormat extension_format = get_image_format( _filename );
        ImageFormat given_format = format;
        ImageFormat header_format = get_image_format_from_header( _filename );

        if(header_format!=UNKNOWN_IMAGE_FORMAT)
        {
            if(given_format==UNKNOWN_IMAGE_FORMAT && extension_format!=UNKNOWN_IMAGE_FORMAT)
            {
                if( header_format != extension_format)
                {
                    std::string extension = boost::filesystem::extension( _filename );
                    throw ImagePlusFileError( _filename, "Image format (from the header) does not correspond to the extension (" + extension + ")" );
                }
            }
            else if(given_format!=UNKNOWN_IMAGE_FORMAT && extension_format==UNKNOWN_IMAGE_FORMAT)
            {
                if( header_format != given_format)
                {
                    throw ImagePlusFileError( _filename, "Image format given does not correspond to the header" );
                }
            }
            else if (given_format!=UNKNOWN_IMAGE_FORMAT && extension_format!=UNKNOWN_IMAGE_FORMAT)
            {
                if( header_format != extension_format)
                {
                    std::string extension = boost::filesystem::extension( _filename );
                    throw ImagePlusFileError( _filename, "Image format (from the header) does not correspond to the extension (" + extension + ")" );
                }
                if( header_format != given_format)
                {
                    throw ImagePlusFileError( _filename, "Image format given does not correspond to the header" );
                }
            }
            _format = header_format;
        }
        else
        {
            if(given_format==UNKNOWN_IMAGE_FORMAT && extension_format!=UNKNOWN_IMAGE_FORMAT)
            {
                _format = extension_format;
            }
            else if(given_format!=UNKNOWN_IMAGE_FORMAT && extension_format==UNKNOWN_IMAGE_FORMAT)
            {
                _format = given_format;
            }
            else if (given_format!=UNKNOWN_IMAGE_FORMAT && extension_format!=UNKNOWN_IMAGE_FORMAT)
            {
                if( given_format != extension_format)
                {
                    std::string extension = boost::filesystem::extension( _filename );
                    throw ImagePlusFileError( _filename, "Image format given does not correspond to the extension (" + extension + ")" );
                }
                _format = given_format;
            }
            else
                _format = UNKNOWN_IMAGE_FORMAT;
        }
        
        // Throw exception if format is not supported
        if(_format == UNKNOWN_IMAGE_FORMAT)
        {
            std::string extension = boost::filesystem::extension( _filename );
            throw ImagePlusFileError( _filename, "Image format not supported (" + extension + ")" );
        }
    }
}


void imageplus::io::ReadImage::_read( ImageRGB<imageplus::uint8>& image ) const
{
#ifndef USE_IMAGEMAGICK

    if( _format == MULT )
    {
        io::ReadMultiArray  rm(_filename);
        MultiArray<uint8,2> bay;
        rm >> bay;
        
        if( image.size_x() != bay.dims(0)/2 || 
            image.size_y() != bay.dims(1)/2 )
        {
            image.resize(bay.dims(0)/2, bay.dims(1)/2);
        }
        
        convert_bayer(bay, image);
    }
    else
    {
        _read_rgb< imageplus::uint8, boost::gil::rgb8_image_t, boost::gil::rgb8_view_t::iterator >(image);
    }

#else

    _read_rgb< imageplus::uint8, Magick::CharPixel >(image);

#endif
}

void imageplus::io::ReadImage::_read( ImageYUV<imageplus::uint8>& image ) const
{
	ImageRGB<uint8> rgb( image.dims());
	_read(rgb);
	image = to_yuv(rgb);
}

void imageplus::io::ReadImage::_read( ImageRGB<imageplus::uint16>& image ) const
{
#ifndef USE_IMAGEMAGICK

    _read_rgb< imageplus::uint16, boost::gil::rgb16_image_t, boost::gil::rgb16_view_t::iterator >(image);

#else

    _read_rgb< imageplus::uint16, Magick::ShortPixel >(image);

#endif
}


void imageplus::io::ReadImage::_read( ImageGray<imageplus::uint8>& image ) const
{
#ifndef USE_IMAGEMAGICK

    return _read_gray< imageplus::uint8, boost::gil::gray8_image_t, boost::gil::gray8_view_t::iterator >(image);

#else

    return _read_gray< imageplus::uint8, Magick::CharPixel >(image);

#endif
}


void imageplus::io::ReadImage::_read( ImageGray<imageplus::uint16>& image ) const
{
#ifndef USE_IMAGEMAGICK

    return _read_gray< imageplus::uint16, boost::gil::gray16_image_t, boost::gil::gray16_view_t::iterator >(image);

#else

    return _read_gray< imageplus::uint16, Magick::ShortPixel >(image);

#endif
}


void imageplus::io::ReadImage::_read( ImageMask& image ) const
{
    ImageGray<uint8> tmp;

#ifndef USE_IMAGEMAGICK
    _read_gray< imageplus::uint8, boost::gil::gray8_image_t, boost::gil::gray8_view_t::iterator >(tmp);
#else
    _read_gray< imageplus::uint8, Magick::CharPixel >(tmp);
#endif
    image = convert(tmp);

}


void imageplus::io::ReadImage::_read( ImaVol<imageplus::uint32,1,2>& image ) const
{
    if(_format==MULT)
    {
        io::ReadMultiArray rm(_filename);
        rm >> image(0);
    }
    else
    {
        throw ImagePlusError( "Reading unsupported image type (unknown extension) for partitions" );
    }
}


#ifndef USE_IMAGEMAGICK
template<typename BoostImage>
void imageplus::io::ReadImage::_read_boost(BoostImage& boost_img) const
{
    switch (_format)
    {
    case JPEG:  return boost::gil::jpeg_read_and_convert_image ( _filename, boost_img );

    case PNG:   return boost::gil::png_read_and_convert_image  ( _filename, boost_img );

    case TIFF:  return boost::gil::tiff_read_and_convert_image ( _filename, boost_img );

    default:    throw ImagePlusError( "Reading unsupported image type (unknown extension)" );
    }
}
#endif


#ifndef USE_IMAGEMAGICK
template<typename T, typename BoostImage, typename BoostIterator>
#else
#if MagickLibVersion >= 0x640
template<typename T, Magick::StorageType MagickPixelType >
#else
template<typename T, MagickLib::StorageType MagickPixelType >
#endif
#endif
void imageplus::io::ReadImage::_read_rgb( ImageRGB<T>& image ) const
{

#ifndef USE_IMAGEMAGICK

    BoostImage boost_img;

    _read_boost(boost_img);

    Image<T,3> ibuffer(boost::gil::view(boost_img).width(), boost::gil::view(boost_img).height());

    T* red_channel_ptr   = ibuffer( RED_CHANNEL   ).data();
    T* green_channel_ptr = ibuffer( GREEN_CHANNEL ).data();
    T* blue_channel_ptr  = ibuffer( BLUE_CHANNEL  ).data();

    //for( BoostView::iterator it = boost::gil::view(boost_img).begin(); it < boost::gil::view(boost_img).end(); it++)
    for( BoostIterator it = boost::gil::view(boost_img).begin(); it < boost::gil::view(boost_img).end(); it++)
    {
        *red_channel_ptr++   = boost::gil::get_color( *it, boost::gil::red_t()   );
        *green_channel_ptr++ = boost::gil::get_color( *it, boost::gil::green_t() );
        *blue_channel_ptr++  = boost::gil::get_color( *it, boost::gil::blue_t()  );
    }

    image = ibuffer;

#else

    Magick::Image magickImage( _filename );

    imageplus::uint64 columns = magickImage.columns();
    imageplus::uint64 rows    = magickImage.rows();

    std::size_t bsize = 3 * columns * rows;

    T* buffer = new T[bsize];

    magickImage.write( 0, 0, columns, rows,
                       "RGB", MagickPixelType, buffer );

    //image = convert_from_packed_rgb (buffer, columns, rows);
    image.resize(columns, rows);
    import_from (image, buffer, bsize*sizeof(T), RGB);

    delete [] buffer;

#endif

}

#ifndef USE_IMAGEMAGICK
template<typename T, typename BoostImage, typename BoostIterator>
#else
#if MagickLibVersion >= 0x640
template<typename T, Magick::StorageType MagickPixelType >
#else
template<typename T, MagickLib::StorageType MagickPixelType >
#endif
#endif
void imageplus::io::ReadImage::_read_gray( ImageGray<T>& image ) const
{

#ifndef USE_IMAGEMAGICK

    BoostImage boost_img;

    _read_boost(boost_img);

    Image<T,1> ibuffer(boost::gil::view(boost_img).width(), boost::gil::view(boost_img).height());

    T* gray_channel_ptr   = ibuffer( GRAY_CHANNEL ).data();

    for( BoostIterator it = boost::gil::view(boost_img).begin(); it < boost::gil::view(boost_img).end(); it++)
    {
        *gray_channel_ptr++   = *it;
    }

    image = ibuffer;

#else

    Magick::Image magickImage( _filename );

    imageplus::uint64 columns = magickImage.columns();
    imageplus::uint64 rows    = magickImage.rows();


    T* buffer = new T[ columns * rows ];
    magickImage.write( 0, 0, columns, rows,
                       "I", MagickPixelType, buffer );

    // Check this
    image = ImageGray<T>( columns, rows );

    // Define pointer to channel data
    T *it1 = image(0).data();

    T* pbuf = buffer;

    for (imageplus::uint32 i = 0; i < columns * rows; i++)
    {
        *it1++ = *pbuf++;
    }

    delete [] buffer;

#endif

}

