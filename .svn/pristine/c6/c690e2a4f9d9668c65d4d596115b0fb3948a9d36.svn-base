
// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------

//!
//!  \file fourier.test
//!


// Fourier is only implemented with FFTW3 support
#ifdef USE_FFTW3 


#include <complex>
#include <imageplus/math/transforms/fourier.hpp>


BOOST_AUTO_TEST_SUITE ( fourier_suite );

using namespace imageplus;
using namespace imageplus::math::transforms;

typedef boost::mpl::list<float64> DataTypes;



BOOST_AUTO_TEST_CASE_TEMPLATE( testcase_fourier, T, DataTypes )
{
    uint64 size = 10;

    // T               rval1 = static_cast<T>(1);

    std::complex<T> cval1(static_cast<T>(10), static_cast<T>(5));
    std::complex<T> cval2(static_cast<T>(5), static_cast<T>(5));

    MultiArray<std::complex<T>,2> cmaVin(size,size);
    cmaVin = cval1;

    cmaVin[5][5] = cval2;

    MultiArray<std::complex<T>,2> cmaVout = fft(cmaVin);

    for (uint64 j = 0; j < cmaVin.dims(1); j++)
    {
        for (uint64 i = 0; i < cmaVin.dims(0); i++)
        {
             if (i == 0 && j == 0)
             {
                  BOOST_CHECK_CLOSE(cmaVout[i][j].imag(), static_cast<T>(500.0), 1e-5);
                  BOOST_CHECK_CLOSE(cmaVout[i][j].real(), static_cast<T>(995.0), 1e-5);
             }
             else
             {
                 BOOST_CHECK_CLOSE(cmaVout[i][j].imag(), static_cast<T>(0.0), 1e-5);
             }
        }
    }



    MultiArray<std::complex<T>,2> cmaVres = ifft(cmaVout);


    for (uint64 i = 0; i < cmaVin.dims(0); i++)
    {
        for (uint64 j = 0; j < cmaVin.dims(1); j++)
        {
            BOOST_CHECK_CLOSE(cmaVin[i][j].real(), cmaVres[i][j].real(), 1e-5);
        }
    }




    MultiArray<float64,2> maVin(4,4);
    maVin[0][0] = 2;
    maVin[1][0] = 3;
    maVin[2][0] = 4;
    maVin[3][0] = 5;
    maVin[0][1] = 6;
    maVin[1][1] = 7;
    maVin[2][1] = 8;
    maVin[3][1] = 9;
    maVin[0][2] = 10;
    maVin[1][2] = 11;
    maVin[2][2] = 12;
    maVin[3][2] = 13;
    maVin[0][3] = 14;
    maVin[1][3] = 15;
    maVin[2][3] = 16;
    maVin[3][3] = 17;

    MultiArray<std::complex<float64>,2> cmaVout2 = rfft(maVin);


    for (uint64 j = 0; j < cmaVin.dims(1); j++)
    {
        for (uint64 i = 0; i < cmaVin.dims(0); i++)
        {
            // std::cout << cmaVout2[i][j];
        }
    }

}

BOOST_AUTO_TEST_CASE_TEMPLATE( testcase_dct, T, DataTypes )
{
    uint64 size = 10;

    T   val1 = static_cast<T>(1);
    T   val2 = static_cast<T>(5);


    // 2D
    MultiArray<T,2> maVin(size,size);
    maVin = val1;

    maVin[5][5] = val2;

    MultiArray<T,2> maVout = dct2d(maVin);


    BOOST_CHECK_CLOSE(maVout[0][0], static_cast<T>(10.4),   1e-5);
    BOOST_CHECK_CLOSE(maVout[9][9], static_cast<T>(0.7804226065), 1e-5);


    MultiArray<T,2> maVres = idct2d(maVout);


    for (uint64 i = 0; i < maVin.dims(0); i++)
    {
        for (uint64 j = 0; j < maVin.dims(1); j++)
        {
              BOOST_CHECK_CLOSE(maVin[i][j], maVres[i][j], 1e-5);
        }
    }


    // Column-wise 1D DCT
    maVout = dct1d(maVin, COL_TRANSFORM);

    BOOST_CHECK_CLOSE(maVout[0][0], static_cast<T>(3.1622776601683795),   1e-5);
    BOOST_CHECK_CLOSE(maVout[9][9], static_cast<T>(0), 1e-5);
    

    maVres = idct1d(maVout, COL_TRANSFORM);

    for (uint64 i = 0; i < maVin.dims(0); i++)
    {
        for (uint64 j = 0; j < maVin.dims(1); j++)
        {
              BOOST_CHECK_CLOSE(maVin[i][j], maVres[i][j], 1e-5);
        }
    }



    // 1D
    MultiArray<T,1> maVin1d(size);
    maVin1d = val1;

    maVin1d[5] = val2;

    MultiArray<T,1> maVout1d = dct1d(maVin1d);


    BOOST_CHECK_CLOSE(maVout1d[0], static_cast<T>(4.4271887242357311),  1e-5);
    BOOST_CHECK_CLOSE(maVout1d[9], static_cast<T>(-1.7668306161237546), 1e-5);


    MultiArray<T,1> maVres1d = idct1d(maVout1d);


    for (uint64 i = 0; i < maVin1d.dims(0); i++)
    {
        BOOST_CHECK_CLOSE(maVin1d[i], maVres1d[i], 1e-5);
    }
}


BOOST_AUTO_TEST_SUITE_END ();


# endif /* USE_FFTW3 */
