/*
 * motion_color_histogram_distance.hpp
 *
 *  Created on: Jan 18, 2013
 *      Author: gpalou
 */

#ifndef MOTION_COLOR_HISTOGRAM_DISTANCE_HPP_
#define MOTION_COLOR_HISTOGRAM_DISTANCE_HPP_


#include <imageplus/descriptors/descriptor_manager.hpp>

#include <imageplus/descriptors/geometry/area.hpp>
#include <imageplus/descriptors/color/color_mean.hpp>
#include <imageplus/descriptors/video/temporal_max.hpp>
#include <imageplus/descriptors/video/temporal_mean.hpp>
#include <imageplus/descriptors/video/temporal_signature.hpp>
#include <imageplus/descriptors/color/color_signature.hpp>

#include <imageplus/math/optimization/emd.hpp>

#include <imageplus/bpt/models/bpt_distance_model.hpp>

namespace imageplus
{
    namespace video_segmentation
    {

        //! Class from which any model must inherit to work properly
        template<class SignalModel, class RegionModel, class OpticalFlowModel, typename order_type=float64>
        class MotionColorHistogramDistance : public bpt::BaseDistanceModel<SignalModel, RegionModel, order_type>
        {
        	typedef VideoSignal<float64,1>	ReliabilityMap;

        	typedef descriptors::ColorSignature<SignalModel>			ColorSignatureDescritor;
        	typedef descriptors::Area									AreaDescriptor;
        	typedef descriptors::TemporalSignature<OpticalFlowModel>	MotionSignatureDescriptor;
        	typedef descriptors::TemporalMean<ReliabilityMap>			ReliabilityMeanDescriptor;

        public:

        	struct Parameters {
        		OpticalFlowModel optical_flow;
        		int64 num_colors;

        		float64 color_damping;
        		float64 motion_damping;
        		float64 spatial_damping;
        		float64 area_damping;

        		ReliabilityMap		flow_reliability; 	// the higher the more reliable

        		Parameters() : optical_flow(OpticalFlowModel::coord_type::Zero()), flow_reliability(ReliabilityMap::coord_type::Zero()) {

        		}
        	};

        	static const Parameters default_parameters() {
        		return Parameters();
        	}


        	MotionColorHistogramDistance(const Parameters& pars = default_parameters()) {
        		_pars = pars;

        		EMDDistance distance(SignalModel::value_float_type::Ones()*_pars.color_damping);

        		_emd 		= math::optimization::EMD<EMDDistance>(distance);
        	}

            //! This function computes the order of a given link (edge of the RAG)
            //!
            //! \param reg1 : Region of one extremum of the link
            //! \param reg2 : Region of the other extremum of the link
            //! \param image : Image being processed
            //! \param bpt : Partition at the moment of the merging
            //! \return The order of the link
        	template<class BPT>
            order_type region_distance(RegionModel& reg1, RegionModel& reg2, SignalModel& image, BPT& bpt, descriptors::DescriptorManager& manager) {

        		float64 dc = color_distance(reg1,reg2,image,bpt,manager);
        		std::vector<float64> dmr = motion_distance(reg1,reg2,image,bpt,manager);
        		float64 da = area_distance(reg1,reg2,image,bpt,manager);

        		float64 dm = dmr[0];
        		//float64 reliability = dmr[1];

        		//float64 ds = spatial_distance(reg1,reg2,image,bpt,manager);

        		if (dm > 1) dm = 0;
        		if (dc > 1) dc = 0;
        		//if (ds > 1) ds = 0;

        		float64 gamma = 0.99;

            	return (1 - (1-dc*gamma)*(1-dm*gamma))*da;
        	}

        	template<class BPT>
        	float64 color_distance(RegionModel& reg1, RegionModel& reg2, SignalModel& image, BPT& bpt, descriptors::DescriptorManager& manager) {

        		typename ColorSignatureDescritor::Parameters signature_pars;
        		signature_pars.num_colors = _pars.num_colors;
        		signature_pars.weights = SignalModel::value_float_type::Ones()*(_pars.color_damping);

        		const typename ColorSignatureDescritor::type& color1 = manager.calc_descriptor<ColorSignatureDescritor>(image, reg1, signature_pars);
        		const typename ColorSignatureDescritor::type& color2 = manager.calc_descriptor<ColorSignatureDescritor>(image, reg2, signature_pars);

        		return _emd.calculate(color1,color2);
        	}

        	template<class BPT>
        	float64 spatial_distance(RegionModel& reg1, RegionModel& reg2, SignalModel& image, BPT& bpt, descriptors::DescriptorManager& manager) {
        		const typename ReliabilityMeanDescriptor::type& reliability1 = manager.calc_descriptor<ReliabilityMeanDescriptor>(_pars.flow_reliability, reg1);
        		const typename ReliabilityMeanDescriptor::type& reliability2 = manager.calc_descriptor<ReliabilityMeanDescriptor>(_pars.flow_reliability, reg2);

        		float64 spatial_distance = 0;

        		int64 begin_frame = std::max(reliability1.begin_frame, reliability2.begin_frame);
        		int64 end_frame = std::min(reliability1.end_frame, reliability2.end_frame);

        		//std::cout << "-" << std::endl;
        		for (int64 f = begin_frame; f <= end_frame; f++) {

        			float64 ds = std::sqrt((reliability1.centroid(f) - reliability2.centroid(f)).squaredNorm());

        			spatial_distance += std::max(spatial_distance,ds); // / (end_frame-begin_frame+1);
        		}

        		return std::log(1+spatial_distance);
        	}


        	template<class BPT>
        	std::vector<float64> motion_distance(RegionModel& reg1, RegionModel& reg2, SignalModel& image, BPT& bpt, descriptors::DescriptorManager& manager) {

        		const typename ReliabilityMeanDescriptor::type& reliability1 = manager.calc_descriptor<ReliabilityMeanDescriptor>(_pars.flow_reliability, reg1);
        		const typename ReliabilityMeanDescriptor::type& reliability2 = manager.calc_descriptor<ReliabilityMeanDescriptor>(_pars.flow_reliability, reg2);

        		typename MotionSignatureDescriptor::Parameters signature_pars;
        		signature_pars.num_points = _pars.num_colors;
        		signature_pars.weights = OpticalFlowModel::value_float_type::Ones()*(_pars.motion_damping);

        		const typename MotionSignatureDescriptor::type& motion1 = manager.calc_descriptor<MotionSignatureDescriptor>(_pars.optical_flow, reg1, signature_pars);
        		const typename MotionSignatureDescriptor::type& motion2 = manager.calc_descriptor<MotionSignatureDescriptor>(_pars.optical_flow, reg2, signature_pars);

        		float64 motion_distance = 0;
        		float64 reliability = 0;

        		int64 begin_frame = std::max(motion1.begin_frame, motion2.begin_frame);
        		int64 end_frame = std::min(motion1.end_frame, motion2.end_frame);

        		for (int64 f = begin_frame; f <= end_frame; f++) {

        			float64 r = std::min(reliability1.mean(f)(0),reliability2.mean(f)(0));

        			EMDMotionDistance distance_motion(OpticalFlowModel::value_float_type::Ones()*_pars.motion_damping);

        			_emd_motion = math::optimization::EMD<EMDMotionDistance>(distance_motion);

        			float64 d = r*_emd_motion.calculate(motion1.signature(f), motion2.signature(f));

        			if (d > motion_distance) {
        				motion_distance = d;
        				reliability = r;
        			}
        		}

        		//if (begin_frame > end_frame) {
        		//	motion_distance = 1.0;
        		//}

        		std::vector<float64> v(2);

        		v[0] = motion_distance;
        		v[1] = reliability;

        		return v;
        	}


        	template<class BPT>
        	float64 area_distance(RegionModel& reg1, RegionModel& reg2, SignalModel& image, BPT& bpt, descriptors::DescriptorManager& manager) {
        		const typename AreaDescriptor::type area1 = manager.calc_descriptor<AreaDescriptor>(image,reg1);
        		const typename AreaDescriptor::type area2 = manager.calc_descriptor<AreaDescriptor>(image,reg2);

        		float64 d = std::min(area1,area2); // * _pars.area_damping;

        		//return 1 - std::exp(-d);
        		return std::log(1+d);
        	}

        private:

        	typedef typename SignalModel::value_float_type 																	ColorType;
        	typedef typename OpticalFlowModel::value_float_type 															MotionType;
        	typedef typename math::statistics::PerceptualDistance<ColorType, typename SignalModel::value_float_type>		EMDDistance;
        	typedef typename math::statistics::PerceptualDistance<MotionType, typename OpticalFlowModel::value_float_type>	EMDMotionDistance;

        	math::optimization::EMD<EMDDistance> 		_emd;
        	math::optimization::EMD<EMDMotionDistance>  _emd_motion;
        	Parameters 									_pars;

        };

    }
}

#endif /* MOTION_COLOR_HISTOGRAM_DISTANCE_HPP_ */
