// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------

#define IMAGEPLUS_TOOL_CONFIG_NAME  bpt_population
#define IMAGEPLUS_TOOL_CONFIG_GROUP bpt

#include <imageplus/toolbox/tool_config.hpp>
#include <boost/filesystem.hpp>

//#include <time.h>

#include <imageplus/core.hpp>

#include <imageplus/io/readimage.hpp>
#include <imageplus/io/writeimage.hpp>

#include <imageplus/io/xml_auxiliar.hpp>
#include <imageplus/io/readwritepartition.hpp>
#include <imageplus/io/writedescriptors.hpp>

#include <imageplus/math/numeric/interpolation.hpp>  // To create thumbnail

#include <imageplus/descriptors/geometry/localization.hpp>
#include <imageplus/descriptors/color/color_statistics.hpp>
#include <imageplus/descriptors/texture/haar.hpp>
#include <imageplus/descriptors/geometry/contour_shape_mpeg7.hpp>
#include <imageplus/descriptors/color/color_layout.hpp>
#include <imageplus/descriptors/color/color_structure.hpp>
#include <imageplus/descriptors/color/dominant_color.hpp>
#include <imageplus/descriptors/texture/edge_histogram.hpp>
#include <imageplus/descriptors/texture/homogeneous_texture.hpp>
#include <imageplus/math/statistics/histogram.hpp>

using namespace std;
using namespace imageplus;
using namespace io;
using namespace descriptors;
using namespace math::statistics;

#ifdef USE_XML
using namespace XERCES_CPP_NAMESPACE;
#endif

IMAGEPLUS_TOOL_CONFIG_BRIEF()
    
    "A tool to populate your BPT or image with visual descriptors.\n";

IMAGEPLUS_TOOL_CONFIG_DESCRIPTION()

    "This tool allows the user to populate a BPT or an image with a set of visual descriptors. " +
    "It reads a BPT or image from file, computes a set of visual descriptors and writes the result to file.\n\n" +
    "Regarding the creation of the image thumbnail:\n" +
    "- If the input is a BPT, and no thumbnail directory '-t' is given, it reads the " +
    "thumbnail URI from the XML and just copies it to the descriptors file. If the thumbnail directory is given, then it overwrites " +
    "the values read from the XML.\n" +
    "- If the input is an image and no directory is given, then the tumbnail is not created.\n\n" +
    "Regarding the selection of the descriptors to be computed, each of the options for the "
    "visual descriptors can be:\n" +
    "- 0: The descriptor is not calculated.\n" +
    "- 1: The descriptor is calculated just for the whole image.\n" +
    "- 2: The descriptor is calculated for all the regions of the BPT.\n";

IMAGEPLUS_TOOL_CONFIG_PARAMETERS()
   
    // Your Arguments
    string input_filename;
    string results_dir;
    
    
    uint32 VDArea;
    uint32 VDLocalization;
    uint32 VDHaarPower;
    uint32 VDEdgeHistogram;
    uint32 VDColorStructure;
    uint32 VDColorLayout;
    uint32 VDContourShape;
    uint32 VDDominantColor;
    uint32 VDOrientedBoundingBox;
    uint32 VDHomogeneousTexture;
    uint32 VDColorMeanVariance;
    uint32 VDHistogram;
    uint64 HistogramNumBins;
    
    string thumbnail_dir;
    uint64 thumbnail_width;
    uint64 thumbnail_height;
    
    string file_type;
    
IMAGEPLUS_TOOL_CONFIG_DEFAULT_VALUES()
    VDArea = 0;
    VDLocalization = 0;
    VDHaarPower = 0;
    VDEdgeHistogram = 0;
    VDColorStructure = 0;
    VDColorLayout = 0;
    VDContourShape = 0;
    VDDominantColor = 0;
    VDOrientedBoundingBox = 0;
    VDHomogeneousTexture = 0;
    VDColorMeanVariance = 0;
    VDHistogram = 0;
    HistogramNumBins = 8;
    
    thumbnail_dir = "-";
    thumbnail_width = 100;
    thumbnail_height = 100;
    
    file_type = "";
        
IMAGEPLUS_TOOL_CONFIG_OPTIONS()
    IMAGEPLUS_TOOL_CONFIG_OPTION(VDArea, "Whether Area is calculated." );
    IMAGEPLUS_TOOL_CONFIG_OPTION(VDOrientedBoundingBox, "Whether OrientedBoundingBox is calculated." );
    IMAGEPLUS_TOOL_CONFIG_OPTION(VDLocalization, "Whether Localization is calculated." );
    IMAGEPLUS_TOOL_CONFIG_OPTION(VDHaarPower, "Whether HaarPower is calculated." );
    IMAGEPLUS_TOOL_CONFIG_OPTION(VDEdgeHistogram, "Whether EdgeHistogram is calculated." );
    IMAGEPLUS_TOOL_CONFIG_OPTION(VDColorStructure, "Whether ColorStructure is calculated." );
    IMAGEPLUS_TOOL_CONFIG_OPTION(VDColorLayout, "Whether ColorLayout is calculated." );
    IMAGEPLUS_TOOL_CONFIG_OPTION(VDContourShape, "Whether ContourShape is calculated." );
    IMAGEPLUS_TOOL_CONFIG_OPTION(VDDominantColor, "Whether DominantColor is calculated." );
    IMAGEPLUS_TOOL_CONFIG_OPTION(VDHomogeneousTexture, "Whether HomogeneousTexture is calculated." );
    IMAGEPLUS_TOOL_CONFIG_OPTION(VDColorMeanVariance, "Whether ColorMeanVariance is calculated." );
    IMAGEPLUS_TOOL_CONFIG_OPTION(VDHistogram, "Whether Histogram is calculated." );
    IMAGEPLUS_TOOL_CONFIG_OPTION(HistogramNumBins, "Number of bins for each dimension of the Histogram." );

    IMAGEPLUS_TOOL_CONFIG_OPTION_ABV ( thumbnail_dir, "Directory where the image thumbnail will be stored (if this"+
                                                      "option is not given, the thumbnail is not generated)", 't' );
    IMAGEPLUS_TOOL_CONFIG_OPTION_ABV ( thumbnail_width, "Width of the thumbnail", 'w' );
    IMAGEPLUS_TOOL_CONFIG_OPTION_ABV ( thumbnail_height, "Height of the thumbnail", 'h' );
    
    IMAGEPLUS_TOOL_CONFIG_OPTION(file_type, "Extension of the file to be read, used when the file does not have one");

IMAGEPLUS_TOOL_CONFIG_FLAGS()

IMAGEPLUS_TOOL_CONFIG_ARGUMENTS()
    IMAGEPLUS_TOOL_CONFIG_ARGUMENT ( input_filename  , "Input BPT or image filename");
    IMAGEPLUS_TOOL_CONFIG_ARGUMENT ( results_dir  , "Directory to store the results");

IMAGEPLUS_TOOL_CONFIG_READ_PARAMETERS()

    IMAGEPLUS_TOOL_CONFIG_READ( input_filename );
    IMAGEPLUS_TOOL_CONFIG_READ( results_dir );

    IMAGEPLUS_TOOL_CONFIG_READ( VDArea );
    IMAGEPLUS_TOOL_CONFIG_READ( VDOrientedBoundingBox );
    IMAGEPLUS_TOOL_CONFIG_READ( VDLocalization );
    IMAGEPLUS_TOOL_CONFIG_READ( VDHaarPower );
    IMAGEPLUS_TOOL_CONFIG_READ( VDEdgeHistogram );
    IMAGEPLUS_TOOL_CONFIG_READ( VDColorStructure );
    IMAGEPLUS_TOOL_CONFIG_READ( VDColorLayout );
    IMAGEPLUS_TOOL_CONFIG_READ( VDContourShape );
    IMAGEPLUS_TOOL_CONFIG_READ( VDDominantColor );
    IMAGEPLUS_TOOL_CONFIG_READ( VDHomogeneousTexture );
    IMAGEPLUS_TOOL_CONFIG_READ( VDColorMeanVariance );
    IMAGEPLUS_TOOL_CONFIG_READ( VDHistogram );
    IMAGEPLUS_TOOL_CONFIG_READ( HistogramNumBins );
    
    IMAGEPLUS_TOOL_CONFIG_READ( thumbnail_dir   );
    IMAGEPLUS_TOOL_CONFIG_READ( thumbnail_width );
    IMAGEPLUS_TOOL_CONFIG_READ( thumbnail_height);   
    
    IMAGEPLUS_TOOL_CONFIG_READ( file_type       );

    
//
// This is the "main" function of your tool.
//
// You can access to all your parameters (options, flags, and arguments)
// with the "cfg" object (see the code.)
//
// Run the exemple with "--help" to see your configuration.
//
    IMAGEPLUS_TOOL_CONFIG_MAIN()
    {   
    #ifdef USE_XML
        try
        {
//            clock_t start = clock();
            
            typedef ImageYUV<uint8> InputType;
            typedef RegionContour<Coord2D<int64> > RegionType;
            typedef Partition<RegionType> partition_type;

            // Complete the path
            boost::filesystem::path input_filename( cfg.input_filename );
            input_filename = boost::filesystem::system_complete(input_filename);

            std::string ext = extension(input_filename);
            
            // Set the output file name      
            string base = boost::filesystem::basename(input_filename);
                  
            std::size_t found=base.rfind("-bpt");
            if (found!=string::npos)  // The original name has "-bpt", so we erase it
            {
                base.erase(found,found+4);
            }

            boost::filesystem::path temp(base + "-vd.xml");
            boost::filesystem::path filename_result(cfg.results_dir / temp );
            
            ImageFormat image_format = UNKNOWN_IMAGE_FORMAT;
            if(ext=="")
            {
            	if( cfg.file_type == "xml" )
            		ext = ".xml";
            	else if(cfg.file_type != "")
            	{
                	if( cfg.file_type == "jpg" || cfg.file_type == "jpeg" )
                	{
                		image_format = JPEG;
                	}
                	else if( cfg.file_type == "png" )
                	{
                		image_format = PNG;
                	}
                	else if (cfg.file_type == "tiff" || cfg.file_type == "tif")
                	{
                		image_format = TIFF;
                	}
    #ifdef USE_IMAGEMAGICK
                	else if( cfg.file_type == "bmp" )
                	{
                		image_format = BMP;
                	}
    #endif
                	else
                		throw(ImagePlusError("Unsupported file_type: " + cfg.file_type));
            	}
            }
            else if(ext==".xml")
            {
            	if( cfg.file_type != "xml" && cfg.file_type != "")
            		throw  ImagePlusError( "Image format given does not correspond to the extension .xml");
            }
            else
            {
            	if (cfg.file_type == "xml")
            	{
            		ext = ".xml";
            	}
            	else if( cfg.file_type != "")
            	{
                	if( cfg.file_type == "jpg" || cfg.file_type == "jpeg" )
                	{
                		image_format = JPEG;
                	}
                	else if( cfg.file_type == "png" )
                	{
                		image_format = PNG;
                	}
                	else if (cfg.file_type == "tiff" || cfg.file_type == "tif")
                	{
                		image_format = TIFF;
                	}
    #ifdef USE_IMAGEMAGICK
                	else if( cfg.file_type == "bmp" )
                	{
                		image_format = BMP;
                	}
    #endif
                	else
                		throw(ImagePlusError("Unsupported file_type: " + cfg.file_type));
            	}
            }
             
            if(ext==".xml") // We handle a BPT
            {            
                XERCES_CPP_NAMESPACE::DOMDocument* doc;
                XERCES_CPP_NAMESPACE::DOMNode* curr_node = xml_init(input_filename.string(), doc);
    
                //Check that the name of the node is "Mpeg7"
                if(strcmp(toNative(curr_node->getNodeName()).c_str(),"Mpeg7") != 0)
                    throw ImagePlusError("XML reading: 'Mpeg7' node not found");

                // Check that there is a sequence of sons named:
                // "Description/MultimediaContent/Image/CreationInformation"
                // and returns a pointer to it
                curr_node = xml_get_check_son(curr_node, "Description");
                curr_node = xml_get_check_son(curr_node, "MultimediaContent");
                curr_node = xml_get_check_son(curr_node, "Image");
                curr_node = xml_get_check_son(curr_node, "CreationInformation");
                
                // Get ImageFile
                XERCES_CPP_NAMESPACE::DOMNode* curr_node2 = xml_get_check_son_by_field(curr_node, "RelatedMaterial", "id", "ImageFile");
                if (curr_node2==0x0)
                    throw ImagePlusError("XML reading: ImageFile field not found (expected in Description/MultimediaContent/Image/CreationInformation)");
                
                curr_node2 = xml_get_check_son(curr_node2, "MediaLocator");
                curr_node2 = xml_get_check_son(curr_node2, "MediaUri");
                
                std::string image_file = xml_get_text_son(curr_node2);
    
                // Get ThumbnailFile
                std::string thumbnail_file;
                curr_node2 = xml_get_check_son_by_field(curr_node, "RelatedMaterial", "id", "ThumbnailFile");
                if (curr_node2==0x0)
                {
                    thumbnail_file = "-";
                }
                else
                {
                    // Just pass the URI
                    curr_node2 = xml_get_check_son(curr_node2, "MediaLocator");
                    curr_node2 = xml_get_check_son(curr_node2, "MediaUri");
                  
                    thumbnail_file = xml_get_text_son(curr_node2);
                }
                
                // Get PartitionSearchFile
                curr_node2 = xml_get_check_son_by_field(curr_node, "RelatedMaterial", "id", "PartitionSearchFile");
                if (curr_node2==0x0)
                    throw ImagePlusError("XML reading: PartitionSearchFile field not found (expected in Description/MultimediaContent/Image/CreationInformation)");
                
                curr_node2 = xml_get_check_son(curr_node2, "MediaLocator");
                curr_node2 = xml_get_check_son(curr_node2, "MediaUri");
                
                std::string partition_file = xml_get_text_son(curr_node2);
                io::ReadImage ri(image_file);
                ImageRGB<uint8> my_image;
                ri >> my_image;


                //Check if the thumbnail has to be created
                if(cfg.thumbnail_dir!="-")
                {
                    //Compute thumbnail dimensions not to distort it 
                    boost::array<float64    ,2> org_size;
                    boost::array<std::size_t,2> new_size;
                    org_size = my_image.sizes();
                    float64 factor = std::min((float64)cfg.thumbnail_width /org_size[0],
                                              (float64)cfg.thumbnail_height/org_size[1]);
                    new_size = factor*org_size;

                    //Generate thumbnail and write it
                    //ImageRGB<uint8> thumbnail(math::numeric::resize(my_image, factor, factor, math::numeric::MEDIAN));
                    ImageRGB<uint8> thumbnail(math::numeric::resize(my_image, new_size));
                        
                    //Generate thumbnail and write it
                    
                    temp = base + "-small.jpg";
                    boost::filesystem::path thumbnail_dir = boost::filesystem::system_complete(cfg.thumbnail_dir);
                    boost::filesystem::path filename_thumbnail = thumbnail_dir / temp;
                    thumbnail_file = filename_thumbnail.string();
                    io::WriteImage wi(thumbnail_file);
                    wi << thumbnail;
                }
                
                
                partition_type my_part;
                io::ReadWritePartition rwpart(input_filename.string(), CHECK_IMAGE_PART, "xml");
                ImageRGB<uint8> image;
                rwpart.read(my_part, image);
    
                
                for(partition_type::roots_iterator it = my_part.begin(), it_end  = my_part.end(); 
                      it != it_end; ++it)
                {
                	// Compute the recursive descriptors (1,2) or not (0)
                    if (cfg.VDArea)         calc_descriptor(new Area(),         image, *it);
                    if (cfg.VDLocalization) calc_descriptor(new Localization<RegionType::CoordType>(), image, *it);
                    if (cfg.VDHaarPower)    calc_descriptor(new HaarPower<ImageRGB<uint8>, 2>(),  image, *it);
                    if (cfg.VDColorMeanVariance)    calc_descriptor(new ColorMeanVariance<ImageRGB<uint8> >(),  image, *it);
                    if (cfg.VDHistogram)    calc_descriptor(new Histogram<ImageRGB<uint8> >(0,255,cfg.HistogramNumBins),  image, *it);

                    // Compute the non-recursive descriptors for the whole image (1,2) or not (0)
                    if (cfg.VDOrientedBoundingBox)  calc_descriptor(new OrientedBoundingBox<RegionType::CoordType>(),  image, *it);
                    if (cfg.VDEdgeHistogram)  calc_descriptor(new EdgeHistogram<ImageRGB<uint8> >(),  image, *it);
                    if (cfg.VDColorStructure) calc_descriptor(new ColorStructure<ImageRGB<uint8> >(), image, *it);  
                    if (cfg.VDColorLayout)    calc_descriptor(new ColorLayout<ImageRGB<uint8> >(),    image, *it);
                    if (cfg.VDContourShape)   calc_descriptor(new ContourShapeMPEG7<RegionType::CoordType>(),   image, *it);  
                    if (cfg.VDDominantColor)  calc_descriptor(new DominantColor<ImageRGB<uint8> >(),  image, *it);
#ifdef USE_FFTW3
                    if (cfg.VDHomogeneousTexture)  calc_descriptor(new HomogeneousTexture<ImageRGB<uint8> >(),  image, *it);
#else
                    if (cfg.VDHomogeneousTexture) throw(ImagePlusError("HomogeneousTexture need FFTW3"));
#endif
                }
                
                for(partition_type::non_roots_iterator it = my_part.begin(), it_end  = my_part.end(); 
                    it != it_end; ++it)
                {            
                	// Compute the non-recursive descriptors for the rest of nodes (2) or none (0)
                	if (cfg.VDOrientedBoundingBox==2)  calc_descriptor(new OrientedBoundingBox<RegionType::CoordType>(),  image, *it);                    
                    if (cfg.VDEdgeHistogram==2)  calc_descriptor(new EdgeHistogram<ImageRGB<uint8> >(),  image, *it);
                    if (cfg.VDColorStructure==2) calc_descriptor(new ColorStructure<ImageRGB<uint8> >(), image, *it);
                    if (cfg.VDColorLayout==2)    calc_descriptor(new ColorLayout<ImageRGB<uint8> >(),    image, *it);
                    if (cfg.VDContourShape==2)   calc_descriptor(new ContourShapeMPEG7<RegionType::CoordType>(),   image, *it);
                    if (cfg.VDDominantColor==2)  calc_descriptor(new DominantColor<ImageRGB<uint8> >(),  image, *it);
#ifdef USE_FFTW3
                    if (cfg.VDHomogeneousTexture==2)  calc_descriptor(new HomogeneousTexture<ImageRGB<uint8> >(),  image, *it);
#else
                    if (cfg.VDHomogeneousTexture) throw(ImagePlusError("HomogeneousTexture need FFTW3"));
#endif
              	}
                
                std::vector<std::string> ident;
                if (cfg.VDArea) ident.push_back("Area");
                if (cfg.VDOrientedBoundingBox) ident.push_back("OrientedBoundingBox");
				if (cfg.VDLocalization) ident.push_back("Localization");
                if (cfg.VDHaarPower) ident.push_back("HaarPower");
                if (cfg.VDEdgeHistogram) ident.push_back("EdgeHistogram");
                if (cfg.VDColorStructure) ident.push_back("ColorStructure");
                if (cfg.VDColorLayout) ident.push_back("ColorLayout");
                if (cfg.VDContourShape) ident.push_back("ContourShapeMPEG7");
                if (cfg.VDDominantColor) ident.push_back("DominantColor");
                if (cfg.VDHomogeneousTexture) ident.push_back("HomogeneousTexture");
                if (cfg.VDColorMeanVariance) ident.push_back("ColorMeanVariance");
                if (cfg.VDHistogram)
                {
                    std::string hist_id("Histogram");
                    for(uint64 ch=0; ch<3; ch++)
                    {
                        hist_id = hist_id + "_" + boost::lexical_cast<std::string>(cfg.HistogramNumBins);
                    }
                    ident.push_back(hist_id);
                }
                
                std::vector<std::string> uri_names;
                std::vector<std::string> uri_values;
                uri_names.push_back("ImageFile");
                uri_values.push_back(image_file);
                if(thumbnail_file!="-")
                {
                    uri_names.push_back("ThumbnailFile");
                    uri_values.push_back(thumbnail_file);
                }
                uri_names.push_back("PartitionSearchFile");
                uri_values.push_back(partition_file);
                uri_names.push_back("BinaryPartitionTree");
                uri_values.push_back(input_filename.string());
                
                WriteDescriptors writedesc(filename_result.string(), ident, uri_names, uri_values);
                writedesc << my_part;
            }
            else  // We handle a single image
            {
            	io::ReadImage ri(input_filename.string(), image_format);
                ImageRGB<uint8> my_image;
                ri >> my_image;
                
                // Compute the descriptors directly from the image (1,2) or not (0)
                if (cfg.VDArea)           calc_descriptor(new Area(),         my_image);
                if (cfg.VDOrientedBoundingBox)    calc_descriptor(new OrientedBoundingBox<RegionType::CoordType>(),  my_image);
                if (cfg.VDLocalization)   calc_descriptor(new Localization<RegionType::CoordType>(), my_image);
                if (cfg.VDHaarPower)      calc_descriptor(new HaarPower<ImageRGB<uint8>, 2>(),  my_image);
                if (cfg.VDEdgeHistogram)  calc_descriptor(new EdgeHistogram<ImageRGB<uint8> >(),  my_image);
                if (cfg.VDColorStructure) calc_descriptor(new ColorStructure<ImageRGB<uint8> >(), my_image);  
                if (cfg.VDColorLayout)    calc_descriptor(new ColorLayout<ImageRGB<uint8> >(),    my_image);
                if (cfg.VDContourShape)   calc_descriptor(new ContourShapeMPEG7<RegionType::CoordType>(),   my_image);  
                if (cfg.VDDominantColor)  calc_descriptor(new DominantColor<ImageRGB<uint8> >(),  my_image);
#ifdef USE_FFTW3
                if (cfg.VDHomogeneousTexture)  calc_descriptor(new HomogeneousTexture<ImageRGB<uint8> >(),  my_image);
#else
                if (cfg.VDHomogeneousTexture) throw(ImagePlusError("HomogeneousTexture need FFTW3"));
#endif
                if (cfg.VDColorMeanVariance)  calc_descriptor(new ColorMeanVariance<ImageRGB<uint8> >(),  my_image);
                if (cfg.VDHistogram)  	  calc_descriptor(new Histogram<ImageRGB<uint8> >(0,255,cfg.HistogramNumBins),  my_image);
                
                
                std::vector<std::string> ident;
                if (cfg.VDArea) ident.push_back("Area");
                if (cfg.VDOrientedBoundingBox) ident.push_back("OrientedBoundingBox");
                if (cfg.VDLocalization) ident.push_back("Localization");
                if (cfg.VDHaarPower) ident.push_back("HaarPower");
                if (cfg.VDEdgeHistogram) ident.push_back("EdgeHistogram");
                if (cfg.VDColorStructure) ident.push_back("ColorStructure");
                if (cfg.VDColorLayout) ident.push_back("ColorLayout");
                if (cfg.VDContourShape) ident.push_back("ContourShapeMPEG7");
                if (cfg.VDDominantColor) ident.push_back("DominantColor");
                if (cfg.VDHomogeneousTexture) ident.push_back("HomogeneousTexture");
                if (cfg.VDColorMeanVariance) ident.push_back("ColorMeanVariance");
                if (cfg.VDHistogram)
                {
                    std::string hist_id("Histogram");
                    for(uint64 ch=0; ch<3; ch++)
                    {
                        hist_id = hist_id + "_" + boost::lexical_cast<std::string>(cfg.HistogramNumBins);
                    }
                    ident.push_back(hist_id);
                }

                
                //Check if the thumbnail has to be created
                std::string thumbnail_file="-";
                if(cfg.thumbnail_dir!="-")
                {
                    //Compute thumbnail dimensions not to distort it 
                    boost::array<float64    ,2> org_size;
                    boost::array<std::size_t,2> new_size;
                    org_size = my_image.sizes();
                    float64 factor = std::min((float64)cfg.thumbnail_width /org_size[0],
                                              (float64)cfg.thumbnail_height/org_size[1]);
                    new_size = factor*org_size;

                    //Generate thumbnail and write it
                    //ImageRGB<uint8> thumbnail(math::numeric::resize(my_image, factor, factor, math::numeric::MEDIAN));
                    ImageRGB<uint8> thumbnail(math::numeric::resize(my_image, new_size));

                    
                    temp = base + "-small.jpg";
                    boost::filesystem::path thumbnail_dir = boost::filesystem::system_complete(cfg.thumbnail_dir);
                    boost::filesystem::path filename_thumbnail = thumbnail_dir / temp;
                    thumbnail_file = filename_thumbnail.string();
                    io::WriteImage wi(thumbnail_file);
                    wi << thumbnail;
                }
                
                
                std::vector<std::string> uri_names;
                std::vector<std::string> uri_values;
                uri_names.push_back("ImageFile");
                uri_values.push_back(input_filename.string());
                if(thumbnail_file!="-")
                {
                    uri_names.push_back("ThumbnailFile");
                    uri_values.push_back(thumbnail_file);
                }
                
                WriteDescriptors writedesc(filename_result.string(), ident, uri_names, uri_values);
                writedesc << my_image;
            }
            
//            clock_t end = clock();
//            std::cout << "Elapsed time: " << (end-start)/(float64)CLOCKS_PER_SEC << " seconds." << std::endl;
            
            return 0;
            
        }
        catch(BacktracedImagePlusException e)
        {
            std::cerr << e.what() << std::endl;
            exit(1);
        }
        catch(std::exception e)
        {
            std::cerr << e.what() << std::endl;
            exit(1);
        }
        
    #else
        throw ImagePlusError("XML dependency needed for bpt_population to work properly");
    #endif
    }


    //
    // This last line is mandatory!
    //
    IMAGEPLUS_TOOL_CONFIG_END()



