/*
 * hierarchical_partition.cpp
 *
 *  Created on: Aug 17, 2012
 *      Author: guillem
 */


#include <imageplus/core/image_signal.hpp>
#include <imageplus/core/video_signal.hpp>
#include <imageplus/core/regions/hierarchical_region.hpp>

#include <imageplus/segmentation/partition/partition.hpp>
#include <imageplus/segmentation/partition/hierarchical_region_partition.hpp>

#include <imageplus/bpt/binary_partition_tree.hpp>
#include <imageplus/bpt/models/mean_color_distance.hpp>
#include <imageplus/toolbox/tictoc.hpp>


using namespace imageplus;
#define uint64 imageplus::uint64


int main() {

	typedef ImageSignal<float64,1> ImageType;
	typedef VideoSignal<float64,1> VideoType;

	typedef ImageType::coord_type coord2d;
	typedef VideoType::coord_type coord3d;

	typedef HierarchicalRegion<coord2d> Region2D;
	typedef HierarchicalRegion<coord3d> Region3D;

	typedef bpt::BinaryPartitionTree<ImageType> 	BPTAlgorithm;
	typedef BPTAlgorithm::BPT						BPT;
	typedef BPTAlgorithm::PartitionType				PartitionType;

	typedef bpt::MeanColorDistanceModel<ImageType, Region2D> MeanColorDistance;

	uint64 N = 400;
	ImageType img(N,N);
	PartitionType p(N,N);

	for (uint64 x = 0; x < N; x++) {
		for (uint64 y = 0; y < N; y++) {
			img(x,y)(0) = x/(N/6) + y/(N/6) + (rand()%10)*0.01;
			//std::cout << img(x,y).value().transpose() << " ";
		}
		//std::cout << std::endl;
	}
	//exit(0);

	p.set_unique_labels();

	BPTAlgorithm::Parameters pars;
	pars.debug = true;
	pars.step = 0.1;
	pars.update_roots_partition = false;

	toolbox::TicToc t;
	t.tic();
	BPTAlgorithm bpt_mean_color(pars);

	bpt_mean_color.init(img,p);
	bpt_mean_color.create<MeanColorDistance>(img);
	t.toc(true);

	typedef bpt::BinaryPartitionTree<VideoType> 	BPTAlgorithm3D;
	typedef BPTAlgorithm3D::BPT						BPT3D;
	typedef BPTAlgorithm3D::PartitionType			PartitionType3D;

	typedef bpt::MeanColorDistanceModel<VideoType, Region3D> MeanColorDistance3D;

	uint64 N3 = 200;
	uint64 frames = 10;
	VideoType vid(N3,N3,frames);
	PartitionType3D p3d(N3,N3,frames);

	for (uint64 f = 0; f < frames; f++)
	for (uint64 x = 0; x < N; x++) {
		for (uint64 y = 0; y < N; y++) {
			vid(x,y,f)(0) = x/(N/4) + y/(N/4) + f/(frames/2) + (rand()%10)*0.01;
			//std::cout << img(x,y).value().transpose() << " ";
		}
		//std::cout << std::endl;
	}
	//exit(0);

	p3d.set_unique_labels();

	BPTAlgorithm3D::Parameters pars3d;
	pars3d.debug = true;
	pars3d.step = 0.1;
	pars3d.update_roots_partition = false;

	t.tic();
	BPTAlgorithm3D bpt_mean_color_3d(pars3d);
	bpt_mean_color_3d.init(vid,p3d);
	bpt_mean_color_3d.create<MeanColorDistance3D>(vid);
	t.toc(true);

}



