// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------

//!
//!  \file color_range.hpp
//!
//!  Class to contain and calculate the color range of images
//!

#ifndef IMAGEPLUS_CORE_COLOR_RANGE_HPP
#define IMAGEPLUS_CORE_COLOR_RANGE_HPP

#include <imageplus/core/visual_descriptors.hpp>
#include <boost/array.hpp>

namespace imageplus
{
    /*!
     * \cond SKIP_DOC
     */
    template<class InputModel>
    struct ChannelRange
    {
        typename InputModel::data_type min; // Minimum of each channel
        typename InputModel::data_type max; // Maximum of each channel
    };
    /*!
     * \endcond SKIP_DOC
     */        
    

    //! \brief Color range of the input (maximum and minimum for each channel)
    //!
    //! \author Jordi Pont Tuset <jordi.pont@upc.edu>
    //!
    //! \date 30-03-2010
    template<class InputModel>
    class ColorRange : public DescriptorBase,
                       public boost::array<ChannelRange<InputModel>, InputModel::channels>
    {
    public:
        //! Type to refer to the type of data which will be returned by this descriptor
        typedef boost::array<ChannelRange<InputModel>, InputModel::channels>  vd_type;
        
        //!
        //! \brief Default constructor
        //!
        ColorRange() : DescriptorBase("ColorRange",true), vd_type()
        {
        };
        
        //! \brief Calculates the color_volume of a region given a pair of iterators. 
        //!
        //! \param[in] first      : Iterator to the beginning of the region
        //! \param[in] last       : Iterator to the end of the region
        //! \param[in] peer_descs : Pointer to CollaborativeDescriptors, in principle is never 0x0 but it is a good idea to ASSERT it
        template< class IteratorModel >
        void calculate(IteratorModel first, IteratorModel last, CollaborativeDescriptors* peer_descs)
        {
            for (std::size_t ii=0; ii<InputModel::channels; ++ii) 
            {
                (*this)[ii].max = std::numeric_limits<typename InputModel::data_type>::min();
                (*this)[ii].min = std::numeric_limits<typename InputModel::data_type>::max();
            }
            
            for(; first!=last; ++first)
            {
                for (std::size_t ii=0; ii<InputModel::channels; ++ii) 
                {
                    (*this)[ii].max =  std::max((*first).value(ii),(*this)[ii].max);
                    (*this)[ii].min =  std::min((*first).value(ii),(*this)[ii].min);
                }
            }
        }
        
        
        //! \brief Calculates color_volume of the father region given the sons ones.
        //!
        //! \param[in] son1_descs : CollaborativeDescriptors of the son 1
        //! \param[in] son2_descs : CollaborativeDescriptors of the son 2
        //! \param[in] peer_descs : Pointer to CollaborativeDescriptors, in principle is never 0x0 but it is a good idea to ASSERT it
        void recursive_calculate(CollaborativeDescriptors& son1_descs, CollaborativeDescriptors& son2_descs, CollaborativeDescriptors* peer_descs)
        {        
            ColorRange<InputModel>& desc1 = son1_descs.get(*this);
            ColorRange<InputModel>& desc2 = son2_descs.get(*this);
            
            for (std::size_t ii=0; ii<InputModel::channels; ++ii) 
            {
                (*this)[ii].max =  std::max(desc1[ii].max, desc2[ii].max);
                (*this)[ii].min =  std::min(desc1[ii].min, desc2[ii].min);
            }
        }
    };
}


#endif

