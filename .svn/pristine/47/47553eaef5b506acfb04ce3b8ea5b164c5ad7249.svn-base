// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------

//
// - NAME of your tool
//   - This is mandatory
//   - Avoid the character '-', use always '_' 
// - GROUP where your tool belong (tools/GROUP directory)
//   - This is optional
//   - Comment the second definition to not group your tool
//
#define IMAGEPLUS_TOOL_CONFIG_NAME  depth_segmentation
#define IMAGEPLUS_TOOL_CONFIG_GROUP bpt

//
// Include tool_config.hpp header 
//
// Note that it is mandatory to FIRST define the name (and group)
// of your tool, and LATER on include this header.
//
#include <imageplus/toolbox/tool_config.hpp>


//
// ImagePlus headers
//
#include <imageplus/core.hpp>
#include <imageplus/bpt/creation.hpp>
#include <imageplus/bpt/creation/stop_merging.hpp>
#include <imageplus/io/readimage.hpp>
#include <imageplus/io/writeimage.hpp>
#include <imageplus/io/readsequence.hpp>
#include <imageplus/io/readwritepartition.hpp>
#include <imageplus/io/writebitstream.hpp> 

#include <imageplus/segmentation/label_flatzone.hpp>
#include <imageplus/segmentation/overlay.hpp>
#include <imageplus/segmentation/distances.hpp>
#include <imageplus/compress/arithmetic_codec.hpp>

#include <imageplus/math/numeric/interpolation.hpp>
#include <imageplus/math/numeric/numeric_util.hpp>

#include <boost/filesystem.hpp>
#include <boost/format.hpp>

#include <time.h>
#include <set>


//
// Namespaces
//
using namespace std;
using namespace imageplus;
using namespace imageplus::bpt;
using namespace imageplus::segmentation;
using namespace imageplus::compress;
using namespace imageplus::math::numeric;


inline bool notdash (const std::string& s)
{
    if ( s.length() == 0 )
        return false;

    if ( s[s.length()-1] == '-' )
        return false;

    return true;
}


std::vector<float64> maxmin_weights( const ImageYUV<uint8>& yuv_image)
{
    // Compute maximum and minimum for each channel and weights
    std::size_t sx = yuv_image.size_x();
    std::size_t sy = yuv_image.size_y();
    std::vector<uint8> curr_min(3,255);
    std::vector<uint8> curr_max(3,0);



    for (std::size_t jj=0; jj<sy; jj++)
    {
        for (std::size_t ii=0; ii<sx; ii++)
        {
            curr_max[0] = std::max(curr_max[0], yuv_image(0)[ii][jj]);
            curr_max[1] = std::max(curr_max[1], yuv_image(1)[ii][jj]);
            curr_max[2] = std::max(curr_max[2], yuv_image(2)[ii][jj]);
            
            curr_min[0] = std::min(curr_min[0], yuv_image(0)[ii][jj]);
            curr_min[1] = std::min(curr_min[1], yuv_image(1)[ii][jj]);
            curr_min[2] = std::min(curr_min[2], yuv_image(2)[ii][jj]);
        }
    }
    
    std::vector<float64> weights(3);
    float64 tmp0 = 1./((float64)curr_max[0]-(float64)curr_min[0]); 
    float64 tmp1 = 1./((float64)curr_max[1]-(float64)curr_min[1]);
    float64 tmp2 = 1./((float64)curr_max[2]-(float64)curr_min[2]);
    
    weights[0] = tmp0 / (tmp0+tmp1+tmp2); 
    weights[1] = tmp1 / (tmp0+tmp1+tmp2);
    weights[2] = tmp2 / (tmp0+tmp1+tmp2);

    return weights;
}


IMAGEPLUS_TOOL_CONFIG_BRIEF()
    
    "Segmentation of depth based on color view.\n";

IMAGEPLUS_TOOL_CONFIG_DESCRIPTION()

    "This tool computes a depth segmentation based on a color view. It works with MVD+depth sequences\n\n";


IMAGEPLUS_TOOL_CONFIG_PARAMETERS()

    // Your Options:
    std::vector<uint64> cams_number;

    uint64 num_regions_initial_partition;
    uint64 num_regions_combined_partition;
    float64 thres_amc_combined_partition;
    
    string input_color_image;
    string input_depth_image;

    uint64 first_frame;
    uint64 last_frame;
    uint64 skip_frames;

    string output_color_initial_partition;
    string output_ideal_partition;
    string output_true_ideal_partition;

    string output_combined_partition;
    string output_non_merging_orders;

    float64 flatzone_tolerance;
    float64 flatzone_color_tolerance;

    // Segmentation images with overlayed contours
    string output_ov_ideal_partition;
    string output_ov_combined_partition;

    uint16 quan_prob_0;

    float64 alpha;
    bool    verbose;

    float64 fps;

    
IMAGEPLUS_TOOL_CONFIG_DEFAULT_VALUES()

    for (uint64 i = 0; i < 8; i++)
    {
      cams_number.push_back(i);
    }

    num_regions_initial_partition = 1000;
    num_regions_combined_partition = 80;
    thres_amc_combined_partition = 0.12;
    alpha = 0.25;

    first_frame = 0;
    last_frame  = 100;
    skip_frames = 0;

    flatzone_tolerance = 5.0;
    flatzone_color_tolerance = 1000.0;

    output_color_initial_partition = "-";
    output_ideal_partition = "-";
    output_true_ideal_partition = "-";
    output_combined_partition = "-";
    output_non_merging_orders = "-";

    // Segmentation images with overlayed contours
    output_ov_ideal_partition = "-";
    output_ov_combined_partition = "-";

    quan_prob_0 = 8;

    verbose=false;

    fps = 15.0;

IMAGEPLUS_TOOL_CONFIG_OPTIONS()

    //
    // Here you have to define your OPTIONS, with a description 
    // and an optional abreviature
    //
    IMAGEPLUS_TOOL_CONFIG_OPTION ( cams_number, "Camera numbers, this should be a vector with the camera number for all cameras");

    IMAGEPLUS_TOOL_CONFIG_OPTION ( num_regions_initial_partition,  "Number of regions in the initial partition");
    IMAGEPLUS_TOOL_CONFIG_OPTION ( num_regions_combined_partition, "Number of regions in the final combined partition" );
    IMAGEPLUS_TOOL_CONFIG_OPTION ( thres_amc_combined_partition,   "Threshold for to stop the AMC merging in the final combined partition, only used if 'num_regions_combined_partition' is 0" );

    IMAGEPLUS_TOOL_CONFIG_OPTION_ABV ( alpha      , "Alpha value in the NWMC criterion"          , 'a' );

    IMAGEPLUS_TOOL_CONFIG_OPTION ( input_color_image, "Filename for color image" );
    IMAGEPLUS_TOOL_CONFIG_OPTION ( input_depth_image, "Filename for depth image" );

    IMAGEPLUS_TOOL_CONFIG_OPTION_ABV ( first_frame, "First frame of the sequence", 'f' );
    IMAGEPLUS_TOOL_CONFIG_OPTION_ABV ( last_frame , "Last frame of the sequence", 'l' );
    IMAGEPLUS_TOOL_CONFIG_OPTION_ABV ( skip_frames, "Skip frames (0 none)", 's' );

    IMAGEPLUS_TOOL_CONFIG_OPTION ( flatzone_tolerance, "Flat-zone hole filling, maximum acceptable difference (norm infinity) between two colors to be considered equal" );
    IMAGEPLUS_TOOL_CONFIG_OPTION ( flatzone_color_tolerance, "Flat-zone hole filling, Maximum WSDM color difference for a hole with respect its surrounding to be filled" );

    IMAGEPLUS_TOOL_CONFIG_OPTION ( output_color_initial_partition, "Filename for initial (fine) color partition. Use \"-\" for no output" );
    IMAGEPLUS_TOOL_CONFIG_OPTION ( output_ideal_partition, "Filename for ideal depth partition. Use \"-\" for no output" );
    IMAGEPLUS_TOOL_CONFIG_OPTION ( output_true_ideal_partition, "Filename for true ideal depth partition. Use \"-\" for no output" );
    IMAGEPLUS_TOOL_CONFIG_OPTION ( output_combined_partition, "Filename for final combined partition" );
    IMAGEPLUS_TOOL_CONFIG_OPTION ( output_non_merging_orders, "Filename for non merging orders" );

    IMAGEPLUS_TOOL_CONFIG_OPTION ( output_ov_ideal_partition, "Filename for overlayed ideal partition. Use \"-\" for no output" );
    IMAGEPLUS_TOOL_CONFIG_OPTION ( output_ov_combined_partition, "Filename for overlayed final combined partition" );

    IMAGEPLUS_TOOL_CONFIG_OPTION ( quan_prob_0, "Number of bits to quantize probability of symbol 0 in the non merging order sequence. Use a value of '0' to use an adaptative bit model and no quantization" );

    IMAGEPLUS_TOOL_CONFIG_OPTION     ( fps, "Frames per second of the input sequence (only used for reporting data)" );

IMAGEPLUS_TOOL_CONFIG_FLAGS()

    IMAGEPLUS_TOOL_CONFIG_FLAG_ABV   ( verbose       , "Print extra information in cerr" , 'v' );

IMAGEPLUS_TOOL_CONFIG_ARGUMENTS()

    //
    // Here you have to define your ARGUMENTS with a description. 
    // You should put them in the DESIRED ORDER in the command-line
    //
    // Note that an argument that is a vector should be the last and no more
    // argument can be added later. Think: is impossible to parser arguments 
    // afters an unknown size vector!
    // If you need more than one vector, use "options" instead of arguments.
    //


IMAGEPLUS_TOOL_CONFIG_READ_PARAMETERS()

    //
    // Here you have to read all your parameters
    //
    // DO NOT FORGET THIS STEP!!
    //

    IMAGEPLUS_TOOL_CONFIG_READ ( cams_number );

    IMAGEPLUS_TOOL_CONFIG_READ ( num_regions_initial_partition );
    IMAGEPLUS_TOOL_CONFIG_READ ( num_regions_combined_partition );
    IMAGEPLUS_TOOL_CONFIG_READ ( thres_amc_combined_partition );

    IMAGEPLUS_TOOL_CONFIG_READ ( alpha );

    IMAGEPLUS_TOOL_CONFIG_READ ( input_color_image );
    IMAGEPLUS_TOOL_CONFIG_READ ( input_depth_image );

    IMAGEPLUS_TOOL_CONFIG_READ( first_frame );
    IMAGEPLUS_TOOL_CONFIG_READ( last_frame );
    IMAGEPLUS_TOOL_CONFIG_READ( skip_frames );

    IMAGEPLUS_TOOL_CONFIG_READ ( flatzone_tolerance );
    IMAGEPLUS_TOOL_CONFIG_READ ( flatzone_color_tolerance );

    IMAGEPLUS_TOOL_CONFIG_READ ( output_color_initial_partition );
    IMAGEPLUS_TOOL_CONFIG_READ ( output_ideal_partition );
    IMAGEPLUS_TOOL_CONFIG_READ ( output_true_ideal_partition );
    IMAGEPLUS_TOOL_CONFIG_READ ( output_combined_partition );
    IMAGEPLUS_TOOL_CONFIG_READ ( output_non_merging_orders );

    IMAGEPLUS_TOOL_CONFIG_READ ( output_ov_ideal_partition );
    IMAGEPLUS_TOOL_CONFIG_READ ( output_ov_combined_partition );

    IMAGEPLUS_TOOL_CONFIG_READ ( quan_prob_0 );

    IMAGEPLUS_TOOL_CONFIG_READ ( verbose );

    IMAGEPLUS_TOOL_CONFIG_READ( fps );

//
// This is the "main" function of your tool.
//
// You can access to all your parameters (options, flags, and arguments)
// with the "cfg" object (see the code.)
//
// Run the exemple with "--help" to see your configuration.
//
IMAGEPLUS_TOOL_CONFIG_MAIN()
{   
    
    std::cout << "Input parameters: " << std::endl;
    std::cout << "  cams_number                    = [";
     for (uint64 i = 0; i < cfg.cams_number.size(); i++)
    {
        std::cout << cfg.cams_number[i];
        if ( i < cfg.cams_number.size() - 1) 
        {
            std::cout << ",";
        }
    }
    std::cout << "]" << std::endl;
    std::cout << "  input_color_image              = " << cfg.input_color_image << std::endl;
    std::cout << "  input_depth_image              = " << cfg.input_depth_image << std::endl;
    
    std::cout << "  first_frame                    = " << cfg.first_frame << std::endl;
    std::cout << "  last_frame                     = " << cfg.last_frame << std::endl;
    std::cout << "  skip_frames                    = " << cfg.skip_frames << std::endl;
    
    std::cout << "  num_regions_initial_partition  = " << cfg.num_regions_initial_partition << std::endl;
    std::cout << "  num_regions_combined_partition = " << cfg.num_regions_combined_partition << std::endl;
    std::cout << "  thres_amc_combined_partition   = " << cfg.thres_amc_combined_partition << std::endl;
    std::cout << "  alpha                          = " << cfg.alpha <<  std::endl;

    std::cout << "  flatzone_tolerance             = " << cfg.flatzone_tolerance <<  std::endl;
    std::cout << "  flatzone_color_tolerance       = " << cfg.flatzone_color_tolerance <<  std::endl;

    std::cout << "  output_color_initial_partition = " << cfg.output_color_initial_partition << std::endl;
    std::cout << "  output_ideal_partition         = " << cfg.output_ideal_partition << std::endl;
    std::cout << "  output_true_ideal_partition    = " << cfg.output_true_ideal_partition << std::endl;
    std::cout << "  output_combined_partition      = " << cfg.output_combined_partition << std::endl;
    std::cout << "  output_non_merging_orders      = " << cfg.output_non_merging_orders << std::endl;
    
    std::cout << "  output_ov_ideal_partition      = " << cfg.output_ov_ideal_partition << std::endl;
    std::cout << "  output_ov_combined_partition   = " << cfg.output_ov_combined_partition << std::endl;
    
    std::cout << "  quan_prob_0                    = " << cfg.quan_prob_0 << std::endl;

    std::cout << "  fps = " << cfg.fps << std::endl;

    std::cout << "  verbose                        = " << cfg.verbose << std::endl;
    std::cout << std::endl << std::endl;

    // Prepare read sequences
    std::vector<io::ReadSequence> rs_color(cfg.cams_number.size());
    std::vector<io::ReadSequence> rs_depth(cfg.cams_number.size());
   
    for (uint64 i = 0; i < cfg.cams_number.size(); i++)
    {
        // Color can be a YUV sequence or printf list of files
        if ( boost::filesystem::extension(cfg.input_color_image) == ".yuv" )
        {
            rs_color[i].open(boost::str( boost::format(cfg.input_color_image) % cfg.cams_number[i] ));
        }

        // Depth is a YUV400 sequence or list of depth files
        if ( boost::filesystem::extension(cfg.input_depth_image) == ".yuv" )
        {
            rs_depth[i].open(boost::str( boost::format(cfg.input_depth_image) % cfg.cams_number[i] ));
        }
    }

    uint64 total_bits   = 0;
    uint64 total_frames = 0;

    // Formatted output header
    std::cout << "               Number_Regions             Number_Non         0         #bits_after     " << std::endl;
    std::cout << " Cam#  Frame#  Base_Partition  Mergins#  Merging_Orders  Probability  ArithmeticCodec  " << std::endl;
    std::cout << "-------------------------------------------------------------------------------------- " << std::endl;   

    for (uint64 current_frame = cfg.first_frame ; current_frame <= cfg.last_frame ; current_frame += cfg.skip_frames+1)
    {

        for (uint64 i_cam = 0; i_cam < cfg.cams_number.size(); i_cam++)
        {

            io::ReadImage ri;
            io::WriteImage writeImage;
            
            ImagePartition<> ideal_partition;
            ImagePartition<> combined_partition;
            ImagePartition<> initial_partition;
            
            ImageYUV<uint8> yuv_image;
            ImageCIELab<uint8> cielab_image;
            ImageGray<uint8> depth_image;
            
            typedef ImageCIELab<uint8> InputType;
            typedef RegionContour<Coord2D<int64> > RegionType;
            typedef Partition<RegionType> partition_type;
            
            // Read input color image
            if ( boost::filesystem::extension(cfg.input_color_image) == ".yuv" ) 
            {
                rs_color[i_cam][current_frame] >> yuv_image;
            } else {
                ImageRGB<uint8> rgb_image;
                ri.open(boost::str( boost::format(cfg.input_color_image) % cfg.cams_number[i_cam] % current_frame ));
                ri >> rgb_image;
                yuv_image = to_yuv(rgb_image);
            }
            cielab_image = to_cielab(yuv_image);
    
            // Read input depth image
            if ( boost::filesystem::extension(cfg.input_depth_image) == ".yuv" ) 
            {
                rs_depth[i_cam][current_frame] >> depth_image;
            } else {
                ri.open(boost::str( boost::format(cfg.input_depth_image) % cfg.cams_number[i_cam] % current_frame ));
                ri >> depth_image;
            }

            clock_t start = clock();
        
            std::vector<float64> weights = maxmin_weights(cielab_image);

            // 
            // Fine partition (color image) using flat_zones
            // 
            ImagePartition<> base_part(yuv_image.size_x(), yuv_image.size_y());
            uint32 num_regions_base;
            if ( ( cfg.flatzone_tolerance == 0.0) && ( cfg.flatzone_color_tolerance == 0.0 ) )
            {
                const FlatZone& my_flatzone = calc_descriptor(new FlatZone(), cielab_image);
                num_regions_base = my_flatzone.num_regions();
                base_part = my_flatzone;
            }
            else
            {
                const FlatZoneHoleFilling& my_flatzone = calc_descriptor(new FlatZoneHoleFilling(cfg.flatzone_tolerance,cfg.flatzone_color_tolerance), cielab_image); 
                num_regions_base = my_flatzone.num_regions();
                base_part = my_flatzone;
            }
                
            clock_t tmp = clock();

            if (cfg.verbose == true)
            {
                std::cerr << "num_regions color flat-zone (fine) partition: " << num_regions_base << std::endl;
                std::cerr << "Elapsed time previous steps: " << ((float64)(tmp-start))/CLOCKS_PER_SEC << std::endl;
                start = tmp;
            }

            //
            // Compute initial partition from color view 
            //
    
            BPTModels<InputType, RegionType> model_set;
            model_set.add_model(new ColorHomogeneity<InputType, RegionType, WEDM>(weights),cfg.alpha);
            //model_set.add_model(new Contour<InputType, RegionType>(), (1-cfg.alpha));

            // label_flatzone can give us an initial partition with few regions
            uint32 num_regs = (num_regions_base > (uint32)cfg.num_regions_initial_partition ) ? cfg.num_regions_initial_partition : num_regions_base;

            // The whole BPT based on the color model 
            partition_type tmp_bpt(base_part);
            create_bpt(tmp_bpt, cielab_image, model_set, num_regs);
        
            partition_type::roots_iterator reg_it = tmp_bpt.begin();
            partition_type::roots_iterator reg_it_end = tmp_bpt.end();
            initial_partition.resize(yuv_image.size_x(),yuv_image.size_y());
            create_image_partition(reg_it, reg_it_end, initial_partition);
            relabel(initial_partition,initial_partition);

            tmp = clock();
            
            if (cfg.verbose == true)
            {
                std::cerr << "Elapsed time computing initial color fine partition: " << ((float64)(tmp-start))/CLOCKS_PER_SEC << std::endl;
            }

            // Save initial partition if asked to
            if ( notdash(cfg.output_color_initial_partition) )
            {
                std::string output_color_initial_partition = boost::str( boost::format( cfg.output_color_initial_partition ) % cfg.cams_number[i_cam] % current_frame );
                io::WriteImage writeImage ( output_color_initial_partition );
                writeImage << initial_partition;
            }



            //
            // Compute true ideal partition from depth (only if asked to write it as it is *NOT* used)
            //
            if ( notdash(cfg.output_true_ideal_partition) )
            {
                // Fine partition using flat_zones
                ImagePartition<> base_part_true(depth_image.size_x(), depth_image.size_y());
                uint32 num_regions_base_true;
                if ( ( cfg.flatzone_tolerance == 0.0) && ( cfg.flatzone_color_tolerance == 0.0 ) )
                {
                    const FlatZone& my_flatzone_true = calc_descriptor(new FlatZone(), depth_image);
                    num_regions_base_true = my_flatzone_true.num_regions();
                    base_part_true = my_flatzone_true;
                }
                else
                {
                    const FlatZoneHoleFilling& my_flatzone_true = calc_descriptor(new FlatZoneHoleFilling(cfg.flatzone_tolerance,cfg.flatzone_color_tolerance), depth_image); 
                    num_regions_base_true = my_flatzone_true.num_regions();
                    base_part_true = my_flatzone_true;
                }
                
                // Compute initial partition    
                BPTModels<ImageGray<uint8>, RegionType> model_set_true;
                model_set_true.add_model(new ColorHomogeneity<ImageGray<uint8>, RegionType, WEDM>(),cfg.alpha);

                uint32 num_regs_true = (num_regions_base_true > (uint32)cfg.num_regions_initial_partition ) ? cfg.num_regions_initial_partition : num_regions_base;

                // The whole BPT based on the color model 
                partition_type tmp_bpt_true(base_part_true);
                create_bpt(tmp_bpt_true, depth_image, model_set_true, num_regs_true);
                
                ImagePartition<> initial_partition_true;
                partition_type::roots_iterator reg_it_true = tmp_bpt_true.begin();
                partition_type::roots_iterator reg_it_end_true = tmp_bpt_true.end();
                initial_partition_true.resize(depth_image.size_x(),depth_image.size_y());
                create_image_partition(reg_it_true, reg_it_end_true, initial_partition_true);
                relabel(initial_partition_true,initial_partition_true);

                // Merging model for the Color+Contour part (NWMC)
                BPTModels<ImageGray<uint8>, RegionType> model_set_gray_true;
                model_set_gray_true.add_model(new ColorHomogeneity<ImageGray<uint8>, RegionType, WEDM>(), cfg.alpha);
                model_set_gray_true.add_model(new Contour<ImageGray<uint8>, RegionType>(), (1-cfg.alpha));

                partition_type ideal_bpt_true(initial_partition_true);
        
                create_bpt(ideal_bpt_true, depth_image, model_set_gray_true, cfg.num_regions_combined_partition);

                ImagePartition<> ideal_partition_true;
                reg_it_true = ideal_bpt_true.begin();
                reg_it_end_true = ideal_bpt_true.end();
                ideal_partition_true.resize(depth_image.size_x(),depth_image.size_y());
                create_image_partition(reg_it_true, reg_it_end_true, ideal_partition_true);
                relabel(ideal_partition_true,ideal_partition_true);

                std::string output_ideal_partition_true = boost::str( boost::format( cfg.output_true_ideal_partition ) % cfg.cams_number[i_cam] % current_frame );
                io::WriteImage writeImage ( output_ideal_partition_true );
                writeImage << ideal_partition_true;

            }

            //
            // Compute ideal_partition from depth (using color fine partition)
            //
            
            start = clock();

            // Merging model for the Color+Contour part (NWMC)
            BPTModels<ImageGray<uint8>, RegionType> model_set_gray;
            model_set_gray.add_model(new ColorHomogeneity<ImageGray<uint8>, RegionType, WEDM>(), cfg.alpha);
            model_set_gray.add_model(new Contour<ImageGray<uint8>, RegionType>(), (1-cfg.alpha));

            partition_type ideal_bpt(initial_partition);
        
            create_bpt(ideal_bpt, depth_image, model_set_gray, cfg.num_regions_combined_partition);

            reg_it = ideal_bpt.begin();
            reg_it_end = ideal_bpt.end();
            ideal_partition.resize(yuv_image.size_x(),yuv_image.size_y());
            create_image_partition(reg_it, reg_it_end, ideal_partition);
            relabel(ideal_partition,ideal_partition);

            tmp = clock();

            if (cfg.verbose == true)
            {
                std::cerr << "Elapsed time ideal depth partition: " << ((float64)(tmp-start))/CLOCKS_PER_SEC << std::endl;
            }

            
            // Save ideal partition if asked to
            if ( notdash(cfg.output_ideal_partition) )
            {
                std::string output_ideal_partition = boost::str( boost::format( cfg.output_ideal_partition ) % cfg.cams_number[i_cam] % current_frame );
                io::WriteImage writeImage ( output_ideal_partition );

                ImagePartition<> tmp_part(ideal_partition);
                relabel (tmp_part,tmp_part);
                
                writeImage << tmp_part;

                if ( notdash(cfg.output_ov_ideal_partition) )
                {
                    
                    // Write the depth image with the contours of the ideal partition overlayed
                    ImageGray<uint8> depth_out(depth_image);
                    overlay_contour (tmp_part, depth_out);
                    
                    std::string ov_output_ideal_partition = boost::str( boost::format( cfg.output_ov_ideal_partition ) % cfg.cams_number[i_cam] % current_frame );
                    writeImage.open( ov_output_ideal_partition );
                    writeImage << depth_out;
                }

            }
            // End of ideal (fine from color, end from depth)
    
            

            //
            // Now create combined partition
            // 

            start = clock();

            BPTModels<InputType, RegionType> model_set_combined;
            model_set_combined.add_model(new ColorHomogeneity<InputType, RegionType, WEDM>(weights), cfg.alpha);
            model_set_combined.add_model(new Contour<InputType, RegionType>(), (1-cfg.alpha));
            StopMerging<InputType, RegionType>* stop_merging = new StopMerging<InputType, RegionType>(ideal_partition);
            model_set_combined.add_model(stop_merging, 0.0);

            partition_type comb_bpt(initial_partition);
            create_bpt(comb_bpt, cielab_image, model_set_combined, cfg.num_regions_combined_partition);
    
            reg_it = comb_bpt.begin();
            reg_it_end = comb_bpt.end();
            combined_partition.resize(yuv_image.size_x(),yuv_image.size_y());
            create_image_partition(reg_it, reg_it_end, combined_partition);
            
            tmp = clock();
            if (cfg.verbose == true)
            {
                std::cerr << "Elapsed time creating combined partition: " << ((float64)(tmp-start))/CLOCKS_PER_SEC << std::endl;
            }
            
            // Save combined partition if asked to
            if ( notdash(cfg.output_combined_partition) )
            {
                std::string output_combined_partition = boost::str( boost::format( cfg.output_combined_partition ) % cfg.cams_number[i_cam] % current_frame );
                io::WriteImage writeImage ( output_combined_partition );
                
                ImagePartition<> tmp_part(combined_partition);
                relabel (tmp_part,tmp_part);
                
                writeImage << tmp_part;

                if ( notdash(cfg.output_ov_combined_partition) )
                {
                    
                    // Write the depth image with the contours of the combined partition overlayed
                    ImageGray<uint8> depth_out(depth_image);
                    overlay_contour (tmp_part, depth_out);
                    
                    std::string output_ov_combined_partition = boost::str( boost::format( cfg.output_ov_combined_partition ) % cfg.cams_number[i_cam] % current_frame );
                    writeImage.open( output_ov_combined_partition );
                    writeImage << depth_out;
                }
 
            }
            // End of combined (fine from color, merged from ideal [color+depth])


            //
            // Compress non_merging_orders using an arithmetic encoder
            //

            start = clock();
            
            // Create bit models (one will be used depending on cfg.quan_prob_0 value)
            Static_Bit_Model ac_model_static;
            Adaptive_Bit_Model ac_model_adaptive;

            // open bitstream to write
            io::WriteBitStream writeBS_merging_orders;
            if ( notdash(cfg.output_non_merging_orders) )
            {
                writeBS_merging_orders.open(boost::str(boost::format(cfg.output_non_merging_orders) % cfg.cams_number[i_cam] % current_frame));

                // Write number of orders into 16 bits
                if ( stop_merging->non_merging_order().size() > 65535 )
                    throw ImagePlusError("Number of merging orders can not be > 65535");
                writeBS_merging_orders.write(stop_merging->non_merging_order().size(),16);
            }
        
            float64 prob_0 = (float64)stop_merging->num_mergings() / (float64)stop_merging->non_merging_order().size();
            uint16 q_prob_0 = 0;
            if ( cfg.quan_prob_0 > 0) 
            {
                // compute 0 probability quantizing it to 16 bits to send it to the decoder 
                q_prob_0 = mnint<uint16>( prob_0 * ( pow((float)2.0,cfg.quan_prob_0) - 1.0 ) );

                // write it to bitstream
                prob_0 = q_prob_0 / ( pow((float)2.0,cfg.quan_prob_0) - 1.0); // decoder should do this operation also 
                ac_model_static.set_probability_0( prob_0 );
            }

            Arithmetic_Codec ace;
            ace.set_buffer(stop_merging->non_merging_order().size());
            ace.start_encoder();
            for (uint32 i = 0; i < stop_merging->non_merging_order().size(); i++)
            {
                uint8 bit = ( stop_merging->non_merging_order()[i] == false ) ? 0 : 1; 
                if (cfg.quan_prob_0 > 0)
                {
                    ace.encode(bit, ac_model_static);
                } else {
                    ace.encode(bit,ac_model_adaptive);
                }
            }
            uint64 num_bytes = ace.stop_encoder(); // return number of bytes used for compression
        
            
            // Write bitstream 
            if ( notdash(cfg.output_non_merging_orders) )
            {
                // Write number of bytes in the file (just to make implementation easier)
                if ( num_bytes > 65535)
                    throw ImagePlusError("Number of bytes can not be greater than 65535");
                writeBS_merging_orders.write(num_bytes,16);

                if (cfg.quan_prob_0 > 0)
                {
                    writeBS_merging_orders.write(q_prob_0,cfg.quan_prob_0);
                }

                for (uint64 x = 0; x < num_bytes; x++)
                {
                    writeBS_merging_orders.write(ace.buffer()[x],8);
                }
                writeBS_merging_orders.close();
            }
       
            tmp = clock();
            
            if (cfg.verbose == true)
            {
                std::cerr << "Time writing Arithmetic Encoded non merging orders: " << ((float64)(tmp-start))/CLOCKS_PER_SEC << std::endl;
            }

            // Read 0 probability from arithmetic encoder if adaptive is used
            if (cfg.quan_prob_0 == 0)
            {
                prob_0 = ac_model_adaptive.get_probability_0();
            }

            
            //MultiArray<uint8,1> temp(stop_merging->non_merging_order().size());
            //for (uint64 kk; kk < temp.dims(0); kk++)
            //    temp[i] = ( stop_merging->non_merging_order()[i] == false ) ? 0 : 1;
            //WriteMultiArray wm("orders.mult");
            //wm << temp;
        
            total_bits += (16 + (uint64)cfg.quan_prob_0 + 8 * num_bytes);
            total_frames++;

            // Formatted output 
            //std::cout << "         Number_Regions             Number_Non         0         #bits_after     " << std::endl;       
            //std::cout << " Frame#  Base_Partition  Mergins#  Merging_Orders  Probability  ArithmeticCodec  " << std::endl;       
            //std::cout << "-------------------------------------------------------------------------------- " << std::endl;
            std::cout << std::setw(4) << cfg.cams_number[i_cam] << "  ";
            std::cout << std::setw(6)  << current_frame << "   ";
            std::cout << std::setw(10) << num_regions_base << "    ";
            std::cout << std::setw(7) << stop_merging->num_mergings() << "   ";
            std::cout << std::setw(10) << stop_merging->non_merging_order().size() << "      ";
            std::cout << std::setw(8) << std::setprecision(5) << prob_0 << "    ";
            std::cout << std::setw(10) << 16 + (uint64)cfg.quan_prob_0 + 8 * num_bytes << "       ";
            std::cout << std::endl; 

        }
    }

    std::cout << std::endl;
    std::cout << "Total bits = " <<  (uint64)total_bits << std::endl;
    std::cout << "Average bitrate (single view) = " <<  std::fixed << total_bits / (float64)total_frames * cfg.fps / 1000.0 << " kbps" << std::endl;
    std::cout << "Average bitrate (all views) = " <<  std::fixed << total_bits / (float64)total_frames * cfg.fps / 1000.0 * (float64)cfg.cams_number.size() << " kbps" << std::endl;

}

//
// This last line is mandatory!
//
IMAGEPLUS_TOOL_CONFIG_END()
