/*
 * temporal_signature.hpp
 *
 *  Created on: Jan 18, 2013
 *      Author: gpalou
 */

#ifndef TEMPORAL_SIGNATURE_HPP_
#define TEMPORAL_SIGNATURE_HPP_

#include <imageplus/descriptors/descriptor_base.hpp>
#include <imageplus/descriptors/video/temporal_mean.hpp>

#include <imageplus/math/math_types.hpp>
#include <imageplus/math/statistics/k_means.hpp>
#include <imageplus/math/statistics/signature.hpp>

namespace imageplus
{
    namespace descriptors
    {
        //!
        //! \brief Area visual descriptor
        //!
        //! \author Jordi Pont <jpont@gps.tsc.upc.edu>, Guillem Palou <guillem.palou@gmail.com>
        //!
        //! \date 02-06-2009
    	template<class Signal>
        class TemporalSignature : public DescriptorBase
        {
        public:

        	//! Type to refer to the type of data which will be returned by this descriptor
        	typedef typename Signal::coord_type				coord_type;
        	typedef typename Signal::value_float_type		value_type;
        	typedef math::statistics::Signature<value_type>	motion_type;
        	typedef typename Area::type						area_type;

        	//! base structur for descriptors using parameters
        	struct TemporalSignatureDescriptorParameters {
        		int64 									num_points;
        		typename Signal::value_float_type		weights;

        		TemporalSignatureDescriptorParameters() : num_points(8) {

        		}
        	};

        	typedef TemporalSignatureDescriptorParameters 	Parameters;

            struct MotionHistogramType {
            	std::vector<motion_type>	signatures;
            	std::vector<area_type> 		area;

            	std::vector<float64> 		reliability;

            	int64 begin_frame;
            	int64 end_frame;

            	inline motion_type signature(int64 frame) const {
            		return signatures[frame - begin_frame];
            	}

            	int64 length() const {
            		return end_frame - begin_frame + 1;
            	}
            };

            typedef MotionHistogramType						type;

            //! function returning the id given a set of parameters
            //! \param[in] pars: parameters to the descriptors (null in this case)
            static const std::string id(const Parameters& pars = default_parameters()) {
            	return "motion_signature";
            }

            //! Default parameters for descriptors
            static const Parameters default_parameters() {
            	return Parameters();
            }

            //!
            //! \brief Default constructor
            //!
            TemporalSignature(const Parameters& pars = default_parameters()) : DescriptorBase(true), _pars(pars) {

            };

            //! Virtual destructor
            ~TemporalSignature(){};

            //! \brief Calculates the area of a region, given a pair of iterators.
            //!
            //! \param[in] first      : Iterator to the beginning of the region
            //! \param[in] last       : Iterator to the end of the region
            //! \param[in] peer_descs : Pointer to CollaborativeDescriptors, in principle is never 0x0 but it is a good idea to ASSERT it
            template< class SignalModel, class RegionModel >
            void calculate(SignalModel& signal, RegionModel& region, const Parameters& pars, typename DescriptorBase::ManagerType* manager)
            {
                _value.begin_frame 	= region.frame_begin();
                _value.end_frame 	= region.frame_end();

                uint64 length = region.length();

                _value.area.clear();
                _value.area.resize(length,0);
                _value.signatures.resize(length);

                std::vector<std::vector<value_type> > points(length);

                for (typename RegionModel::iterator p = region.begin(); p != region.end(); ++p) {
                	const coord_type& pos 		= (*p);
                	const value_type& motion 	= signal(pos);
                	int64 frame = pos(2);

                	points[frame - _value.begin_frame].push_back(motion);
                	_value.area[frame - _value.begin_frame]++;
                }

                for (uint64 i = 0; i < length; i++) {
                	math::statistics::KMeansParameters pars;
                	math::statistics::KMeans<value_type> kmeans(pars);

                	int64 N = points[i].size();
                	if (N <= _pars.num_points) {
                		_value.signatures[i].features = points[i];
                		_value.signatures[i].weights = math::Vector(N); _value.signatures[i].weights.fill(1.0/N);
                	} else {
                		kmeans.calculate(points[i], _pars.num_points);
                  		_value.signatures[i].features = kmeans.centers();
                		_value.signatures[i].weights = kmeans.weights();
                	}
                }
            }

            //!
            //! \brief Calculates recursively area of the father region given the sons ones.
            //!
            //! \param[in] son1_descs : CollaborativeDescriptors of the son 1
            //! \param[in] son2_descs : CollaborativeDescriptors of the son 2
            //! \param[in] peer_descs : Pointer to CollaborativeDescriptors, in principle is never 0x0 but it is a good idea to ASSERT it
            template<class SignalModel, class RegionModel, class ChildContainer>
            void recursive_calculate(SignalModel& signal, RegionModel& region, ChildContainer& childs, const Parameters& pars, typename DescriptorBase::ManagerType* manager)
            {

            	_value.begin_frame 	= 1e9;
            	_value.end_frame 	= -1;

            	_value.area.clear();
            	_value.signatures.clear();

            	std::vector<const type*> child_values;
                for (typename ChildContainer::iterator child = childs.begin(); child != childs.end(); ++child) {
                	const type& child_value = manager->calc_descriptor<TemporalSignature<SignalModel> >(signal,(RegionModel&)**child, pars);
                	child_values.push_back(&child_value);
                	_value.begin_frame 	= std::min(_value.begin_frame, child_value.begin_frame);
                	_value.end_frame 	= std::max(_value.end_frame, child_value.end_frame);
                }

                _value.signatures.resize(_value.length());
                _value.area.resize(_value.length(),0);
                // Suported only with two childs
                const type& child1 = *child_values[0];
                const type& child2 = *child_values[1];


               // std::cout << "Calculating " << region.label() << " from " << childs[0]->label() << " " << childs[1]->label() << std::endl;

                for (int64 k = _value.begin_frame; k <= _value.end_frame; k++) {
                	int64 b1 = child1.begin_frame;
                	int64 b2 = child2.begin_frame;
                	int64 e1 = child1.end_frame;
                	int64 e2 = child2.end_frame;

                	int64 pos_now = k - _value.begin_frame;


                	if (k >= b1 && k <= e1 && k >= b2 && k <= e2) {
                		int64 pos_child1 = k-b1;
                		int64 pos_child2 = k-b2;

                		//std::cout << "Joining " << k << " " << _value.begin_frame << " " << b1 << " " << b2 << std::endl;
                		_value.signatures[pos_now] = join_signatures(child1.signatures[pos_child1], child2.signatures[pos_child2],
                													 child1.area[pos_child1], child2.area[pos_child2]);
                		_value.area[pos_now] = child1.area[pos_child1] + child2.area[pos_child2];
                   	} else {
                		// put child1 as the new signature
                		if (k >= b1 && k <= e1) {
                			int64 pos_child1 = k-b1;
                			_value.signatures[pos_now] = child1.signatures[pos_child1];
                			_value.area[pos_now] = child1.area[pos_child1];

                		}
                		// put child2 as the new signature
                		if (k >= b2 && k <= e2) {
                			int64 pos_child2 = k-b2;
                			_value.signatures[pos_now] = child2.signatures[pos_child2];
                			_value.area[pos_now] = child2.area[pos_child2];
                		}
                	}
                }
            }

            const type& value() const {
            	return _value;
            }

        private:

            float64 motion_distance(value_type& a, value_type& b) {
            	value_type dif =  a-b;
            	math::Vector n = dif.array().square() * _pars.weights.array().square();
            	return std::sqrt(n.sum());
            }

            value_type average_motion(value_type& a, value_type& b, float64 p1, float64 p2) {
            	value_type av;
            	av = p1/(p1+p2)*a + p2/(p1+p2)*b;
            	return av;
            }

            motion_type join_signatures(const motion_type& s1, const motion_type& s2, uint64 a1, uint64 a2) {
            	std::list<value_type> 	c;
            	std::list<float64>		p;

            	c.insert(c.end(), s1.features.begin(), s1.features.end());
            	c.insert(c.end(), s2.features.begin(), s2.features.end());

            	/*std::cout << "Joining" << std::endl;

            	std::cout << "signature 1 " << s1.elements() << " " << s1.weights.sum() << std::endl;
            	for (uint64 i = 0; i < s1.elements(); i++) {
            		std::cout << s1.weights(i) << " :: " << s1.features[i].transpose() << std::endl;
            	}

            	std::cout << "signature 2 " << s2.elements() << " " << s2.weights.sum() <<  std::endl;
            	for (uint64 i = 0; i < s2.elements(); i++) {
            		std::cout << s2.weights(i) << " :: " << s2.features[i].transpose() << std::endl;
            	}
            	std::cout << "-----------" << std::endl;*/

            	for (uint64 i = 0; i < s1.elements(); i++) {
            		p.push_back(s1.weights(i)*a1/(a1+a2));
            	}
            	for (uint64 i = 0; i < s2.elements(); i++) {
            		p.push_back(s2.weights(i)*a2/(a1+a2));
            	}

            	while (true) {
            		typename std::list<value_type>::iterator 				m1,m2,motion1,motion2;
            		std::list<float64>::iterator 							p1,p2,perc1,perc2;


            		bool merge = ((int64)c.size() > _pars.num_points);
            		if (!merge) break;

            		float64 min_d = 1e20;

            		perc1 = p.begin();
            		motion1 = c.begin();

            		for (; motion1 != c.end(); motion1++, perc1++) {
            			perc2 = perc1; perc2++;
            			motion2 = motion1; motion2++;
            			for (; motion2 != c.end(); motion2++, perc2++) {
            				float64 d;

            				//std::cout << (*motion1).transpose() << " " << (*motion2).transpose() << std::endl;

            				d = motion_distance(*motion1, *motion2);
            				d*=(*perc1+*perc2);

            				if (min_d > d) {
            					m1 = motion1; m2 = motion2;
            					p1 = perc1; p2 = perc2;

            					min_d = d;
            				}
            			}
            		}

            		// Merge gaussians
            		float64 pf = *p1+*p2;

            		if (pf != 0) {
            			value_type cf = average_motion(*m1,*m2,*p1,*p2);
            			c.erase(m2); c.erase(m1); c.push_back(cf);
            			p.erase(p2); p.erase(p1); p.push_back(pf);
            		} else {
            			c.erase(m2); c.erase(m1);
            			p.erase(p2); p.erase(p1);
            		}
            	}

            	motion_type m;
            	for (typename std::list<value_type>::iterator it = c.begin(); it != c.end(); ++it) {
            		m.features.push_back(*it);
            	}
            	m.weights = math::Vector(p.size());
            	uint64 k = 0;
            	for (std::list<float64>::iterator it = p.begin(); it != p.end(); ++it, k++) {
            		m.weights(k) = *it;
            	}
            	//m.weights /= m.weights.sum();

            	return m;
            }

        private:

            //!parameters
            Parameters _pars;

            //! temporal mean
            type _value;

        };
    }
}

#endif /* TEMPORAL_SIGNATURE_HPP_ */
