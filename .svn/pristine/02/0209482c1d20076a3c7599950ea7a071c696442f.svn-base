/*
 * join_components_and_order.hpp
 *
 *  Created on: Dec 21, 2012
 *      Author: gpalou
 */

#ifndef JOIN_COMPONENTS_AND_ORDER_HPP_
#define JOIN_COMPONENTS_AND_ORDER_HPP_

#include <map>
#include <imageplus/segmentation/partition/rag.hpp>
#include <imageplus/math/graphs/algorithms/ordering.hpp>
#include <imageplus/math/graphs/algorithms/connected_components.hpp>
#include <imageplus/math/graphs/graph_io.hpp>

namespace imageplus {
	namespace monocular_depth {

	template<class DOG, class BPT, class Input, class Distance>
	std::map<uint64, std::pair<float64,uint64> > join_components_and_order(DOG& dog, BPT& bpt, Input& signal, Distance& distance) {

		// typedefs
		typedef std::pair<uint64,uint64> region_pair;
		typedef std::pair<float64,region_pair> region_distance;
		typedef segmentation::RAG<typename BPT::PartitionType, Input::coord_dimensions> RAGType;
		typedef typename DOG::Node	Node;

		/*Find the partial order of the graph*/
		std::map<uint64, std::pair<float64,uint64> > 	region_depths;
		std::vector<region_distance> region_distances;

		math::graphs::TopologicalPartialSort<DOG> tp;
		tp.calculate(dog);
		std::vector<uint64> depths = tp.nodes_order();

		std::map<uint64,Node> nodes;
		typename RAGType::Graph rag_dog;

		for (typename DOG::node_iterator i = dog.nodes_begin(); i != dog.nodes_end(); ++i) {
			region_depths[dog.node_properties(*i).id].first = depths[(uint64)*i];
			nodes[dog.node_properties(*i).id] = *i;

			Node n = rag_dog.add_node();
			rag_dog.node_properties(n).id = dog.node_properties(*i).id;
		}
		for (typename DOG::edge_iterator i = dog.edges_begin(); i != dog.edges_end(); ++i) {
			Node a = dog.source(*i);
			Node b = dog.target(*i);
			rag_dog.add_edge(a,b);
		}

		math::graphs::ConnectedComponents<typename RAGType::Graph> components;
		uint64 C = components.calculate(rag_dog);
		std::vector<int64> comp = components.components();

		std::cout << "There are " << C << " connected components " << std::endl;

		if (C==1) return region_depths;

		std::map<uint64,float64> component_region;
		for (uint64 i = 0; i < comp.size(); i++) {
			uint64 r = rag_dog.node_properties(i).id;
			component_region[r] = comp[i];
			region_depths[r].second = comp[i];
		}

		//Find adjacent regions and get the distances
		RAGType rag;
		rag.init(bpt.leaves_partition());
		typename RAGType::Graph rag_graph = rag.rag();

		descriptors::DescriptorManager manager;
		manager.set_max_number_of_regions(bpt.max_label()+1);

		for (typename RAGType::Graph::edge_iterator e = rag_graph.edges_begin(); e != rag_graph.edges_end(); ++e) {
			uint64 ra = rag_graph.node_properties(rag_graph.source(*e)).id;
			uint64 rb = rag_graph.node_properties(rag_graph.target(*e)).id;
			if (component_region[ra] != component_region[rb]) {
				float64 d = distance.region_distance(bpt(ra),bpt(rb), signal, bpt, manager);
				region_distances.push_back(region_distance(d, region_pair(ra,rb)));
			}
		}

		//join connected components
		sort(region_distances.begin(), region_distances.begin());
		for (uint64 i = 0; i < region_distances.size(); i++) {
			if (C == 1) break;
			uint64 ca = component_region[region_distances[i].second.first];
			uint64 cb = component_region[region_distances[i].second.second];
			if (ca != cb) {
				std::map<uint64,bool> visited;
				float64 d_ref = region_depths[region_distances[i].second.first].first;
				float64 d_joined = region_depths[region_distances[i].second.second].first;
				// join connected components and assign a correct depth with respect to the joined edges
				for (std::map<uint64,std::pair<float64,uint64> >::iterator k = region_depths.begin(); k != region_depths.end(); k++) {
					if (component_region[k->first] == ca) {
						k->second.first = d_joined + (k->second.first-d_ref);
						component_region[k->first] = cb;
					}
				}
				C--;
			}
		}

		return region_depths;
	}

	}
}

#endif /* JOIN_COMPONENTS_AND_ORDER_HPP_ */
