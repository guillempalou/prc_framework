// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------

//!
//!  \file convolution.cpp
//!
//!  Add brief description of the file here
//!


#include <imageplus/math/numeric/convolution.hpp>
#include <imageplus/math/numeric/numeric_util.hpp>
#include <imageplus/math/numeric/transformations.hpp>

using namespace imageplus;
using namespace imageplus::math::numeric;



template <typename T1> 
void imageplus::math::numeric::convolve(const MultiArray<T1,1>& in, const Kernel<1>& kernel, bool pad, MultiArray<T1,1>& out)
{
    MultiArray<T1,1> in_pad;
    const MultiArray<T1,1>* pin;
 
    if (pad)
    {
        // Apply padding to input ma
        asymmetric_padding (in, kernel.pad_size(), static_cast<T1>(0), in_pad);
        pin = &in_pad;
    }
    else 
    {
        pin = &in;
    }

    out.resize((*pin).dims());

    typename MultiArray<T1,1>::const_iterator in_begin = pin->begin();
    typename MultiArray<T1,1>::const_iterator in_end = pin->end();
    typename MultiArray<T1,1>::iterator out_begin=out.begin();

    convolve (in_begin, in_end, kernel, out_begin);
}


template <typename T1> 
MultiArray<T1,1> imageplus::math::numeric::convolve(const MultiArray<T1,1>& in, const Kernel<1>& kernel, bool pad)
{
    MultiArray<T1,1> out;
    convolve (in, kernel, pad, out);
    return out;
}


template <typename T1> 
void imageplus::math::numeric::convolve(const MultiArray<T1,2>& in, const Kernel<2>& kernel, bool pad, MultiArray<T1,2>& out)
{
    MultiArray<T1,2>        in_pad;
    const MultiArray<T1,2>* pin;
 
    if (pad)
    {
        // Apply padding to input ma
        asymmetric_padding (in, kernel.pad_size(), static_cast<T1>(0), in_pad);
        pin = &in_pad;
    }
    else 
    {
        pin = &in;
    }

    out.resize(pin->dims());

    uint64 psx_l         = kernel.pad_size(0,0);
    uint64 psx_r         = kernel.pad_size(0,1);
    uint64 psy_u         = kernel.pad_size(1,0);
    uint64 psy_d         = kernel.pad_size(1,1);

    uint64 num_elements = kernel.num_elements();

    // Skip the computation in several non-overlaping zones
    // for efficiency reasons. In the inside part, no checking for
    // 'out of borders' is necessary.

    // Compute the 'inside' part (no problems with borders)
    for (uint64 j=psy_u; j < out.dims(1) - psy_d; ++j)
    for (uint64 i=psx_l; i < out.dims(0) - psx_r; ++i)
    {
        float64 s = 0;

        // Loop for all active elements in the kernel
        for (uint64 k=0; k < num_elements; ++k)
        {
            Coord<int64,2> coord_element( kernel.coord(k) + Coord<int64,2>(i,j));
            s += (*pin)(coord_element) * kernel.weight(k);
        }

        out[i][j] = std::numeric_limits<T1>::is_integer ? mnint<T1>(s) : static_cast<T1>(s);
    }
    
    // Compute the left borders
    for (uint64 j=psy_u; j < out.dims(1) - psy_d; ++j)
    for (uint64 i=0;     i < psx_l;               ++i)
    {
        float64 s = 0;

        // Loop for all active elements in the kernel
        for (uint64 k=0; k < num_elements; ++k)
        {
            Coord<int64,2> coord_element( kernel.coord(k) + Coord<int64,2>(i,j));

            // Check if final coordinate is inside the multiarray
            if (coord_element[0] >= 0)
            {
                s += (*pin)(coord_element) * kernel.weight(k);
            }
        }
        out[i][j] = std::numeric_limits<T1>::is_integer ? mnint<T1>(s) : static_cast<T1>(s);
    }

    // Compute the right border
    for (uint64 j=psy_u; j < out.dims(1) - psy_d; ++j)
    for (uint64 i=psx_r; i < out.dims(0);         ++i)
    {
        float64 s = 0;

        // Loop for all active elements in the kernel
        for (uint64 k=0; k < num_elements; ++k)
        {
            Coord<int64,2> coord_element( kernel.coord(k) + Coord<int64,2>(i,j));

            // Check if final coordinate is inside the multiarray
            if (coord_element[0] < (int64)out.dims(0))
            {
                s += (*pin)(coord_element) * kernel.weight(k);
            }
        }
        out[i][j] = std::numeric_limits<T1>::is_integer ? mnint<T1>(s) : static_cast<T1>(s);
    }


    // Compute the top border
    for (uint64 j=0    ; j < psy_u;               ++j)
    for (uint64 i=psx_l; i < out.dims(0) - psx_r; ++i)
    {
        float64 s = 0;

        // Loop for all active elements in the kernel
        for (uint64 k=0; k < num_elements; ++k)
        {
            Coord<int64,2> coord_element( kernel.coord(k) + Coord<int64,2>(i,j));

            // Check if final coordinate is inside the multiarray
            if (coord_element[1] >= 0)
            {
                s += (*pin)(coord_element) * kernel.weight(k);
            }
        }
        out[i][j] = std::numeric_limits<T1>::is_integer ? mnint<T1>(s) : static_cast<T1>(s);
    }


    // Compute the bottom border
    for (uint64 j=psy_d; j < out.dims(1);         ++j)
    for (uint64 i=psx_l; i < out.dims(0) - psx_r; ++i)
    {
        float64 s = 0;

        // Loop for all active elements in the kernel
        for (uint64 k=0; k < num_elements; ++k)
        {
            Coord<int64,2> coord_element( kernel.coord(k) + Coord<int64,2>(i,j));

            // Check if final coordinate is inside the multiarray
            if (coord_element[1] < (int64)out.dims(1))
            {
                s += (*pin)(coord_element) * kernel.weight(k);
            }
        }
        out[i][j] = std::numeric_limits<T1>::is_integer ? mnint<T1>(s) : static_cast<T1>(s);
    }

    //
    // Compute the four corners
    //

    // Top left
    for (uint64 j=0; j < psy_u; ++j)
    for (uint64 i=0; i < psx_l; ++i)
    {
        float64 s = 0;

        // Loop for all active elements in the kernel
        for (uint64 k=0; k < num_elements; ++k)
        {
            Coord<int64,2> coord_element( kernel.coord(k) + Coord<int64,2>(i,j));

            // Check if final coordinate is inside the multiarray
            if (check_coordinate(coord_element, out))
            {
                s += (*pin)(coord_element) * kernel.weight(k);
            }
        }
        out[i][j] = std::numeric_limits<T1>::is_integer ? mnint<T1>(s) : static_cast<T1>(s);
    }

    // Top right
    for (uint64 j=0;                 j < psy_u;       ++j)
    for (uint64 i=out.dims(0)-psx_r; i < out.dims(0); ++i)
    {
        float64 s = 0;

        // Loop for all active elements in the kernel
        for (uint64 k=0; k < num_elements; ++k)
        {
            Coord<int64,2> coord_element( kernel.coord(k) + Coord<int64,2>(i,j));

            // Check if final coordinate is inside the multiarray
            if (check_coordinate(coord_element, out))
            {
                s += (*pin)(coord_element) * kernel.weight(k);
            }
        }
        out[i][j] = std::numeric_limits<T1>::is_integer ? mnint<T1>(s) : static_cast<T1>(s);
    }

    // Bottom left
    for (uint64 j=out.dims(1)-psy_d; j < out.dims(1); ++j)
    for (uint64 i=0;                 i < psx_l;       ++i)
    {
        float64 s = 0;

        // Loop for all active elements in the kernel
        for (uint64 k=0; k < num_elements; ++k)
        {
            Coord<int64,2> coord_element( kernel.coord(k) + Coord<int64,2>(i,j));

            // Check if final coordinate is inside the multiarray
            if (check_coordinate(coord_element, out))
            {
                s += (*pin)(coord_element) * kernel.weight(k);
            }
        }
        out[i][j] = std::numeric_limits<T1>::is_integer ? mnint<T1>(s) : static_cast<T1>(s);
    }


    // Bottom right
    for (uint64 j=out.dims(1)-psy_d; j < out.dims(1); ++j)
    for (uint64 i=out.dims(0)-psx_r; i < out.dims(0); ++i)
    {
        float64 s = 0;

        // Loop for all active elements in the kernel
        for (uint64 k=0; k < num_elements; ++k)
        {
            Coord<int64,2> coord_element( kernel.coord(k) + Coord<int64,2>(i,j));

            // Check if final coordinate is inside the multiarray
            if (check_coordinate(coord_element, out))
            {
                s += (*pin)(coord_element) * kernel.weight(k);
            }
        }
        out[i][j] = std::numeric_limits<T1>::is_integer ? mnint<T1>(s) : static_cast<T1>(s);
    }

}


template <typename T1> 
MultiArray<T1,2> imageplus::math::numeric::convolve(const MultiArray<T1,2>& in, const Kernel<2>& kernel, bool pad)
{
    MultiArray<T1,2> out;
    convolve (in, kernel, pad, out);
    return out;
}


template <typename T1> 
void imageplus::math::numeric::convolve(const MultiArray<T1,2>& in, const Kernel<1>& kernel, ConvolutionType dir, bool pad, MultiArray<T1,2>& out)
{
    typedef boost::multi_array_types::index_range range;
    typename MultiArray<T1,2>::index_gen indices;


    MultiArray<T1,2>        in_pad;
    const MultiArray<T1,2>* pin;

    if (dir == ROWS)
    {
        if (pad)
        {
            // Apply padding to input ma
            asymmetric_padding (in, kernel.pad_size(0), 0, static_cast<T1>(0), in_pad);
            pin = &in_pad;
        }

        out.resize(pin->dims());

        uint64 sx = pin->dims(0);
        uint64 sy = pin->dims(1);

        // Convolve rows 
        for(uint64 ii = 0; ii<sy; ++ii)
        {
            typename MultiArray<T1,2>::template const_array_view<1>::type view_in  = (*pin)[indices[range(0,sx)][ii]];
            typename MultiArray<T1,2>::template array_view<1>::type       view_out = out[indices[range(0,sx)][ii]];

            convolve(view_in.begin(), view_in.end(), kernel, view_out.begin());
        }
    }
    else if (dir == COLUMNS)
    {
        if (pad)
        {
            // Apply padding to input ma
            asymmetric_padding (in, kernel.pad_size(1), 1, static_cast<T1>(0), in_pad);
            pin = &in_pad;
        }

        out.resize(pin->dims());

        uint64 sx = pin->dims(0);
        uint64 sy = pin->dims(1);

        // Convolve columns 
        for(uint64 ii = 0; ii<sx; ++ii)
        {
            typename MultiArray<T1,2>::template const_array_view<1>::type view_in  = (*pin)[indices[ii][range(0,sy)]];
            typename MultiArray<T1,2>::template array_view<1>::type       view_out = out[indices[ii][range(0,sy)]];

            convolve(view_in.begin(), view_in.end(), kernel, view_out.begin());
        }
    }
    else
    {
        throw ImagePlusError("Error(convolve): Invalid direction (ROWS / COLUMNS)" );
    }
}



template <typename T1> 
MultiArray<T1,2> imageplus::math::numeric::convolve(const MultiArray<T1,2>& in, const Kernel<1>& kernel, ConvolutionType dir, bool pad)
{
    MultiArray<T1,2> out;

    convolve (in, kernel, dir, pad, out);

    return out;
}



template <typename T1> 
void imageplus::math::numeric::convolve(const MultiArray<T1,2>& in, const Kernel<1>& kernel1, const Kernel<1>& kernel2, bool pad, MultiArray<T1,2>& out)
{
    MultiArray<T1,2>        in_pad;
    const MultiArray<T1,2>* pin;
 
    if (pad)
    {
        // Apply padding to input ma
        asymmetric_padding (in,     kernel1.pad_size(0), 0, static_cast<T1>(0), in_pad);
        asymmetric_padding (in_pad, kernel2.pad_size(0), 1, static_cast<T1>(0), in_pad);
        pin = &in_pad;
    }
    else 
    {
        pin = &in;
    }

    out.resize(pin->dims());

    uint64 sx = pin->dims(0);
    uint64 sy = pin->dims(1);

    typedef boost::multi_array_types::index_range range;
    typename MultiArray<T1,2>::index_gen indices;

    MultiArray<T1,2> tmp(out.dims());

    // Convolve rows with first kernel
    for(uint64 ii = 0; ii<sy; ++ii)
    {
        typename MultiArray<T1,2>::template const_array_view<1>::type view_in  = (*pin)[indices[range(0,sx)][ii]];
        typename MultiArray<T1,2>::template array_view<1>::type       view_out = tmp[indices[range(0,sx)][ii]];

        convolve(view_in.begin(), view_in.end(), kernel1, view_out.begin());
    }

    // Convolve columns with second kernel
    for(uint64 ii = 0; ii<sx; ++ii)
    {
        typename MultiArray<T1,2>::template const_array_view<1>::type view_in  = tmp[indices[ii][range(0,sy)]];
        typename MultiArray<T1,2>::template array_view<1>::type       view_out = out[indices[ii][range(0,sy)]];

        convolve(view_in.begin(), view_in.end(), kernel2, view_out.begin());
    }
}

template <typename T1> 
MultiArray<T1,2> imageplus::math::numeric::convolve(const MultiArray<T1,2>& in, const Kernel<1>& kernel1, const Kernel<1>& kernel2, bool pad)
{
    MultiArray<T1,2> out;

    convolve (in, kernel1, kernel2, pad, out);

    return out;
}







#if 0

#include <numeric/convolution_auxiliar.hpp>


template <typename T1> 
MultiArray<T1,2> imageplus::math::numeric::convolve (const MultiArray<T1,2>& in, const MultiArray<float64,1>& kernel, ConvolutionType dir)
{
    MultiArray<T1,2> out(in.dims());


    uint64 dim_x = in.dims(0);
    uint64 dim_y = in.dims(1);

    if (dir == ROWS || dir == ROWS_COLUMNS)
    {
        for (uint64 row=0; row < dim_y; ++row)
        {
            typename MultiArray<T1,1>::const_view in_rowview  =  in[boost::indices[typename boost::multi_array<T1,2>::index_range(0,in.dims(0))][row]];
            typename MultiArray<T1,1>::view       out_rowview = out[boost::indices[typename boost::multi_array<T1,2>::index_range(0,out.dims(0))][row]];

            // Convolution
            convolve1d (in_rowview.begin(), dim_x, kernel.begin(), kernel.dims(0), out_rowview.begin());
        }
        if (dir == ROWS) /* Done!! */
        {
            return out;
        }
    }


    // For column convolution, multiarrays are transposed, convoluted as rows, and transposed again.
    MultiArray<T1,2> tmp;
    if (dir == COLUMNS)
    {
        tmp = math::numeric::trans(in);
    }
    if (dir == ROWS_COLUMNS)
    {
        tmp = math::numeric::trans(out);
    }

    dim_x = tmp.dims(0);
    dim_y = tmp.dims(1);

    // Resize out to reflect the transposition
    out.resize(tmp.dims());
                
    for (uint64 row=0; row < dim_y; ++row)
    {
        typename MultiArray<T1,1>::view in_rowview  = tmp[boost::indices[typename boost::multi_array<T1,2>::index_range(0,tmp.dims(0))][row]];
        typename MultiArray<T1,1>::view out_rowview = out[boost::indices[typename boost::multi_array<T1,2>::index_range(0,out.dims(0))][row]];

        // Convolution
        convolve1d (in_rowview.begin(), dim_x, kernel.begin(), kernel.dims(0), out_rowview.begin());
    }

    return math::numeric::trans(out);
};



template <typename T1> 
MultiArray<T1,2> imageplus::math::numeric::convolve(const MultiArray<T1,2>& in, const MultiArray<float64,1>& kernel1, const MultiArray<float64,1>& kernel2)
{
    MultiArray<T1,2> tmp1(in.dims());
    //MultiArray<T1,2> tmp1(in.dims(0)+kernel1.dims(0)-1, in.dims(1));

    uint64 dim_x = tmp1.dims(0);
    uint64 dim_y = in.dims(1);

    for (uint64 row=0; row < dim_y; ++row)
    {
        typename MultiArray<T1,1>::const_view in_rowview  =   in[boost::indices[typename boost::multi_array<T1,2>::index_range(0,in.dims(0))][row]];
        typename MultiArray<T1,1>::view out_rowview       = tmp1[boost::indices[typename boost::multi_array<T1,2>::index_range(0,tmp1.dims(0))][row]];
                    
        // Convolution
        convolve1d (in_rowview.begin(), dim_x, kernel1.begin(), kernel1.dims(0), out_rowview.begin());
    }

                
    // For column convolution, multiarrays are transposed, convoluted as rows, and transposed again.
    MultiArray<T1,2> tmp2 = math::numeric::trans(tmp1);

    // Result (transposed)
    MultiArray<T1,2> out(tmp2.dims());

    dim_x = tmp2.dims(0);
    dim_y = tmp2.dims(1);
                
    for (uint64 row=0; row < dim_y; ++row)
    {
        typename MultiArray<T1,1>::view in_rowview  = tmp2[boost::indices[typename boost::multi_array<T1,2>::index_range(0,tmp2.dims(0))][row]];
        typename MultiArray<T1,1>::view out_rowview =  out[boost::indices[typename boost::multi_array<T1,2>::index_range(0,out.dims(0))][row]];

        // Convolution
        convolve1d (in_rowview.begin(), dim_x, kernel2.begin(), kernel2.dims(0), out_rowview.begin());
    }

    return math::numeric::trans(out);
};


#endif


namespace imageplus
{
    namespace math
    {
        namespace numeric
        {
            //
            // One 1-D kernel and convolution direction 
            //


            template void convolve(const MultiArray<uint8, 1>& , const Kernel<1>& , bool , MultiArray<uint8, 1>& );
            template void convolve(const MultiArray<int64, 1>& , const Kernel<1>& , bool , MultiArray<int64, 1>& );
            template void convolve(const MultiArray<uint32,1>& , const Kernel<1>& , bool , MultiArray<uint32,1>& );
            template void convolve(const MultiArray<float64,1>& , const Kernel<1>& , bool , MultiArray<float64,1>& );

            template MultiArray<uint8,1>   convolve(const MultiArray<uint8, 1>& ,  const Kernel<1>& , bool );
            template MultiArray<int64, 1>  convolve(const MultiArray<int64, 1>& ,  const Kernel<1>& , bool );
            template MultiArray<uint32,1>  convolve(const MultiArray<uint32,1>& ,  const Kernel<1>& , bool );
            template MultiArray<float64,1> convolve(const MultiArray<float64,1>& , const Kernel<1>& , bool );

            template void convolve(const MultiArray<uint8,2>&     , const Kernel<2>& , bool , MultiArray<uint8,2>&);
            template void convolve(const MultiArray<int64,2>&     , const Kernel<2>& , bool , MultiArray<int64,2>&);
            template void convolve(const MultiArray<uint32,2>&    , const Kernel<2>& , bool , MultiArray<uint32,2>&);
            template void convolve(const MultiArray<float64,2>&   , const Kernel<2>& , bool , MultiArray<float64,2>&);

            template MultiArray<uint8,2>   convolve(const MultiArray<uint8, 2>& ,  const Kernel<2>& , bool );
            template MultiArray<int64, 2>  convolve(const MultiArray<int64, 2>& ,  const Kernel<2>& , bool );
            template MultiArray<uint32,2>  convolve(const MultiArray<uint32,2>& ,  const Kernel<2>& , bool );
            template MultiArray<float64,2> convolve(const MultiArray<float64,2>& , const Kernel<2>& , bool );



            template void convolve(const MultiArray<uint8,2>&    , const Kernel<1>& , ConvolutionType  , bool, MultiArray<uint8,2>& );
            template void convolve(const MultiArray<int64,2>&    , const Kernel<1>& , ConvolutionType  , bool, MultiArray<int64,2>& );
            template void convolve(const MultiArray<uint32,2>&   , const Kernel<1>& , ConvolutionType  , bool, MultiArray<uint32,2>& );
            template void convolve(const MultiArray<float64,2>&  , const Kernel<1>& , ConvolutionType  , bool, MultiArray<float64,2>& );


            template MultiArray<uint8,2>   convolve(const MultiArray<uint8,2>&    , const Kernel<1>& , ConvolutionType  , bool);
            template MultiArray<uint32,2>  convolve(const MultiArray<uint32,2>&   , const Kernel<1>& , ConvolutionType  , bool);
            template MultiArray<int64,2>   convolve(const MultiArray<int64,2>&    , const Kernel<1>& , ConvolutionType  , bool);
            template MultiArray<float64,2> convolve(const MultiArray<float64,2>&  , const Kernel<1>& , ConvolutionType  , bool);

            template void convolve(const MultiArray<uint8,2>&    , const Kernel<1>& , const Kernel<1>&  , bool, MultiArray<uint8,2>& );
            template void convolve(const MultiArray<uint32,2>&   , const Kernel<1>& , const Kernel<1>&  , bool, MultiArray<uint32,2>& );
            template void convolve(const MultiArray<int64,2>&    , const Kernel<1>& , const Kernel<1>&  , bool, MultiArray<int64,2>& );
            template void convolve(const MultiArray<float64,2>&  , const Kernel<1>& , const Kernel<1>&  , bool, MultiArray<float64,2>& );


            template MultiArray<uint8,2>   convolve(const MultiArray<uint8,2>&    , const Kernel<1>& , const Kernel<1>& , bool);
            template MultiArray<uint32,2>  convolve(const MultiArray<uint32,2>&   , const Kernel<1>& , const Kernel<1>& , bool);
            template MultiArray<int64,2>   convolve(const MultiArray<int64,2>&    , const Kernel<1>& , const Kernel<1>& , bool);
            template MultiArray<float64,2> convolve(const MultiArray<float64,2>&  , const Kernel<1>& , const Kernel<1>& , bool);




#if 0
            template MultiArray<int16,2>   convolve(const MultiArray<int16,2>& ,   const MultiArray<float64,1>& , ConvolutionType );
            template MultiArray<int32,2>   convolve(const MultiArray<int32,2>& ,   const MultiArray<float64,1>& , ConvolutionType );
            template MultiArray<int64,2>   convolve(const MultiArray<int64,2>& ,   const MultiArray<float64,1>& , ConvolutionType );
            template MultiArray<float64,2> convolve(const MultiArray<float64,2>& , const MultiArray<float64,1>& , ConvolutionType );


            // These are dangerous if kernel has negative values!
            template MultiArray<uint8,2>  convolve(const MultiArray<uint8,2>& ,  const MultiArray<float64,1>& , ConvolutionType );
            template MultiArray<uint16,2> convolve(const MultiArray<uint16,2>& , const MultiArray<float64,1>& , ConvolutionType );
            template MultiArray<uint32,2> convolve(const MultiArray<uint32,2>& , const MultiArray<float64,1>& , ConvolutionType );
            template MultiArray<uint64,2> convolve(const MultiArray<uint64,2>& , const MultiArray<float64,1>& , ConvolutionType );



            //
            // Two 1-D kernels
            //
            template MultiArray<int16,2>   convolve(const MultiArray<int16,2>& ,   const MultiArray<float64,1>& , const MultiArray<float64,1>& );
            template MultiArray<int32,2>   convolve(const MultiArray<int32,2>& ,   const MultiArray<float64,1>& , const MultiArray<float64,1>& );
            template MultiArray<int64,2>   convolve(const MultiArray<int64,2>& ,   const MultiArray<float64,1>& , const MultiArray<float64,1>& );
            template MultiArray<float64,2> convolve(const MultiArray<float64,2>& , const MultiArray<float64,1>& , const MultiArray<float64,1>& );

            // These are dangerous if kernel has negative values!
            template MultiArray<uint8,2>  convolve(const MultiArray<uint8,2>& ,  const MultiArray<float64,1>& , const MultiArray<float64,1>& );
            template MultiArray<uint16,2> convolve(const MultiArray<uint16,2>& , const MultiArray<float64,1>& , const MultiArray<float64,1>& );
            template MultiArray<uint32,2> convolve(const MultiArray<uint32,2>& , const MultiArray<float64,1>& , const MultiArray<float64,1>& );
            template MultiArray<uint64,2> convolve(const MultiArray<uint64,2>& , const MultiArray<float64,1>& , const MultiArray<float64,1>& );
#endif

        }
    }
}
