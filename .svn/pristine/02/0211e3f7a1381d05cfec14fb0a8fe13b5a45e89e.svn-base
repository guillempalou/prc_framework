// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------

//! 
//! \file color_range.test
//!
//! Tests for color range 
//!
#include <imageplus/core/color_range.hpp>
#include <imageplus/core/imagergb.hpp>
#include <imageplus/core/imagergb.hpp>
#include <imageplus/core/partition.hpp>
#include <imageplus/core/partition_functions.hpp>
#include <imageplus/core/region_contour.hpp>


BOOST_AUTO_TEST_SUITE ( Color_Range_Suite );

using namespace imageplus;

BOOST_AUTO_TEST_CASE( ColorRange_test)
{    
    ImageRGB<uint8> my_image(3,3);
    my_image(RED_CHANNEL) = 1;
    my_image(GREEN_CHANNEL) = 2;
    my_image(BLUE_CHANNEL) = 3;
    my_image(RED_CHANNEL)[0][0] = 25;
    my_image(GREEN_CHANNEL)[0][1] = 100;
    my_image(BLUE_CHANNEL)[2][2] = 0;

    const ColorRange<ImageRGB<uint8> >& range = calc_descriptor(new ColorRange<ImageRGB<uint8> >, my_image);
    
    BOOST_CHECK_EQUAL(range[RED_CHANNEL].min, 1);
    BOOST_CHECK_EQUAL(range[GREEN_CHANNEL].min, 2);
    BOOST_CHECK_EQUAL(range[BLUE_CHANNEL].min, 0);
    BOOST_CHECK_EQUAL(range[RED_CHANNEL].max, 25);
    BOOST_CHECK_EQUAL(range[GREEN_CHANNEL].max, 100);
    BOOST_CHECK_EQUAL(range[BLUE_CHANNEL].max, 3);
    
    
    ImagePartition<> my_im_part(3,3);
    my_im_part[0][0] = 25;
    my_im_part[0][1] = 25;
    my_im_part[0][2] = 25;
    my_im_part[1][0] = 10;
    my_im_part[1][1] = 10;
    my_im_part[1][2] = 10;
    my_im_part[2][0] = 25;
    my_im_part[2][1] = 25;
    my_im_part[2][2] = 10;
     
    typedef ImageRGB<uint8> InputType;
    typedef RegionContour<Coord2D<int64> > RegionType;
    typedef Partition<RegionType> partition_type;
    partition_type my_part(my_im_part);
     
    merge_regions(25, 10, 30, my_part);
    
    const ColorRange<ImageRGB<uint8> >& range25 = calc_descriptor(new ColorRange<ImageRGB<uint8> >, my_image, my_part[25]);
    
    BOOST_CHECK_EQUAL(range25[RED_CHANNEL].min, 1);
    BOOST_CHECK_EQUAL(range25[GREEN_CHANNEL].min, 2);
    BOOST_CHECK_EQUAL(range25[BLUE_CHANNEL].min, 3);
    BOOST_CHECK_EQUAL(range25[RED_CHANNEL].max, 25);
    BOOST_CHECK_EQUAL(range25[GREEN_CHANNEL].max, 100);
    BOOST_CHECK_EQUAL(range25[BLUE_CHANNEL].max, 3);
    
    const ColorRange<ImageRGB<uint8> >& range10 = calc_descriptor(new ColorRange<ImageRGB<uint8> >, my_image, my_part[10]);
    
    BOOST_CHECK_EQUAL(range10[RED_CHANNEL].min, 1);
    BOOST_CHECK_EQUAL(range10[GREEN_CHANNEL].min, 2);
    BOOST_CHECK_EQUAL(range10[BLUE_CHANNEL].min, 0);
    BOOST_CHECK_EQUAL(range10[RED_CHANNEL].max, 1);
    BOOST_CHECK_EQUAL(range10[GREEN_CHANNEL].max, 2);
    BOOST_CHECK_EQUAL(range10[BLUE_CHANNEL].max, 3);
    
    const ColorRange<ImageRGB<uint8> >& range30 = calc_descriptor(new ColorRange<ImageRGB<uint8> >, my_image, my_part[30]);
    
    BOOST_CHECK_EQUAL(range30[RED_CHANNEL].min, 1);
    BOOST_CHECK_EQUAL(range30[GREEN_CHANNEL].min, 2);
    BOOST_CHECK_EQUAL(range30[BLUE_CHANNEL].min, 0);
    BOOST_CHECK_EQUAL(range30[RED_CHANNEL].max, 25);
    BOOST_CHECK_EQUAL(range30[GREEN_CHANNEL].max, 100);
    BOOST_CHECK_EQUAL(range30[BLUE_CHANNEL].max, 3);
}


BOOST_AUTO_TEST_SUITE_END ();



