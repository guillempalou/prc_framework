// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------

//!
//!  \file imageyuv422.cpp
//!
//!  Implementation for ImageYUV422 class
//!

#include <imageplus/core/check_size.hpp>

#include <imageplus/core/imageyuv422.hpp>

using namespace imageplus;

template<typename T>
ImageYUV422<T>::ImageYUV422()
        : Image<T,3>()
{
}


template<typename T>
ImageYUV422<T>::ImageYUV422 ( uint64 width, uint64 height )
        : Image<T,3>()
{
    if ( (width % 2) != 0 )
    {
        throw ImagePlusError("width dimension must be even for 422 images");
    }
    
    (*this)(0) = MultiArray<T,2>(width,height);
    (*this)(1) = MultiArray<T,2>(width/2,height);
    (*this)(2) = MultiArray<T,2>(width/2,height);
}
        
 
template<typename T>
ImageYUV422<T>:: ImageYUV422(const ImaVol<T,3,2>& copy)  throw (ImagePlusError)
        : Image<T,3>(copy)
{
    check_size_yuv422(copy);
}

template<typename T>
ImageYUV422<T>::ImageYUV422(const Image<T,3>& copy) throw (ImagePlusError)
        : Image<T,3>(copy)
{
    check_size_yuv422(copy);
}


template<typename T>
ImageYUV422<T>::ImageYUV422(const ImageYUV422<T>& copy) throw (ImagePlusError)
        : Image<T,3>(copy)
{
#ifndef NDEBUG
    check_size_yuv422(copy);
#endif
}


template<typename T>
inline ImageYUV422<T>::ImageYUV422(const std::vector< std::vector<uint64> >& dims) throw (ImagePlusError)
        : Image<T,3>(dims)
{
    if ( (dims[0][0] != 2*dims[1][0]) || (dims[0][0] != 2*dims[2][0]) )
    {
        throw ImagePlusError("width of U and V channel must be half Y channel width (422)");
    }
    
    if ( (dims[0][1] != dims[1][1]) || (dims[0][1] != dims[2][1]) )
    {
        throw ImagePlusError("height of U and V channel must be equal to Y channel height (422)");
    }
}


template<typename T>
ImageYUV422<T>::~ImageYUV422()
{
}


template<typename T>
void ImageYUV422<T>::resize ( uint64 width, uint64 height )
{
    if ( (width % 2) != 0 )
    {
        throw ImagePlusError("Width dimension must be even for YUV422 images");
    }
    
    std::vector<uint64> dims;
    dims.push_back(width);
    dims.push_back(height);
    
    (*this)(0).resize( dims );

    dims.resize(0);
    dims.push_back(width/2);
    dims.push_back(height);
    
    (*this)(1).resize( dims );
    (*this)(2).resize( dims );
}



template<typename T>
void ImageYUV422<T>::resize ( const std::vector< std::vector<uint64> >& dims )
{
    if ( dims.size() != 3 )
    {
        throw ImagePlusError("Dimensions of dims must be equal to the number of channels");
    }
   
    for (uint64 c=0; c < 3; c++)
    {
        if (dims[c].size() != 2)
        {
            throw ImagePlusError("Dimensions for each dims[i] must be equal to 2");
        }
        
    }   
    
    if ( (dims[0][0] != 2*dims[1][0]) || (dims[0][0] != 2*dims[2][0]) )
    {
        throw ImagePlusError("resize(dims): Width of U and V channel must be half Y channel width (YUV422)");
    }
    
    if ( (dims[0][1] != dims[1][1]) || (dims[0][1] != dims[2][1]) )
    {
        throw ImagePlusError("resize(dims): Height of U and V channel must be equal to Y channel height (YUV422)");
    }

    (*this)(0).resize( dims[0] );
    (*this)(1).resize( dims[1] );
    (*this)(2).resize( dims[2] );
}


template<typename T>
const ImageYUV422<T>& ImageYUV422<T>::operator=( const ImaVol<T,3,2>& copy ) throw (ImagePlusError)
{
    check_size_yuv422(copy);

    (*this).Image<T,3>::operator=( copy );
    
    return *this;
}

template<typename T>
const ImageYUV422<T>& ImageYUV422<T>::operator=( const Image<T,3>& copy ) throw (ImagePlusError)
{
    check_size_yuv422(copy);

    (*this).Image<T,3>::operator=( copy );

    return *this;
}

template<typename T>
const ImageYUV422<T>& ImageYUV422<T>::operator=( const ImageYUV422<T>& copy ) throw (ImagePlusError)
{
#ifndef NDEBUG
    check_size_yuv422(copy);
#endif
    
    (*this).Image<T,3>::operator=( copy );
    
    return *this;
}

template<typename T>
const T& ImageYUV422<T>::operator=(const T& val)
{
    (*this).Image<T,3>::operator=( val );

    return val;
}


// ImageYUV422 instantiations
namespace imageplus
{
    template class ImageYUV422<uint8>;
    template class ImageYUV422<uint16>;
    template class ImageYUV422<uint32>;
    template class ImageYUV422<uint64>;

    template class ImageYUV422<int8>;
    template class ImageYUV422<int16>;
    template class ImageYUV422<int32>;
    template class ImageYUV422<int64>;

    template class ImageYUV422<float64>;
}
