/*
 * color_signature.hpp
 *
 *  Created on: Oct 17, 2012
 *      Author: guillem
 */

#ifndef COLOR_SIGNATURE_HPP_
#define COLOR_SIGNATURE_HPP_

#include <imageplus/descriptors/descriptor_base.hpp>
#include <imageplus/math/math_types.hpp>
#include <imageplus/math/statistics/k_means.hpp>
#include <imageplus/math/statistics/signature.hpp>
#include <imageplus/descriptors/geometry/area.hpp>

#include <list>

namespace imageplus
{
    namespace descriptors
    {
        //!
        //! \brief Area visual descriptor
        //!
        //! \author Jordi Pont <jpont@gps.tsc.upc.edu>, Guillem Palou <guillem.palou@gmail.com>
        //!
        //! \date 02-06-2009
    	template<class Signal>
        class ColorSignature : public DescriptorBase
        {
        public:
        	typedef typename Signal::value_type			ColorType;

        	typedef math::statistics::Signature<ColorType> type;

        public:

        	//! base structur for descriptors using parameters
        	struct ColorMeanDescriptorParameters {
        		int64 									num_colors;
        		typename Signal::value_float_type		weights;

        		ColorMeanDescriptorParameters() : num_colors(8) {

        		}
        	};

        	typedef ColorMeanDescriptorParameters 	Parameters;

            //! function returning the id given a set of parameters
            //! \param[in] pars: parameters to the descriptors (null in this case)
            static const std::string id(const Parameters& pars = default_parameters()) {
            	return "color_mean";
            }

            //! Default parameters for descriptors
            static const Parameters default_parameters() {
            	return Parameters();
            }

            //!
            //! \brief Default constructor
            //!
            ColorSignature(const Parameters& pars = default_parameters()) : DescriptorBase(true), _value(), _pars(pars) {};

            //! Virtual destructor
            ~ColorSignature(){};


        	float64 color_distance(ColorType& a, ColorType& b) {
        		ColorType dif =  a-b;

        		math::Vector n = dif.array().square() * _pars.weights.array().square();

        		return std::sqrt(n.sum());
        	}

        	ColorType average_color(ColorType& color1, float64 p1, ColorType& color2, float64 p2) {
        		ColorType av;

        		av = p1/(p1+p2)*color1 + p2/(p1+p2)*color2;

        		return av;
        	}

            //! \brief Calculates the area of a region, given a pair of iterators.
            //!
            //! \param[in] first      : Iterator to the beginning of the region
            //! \param[in] last       : Iterator to the end of the region
            //! \param[in] peer_descs : Pointer to CollaborativeDescriptors, in principle is never 0x0 but it is a good idea to ASSERT it
            template< class SignalModel, class RegionModel >
            void calculate(SignalModel& signal, RegionModel& region, const Parameters& pars, typename DescriptorBase::ManagerType* manager)
            {
            	// Simply call look if we have the same colors
            	// It is only possible to start with regions less than 8 different colors
            	std::map<std::vector<float64>, uint64> count_map;
            	std::map<std::vector<float64>, ColorType> color_map;
            	std::vector<ColorType> points;
            	uint32 totals = 0;

            	//std::cout << "calculating " << region.label() << std::endl;
            	_pars = pars;

            	for(typename RegionModel::iterator p = region.begin(); p != region.end(); ++p ) {
            		totals++;
            		std::vector<float64> c;

            		ColorType color = signal(*p);
            		for(int64 k = 0; k < color.rows(); k++ ) {
            			c.push_back(color(k));
            		}
            		points.push_back(color);

            		count_map[c]++;
            		color_map[c] = color;
            	}

            	if (count_map.size() > (uint64)_pars.num_colors) {
            		math::statistics::KMeansParameters pars;
            		math::statistics::KMeans<ColorType> kmeans(pars);

            		kmeans.calculate(points, _pars.num_colors);
            		_value.features = kmeans.centers();
            		_value.weights = kmeans.weights();

            	} else {
            		//put the colors in the array
            		_value.features.clear();
            		_value.weights = math::Vector(count_map.size());
            		uint64 i = 0;
            		std::map<std::vector<float64>, uint64>::iterator it2 = count_map.begin();
            		for (typename std::map<std::vector<float64>, ColorType>::iterator it = color_map.begin(); it != color_map.end(); it++, i++, it2++) {
            			_value.features.push_back(it->second);
            			_value.weights(i) = (it2->second*1.0/totals);
            		}

            	}
            }

            //!
            //! \brief Calculates recursively area of the father region given the sons ones.
            //!
            //! \param[in] son1_descs : CollaborativeDescriptors of the son 1
            //! \param[in] son2_descs : CollaborativeDescriptors of the son 2
            //! \param[in] peer_descs : Pointer to CollaborativeDescriptors, in principle is never 0x0 but it is a good idea to ASSERT it
            template<class SignalModel, class RegionModel, class ChildContainer>
            void recursive_calculate(SignalModel& signal, RegionModel& region, ChildContainer& childs, const Parameters& pars, typename DescriptorBase::ManagerType* manager)
            {
            	std::vector<const type*> child_values;
            	std::vector<Area::type> child_areas;

            	int64 N = 0;
            	int64 total_points = 0;
            	_pars = pars;
            	for (typename ChildContainer::iterator child = childs.begin(); child != childs.end(); ++child) {
            		const type& child_value = manager->calc_descriptor<ColorSignature<SignalModel> >(signal,(RegionModel&)**child, pars);
            		const Area::type& child_area = manager->calc_descriptor<Area>(signal,(RegionModel&)**child);

              		child_values.push_back(&child_value);
              		child_areas.push_back(child_area);

              		total_points+=child_area;
              		N++;
            	}

            	std::list<ColorType> 	c;
            	std::list<float64>		p;
            	for (int64 i = 0; i < N; i++) {
            		const type& child = *child_values[i];
            		c.insert(c.end(), child.features.begin(), child.features.end());

            		for (uint64 k = 0; k < child.features.size(); k++)
            			p.push_back(child.weights(k)*child_areas[i]/total_points);
            	}

            	if ((int64)c.size() > _pars.num_colors)
            		_reduce_points(c,p);

            	_value.features = typename type::Features(c.begin(),c.end());
            	_value.weights = math::Vector(p.size());

            	uint64 i = 0;
            	for (std::list<float64>::iterator it = p.begin(); it != p.end(); it++)
            		_value.weights(i++) = *it;
            }

            const type& value() const {
            	return _value;
            }
        private:

            void _reduce_points(std::list<ColorType>& c, std::list<float64>& p) {

            	while (true) {
            		typename std::list<ColorType>::iterator 				c1,c2,color1,color2;
            		std::list<float64>::iterator 							p1,p2,perc1,perc2;

            		bool merge = ((int64)c.size() > _pars.num_colors);
            		if (!merge) break;

            		float64 min_d = 1e20;

            		perc1 = p.begin();
            		color1 = c.begin();

            		for (; color1 != c.end(); color1++, perc1++) {
            			perc2 = perc1; perc2++;
            			color2 = color1; color2++;
            			for (; color2 != c.end(); color2++, perc2++) {
            				float64 d;

            				d = color_distance(*color1, *color2);
            				d*=(*perc1+*perc2);

            				if (min_d > d) {
            					c1 = color1; c2 = color2;
            					p1 = perc1; p2 = perc2;

            					min_d = d;
            				}
            			}
            		}


            		// Merge gaussians
            		float64 pf = *p1+*p2;
            		ColorType cf = average_color(*c1,*p1,*c2,*p2);

            		c.erase(c2); c.erase(c1); c.push_back(cf);
            		p.erase(p2); p.erase(p1); p.push_back(pf);

            	}
            }

        private:
            //! Area of the region
            type _value;

            //! Parameters
            Parameters _pars;

        };
    }
}

#endif /* COLOR_SIGNATURE_HPP_ */
