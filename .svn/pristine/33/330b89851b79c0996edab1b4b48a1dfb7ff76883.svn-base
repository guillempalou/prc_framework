/*
 * min_area_pruner.hpp
 *
 *  Created on: Dec 18, 2012
 *      Author: gpalou
 */

#ifndef MIN_AREA_PRUNER_HPP_
#define MIN_AREA_PRUNER_HPP_

#include <imageplus/bpt/pruning/bpt_pruner.hpp>
#include <imageplus/descriptors/descriptor_manager.hpp>
#include <imageplus/descriptors/geometry/area.hpp>

namespace imageplus {
	namespace bpt {

	//! Class that prunes the BPT such that all regions are at least a given area
	//! \param BPT: BT type
	//! \param ImageModel: Image type
	template<class BPT, class ImageModel>
	class MinAreaPruner : public BPTPruner<BPT,ImageModel> {

		//! Base class
		typedef BPTPruner<BPT,ImageModel> Pruner;

		//! RegionIDs type
		typedef typename Pruner::RegionsIDs RegionsIDs;

	public:

		//! Constructor
		//! \param[in] th : minimum area
		MinAreaPruner(float64 th, bool prune) : Pruner(true) {_area_threshold = th;}

		//! Sets the area threshold
		//! \param[in] th : minimum area. all the pruned regions should have greater area
		void set_area_threshold(float64 th) {_area_threshold = th;}

		//! Base function to find the regions to prune
		//! \param[in] bpt: the tree
		//! \param[in] img: the image where the regions belong
		const RegionsIDs& find_pruned_regions(BPT& bpt, ImageModel& img, uint64 reg_id, uint64 region_objective) {
			return find_pruned_regions(bpt,img);
		}

		//! Base function to find the regions to prune
		//! \param[in] bpt: the tree
		//! \param[in] img: the image where the regions belong
		const RegionsIDs& find_pruned_regions(BPT& bpt, ImageModel& img) {
			int64 head = 1;
			int64 tail = 0;

			std::vector<uint64> regions;
			regions.push_back(bpt.max_label());

			float64 area_threshold = _area_threshold;

			descriptors::DescriptorManager manager;
			manager.set_max_number_of_regions(bpt.max_label()+1);

			while (head != tail) {
				uint64 id = regions[tail];

				if (bpt(id).children().size() == 0) { tail++; continue; }

				int64 son1 = bpt(id).child(0)->label();
				int64 son2 = bpt(id).child(1)->label();

				descriptors::Area::type area1 = manager.calc_descriptor<descriptors::Area>(img, bpt(son1));
				descriptors::Area::type area2 = manager.calc_descriptor<descriptors::Area>(img, bpt(son2));

				if (area1 > area_threshold && area2 > area_threshold) {
					regions.push_back(son1);
					regions.push_back(son2);
					head++;
					head++;
				} else {
					Pruner::_regions.insert(son1);
					Pruner::_regions.insert(son2);
				}

				tail++;
			}

			return Pruner::_regions;
		}

	private:
		//! threshold
		float64 _area_threshold;

	};

	}
}

#endif /* MIN_AREA_PRUNER_HPP_ */
