// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------

//!
//!  \file qr_factorization.test
//!

#include <imageplus/math/numeric/qr_decomposition.hpp>
#include <imageplus/math/numeric/matrices.hpp>
#include <imageplus/math/numeric/products.hpp>
#include <imageplus/math/numeric/lu_decomposition.hpp>
#include <imageplus/math/numeric/transformations.hpp>


BOOST_AUTO_TEST_SUITE ( QRSuite );

using namespace imageplus;
using namespace imageplus::math::numeric;

typedef boost::mpl::list<float64> DataTypes;


BOOST_AUTO_TEST_CASE_TEMPLATE( QRFactorization, T, DataTypes )
{
    uint64 size = 4;
    
    MultiArray<T,2> A(size,size);

    A[0][0] = 1;
    A[1][0] = 2;
    A[2][0] = 3;
    A[3][0] = 4;

    A[0][1] = 5;
    A[1][1] = 6;
    A[2][1] = 7;
    A[3][1] = 8;

    A[0][2] = 9;
    A[1][2] = 0;
    A[2][2] = 9;
    A[3][2] = 8;

    A[0][3] = 7;
    A[1][3] = 6;
    A[2][3] = 5;
    A[3][3] = 4;


    QRDecomposition qr(A);

    MultiArray<float64,2> Q = qr.q();
    MultiArray<float64,2> R = qr.r();

    //
    // Check that Q is orthogonal. Q*Q' = I
    //

    MultiArray<float64,2> QQT;
    MultiArray<float64,2> id;

    QQT = prod(Q,trans(Q));
    id  = imageplus::math::numeric::identity_matrix<float64>(size);

    for (uint64 j = 0; j < size; j++)
    {
        for (uint64 i = 0; i < size; i++)
        {
            if (id[i][j] == 0)
            {
                BOOST_CHECK_SMALL(QQT[i][j], 1e-7);
            }
            else
            {
                BOOST_CHECK_CLOSE(id[i][j], QQT[i][j], 1e-7);
            }
        }
    }


    //
    // Check that R is upper triangular
    //
    BOOST_CHECK( is_upper_triangular(R) == true);

 
    //
    // Check that QR=A
    //
    MultiArray<float64,2> QR;
    QR = imageplus::math::numeric::prod(Q, R);

    for (uint64 j = 0; j < size; j++)
    {
        for (uint64 i = 0; i < size; i++)
        {
            if (A[i][j] == 0)
            {
                BOOST_CHECK_SMALL(QR[i][j], 1e-7);
            }
            else
            {
                BOOST_CHECK_CLOSE(A[i][j], QR[i][j], 1e-7);
            }
        }
    }

    
// AGIL: Please, do not use cout in tests, use BOOST_TEST_MESSAGE( message ) instead and run tests with "--log_level=messag"
#   if 0
    std::cout << "QQT:" << std::endl;

    for (uint64 j = 0; j < size; j++)
    {
        for (uint64 i = 0; i < size; i++)
        {
            std::cout << QQT[i][j] << " ";
        }
        std::cout << std::endl;
    }

    std::cout << std::endl;
    std::cout << std::endl;
    std::cout << "QR:" << std::endl;

    for (uint64 j = 0; j < size; j++)
    {
        for (uint64 i = 0; i < size; i++)
        {
            std::cout << QR[i][j] << " ";
        }
        std::cout << std::endl;
    }
#   endif


}    


BOOST_AUTO_TEST_SUITE_END ();
