// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------

//!
//!  \file imagepartition.cpp
//!
//!  Implementation for ImagePartition class
//!

#include <imageplus/core/imagepartition.hpp>
#include <imageplus/core/padding.hpp>

#include <deque>


using namespace imageplus;


template<typename T>
ImagePartition<T>::ImagePartition()
        : Image<T,1>()
{
}


template<typename T>
ImagePartition<T>::ImagePartition(uint64 x, uint64 y)
        : Image<T,1>(x,y)
{
}


template<typename T>
ImagePartition<T>::ImagePartition(const ImaVol<T,1,2>& copy)
        : Image<T,1>(copy)
{
}


template<typename T>
ImagePartition<T>::ImagePartition(const Image<T,1>& copy)
        : Image<T,1>(copy)
{
}

template<typename T>
ImagePartition<T>::ImagePartition(const ImagePartition& copy)
        : Image<T,1>(copy)
{
}

template<typename T>
ImagePartition<T>::ImagePartition(const std::vector< std::vector<uint64> >& dims)
        : Image<T,1>(dims)
{
}


template<typename T>
ImagePartition<T>::~ImagePartition()
{
}

template<typename T>
const ImagePartition<T>& ImagePartition<T>::operator=(const ImaVol<T,1,2>& copy)
{
    (*this).Image<T,1>::operator=( copy );

    return *this;
}

template<typename T>
const ImagePartition<T>& ImagePartition<T>::operator=(const Image<T,1>& copy)
{
    (*this).Image<T,1>::operator=( copy );

    return *this;
}


template<typename T>
const ImagePartition<T>& ImagePartition<T>::operator=(const ImagePartition& copy)
{
    (*this).Image<T,1>::operator=( copy );

    return *this;
}


template<typename T>
const T& ImagePartition<T>::operator=(const T& val)
{
    (*this).Image<T,1>::operator=( val );

    return val;
}





template<typename T>
T imageplus::relabel(const ImaVol<T,1,2>& partition_in, ImaVol<T,1,2>& partition_out, part_bimap& bimap, T init)
{
    ASSERT(partition_out.size_x()==partition_in.size_x(), "relabel: The x sizes of the partitions are not equal");
    ASSERT(partition_out.size_y()==partition_in.size_y(), "relabel: The y sizes of the partitions are not equal");
 
    T num_reg;
    
    std::size_t size_x = partition_in.size_x();
    std::size_t size_y = partition_in.size_y();
    
    part_bimap::left_const_iterator it;
    part_bimap::left_const_iterator it_end = bimap.left.end();
    
    T max_region = init;
    
    for(std::size_t jj=0; jj<size_y; jj++)
    {
        for(std::size_t ii=0; ii<size_x; ii++)
        {
            it = bimap.left.find(partition_in(0)[ii][jj]);
            
            if(it == it_end)
            {
                bimap.insert( map(partition_in(0)[ii][jj], max_region) );
                partition_out[ii][jj] = max_region;
                max_region++;
            }
            else
            {
                partition_out[ii][jj] = it->second;
            }
        }
    }
    num_reg = max_region-init;
    
    return num_reg;
}
    
    
template<typename T>
T imageplus::relabel(const ImagePartition<T>& partition_in, ImagePartition<T>& partition_out, T init)
{
    part_bimap bimap;
    T num_reg = relabel(partition_in, partition_out, bimap, init);
    return num_reg;
}


template<typename T>
partition_table imageplus::region_areas(const ImagePartition<T>& part_in)
{
    uint64 x_size = part_in.size_x();
    uint64 y_size = part_in.size_y();
    
    partition_table table;
    partition_table::left_iterator iter1;
    partition_table::left_const_iterator iter_end; 
    iter_end = table.left.end();
    
    for(std::size_t jj=0; jj<y_size; jj++)
    {
        for(std::size_t ii=0; ii<x_size; ii++)
        {
            uint64 curr_label = (uint64)part_in(0)[ii][jj];
            iter1 = table.left.find(curr_label);
            if(iter1 == iter_end)  //The region was not there
            {
                table.insert( table_entry( curr_label, 1 ) );
            }
            else  //The region was already there
            {
                iter1->second = iter1->second + 1;
            }
        }
    }
    
    return table;
}





namespace imageplus
{
//    template class ImagePartition<int8>;
    template class ImagePartition<int16>;
//    template class ImagePartition<int32>;
//    template class ImagePartition<int64>;
//    
//    template class ImagePartition<uint8>;
//    template class ImagePartition<uint16>;
    template class ImagePartition<uint32>;
//    template class ImagePartition<uint64>;
    
    
    template uint32 relabel(const ImaVol<uint32,1,2>& partition_in, ImaVol<uint32,1,2>& partition_out, part_bimap& bimap, uint32 init);
    template uint32 relabel(const ImagePartition<uint32>& partition_in, ImagePartition<uint32>& partition_out, uint32 init);
    
    template partition_table region_areas(const ImagePartition<uint32>& part_in);
    
//    template uint32 label_flatzone(ImagePartition<uint32>& partition_out, const Image<uint8,1>& image_in);
//    template uint32 label_flatzone(ImagePartition<uint32>& partition_out, const Image<uint8,3>& image_in);
//    template uint32 label_flatzone(ImagePartition<uint32>& partition_out, const Image<uint16,1>& image_in);
//    template uint32 label_flatzone(ImagePartition<uint32>& partition_out, const Image<uint16,3>& image_in);
//    
//    template uint32 label_flatzone(ImagePartition<uint32>& partition_out, const Image<uint8,1>& image_in, float64 tolerance);
//    template uint32 label_flatzone(ImagePartition<uint32>& partition_out, const Image<uint8,3>& image_in, float64 tolerance);
//    template uint32 label_flatzone(ImagePartition<uint32>& partition_out, const Image<uint16,1>& image_in, float64 tolerance);
//    template uint32 label_flatzone(ImagePartition<uint32>& partition_out, const Image<uint16,3>& image_in, float64 tolerance);

}//imageplus


