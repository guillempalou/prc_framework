// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------

//!
//!  \file svd.hpp
//!
//!  \brief Class for SVD decomposition
//!

#ifndef IMAGEPLUS_MATH_NUMERIC_SVD_H
#define IMAGEPLUS_MATH_NUMERIC_SVD_H

#include <imageplus/core.hpp>

namespace imageplus
{
	namespace math
	{
		namespace numeric 
		{

            //! Value \f$2.0^-52.0\f$ used to decide if a small quantity should be considered as zero 
            const float64 SVD_EPS = 2.2204e-16; //float64 eps(pow(2.0,-52.0));

            //!
            //! \brief Class for Singular Value Decomposition
            //!
            //! <a href="http://en.wikipedia.org/wiki/Singular_value_decomposition">SVD</a> 
            //! is a factorization of a rectangular real or complex matrix, with 
            //! several applications in signal processing and statistics. Applications 
            //! which employ the SVD include computing the pseudoinverse, least squares 
            //! fitting of data, matrix approximation, and determining the rank, range and null space of a matrix.\n\n
            //! Suppose M is an m-by-n real or complex matrix. Then there exists a factorization of the form:\n
            //!
            //! M = U·S·V*\n
            //!
            //! where U is an m-by-n unitary matrix, the matrix S is n-by-n with nonnegative numbers on 
            //! the diagonal (as defined for a rectangular matrix) and zeros off the diagonal, and V* 
            //! denotes the conjugate transpose of V, an n-by-n unitary matrix. Such a factorization 
            //! is called a singular-value decomposition of M.\n
            //!
            //! The matrix V thus contains a set of orthonormal "input" or "analysing" basis vector directions for M\n
            //! The matrix U contains a set of orthonormal "output" basis vector directions for M\n
            //! The matrix S contains the singular values, which can be thought of as scalar "gain 
            //! controls" by which each corresponding input is multiplied to give a corresponding output.\n
            //!
            //! The singular values, sigma[k] = S[k][k], are ordered so that
            //! sigma[0] >= sigma[1] >= ... >= sigma[n-1].\n
            //!
            //! The ordered diagonal matrix S is uniquely determined by M (though the matrices U and V are not).\n
            //!
            //! The singular value decompostion always exists, so the constructor will
            //! never fail.  The matrix condition number and the effective numerical
            //! rank can be computed from this decomposition.\n
            //! (Adapted from JAMA, a Java Matrix Library, developed by jointly 
            //! by the Mathworks and NIST; see  http://math.nist.gov/javanumerics/jama).
            //!
            //! \headerfile include/imageplus/math/numeric/svd.hpp <math/numeric/svd.hpp>
            //!
            //! \author Josep Ramon Morros <ramon.morros@upc.edu>
            //!
            //! \date 26-6-2008
            //!
			class SVD
			{
				public:
                    //!
                    //! \brief Constructor for MultiArray
                    //!
                    //! \param[in] arg  : Input multiarray
                    //!
					SVD (const MultiArray<float64,2>& arg);
					
                    //!			
                    //! \brief Return matrix U
                    //!
                    //! U contains a set of orthonormal "output" basis vector directions for M
                    //!
                    //! \return  Ortonormal matrix U
                    //!
					MultiArray<float64,2> u () const;
				
                    //!			
                    //! \brief Return matrix V
                    //!
                    //! V thus contains a set of orthonormal "input" or "analysing" basis vector directions for M
                    //!
                    //! \return  Orthonormal matrix V
                    //!
					MultiArray<float64,2> v () const;
							
                    //!			
                    //! \brief Return a vector with the singular values
                    //!
                    //! \return  Vector with singular values
                    //!
					MultiArray<float64,1> singular_values () const;
				
                    //!			
                    //! \brief Return the diagonal matrix of singular values
                    //!
                    //! \return  Diagonal matrix with singular values
                    //!
					MultiArray<float64,2> s () const;
				                    
                    //!
                    //! \brief Two norm  (max(S))
                    //!
                    //! \return Two norm (max(S))
                    //!
					float64 norm2 () const;

                    //!
                    //! \brief Two norm of condition number (max(S)/min(S))
                    //!
                    //! \return Two norm of condition number (max(S)/min(S))				
                    //!
					float64 cond () const;
				
                    //!
                    //! \brief Effective numerical matrix rank
                    //!
                    //! \return Number of nonnegligible singular values.
                    //!
					uint64 rank () const;
	
				
				private:

                    //! Number of columns
					uint64 _size_x;

                    //! Number of rows 
                    uint64 _size_y;

                    //! Contains a set of orthonormal "output" basis vector directions for input matrix
					MultiArray<float64,2> _u;

                    //! contains a set of orthonormal "input" or "analysing" basis vector directions for input matrix
					MultiArray<float64,2> _v;

                    //! Vector with singular values
					MultiArray<float64,1> _s;

			};
		}
	}
}

#endif

