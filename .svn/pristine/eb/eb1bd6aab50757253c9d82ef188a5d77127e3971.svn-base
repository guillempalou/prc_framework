// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------

//!
//!  \file io_auxiliar.cpp
//!
//!  Auxiliar methos for io module
//!


#include <fstream>

#include <io_auxiliar.hpp>

#ifdef USE_IMAGEMAGICK
#include <Magick++.h>
#else

/*
 * To solve linking problems with new versions of libpng
 * (from http://stackoverflow.com/questions/2442335/libpng-boostgil-png-infopp-null-not-found)
 */
#ifndef png_infopp_NULL
#define png_infopp_NULL (png_infopp)NULL
#endif

#ifndef int_p_NULL
#define int_p_NULL (int*)NULL
#endif

#include <boost/gil/extension/io/jpeg_dynamic_io.hpp>
#include <boost/gil/extension/io/png_dynamic_io.hpp>
#include <boost/gil/extension/io/tiff_dynamic_io.hpp>
#endif

// To check files
#include <boost/filesystem.hpp>

#include <imageplus/io/readbitstream.hpp>

namespace imageplus
{
    namespace io
    {
        ImageFormat get_image_format_from_header(const std::string& file_path)
        {
            ReadBitStream rbs(file_path);
            uint64 read_two_bytes = rbs.read(16);

            if(read_two_bytes==65496) // JPG: 255, 216
            {
                return JPEG;
            }
            else if(read_two_bytes==35152) // PNG: 137, 80
            {
                if(rbs.read(16)!=20039) return UNKNOWN_IMAGE_FORMAT; // 78, 71
                if(rbs.read(16)!= 3338) return UNKNOWN_IMAGE_FORMAT; // 13, 10
                if(rbs.read(16)!= 6666) return UNKNOWN_IMAGE_FORMAT; // 26, 10
                return PNG;
            }
            else if(read_two_bytes==18761) // TIFF (Intel):  73, 73
            {                
                if(rbs.read(8)!=42) return UNKNOWN_IMAGE_FORMAT; // 42
                return TIFF;
            }
            else if(read_two_bytes==19789) // TIFF (Mac): 77, 77
            {                
                if(rbs.read(8)!=42) return UNKNOWN_IMAGE_FORMAT; // 42
                return TIFF;
            }
            else if(read_two_bytes==65280) // MULT: 255, 0
            {                
                return MULT;
            }   
#ifdef USE_IMAGEMAGICK
            else if(read_two_bytes==16973)  // BMP: 'B', 'M'
            {
                return BMP;
            }
            else if(read_two_bytes==20533)  // PM: 'P', '5'
            {
                return PM;
            }
            else if(true)  // TODO: Check RAS
            {
                return RAS;
            }
#endif
            else // UNKNOWN_IMAGE_FORMAT
            {
                return UNKNOWN_IMAGE_FORMAT;
            }
        }
        
        
        ImageFormat get_image_format(const std::string& file_path)
        {
            // set the extension type
            std::string ext = boost::filesystem::extension( file_path );
            if( ext == ".jpg" || ext == ".jpeg" )
            {
                return JPEG;
            }
            else if( ext == ".png" )
            {
                return PNG;
            }
            else if ( ext == ".tiff" || ext == ".tif")
            {
                return TIFF;
            }
            else if ( ext == ".mult" || ext == ".prl"   ||
                      ext == ".bay"  || ext == ".bayer" )
            {
                return MULT;
            }

#ifdef USE_IMAGEMAGICK
            else if( ext == ".ras" )
            {
                return RAS;
            }
            else if( ext == ".bmp" )
            {
                return BMP;
            }
            else if( ext == ".ppm" || ext == ".pgm"   )
            {
                return PM;
            }
#endif
            else // UNKNOWN_IMAGE_FORMAT
            {
                return UNKNOWN_IMAGE_FORMAT;

                // TODO: Add a method to print the supported image types
                //throw ImagePlusFileError( file_path, "Image type not supported (" + ext + ")" );
            }
        }


        std::vector<uint64> get_image_dimensions(const std::string& file_path, const ImageFormat format)
        {
            std::vector<uint64> v(2); v[0] = 0; v[1] = 0;

            switch (format)
            {
#ifdef USE_IMAGEMAGICK
                case JPEG:
                case PNG:
                case TIFF:
                case RAS:
                case BMP:
                {
                    Magick::Image magickImage;
                    magickImage.ping( file_path );
                    v[0] = magickImage.columns();
                    v[1] = magickImage.rows();
                    break;
                }
#else
                case JPEG:
                {
                    boost::gil::point2< std::ptrdiff_t > p2 = boost::gil::jpeg_read_dimensions (file_path.c_str());
                    v[0] = p2[0]; v[1] = p2[1];
                    break;
                }
                case PNG:
                {
                    boost::gil::point2< std::ptrdiff_t > p2 = boost::gil::png_read_dimensions (file_path.c_str());
                    v[0] = p2[0]; v[1] = p2[1];
                    break;
                }
                case TIFF:
                {
                    boost::gil::point2< std::ptrdiff_t > p2 = boost::gil::tiff_read_dimensions (file_path.c_str());
                    v[0] = p2[0]; v[1] = p2[1];
                    break;
                }
#endif
                case MULT:
                {
                    // Open file
                    std::ifstream fp (file_path.c_str(), std::ios::in | std::ios::binary);
                    if (!fp.is_open())
                    {
                        throw ImagePlusFileNotFound(file_path);
                    }

                    // read magic number to start of file
                    uint16 mn;
                    fp.read((char*)&mn,sizeof(mn));
                    if (mn != MULT_MAGIC_NUMBER)
                    {
                        throw ImagePlusError("Magic number does not exists in the file");
                    }

                    // read filetype
                    uint8 ft;
                    fp.read((char*)&ft,sizeof(ft));
                    if (ft != MULT_FILETYPE)
                    {
                        throw ImagePlusError("File type is not multiarray");
                    }

                    // read compress & datatype
                    uint8 c;
                    fp.read((char*)&c,sizeof(c));
                    fp.read((char*)&c,sizeof(c));

                    // read dimensions
                    uint64 d;
                    fp.read((char*)&d,sizeof(d));

                    std::vector<uint64> dims(d);
                    for (uint64 i = 0; i < d; i++)
                    {
                        uint64 s;
                        fp.read((char*)&s,sizeof(s));
                        dims[i] = s;
                    }
                    v = dims;
                    break;
                }

                case UNKNOWN_IMAGE_FORMAT:
                default:
                    throw ImagePlusFileError(file_path, "Image type not supported" );
                    break;
            }

            return v;
        }
    }
}
