// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------

/*!
 * \example quantizer.test
 * 
 * Test-Example to show how to create and use an \ref imageplus::Quantizer.
 */

/*
 * The header where Quantizer is declared 
 */
#include <imageplus/core/quantizer.hpp>

BOOST_AUTO_TEST_SUITE ( QuantizerTestExampleSuite );

using namespace imageplus;

/*
 * We can quantize any data type BUT, because float imprecision, floats quantization 
 * of values equal or close to the (float) thresholds are ambiguous.
 * 
 * See the test-example named "Test_Float_Quantizer" at the end of this test-example to see this ambiguity.
 */
typedef boost::mpl::list< uint8,
                          uint16,
                          uint32,
                          uint64,
                          int8,
                          int16,
                          int32,
                          int64   > QuantizerIntegerTypes;

typedef boost::mpl::list< float32,
                          float64 > QuantizerFloatTypes;

BOOST_AUTO_TEST_CASE_TEMPLATE( Test_Uniform_Quantizer, T, QuantizerIntegerTypes )
{
    /*
     * Creating a Uniform Quantizer on the range [10,...,110] with 10 bins:
     *
     *   10    20 21   30 31   40 41   50 51   60 61   70 71   80 81   90 91  100 101  110
     *   |   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |
     */
    Quantizer<T> q( 10, 110, 10 );
                /* min, max, nbins */

    /*
     * Checking that the number of bins is the expected one.
     */
    BOOST_CHECK( q.num_bins() == 10 );
    
    /*
     * Checking that the internal thresholds of the quantizer are the expected ones
     */
    BOOST_CHECK( q.threshold( 0) ==  10 );
    BOOST_CHECK( q.threshold( 1) ==  20 );
    BOOST_CHECK( q.threshold( 2) ==  30 );
    BOOST_CHECK( q.threshold( 3) ==  40 );
    BOOST_CHECK( q.threshold( 4) ==  50 );
    BOOST_CHECK( q.threshold( 5) ==  60 );
    BOOST_CHECK( q.threshold( 6) ==  70 );
    BOOST_CHECK( q.threshold( 7) ==  80 );
    BOOST_CHECK( q.threshold( 8) ==  90 );
    BOOST_CHECK( q.threshold( 9) == 100 );
    BOOST_CHECK( q.threshold(10) == 110 );
    
    /*
     * Checking the quantization of the minimum amb maxim values of the input range [10,...,110] 
     */
    BOOST_CHECK( q.bin(  10 ) == 0 ); // 0
    BOOST_CHECK( q.bin( 110 ) == 9 ); // nbins-1

    /*
     * Checking out of range values
     */
    BOOST_CHECK( q.bin(   0 ) == 0 ); // min value:  10
    BOOST_CHECK( q.bin( 120 ) == 9 ); // max value: 110

    /*
     * Checking values between thresholds
     */
    BOOST_CHECK( q.bin(  11 ) == 0 );
    BOOST_CHECK( q.bin(  19 ) == 0 ); // 1st threshold:  20
    BOOST_CHECK( q.bin(  21 ) == 1 );
    BOOST_CHECK( q.bin(  29 ) == 1 ); // 2nd threshold:  30
    BOOST_CHECK( q.bin(  31 ) == 2 );
    BOOST_CHECK( q.bin(  39 ) == 2 ); // 3th threshold:  40
    BOOST_CHECK( q.bin(  41 ) == 3 );
    BOOST_CHECK( q.bin(  49 ) == 3 ); // 4th threshold:  50
    BOOST_CHECK( q.bin(  51 ) == 4 );
    BOOST_CHECK( q.bin(  59 ) == 4 ); // 5th threshold:  60
    BOOST_CHECK( q.bin(  61 ) == 5 );
    BOOST_CHECK( q.bin(  69 ) == 5 ); // 6th threshold:  70
    BOOST_CHECK( q.bin(  71 ) == 6 );
    BOOST_CHECK( q.bin(  79 ) == 6 ); // 7th threshold:  80
    BOOST_CHECK( q.bin(  81 ) == 7 );
    BOOST_CHECK( q.bin(  89 ) == 7 ); // 8th threshold:  90
    BOOST_CHECK( q.bin(  91 ) == 8 );
    BOOST_CHECK( q.bin(  99 ) == 8 ); // 9th threshold: 100
    BOOST_CHECK( q.bin( 101 ) == 9 );
    BOOST_CHECK( q.bin( 109 ) == 9 );

    /*
     * Checking the thresholds
     * 
     * NOTE: Float Quantizers are ambiguos in the thresholds values, or close to them.
     *       But integers Quantizers are not abiguous, always return the lower bin in the thresholds. 
     *       (see the Test_Float_Quantizer below).
     */
    BOOST_CHECK( q.bin(  20 ) == 0 );
    BOOST_CHECK( q.bin(  30 ) == 1 );
    BOOST_CHECK( q.bin(  40 ) == 2 );
    BOOST_CHECK( q.bin(  50 ) == 3 );
    BOOST_CHECK( q.bin(  60 ) == 4 );
    BOOST_CHECK( q.bin(  70 ) == 5 );
    BOOST_CHECK( q.bin(  80 ) == 6 );
    BOOST_CHECK( q.bin(  90 ) == 7 );
    BOOST_CHECK( q.bin( 100 ) == 8 );
    BOOST_CHECK( q.bin( 110 ) == 9 );
}

BOOST_AUTO_TEST_CASE_TEMPLATE( Test_Non_Uniform_Quantizer, T, QuantizerIntegerTypes )
{
    /*
     * Creating a Non-Uniform Quantizer like this:
     *
     *   10   22  28      42  48      62  68      82  88     102   110
     *   |  0   | 1 |   2   | 3 |   4   | 5 |   6   | 7 |   8   | 9  |
     */
    MultiArray<T,1> thresholds(11); // 11 = 9 thresholds + min + max
                                    // 11 = num_bins + 1

    thresholds[ 0] =  10; // mininum of the desired Quantizer
    thresholds[10] = 110; // maximun of the desired Quantizer

    thresholds[ 1] =  22; // the rest of the thresholds of the desired Quantizer
    thresholds[ 2] =  28;
    thresholds[ 3] =  42;
    thresholds[ 4] =  48;
    thresholds[ 5] =  62;
    thresholds[ 6] =  68;
    thresholds[ 7] =  82;
    thresholds[ 8] =  88;
    thresholds[ 9] = 102;

    Quantizer<T> q( thresholds );
    
    /*
     * Checking that the number of bins is the expected one
     */
    BOOST_CHECK( q.num_bins() == 10 );
    
    /*
     * Checking the expected internal thresholds of the Quantizer
     */
    BOOST_CHECK( q.threshold( 0) ==  10 );
    BOOST_CHECK( q.threshold( 1) ==  22 );
    BOOST_CHECK( q.threshold( 2) ==  28 );
    BOOST_CHECK( q.threshold( 3) ==  42 );
    BOOST_CHECK( q.threshold( 4) ==  48 );
    BOOST_CHECK( q.threshold( 5) ==  62 );
    BOOST_CHECK( q.threshold( 6) ==  68 );
    BOOST_CHECK( q.threshold( 7) ==  82 );
    BOOST_CHECK( q.threshold( 8) ==  88 );
    BOOST_CHECK( q.threshold( 9) == 102 );
    BOOST_CHECK( q.threshold(10) == 110 );
    
    /*
     * Checking the number of bins and the minimum and maximum values of the input range [10,...,110]
     */
    BOOST_CHECK( q.bin(  10 ) == 0 ); // min value:  10
    BOOST_CHECK( q.bin( 110 ) == 9 ); // max value: 110

    /*
     * Checking out of range values
     */
    BOOST_CHECK( q.bin(   0 ) == 0 ); // min value:  10
    BOOST_CHECK( q.bin( 120 ) == 9 ); // max value: 110

    /*
     * Checking values between thresholds
     */
    BOOST_CHECK( q.bin(  11 ) == 0 );
    BOOST_CHECK( q.bin(  21 ) == 0 ); // 1st threshold:  22
    BOOST_CHECK( q.bin(  23 ) == 1 );
    BOOST_CHECK( q.bin(  27 ) == 1 ); // 2nd threshold:  28
    BOOST_CHECK( q.bin(  29 ) == 2 );
    BOOST_CHECK( q.bin(  41 ) == 2 ); // 3th threshold:  42
    BOOST_CHECK( q.bin(  43 ) == 3 );
    BOOST_CHECK( q.bin(  47 ) == 3 ); // 4th threshold:  48
    BOOST_CHECK( q.bin(  49 ) == 4 );
    BOOST_CHECK( q.bin(  61 ) == 4 ); // 5th threshold:  62
    BOOST_CHECK( q.bin(  63 ) == 5 );
    BOOST_CHECK( q.bin(  67 ) == 5 ); // 6th threshold:  68
    BOOST_CHECK( q.bin(  69 ) == 6 );
    BOOST_CHECK( q.bin(  81 ) == 6 ); // 7th threshold:  82
    BOOST_CHECK( q.bin(  83 ) == 7 );
    BOOST_CHECK( q.bin(  87 ) == 7 ); // 8th threshold:  88
    BOOST_CHECK( q.bin(  89 ) == 8 );
    BOOST_CHECK( q.bin( 101 ) == 8 ); // 9th threshold: 102
    BOOST_CHECK( q.bin( 103 ) == 9 );
    BOOST_CHECK( q.bin( 109 ) == 9 );

    /*
     * Checking the thresholds
     *
     * NOTE: Float Quantizers are ambiguos in the thresholds values, or close to them.
     *       But integers Quantizers are not abiguous, always return the lower bin in the thresholds. 
     *       (see the Test_Float_Quantizer below).
     */
    BOOST_CHECK( q.bin(  22 ) == 0 );
    BOOST_CHECK( q.bin(  28 ) == 1 );
    BOOST_CHECK( q.bin(  42 ) == 2 );
    BOOST_CHECK( q.bin(  48 ) == 3 );
    BOOST_CHECK( q.bin(  62 ) == 4 );
    BOOST_CHECK( q.bin(  68 ) == 5 );
    BOOST_CHECK( q.bin(  82 ) == 6 );
    BOOST_CHECK( q.bin(  88 ) == 7 );
    BOOST_CHECK( q.bin( 102 ) == 8 );
    BOOST_CHECK( q.bin( 110 ) == 9 );
}

BOOST_AUTO_TEST_CASE_TEMPLATE( Test_Quantizer_Constructions, T, QuantizerIntegerTypes  )
{
    /*
     * Creating a simple uniform Quantizer on the range 10 to 20 with 5 bins:
     *
     *   10  12 13 14 15 16 17 18 19  20
     *   |  0  |  1  |  2  |  3  |  4  |
     */
    MultiArray<T,1> thresholds(6); // 6 = 4 thresholds + min + max
                                   // 6 = num_bins + 1

    thresholds[0] = 10; // min
    thresholds[5] = 20; // max

    thresholds[1] = 12; // thresholds
    thresholds[2] = 14;
    thresholds[3] = 16;
    thresholds[4] = 18;

    /*
     * Check that a Quantizer from uniform thresholds is the same than a uniform Quantizer
     */
    BOOST_CHECK( Quantizer<T>( thresholds )  == Quantizer<T>( 10, 20, 5 ) );
    
    /*
     * Checking that other Quantizers are different
     */
    BOOST_CHECK( Quantizer<T>( 10, 20, 5 )  != Quantizer<T>( 10, 20, 2 ) ); // nbins are different
    BOOST_CHECK( Quantizer<T>(  0, 20, 5 )  != Quantizer<T>( 10, 20, 2 ) ); //   min are different
    BOOST_CHECK( Quantizer<T>( 10, 30, 5 )  != Quantizer<T>( 10, 20, 2 ) ); //   max are different
}

BOOST_AUTO_TEST_CASE_TEMPLATE( Test_Float_Quantizer, T, QuantizerFloatTypes )
{
    /*
     * Creating a uniform float Quantizer for the range [0.0,...,1.0] with 5 bins:
     *
     *   0.0   0.20   0.40   0.60   0.80   1.0
     *   ||  0  ||  1  ||  2  ||  3  ||  4  ||
     */
    Quantizer<T> q( 0.0, 1.0, 5 );

    /*
     * Checking that the number of bins are the expected one
     */
    BOOST_CHECK( q.num_bins() == 5 );
    
    /*
     * Checking that the internal thresholds of the Quantizer are the expected ones
     */
    BOOST_CHECK_SMALL( q.threshold(0) - 0.00, 0.01 );
    BOOST_CHECK_SMALL( q.threshold(1) - 0.20, 0.01 );
    BOOST_CHECK_SMALL( q.threshold(2) - 0.40, 0.01 );
    BOOST_CHECK_SMALL( q.threshold(3) - 0.60, 0.01 );
    BOOST_CHECK_SMALL( q.threshold(4) - 0.80, 0.01 );
    BOOST_CHECK_SMALL( q.threshold(5) - 1.00, 0.01 );
    
    /*
     * Checking min and max values
     */
    BOOST_CHECK( q.bin( 0.0 ) == 0 ); // min value: 0.0
    BOOST_CHECK( q.bin( 1.0 ) == 4 ); // max value: 1.0

    /*
     * Checking out of range values
     */
    BOOST_CHECK( q.bin(-0.50 ) == 0 );
    BOOST_CHECK( q.bin( 1.50 ) == 4 );

    /*
     * Checking values between thresholds
     */
    BOOST_CHECK( q.bin( 0.05 ) == 0 );
    BOOST_CHECK( q.bin( 0.15 ) == 0 );
    BOOST_CHECK( q.bin( 0.25 ) == 1 );
    BOOST_CHECK( q.bin( 0.35 ) == 1 );
    BOOST_CHECK( q.bin( 0.45 ) == 2 );
    BOOST_CHECK( q.bin( 0.55 ) == 2 );
    BOOST_CHECK( q.bin( 0.65 ) == 3 );
    BOOST_CHECK( q.bin( 0.75 ) == 3 );
    BOOST_CHECK( q.bin( 0.85 ) == 4 );
    BOOST_CHECK( q.bin( 0.95 ) == 4 );

    /*
     * Checking the thresholds.
     * Because the implicit imprecision of float types the bin of values equal or too close to 
     * the Quantizer thresholds are ambiguous, they can be the lower or the greater bin.
     */
    BOOST_CHECK( q.bin( 0.20 ) == 0 || q.bin( 0.20 ) == 1 );
    BOOST_CHECK( q.bin( 0.40 ) == 1 || q.bin( 0.40 ) == 2 );
    BOOST_CHECK( q.bin( 0.60 ) == 2 || q.bin( 0.60 ) == 3 );
    BOOST_CHECK( q.bin( 0.80 ) == 3 || q.bin( 0.80 ) == 4 );
}

BOOST_AUTO_TEST_SUITE_END ();
