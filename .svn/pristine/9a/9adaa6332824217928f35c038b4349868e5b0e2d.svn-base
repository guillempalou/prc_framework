// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------

//! 
//! \file coocurrence_matrix.test
//!
//! Tests for coocurrence matrix 
//!
#include <imageplus/core.hpp>
#include <imageplus/math/statistics/coocurrence_matrix.hpp> 

BOOST_AUTO_TEST_SUITE ( CoocurrenceMatrix_Suite );

using namespace imageplus;
using namespace math::statistics;


BOOST_AUTO_TEST_CASE( ChannelCoocurrenceMatrix_test)
{    
    ImagePartition<> my_im_part(3,3);
    my_im_part[0][0] = 1;   my_im_part[1][0] = 1;   my_im_part[2][0] = 2;
    my_im_part[0][1] = 1;   my_im_part[1][1] = 2;   my_im_part[2][1] = 2;
    my_im_part[0][2] = 1;   my_im_part[1][2] = 2;   my_im_part[2][2] = 2;
    
    
    ImageRGB<uint8> my_image(3,3);
    my_image(RED_CHANNEL)[0][0] = 0;     my_image(RED_CHANNEL)[1][0] = 0;    my_image(RED_CHANNEL)[2][0] = 0;
    my_image(RED_CHANNEL)[0][1] = 0;     my_image(RED_CHANNEL)[1][1] = 0;    my_image(RED_CHANNEL)[2][1] = 0;
    my_image(RED_CHANNEL)[0][2] = 0;     my_image(RED_CHANNEL)[1][2] = 0;    my_image(RED_CHANNEL)[2][2] = 0;
        
    my_image(GREEN_CHANNEL)[0][0] = 0;   my_image(GREEN_CHANNEL)[1][0] = 1;  my_image(GREEN_CHANNEL)[2][0] = 2;
    my_image(GREEN_CHANNEL)[0][1] = 0;   my_image(GREEN_CHANNEL)[1][1] = 1;  my_image(GREEN_CHANNEL)[2][1] = 2;
    my_image(GREEN_CHANNEL)[0][2] = 0;   my_image(GREEN_CHANNEL)[1][2] = 1;  my_image(GREEN_CHANNEL)[2][2] = 2;

    my_image(BLUE_CHANNEL)[0][0] = 1;    my_image(BLUE_CHANNEL)[1][0] = 2;   my_image(BLUE_CHANNEL)[2][0] = 0;
    my_image(BLUE_CHANNEL)[0][1] = 2;    my_image(BLUE_CHANNEL)[1][1] = 0;   my_image(BLUE_CHANNEL)[2][1] = 1;
    my_image(BLUE_CHANNEL)[0][2] = 1;    my_image(BLUE_CHANNEL)[1][2] = 2;   my_image(BLUE_CHANNEL)[2][2] = 0;

    
    typedef ImageRGB<uint8> InputType;
    typedef RegionContour<Coord2D<int64> > RegionType;
    typedef Partition<RegionType> partition_type;
    partition_type my_part(my_im_part);
    
    merge_regions(1, 2, 3, my_part);

    // Check Region 1
    const ChannelCoocurrenceMatrix<InputType>& desc1 = calc_descriptor(new ChannelCoocurrenceMatrix<InputType>(0,2,3), my_image, my_part[1]);
    
    MultiArray<uint64,2> matrix_ok(3,3);
    matrix_ok[0][0] = 10;  matrix_ok[1][0] = 0;   matrix_ok[2][0] = 0;
    matrix_ok[0][1] = 0;   matrix_ok[1][1] = 0;   matrix_ok[2][1] = 0;
    matrix_ok[0][2] = 0;   matrix_ok[1][2] = 0;   matrix_ok[2][2] = 0;
    BOOST_CHECK(desc1.at(RED_CHANNEL)==matrix_ok);
    
    matrix_ok[0][0] = 4;   matrix_ok[1][0] = 1;   matrix_ok[2][0] = 0;
    matrix_ok[0][1] = 3;   matrix_ok[1][1] = 1;   matrix_ok[2][1] = 0;
    matrix_ok[0][2] = 0;   matrix_ok[1][2] = 1;   matrix_ok[2][2] = 0;
    BOOST_CHECK(desc1.at(GREEN_CHANNEL)==matrix_ok);

    matrix_ok[0][0] = 0;   matrix_ok[1][0] = 0;   matrix_ok[2][0] = 3;
    matrix_ok[0][1] = 0;   matrix_ok[1][1] = 0;   matrix_ok[2][1] = 3;
    matrix_ok[0][2] = 0;   matrix_ok[1][2] = 4;   matrix_ok[2][2] = 0;
    BOOST_CHECK(desc1.at(BLUE_CHANNEL)==matrix_ok);

    
    // Check Region 2
    const ChannelCoocurrenceMatrix<InputType>& desc2 = calc_descriptor(new ChannelCoocurrenceMatrix<InputType>(0,2,3), my_image, my_part[2]);
    
    matrix_ok[0][0] = 14;  matrix_ok[1][0] = 0;   matrix_ok[2][0] = 0;
    matrix_ok[0][1] = 0;   matrix_ok[1][1] = 0;   matrix_ok[2][1] = 0;
    matrix_ok[0][2] = 0;   matrix_ok[1][2] = 0;   matrix_ok[2][2] = 0;
    BOOST_CHECK(desc2.at(RED_CHANNEL)==matrix_ok);
    
    matrix_ok[0][0] = 0;   matrix_ok[1][0] = 2;   matrix_ok[2][0] = 0;
    matrix_ok[0][1] = 0;   matrix_ok[1][1] = 3;   matrix_ok[2][1] = 3;
    matrix_ok[0][2] = 0;   matrix_ok[1][2] = 2;   matrix_ok[2][2] = 4;
    BOOST_CHECK(desc2.at(GREEN_CHANNEL)==matrix_ok);

    matrix_ok[0][0] = 0;   matrix_ok[1][0] = 3;   matrix_ok[2][0] = 2;
    matrix_ok[0][1] = 3;   matrix_ok[1][1] = 0;   matrix_ok[2][1] = 1;
    matrix_ok[0][2] = 5;   matrix_ok[1][2] = 0;   matrix_ok[2][2] = 0;
    BOOST_CHECK(desc2.at(BLUE_CHANNEL)==matrix_ok);
    
    
    // Check Region 3 (recursive)
    const ChannelCoocurrenceMatrix<InputType>& desc3 = calc_descriptor(new ChannelCoocurrenceMatrix<InputType>(0,2,3), my_image, my_part[3]);
    
    matrix_ok[0][0] = 24;  matrix_ok[1][0] = 0;   matrix_ok[2][0] = 0;
    matrix_ok[0][1] = 0;   matrix_ok[1][1] = 0;   matrix_ok[2][1] = 0;
    matrix_ok[0][2] = 0;   matrix_ok[1][2] = 0;   matrix_ok[2][2] = 0;
    BOOST_CHECK(desc3.at(RED_CHANNEL)==matrix_ok);
    
    matrix_ok[0][0] = 4;   matrix_ok[1][0] = 3;   matrix_ok[2][0] = 0;
    matrix_ok[0][1] = 3;   matrix_ok[1][1] = 4;   matrix_ok[2][1] = 3;
    matrix_ok[0][2] = 0;   matrix_ok[1][2] = 3;   matrix_ok[2][2] = 4;
    BOOST_CHECK(desc3.at(GREEN_CHANNEL)==matrix_ok);

    matrix_ok[0][0] = 0;   matrix_ok[1][0] = 3;   matrix_ok[2][0] = 5;
    matrix_ok[0][1] = 3;   matrix_ok[1][1] = 0;   matrix_ok[2][1] = 4;
    matrix_ok[0][2] = 5;   matrix_ok[1][2] = 4;   matrix_ok[2][2] = 0;
    BOOST_CHECK(desc3.at(BLUE_CHANNEL)==matrix_ok);
}



BOOST_AUTO_TEST_CASE( NormChannelCoocurrenceMatrix_test)
{    
    ImagePartition<> my_im_part(3,3);
    my_im_part[0][0] = 1;   my_im_part[1][0] = 1;   my_im_part[2][0] = 2;
    my_im_part[0][1] = 1;   my_im_part[1][1] = 2;   my_im_part[2][1] = 2;
    my_im_part[0][2] = 1;   my_im_part[1][2] = 2;   my_im_part[2][2] = 2;
    
    
    ImageRGB<uint8> my_image(3,3);
    my_image(RED_CHANNEL)[0][0] = 0;     my_image(RED_CHANNEL)[1][0] = 0;    my_image(RED_CHANNEL)[2][0] = 0;
    my_image(RED_CHANNEL)[0][1] = 0;     my_image(RED_CHANNEL)[1][1] = 0;    my_image(RED_CHANNEL)[2][1] = 0;
    my_image(RED_CHANNEL)[0][2] = 0;     my_image(RED_CHANNEL)[1][2] = 0;    my_image(RED_CHANNEL)[2][2] = 0;
        
    my_image(GREEN_CHANNEL)[0][0] = 0;   my_image(GREEN_CHANNEL)[1][0] = 1;  my_image(GREEN_CHANNEL)[2][0] = 2;
    my_image(GREEN_CHANNEL)[0][1] = 0;   my_image(GREEN_CHANNEL)[1][1] = 1;  my_image(GREEN_CHANNEL)[2][1] = 2;
    my_image(GREEN_CHANNEL)[0][2] = 0;   my_image(GREEN_CHANNEL)[1][2] = 1;  my_image(GREEN_CHANNEL)[2][2] = 2;

    my_image(BLUE_CHANNEL)[0][0] = 1;    my_image(BLUE_CHANNEL)[1][0] = 2;   my_image(BLUE_CHANNEL)[2][0] = 0;
    my_image(BLUE_CHANNEL)[0][1] = 2;    my_image(BLUE_CHANNEL)[1][1] = 0;   my_image(BLUE_CHANNEL)[2][1] = 1;
    my_image(BLUE_CHANNEL)[0][2] = 1;    my_image(BLUE_CHANNEL)[1][2] = 2;   my_image(BLUE_CHANNEL)[2][2] = 0;

    
    typedef ImageRGB<uint8> InputType;
    typedef RegionContour<Coord2D<int64> > RegionType;
    typedef Partition<RegionType> partition_type;
    partition_type my_part(my_im_part);
    
    merge_regions(1, 2, 3, my_part);

    // Check Region 1
    const NormChannelCoocurrenceMatrix<InputType>& desc1 = calc_descriptor(new NormChannelCoocurrenceMatrix<InputType>(0,2,3), my_image, my_part[1]);
    
    MultiArray<float64,2> matrix_ok(3,3);
    matrix_ok[0][0] = 1;   matrix_ok[1][0] = 0;   matrix_ok[2][0] = 0;
    matrix_ok[0][1] = 0;   matrix_ok[1][1] = 0;   matrix_ok[2][1] = 0;
    matrix_ok[0][2] = 0;   matrix_ok[1][2] = 0;   matrix_ok[2][2] = 0;
    BOOST_CHECK(desc1.at(RED_CHANNEL)==matrix_ok);
    BOOST_CHECK(desc1.hist_sum()[RED_CHANNEL]==10);
    
    matrix_ok[0][0] = 0.4;   matrix_ok[1][0] = 0.1;   matrix_ok[2][0] = 0;
    matrix_ok[0][1] = 0.3;   matrix_ok[1][1] = 0.1;   matrix_ok[2][1] = 0;
    matrix_ok[0][2] = 0  ;   matrix_ok[1][2] = 0.1;   matrix_ok[2][2] = 0;
    BOOST_CHECK(desc1.at(GREEN_CHANNEL)==matrix_ok);
    BOOST_CHECK(desc1.hist_sum()[GREEN_CHANNEL]==10);

    matrix_ok[0][0] = 0;   matrix_ok[1][0] = 0  ;   matrix_ok[2][0] = 0.3;
    matrix_ok[0][1] = 0;   matrix_ok[1][1] = 0  ;   matrix_ok[2][1] = 0.3;
    matrix_ok[0][2] = 0;   matrix_ok[1][2] = 0.4;   matrix_ok[2][2] = 0  ;
    BOOST_CHECK(desc1.at(BLUE_CHANNEL)==matrix_ok);
    BOOST_CHECK(desc1.hist_sum()[BLUE_CHANNEL]==10);

    
    // Check Region 2
    const NormChannelCoocurrenceMatrix<InputType>& desc2 = calc_descriptor(new NormChannelCoocurrenceMatrix<InputType>(0,2,3), my_image, my_part[2]);
    
    BOOST_CHECK_CLOSE(desc2.at(RED_CHANNEL)[0][0], 1., 1e-10);
    BOOST_CHECK_CLOSE(desc2.at(RED_CHANNEL)[0][1], 0., 1e-10);
    BOOST_CHECK_CLOSE(desc2.at(RED_CHANNEL)[0][2], 0., 1e-10);
    BOOST_CHECK_CLOSE(desc2.at(RED_CHANNEL)[1][0], 0., 1e-10);
    BOOST_CHECK_CLOSE(desc2.at(RED_CHANNEL)[1][1], 0., 1e-10);
    BOOST_CHECK_CLOSE(desc2.at(RED_CHANNEL)[1][2], 0., 1e-10);
    BOOST_CHECK_CLOSE(desc2.at(RED_CHANNEL)[2][0], 0., 1e-10);
    BOOST_CHECK_CLOSE(desc2.at(RED_CHANNEL)[2][1], 0., 1e-10);
    BOOST_CHECK_CLOSE(desc2.at(RED_CHANNEL)[2][2], 0., 1e-10);
    BOOST_CHECK(desc2.hist_sum()[RED_CHANNEL]==14);
    
    BOOST_CHECK_CLOSE(desc2.at(GREEN_CHANNEL)[0][0], 0.    , 1e-10);
    BOOST_CHECK_CLOSE(desc2.at(GREEN_CHANNEL)[0][1], 0.    , 1e-10);
    BOOST_CHECK_CLOSE(desc2.at(GREEN_CHANNEL)[0][2], 0.    , 1e-10);
    BOOST_CHECK_CLOSE(desc2.at(GREEN_CHANNEL)[1][0], 2./14., 1e-10);
    BOOST_CHECK_CLOSE(desc2.at(GREEN_CHANNEL)[1][1], 3./14., 1e-10);
    BOOST_CHECK_CLOSE(desc2.at(GREEN_CHANNEL)[1][2], 2./14., 1e-10);
    BOOST_CHECK_CLOSE(desc2.at(GREEN_CHANNEL)[2][0], 0.    , 1e-10);
    BOOST_CHECK_CLOSE(desc2.at(GREEN_CHANNEL)[2][1], 3./14., 1e-10);
    BOOST_CHECK_CLOSE(desc2.at(GREEN_CHANNEL)[2][2], 4./14., 1e-10);
    BOOST_CHECK(desc2.hist_sum()[GREEN_CHANNEL]==14);

    BOOST_CHECK_CLOSE(desc2.at(BLUE_CHANNEL)[0][0], 0.    , 1e-10);
    BOOST_CHECK_CLOSE(desc2.at(BLUE_CHANNEL)[0][1], 3./14., 1e-10);
    BOOST_CHECK_CLOSE(desc2.at(BLUE_CHANNEL)[0][2], 5./14., 1e-10);
    BOOST_CHECK_CLOSE(desc2.at(BLUE_CHANNEL)[1][0], 3./14., 1e-10);
    BOOST_CHECK_CLOSE(desc2.at(BLUE_CHANNEL)[1][1], 0.    , 1e-10);
    BOOST_CHECK_CLOSE(desc2.at(BLUE_CHANNEL)[1][2], 0.    , 1e-10);
    BOOST_CHECK_CLOSE(desc2.at(BLUE_CHANNEL)[2][0], 2./14., 1e-10);
    BOOST_CHECK_CLOSE(desc2.at(BLUE_CHANNEL)[2][1], 1./14., 1e-10);
    BOOST_CHECK_CLOSE(desc2.at(BLUE_CHANNEL)[2][2], 0.    , 1e-10);
    BOOST_CHECK(desc2.hist_sum()[BLUE_CHANNEL]==14);
    
    
    // Check Region 3 (recursive)
    const NormChannelCoocurrenceMatrix<InputType>& desc3 = calc_descriptor(new NormChannelCoocurrenceMatrix<InputType>(0,2,3), my_image, my_part[3]);
    
    BOOST_CHECK_CLOSE(desc3.at(RED_CHANNEL)[0][0], 1., 1e-10);
    BOOST_CHECK_CLOSE(desc3.at(RED_CHANNEL)[0][1], 0., 1e-10);
    BOOST_CHECK_CLOSE(desc3.at(RED_CHANNEL)[0][2], 0., 1e-10);
    BOOST_CHECK_CLOSE(desc3.at(RED_CHANNEL)[1][0], 0., 1e-10);
    BOOST_CHECK_CLOSE(desc3.at(RED_CHANNEL)[1][1], 0., 1e-10);
    BOOST_CHECK_CLOSE(desc3.at(RED_CHANNEL)[1][2], 0., 1e-10);
    BOOST_CHECK_CLOSE(desc3.at(RED_CHANNEL)[2][0], 0., 1e-10);
    BOOST_CHECK_CLOSE(desc3.at(RED_CHANNEL)[2][1], 0., 1e-10);
    BOOST_CHECK_CLOSE(desc3.at(RED_CHANNEL)[2][2], 0., 1e-10);
    BOOST_CHECK_EQUAL(desc3.hist_sum()[RED_CHANNEL],(std::size_t)24);
    
    BOOST_CHECK_CLOSE(desc3.at(GREEN_CHANNEL)[0][0], 4./24., 1e-10);
    BOOST_CHECK_CLOSE(desc3.at(GREEN_CHANNEL)[0][1], 3./24., 1e-10);
    BOOST_CHECK_CLOSE(desc3.at(GREEN_CHANNEL)[0][2], 0./24., 1e-10);
    BOOST_CHECK_CLOSE(desc3.at(GREEN_CHANNEL)[1][0], 3./24., 1e-10);
    BOOST_CHECK_CLOSE(desc3.at(GREEN_CHANNEL)[1][1], 4./24., 1e-10);
    BOOST_CHECK_CLOSE(desc3.at(GREEN_CHANNEL)[1][2], 3./24., 1e-10);
    BOOST_CHECK_CLOSE(desc3.at(GREEN_CHANNEL)[2][0], 0./24., 1e-10);
    BOOST_CHECK_CLOSE(desc3.at(GREEN_CHANNEL)[2][1], 3./24., 1e-10);
    BOOST_CHECK_CLOSE(desc3.at(GREEN_CHANNEL)[2][2], 4./24., 1e-10);
    BOOST_CHECK_EQUAL(desc3.hist_sum()[GREEN_CHANNEL],(std::size_t)24);

    BOOST_CHECK_CLOSE(desc3.at(BLUE_CHANNEL)[0][0], 0./24., 1e-10);
    BOOST_CHECK_CLOSE(desc3.at(BLUE_CHANNEL)[0][1], 3./24., 1e-10);
    BOOST_CHECK_CLOSE(desc3.at(BLUE_CHANNEL)[0][2], 5./24., 1e-10);
    BOOST_CHECK_CLOSE(desc3.at(BLUE_CHANNEL)[1][0], 3./24., 1e-10);
    BOOST_CHECK_CLOSE(desc3.at(BLUE_CHANNEL)[1][1], 0./24., 1e-10);
    BOOST_CHECK_CLOSE(desc3.at(BLUE_CHANNEL)[1][2], 4./24., 1e-10);
    BOOST_CHECK_CLOSE(desc3.at(BLUE_CHANNEL)[2][0], 5./24., 1e-10);
    BOOST_CHECK_CLOSE(desc3.at(BLUE_CHANNEL)[2][1], 4./24., 1e-10);
    BOOST_CHECK_CLOSE(desc3.at(BLUE_CHANNEL)[2][2], 0./24., 1e-10);
    BOOST_CHECK_EQUAL(desc3.hist_sum()[BLUE_CHANNEL],(std::size_t)24);

}



BOOST_AUTO_TEST_SUITE_END ();



