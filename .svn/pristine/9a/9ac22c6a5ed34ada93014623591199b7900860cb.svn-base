// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------

//!
//!  \file model.hpp
//!
//!  Model
//!


#ifndef IMAGEPLUS_SEMANTIC_MODEL_HPP
#define IMAGEPLUS_SEMANTIC_MODEL_HPP

#include <list>
#include <string>

#include <boost/foreach.hpp>

#include <imageplus/core.hpp>
#include <imageplus/semantic/modelpart.hpp>

namespace imageplus {
	namespace semantic {

		//!
		//! \brief Classifier model of a semantic class.
		//!
		//! This class is used to represent a classifier model of a semantic
		//! class. It contains a set of model parts, which are instances of
		//! ModelPart and contain the classifiers for each visual descriptor
		//! of the part.
		//!
		//! Instances of this class are obtained from a Models instance using
		//! the Models::get_model(semantic_class_id) method. Instantiating
		//! this class directly is not recommended.
		//!
		//! Instances of this class are iterable, the iterator will iterate
		//! through all model parts included in the instance.
		//!
		//! Example: print all model parts (using the SVM classifier)
		//! \code
		//! Model<SVM> model;
		//! BOOST_FOREACH(ModelPart<SVM> mp, model)
		//! 	std::cout << mp << std::endl;
		//! \endcode
		//!
		//!	In order to load an instance from a file and save it back again
		//! see the ReadWriteModel class.
		//!
		//! \author Pau Haro Negre
		//!
		//! \date 10-6-2011
		//!
		template<class Classifier>
		class Model
		{
		public:

			friend class ReadWriteModel;
			friend class ReadWriteModels;

			//! Type of the model parts of this model instance container
			typedef std::list<ModelPart<Classifier> > ModelPartsType;

            //! Default constructor
			Model() {}

            //! Constructor receiving a semantic class id.
            //!
            //! \param[in] semantic_class Id of the semantic class
            explicit Model(uint32 semantic_class)
            	: _semantic_class(semantic_class) {}

            //! Destructor
            ~Model() {}


            //! Add a new part to the model.
            //!
            //! \param[in] part %Model part to add
            void add_part(const ModelPart<Classifier>& part)
            {
            	_model_parts.push_back(part);
            }

            //! Get all parts of this model.
            //!
            //! \return Container of parts of this model
            const ModelPartsType& get_parts() const
            {
            	return _model_parts;
            }


			//! Set model file URI.
			//!
			//! \param[in] file_uri file URI or file name
			void set_file_uri(const std::string& file_uri)
			{
				if (file_uri.find("file:") == 0)
					// file_uri = "file:/path/to/file.xml"
					_file_uri = file_uri;
				else
					// file_uri = "/path/to/file.xml"
					_file_uri = "file:"+file_uri;
			}

			//! Get model file URI (e.g.: "file:/path/to/file.xml").
			//!
			//! \return Model file URI
			std::string get_file_uri() const
			{
				return _file_uri;
			}


    		//! Output a representation of the given Model to an ostream.
            //!
            //! \param[in,out] os Output stream where the representation will be appended
            //! \param[in]     m  %Instance of Model class to write to the stream
    		//!
    		//! \return Description of the Model is appended to the given ostream.
    		friend std::ostream& operator<<(std::ostream &os, const Model& m)
    		{
    			os << "Model of 'semantic class " << m._semantic_class << "' parts:" << std::endl;

    			BOOST_FOREACH(ModelPart<Classifier> part, m._model_parts)
    				os << "- " << part << std::endl;

    			return os;
    		}


		private:
			//! Semantic class
			uint32 _semantic_class;

			//! Container of model parts
			ModelPartsType _model_parts;

			//! %Model file URI
			std::string _file_uri;
			
		};
	}
}

#endif //IMAGEPLUS_SEMANTIC_MODEL_HPP
