// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------


/*!
 *
 * \file capture_oni.cpp
 *
 * \author Albert Gil
 */

#ifdef USE_OPENNI


#define IMAGEPLUS_CLIENT_CONFIG_NAME  capture_oni

#include <imageplus/toolbox/client_config.hpp>

#include <imageplus/io/capture_kinect.hpp>
#include <imageplus/core/timestamp.hpp>

//
// Used namespaces
//
using namespace imageplus;
using namespace imageplus::io;
using namespace std;


IMAGEPLUS_CLIENT_CONFIG_BRIEF()

    "This client captures images and depth maps from a Kinect camera and send them to a flow\n";

IMAGEPLUS_CLIENT_CONFIG_DESCRIPTION()

    "This client captures images and depth maps from a Kinect camera and send them to a flow.    \n" +
    "                                                                      \n" +
    "I uses OpenNI for the data and for the timestamps.                    \n";

IMAGEPLUS_CLIENT_CONFIG_PARAMETERS()

    // options
    uint16       use_every_N_frames;
    std::string  calibration_file;
    std::size_t  width;
    std::size_t  height;

    std::string  onifile;

	// flags

    // arguments

    // flows
    VideoOutputFlow video;
    VideoOutputFlow depth;
    VideoOutputFlow point;

IMAGEPLUS_CLIENT_CONFIG_DEFAULT_VALUES()

    //
    // Here you should assign default values to your parameters
    //
    use_every_N_frames = 1;
    calibration_file   = "";
    width              = XN_VGA_X_RES;
    height             = XN_VGA_Y_RES;
    onifile            = "";

IMAGEPLUS_CLIENT_CONFIG_OPTIONS()

    //
    // Here you have to define your OPTIONS, with a description
    // and an optional abreviature
    //
    CLIENT_CONFIG_OPTION_ABV( use_every_N_frames , "to discard N frames"    , 'N' );
	CLIENT_CONFIG_OPTION_ABV( calibration_file   , "the calibration file for the kinect camera (for multiview proposes)"    , 'c' );
	CLIENT_CONFIG_OPTION_ABV( width              , "the video and depth width (XN_VGA_X_RES)"    , 'w' );
	CLIENT_CONFIG_OPTION_ABV( height             , "the video and depth height (XN_VGA_Y_RES)"    , 'h' );
	CLIENT_CONFIG_OPTION_ABV( onifile            , "the .oni filename to be read instead of capturing live data from the camera"    , 'f' );

IMAGEPLUS_CLIENT_CONFIG_FLAGS()

    //
    // Here you have to define your FLAGS, with a description
    // and an optional abreviature
    //

IMAGEPLUS_CLIENT_CONFIG_ARGUMENTS()

    //
    // Here you have to define your ARGUMENTS with a description.
    // You should put them in the DESIRED ORDER in the command-line
    //
    // Note that an argument that is a vector should be the last and no more
    // argument can be added later. Think: is impossible to parser arguments
    // afters an unknown size vector!
    // If you need more than one vector, use "options" instead of arguments.
    //

IMAGEPLUS_CLIENT_CONFIG_FLOWS()

    //
    // Here you have to define your FLOWS
    //
    CLIENT_CONFIG_VIDEO_OUT( video );
    CLIENT_CONFIG_VIDEO_OUT( depth );
    CLIENT_CONFIG_VIDEO_OUT( point );

IMAGEPLUS_CLIENT_CONFIG_READ_PARAMETERS()

    //
    // Here you have to read all your parameters
    //
    // DO NOT FORGET THIS STEP!!
    //
    IMAGEPLUS_CLIENT_CONFIG_READ( use_every_N_frames );
    IMAGEPLUS_CLIENT_CONFIG_READ( calibration_file   );
    IMAGEPLUS_CLIENT_CONFIG_READ( width              );
    IMAGEPLUS_CLIENT_CONFIG_READ( height             );
    IMAGEPLUS_CLIENT_CONFIG_READ( onifile            );

IMAGEPLUS_CLIENT_CONFIG_METADATAS()

    //
    // Here you can get the metadatas from the input flows
    // And you MUST set the metadata of your output flows
    //
    // Note that from now on you can access to the previously
    // defined config parameters with the "cfg" object.
    //

    VideoMetadata video_metadata;
	VideoMetadata depth_metadata;
	VideoMetadata point_metadata;


    // Define output metadata flow as RGB
    video_metadata.imageFormat = SFC::VideoMetadata::packedRGB;
    video_metadata.dataType    = SFC::VideoMetadata::type_8u;
    video_metadata.frameRate   = 25/cfg.use_every_N_frames;
    video_metadata.width       = cfg.width;
    video_metadata.height      = cfg.height;
    strncpy(video_metadata.calibrationFile, cfg.calibration_file.c_str(), 255 );

    depth_metadata.imageFormat = SFC::VideoMetadata::singleChannel;
    depth_metadata.dataType    = SFC::VideoMetadata::type_16s;
    depth_metadata.frameRate   = 25/cfg.use_every_N_frames;
    depth_metadata.width       = cfg.width;
    depth_metadata.height      = cfg.height;
    strncpy(video_metadata.calibrationFile, cfg.calibration_file.c_str(), 255 );

    point_metadata.imageFormat = SFC::VideoMetadata::packedRGB;
    point_metadata.dataType    = SFC::VideoMetadata::type_32f;
    point_metadata.frameRate   = 25/cfg.use_every_N_frames;
    point_metadata.width       = cfg.width;
    point_metadata.height      = cfg.height;
    strncpy(video_metadata.calibrationFile, cfg.calibration_file.c_str(), 255 );


    cfg.video->setMetadata( video_metadata );
    cfg.depth->setMetadata( depth_metadata );
    cfg.point->setMetadata( point_metadata );

//
// This is the "main" function of your client.
//
// You can access to all your parameters (options, flags, and arguments)
// with the "cfg" object (see the code.)
//
// Run the client with "--help" to see your configuration.
//
IMAGEPLUS_CLIENT_CONFIG_MAIN()
{
    //
    // Here you can declare and initialize the variables that
    // will be used in the main loop
    //
	std::size_t           frame_counter = 1;
    CaptureKinect         cap (cfg.onifile );
    CaptureKinect::Frame  frame;
    MultiArray<float32,3> point(cfg.width,cfg.height,3);

    std::size_t     frame_number = 0;

    std::size_t     bsize_video = cfg.width*cfg.height*3*sizeof(uint8);
    std::size_t     bsize_depth = cfg.width*cfg.height*1*sizeof(uint16);

    //
    // Also you should define pointers to the flow buffer
    //
    uint8*   buffer_video;
    int16*   buffer_depth;
    float32* buffer_point;

    //
    // Start capturing
    //
    cap.start();

    //
    // This is the main loop of you client.
    // You can think on it as a "while(running)" loop.
    // It ends only when the SmartFlow server send the "kill" signal
    // or if you execute "running=false"
    //
    CLIENT_CONFIG_WHILE_RUNNING()
    {
        try
        {
            cap >> frame;
        }
        catch( ImagePlusError& e )
        {
            std::cout << "Error capturing frame: " << frame_number << "\n";
            std::cout << e.what() << std::endl;
        }

        //
        // Get output buffer from the flow:
        //
        if( frame_counter == cfg.use_every_N_frames )
        {
	        cfg.video->get_buffer(buffer_video);
	        cfg.depth->get_buffer(buffer_depth);
	        cfg.point->get_buffer(buffer_point);

	        //
	        // Fills up the output buffer
	        //
	        //rgb.export_to(buffer_video, cfg.width, cfg.height, RGB);
	        export_to(frame.image,           buffer_video,  bsize_video, RGB);
	        export_to(frame.depth, (uint16*)(buffer_depth), bsize_depth, GRAY);

	        //point = frame_number;
	        //point = frame.point;
	        //float32* ppoint = point.data();
	        float64* ppoint = frame.point.data();
	        for(std::size_t ii=0; ii < point.num_elements(); ++ii)
	        {
	            *buffer_point++ =  *ppoint++;
	        }

	        //
	        // Send and release the output buffer
	        //
	        send_buffer(cfg.video, frame.ts_image);
	        send_buffer(cfg.depth, frame.ts_depth);
	        send_buffer(cfg.point, frame.ts_depth);

	        // Increment the frame buffer
	        frame_number++;
	        frame_counter = 1;

        }
        else
        {
        	frame_counter++;
        }
    }

    // End client
    cap.stop();
    return (0);
}


//
// This last line is mandatory!
//
IMAGEPLUS_CLIENT_CONFIG_END()


#else

#include <iostream>

int main(int argc, char* argv[])
{
    std::cout << "Please, to run this client you should build it with the flag USE_OPENNI." << std::endl;
}

#endif // USE_OPENNI
