// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------

//!
//!  \file morphological_gradient.hpp
//!
//!  Interface for computing morpological gradients on MultiArray and ImageGray objects
//!

#ifndef IMAGEPLUS_MORPHOLOGY_MORPHOLOGICAL_GRADIENT_HPP
#define IMAGEPLUS_MORPHOLOGY_MORPHOLOGICAL_GRADIENT_HPP

#include <imageplus/core.hpp>
#include <imageplus/math/morphology/erosion.hpp>
#include <imageplus/math/morphology/dilation.hpp>


namespace imageplus
{
    namespace math
    {
        namespace morphology
        {
            //!
            //!  \brief Type of morphological gradient. Available values are DIL_ERO (dilation - erosion), DIL_ORI (dil - original image), ORI_ERO (original image - erosion)
            //!
            enum MGradType
            {
                DIL_ERO,
                DIL_ORI,
                ORI_ERO
            };

            //!
            //! \brief MorphologicalGradient filter
            //!
            //! Computes the morphological gradient of an image. Three modes are defined:  DIL_ERO (dilation - erosion), DIL_ORI (dil - original image), ORI_ERO (original image - erosion)
            //!
            //! \attention
            //! Note that this filter is only instantiated for signed integer types because the gradient may have negative values.
            //!
            //! \attention
            //! The actual implementation of the operation is in method implementation(). Althoug this method is public
            //! it should never be called directly. Method filter(), inherited from base class Filter should always be called,
            //! with the object to be filtered as a parameter
            //!
            //! \code
            //!    ImageGray<uint8> g1(100,100), g2(100,100);
            //!    ...
            //!    MorphologicalGradient<2> mg(4,3); // Connectivity 4 (cross) and 3x3 kernel
            //!    g2 = mg.filter(g1);
            //! \endcode
            //!
            //! \sa StructuringElement
            //!
            //! \author Josep Ramon Morros <ramon.morros@upc.edu>
            //!
            //! \date 10-Nov-2008
            //!
            template <std::size_t N>
            class MorphologicalGradient : public Filter< MorphologicalGradient<N> >
            {
                public:

                    //!
                    //! \brief Default constructor
                    //!
                    //! Morphological gradient using a simple, squared 3x3, 8 connectivity structuring element: all sides are equal and have an 
                    //! odd size. The origin is at the center of the SE. These SE are the most frequently used.
                    //! In 2D there are two possible shapes for simple SE : a cross (4 connectivity) or a filled square (8 connectivity)
                    //!
                    MorphologicalGradient( );


                    //!
                    //! \brief Constructor
                    //!
                    //! Morphological gradient using a simple structuring element. Simple se are a special case: all sides are equal and have an 
                    //! odd size. The origin is at the center of the SE. These SE are the most frequently used.
                    //! In 2D there are two possible shapes for simple SE : a cross (4 connectivity) or a filled square (8 connectivity)
                    //! When possible, use this constructor because the implementation is faster
                    //!
                    //! \param[in] connectivity : Connectivity (4, 8, 6, 18, 26)
                    //! \param[in] size         : Size of the kernel. The default is 3, for a 3x3 (2D) or 3x3x3 (3D) kernel
                    //! \param[in] method       : 
                    //!

                    MorphologicalGradient (uint64 connectivity, uint64 size=3, MGradType method=DIL_ERO) throw (ImagePlusError);


                    //!
                    //! \brief Constructor
                    //!
                    //! Morphological gradient using an arbitrary shape Structuring Element. This is the general case. Any shape is allowed,
                    //! sides can be of different sizes, even or odd, and the origin can be situated in any place in the SE.
                    //! Operations for arbitrary SE generally are less efficient.
                    //!
                    //! \param[in] se: Structuring element
                    //! \param[in] method       : 
                    //!
                    MorphologicalGradient (const StructuringElement<N>& se, MGradType method=DIL_ERO) throw (ImagePlusError);


                    //!
                    //! \brief Overloading of method implementation() for a MultiArray object
                    //!
                    //! WARNING!: Never use this method. Use filter() instead.
                    //!
                    //! \param[in] m: MultiArray object to be filtered
                    //!
                    //! \return Filtered object
                    //!
                    template<typename T, std::size_t D>
                    MultiArray<T,D> implementation(const MultiArray<T,D>& m) const throw (ImagePlusError, ImagePlusNotImplemented);

                    //!
                    //! \brief Overloading of method implementation() for an Image object
                    //!
                    //! WARNING!: Never use this method. Use filter() instead.
                    //!
                    //! \param[in] m: Image object to be filtered
                    //!
                    //! \return Filtered object
                    //!
                    template<typename T, std::size_t CHANNELS>
                    Image<T,CHANNELS> implementation(const Image<T,CHANNELS>& m) const throw (ImagePlusError);


                    //!
                    //! \brief Overloading of method implementation() for an Volume object
                    //!
                    //! WARNING!: Never use this method. Use filter() instead.
                    //!
                    //! \param[in] vol : Volume object to be filtered
                    //!
                    //! \return Filtered object
                    //!
                    template<typename T, std::size_t CHANNELS>
                    Volume<T,CHANNELS> implementation(const Volume<T,CHANNELS>& vol) const throw (ImagePlusError);

                private:

                    //! Structuring Element
                    StructuringElement<N> _se;

                    //! Type of gradient
                    MGradType _type;

            };
        } /// namespace morphology
        
    }

} /// namespace imageplus

#endif // IMAGEPLUS_MORPHOLOGY_MORPHOLOGICAL_GRADIENT_HPP
