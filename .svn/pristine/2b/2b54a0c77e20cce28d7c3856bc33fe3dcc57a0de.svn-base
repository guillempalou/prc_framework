// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------

//!
//! \file coord.cpp
//!
//! \author Eduardo Mendon√ßa <eduardo@gps.tsc.upc.edu>
//!
//! Implementation of auxiliar math functions or procedures for BBox class
//!

#include <imageplus/math/geometry/bbox_math.hpp>
#include <imageplus/math/statistics/multiarray_statistics.hpp>

// for uint64 std::abs(int64)
#include <imageplus/math.hpp>

using namespace imageplus;

#if 0 // AGIL: moved to hpp
template <typename T, std::size_t D>
void imageplus::math::geometry::limit_bbox_to_bbox(const BBox<T,D>& ref_bb, BBox<T,D>& bb) {

    ASSERT(bb.dimension() == ref_bb.dimension(), "dimensions of bounding boxs must match");

    for (size_type i = 0; i != bb.dimension(); ++i) 
    {
        int64 opp = bb.origin()[i] + (int64)bb.side(i);

        if (bb.origin()[i] < ref_bb.origin()[i])
        {
            bb.origin()[i] = ref_bb.origin()[i];
        }
        if (opp > (ref_bb.origin()[i]+(int64)ref_bb.side(i)))
	    {
            opp = ref_bb.origin()[i]+(int64)ref_bb.side(i);
        }
        
        bb.side(i) = std::abs(opp-bb.origin()[i]); 
    }
    
}
#endif

template <typename T, std::size_t D>
void imageplus::math::geometry::limit_point_to_bbox(const BBox<T,D>& ref_bb, Coord<T,D>& point) {

    ASSERT(point.dims() == ref_bb.dimension(), "dimensions of bounding boxs must match");

    for (size_type i = 0; i != point.dims(); ++i) 
    {

        if (point[i] < ref_bb.origin()[i])
        {
            point[i] = ref_bb.origin()[i];
        }

        if (point[i] > ref_bb.origin()[i]+(int64)ref_bb.side(i)) 
        {
            point[i] = ref_bb.origin()[i]+(int64)ref_bb.side(i);
        }
    }
}


template <typename T>
void imageplus::math::geometry::regions_bbox (const ImagePartition<T>& in, MultiArray<BBox2D,1>& bbox)
{
    int64 dim_x = in.size_x();
    int64 dim_y = in.size_y();

    int64 max_lab = math::statistics::maxval(in(PARTITION_CHANNEL));
    int64 min_lab = math::statistics::minval(in(PARTITION_CHANNEL));

    int64 num_of_regions = max_lab-min_lab+1;

    MultiArray<Coord2D<>,1> tl (num_of_regions);
    MultiArray<Coord2D<>,1> br (num_of_regions);
    bbox.resize(boost::extents[num_of_regions]);

    Coord2D<> maxp(dim_x-1, dim_y-1);
    Coord2D<> origin(0, 0);

    /* Initialize bboxes */
    for (int64 i = 0; i < num_of_regions; i++)
    {
        tl[i] = maxp;
        br[i] = origin;

        //bbox[i].side_x() = bbox[i].side_y() = 0;
        //bbox[i].origin() = maxp;
    }
  
    for (int64 j = 0; j < dim_y; j++)
    for (int64 i = 0; i < dim_x; i++)
    {
        const T val = in[i][j]-min_lab;

        /* Left coord */
        if (i < tl[val].x())
        {
            tl[val].x() = i;
        }

        /* Top coord */
        if (j < tl[val].y())
        {
            tl[val].y() = j;
        }

        /* Right coord */
        if (i > br[val].x())
        {
            br[val].x() = i;
        }

        /* Bottom coord */
        if (j > br[val].y())
        {
            br[val].y() = j;
        }
    }

    for (int64 i = 0; i < num_of_regions; ++i)
    {
        bbox[i] = BBox2D(tl[i],br[i]);
    }
} /* End of regions_bbox() */


template <typename T>
BBox2D imageplus::math::geometry::region_bbox (const ImagePartition<T>& in, T reg)
{
    int64 dim_x = in.size_x();
    int64 dim_y = in.size_y();

    Coord2D<> tl(dim_x-1,dim_y-1);  
    Coord2D<> br(0,0);
  

    for (int64 j = 0; j < dim_y; j++)
    for (int64 i = 0; i < dim_x; i++)
    {
        const T val = in[i][j];
        if (val == reg)
        {
            /* Left coord */
            if (i < tl.x())
            {
                tl.x() = i;
            }
            /* Top coord */
            if (j < tl.y())
            {
                tl.y() = j;
            }

            /* Right coord */
            if (i > br.x())
            {
                br.x() = i;
            }

            /* Bottom coord */
            if (j > br.y())
            {
                br.y() = j;
            }
        }
    }

    BBox2D bbox(tl,br);

    return bbox;

} /* End of region_bbox() */


template <typename T>
BBox2D imageplus::math::geometry::blob_bbox (const MultiArray<T,2>& in)
{
  bool goon = true;
  
  int64 width  = in.dims(0);
  int64 height = in.dims(1);

  Coord2D<> p1(0,0), p2(0,0);

  for (int64 j = 0; j< height && goon; j++)
  for (int64 i = 0; i< width  && goon; i++)
	{
      if(in[i][j] > 0) 
		{
		  goon  = false;
		  p1.y() = j;
		}
    }
  
  goon = true;
  for (int64 j = height - 1; j>=0 && goon; j--)
  for (int64 i = width - 1;  i>=0 && goon; i--) 
	{
      if(in[i][j]>0) 
		{
		  goon= false;
		  p2.y() = j; 
		}
    }
  
  goon=true;
  for (int64 i=0; i<width  && goon; i++)
  for (int64 j=0; j<height && goon; j++) 
	{
      if(in[i][j]>0) 
		{
		  goon= false;
		  p1.x() = i;
		}
    }
  
  goon=true;
  for (int64 i= width-1;  i>=0 && goon; i--)
  for (int64 j= height-1; j>=0 && goon; j--) 
	{
      if(in[i][j]>0) 
		{
		  goon= false;
		  p2.x() = i;
		}
    }

  BBox2D out (p1,p2);

  return out;
}


BBox2D imageplus::math::geometry::blob_bbox (const ImageMask& in)
{
  bool goon = true;
  
  int64 width  = in.size_x();
  int64 height = in.size_y();

  Coord2D<> p1(0,0), p2(0,0);

  for (int64 j = 0; j< height && goon; j++)
  for (int64 i = 0; i< width  && goon; i++)
	{
        if(in[i][j]) 
		{
		  goon  = false;
		  p1.y() = j;
		}
    }
  
  goon = true;
  for (int64 j = height - 1; j>=0 && goon; j--)
  for (int64 i = width - 1;  i>=0 && goon; i--) 
	{
      if(in[i][j]) 
		{
		  goon= false;
		  p2.y() = j; 
		}
    }
  
  goon=true;
  for (int64 i=0; i<width  && goon; i++)
  for (int64 j=0; j<height && goon; j++) 
	{
      if(in[i][j]) 
		{
		  goon= false;
		  p1.x() = i;
		}
    }
  
  goon=true;
  for (int64 i= width-1;  i>=0 && goon; i--)
  for (int64 j= height-1; j>=0 && goon; j--) 
	{
      if(in[i][j]) 
		{
		  goon= false;
		  p2.x() = i;
		}
    }

  BBox2D out (p1,p2);

  return out;
}


namespace imageplus
{
    namespace math
    {
        namespace geometry
        {
            // 2 dimensions
//            template void limit_bbox_to_bbox(const BBox<int64,2>& ref_bb, BBox<int64,2>& bb);
            template void limit_point_to_bbox(const BBox<int64,2>& ref_bb, Coord<int64,2>& point);

            // 3 dimensions
//            template void limit_bbox_to_bbox(const BBox<int64,3>& ref_bb, BBox<int64,3>& bb);
            template void limit_point_to_bbox(const BBox<int64,3>& ref_bb, Coord<int64,3>& point);

            template void regions_bbox (const ImagePartition<int16>& in, MultiArray<BBox2D,1>& bbox);
            template void regions_bbox (const ImagePartition<uint32>& in, MultiArray<BBox2D,1>& bbox);

            template BBox2D region_bbox (const ImagePartition<int16>& in,  int16 reg);
            template BBox2D region_bbox (const ImagePartition<uint32>& in, uint32 reg);

            template BBox2D blob_bbox (const MultiArray<int16,2>&  in);
            template BBox2D blob_bbox (const MultiArray<uint32,2>& in);
            template BBox2D blob_bbox (const MultiArray<int64,2>&  in);

        }
    }
}//imageplus

