// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------

/*!
 * \file import_export.cpp
 */

#include <imageplus/core/import_export.hpp>

namespace imageplus
{
    template<typename T, typename U>
    void import_from( ImageRGB<T>&    ima,
                      const U*        buffer,
                      std::size_t     size,
                      ImportExportMode mode ) throw (ImagePlusNotImplemented)
    {
        T* rr = ima(RED_CHANNEL)  .data();
        T* gg = ima(GREEN_CHANNEL).data();
        T* bb = ima(BLUE_CHANNEL) .data();

        std::size_t numelem = ima(RED_CHANNEL).num_elements();

        switch(mode)
        {
        case RGB :
            ASSERT( (size == ima.size_x()*ima.size_y()*3*sizeof(T)), "Buffer size does not match image size" );
            for(std::size_t ii=0; ii< numelem ; ++ii)
            {
                *rr++ = static_cast<T>(*buffer++);
                *gg++ = static_cast<T>(*buffer++);
                *bb++ = static_cast<T>(*buffer++);
            }
            break;

        case BGR :
            ASSERT( (size == ima.size_x()*ima.size_y()*3*sizeof(T)), "Buffer size does not match image size" );
            for(std::size_t ii=0; ii< numelem ; ++ii)
            {
                *bb++ = static_cast<T>(*buffer++);
                *gg++ = static_cast<T>(*buffer++);
                *rr++ = static_cast<T>(*buffer++);
            }
            break;

        case RGBA :
            ASSERT( (size == ima.size_x()*ima.size_y()*4*sizeof(T)), "Buffer size does not match image size" );
            for(std::size_t ii=0; ii< numelem ; ++ii)
            {
                *rr++ = static_cast<T>(*buffer++);
                *gg++ = static_cast<T>(*buffer++);
                *bb++ = static_cast<T>(*buffer++);
                         buffer++;
            }
            break;

        default :
            throw ImagePlusNotImplemented("Buffer Color Mode not implemented");
            break;
        }
    }

    template<typename T, typename U>
    void export_to( const ImageRGB<T>& ima,
                    U*                 buffer,
                    std::size_t        size,
                    ImportExportMode    mode ) throw (ImagePlusNotImplemented)
    {
        const T* rr = ima(RED_CHANNEL)  .data();
        const T* gg = ima(GREEN_CHANNEL).data();
        const T* bb = ima(BLUE_CHANNEL) .data();

        std::size_t numelem = ima(RED_CHANNEL).num_elements();

        switch(mode)
        {
        case RGB :
            ASSERT( (size == ima.size_x()*ima.size_y()*3*sizeof(T)), "Buffer size does not match image size" );
            for(std::size_t ii=0; ii< numelem ; ++ii)
            {
                *buffer++ = static_cast<U>(*rr++);
                *buffer++ = static_cast<U>(*gg++);
                *buffer++ = static_cast<U>(*bb++);
            }
            break;
        case BGR :
            ASSERT( (size == ima.size_x()*ima.size_y()*3*sizeof(T)), "Buffer size does not match image size" );
            for(std::size_t ii=0; ii< numelem ; ++ii)
            {
                *buffer++ = static_cast<U>(*bb++);
                *buffer++ = static_cast<U>(*gg++);
                *buffer++ = static_cast<U>(*rr++);
            }
            break;

        case RGBA :
            ASSERT( (size == ima.size_x()*ima.size_y()*4*sizeof(T)), "Buffer size does not match image size" );
            for(std::size_t i=0; i< numelem ; ++i)
            {
                *buffer++ = static_cast<U>(*rr++);
                *buffer++ = static_cast<U>(*gg++);
                *buffer++ = static_cast<U>(*bb++);
                *buffer++ = 1; //alpha value
            }
            break;

        default :
            throw ImagePlusNotImplemented("Buffer Color Mode not implemented");
            break;
        }
    }

    template<typename T>
    void import_from( ImageGray<T>&   ima,
                      const T*        buffer,
                      std::size_t     size,
                      ImportExportMode mode ) throw (ImagePlusNotImplemented)
    {
        T* gg = ima(GRAY_CHANNEL).data();

        std::size_t numelem = ima(GRAY_CHANNEL).num_elements();

        switch(mode)
        {
        case GRAY :
            ASSERT( (size == ima.size_x()*ima.size_y()*sizeof(T)), "Buffer size does not match image size" );
            memcpy(gg, buffer, numelem*sizeof(T));
            break;
        default:
            throw ImagePlusNotImplemented("Buffer Color Mode not implemented");
        }
    }

    template<typename T>
    void export_to( const ImageGray<T>& ima,
                    T*                  buffer,
                    std::size_t         size,
                    ImportExportMode    mode ) throw (ImagePlusNotImplemented)
    {
        const T* gg = ima(GRAY_CHANNEL).data();

        std::size_t numelem = ima(GRAY_CHANNEL).num_elements();

        switch(mode)
        {
        case RGB:
            ASSERT( (size == ima.size_x()*ima.size_y()*sizeof(T)*3), "Buffer size does not match image size" );
            for(std::size_t ii=0; ii< numelem ; ++ii)
            {
                *buffer++ = *gg;
                *buffer++ = *gg;
                *buffer++ = *gg;

                ++gg;
            }

        case GRAY :
            ASSERT( (size == ima.size_x()*ima.size_y()*sizeof(T)), "Buffer size does not match image size" );
            memcpy(buffer, gg, numelem*sizeof(T));
            break;

        default:
            throw ImagePlusNotImplemented("Buffer Color Mode not implemented");
        }
    }

    template<typename T>
    void import_from( ImageYUV422<T>&   ima,
                      const T*          buffer,
                      std::size_t       size,
                      ImportExportMode   mode ) throw (ImagePlusNotImplemented)
    {
        T* yy = ima(0).data();
        T* uu = ima(1).data();
        T* vv = ima(2).data();

        std::size_t nelems = ima(1).num_elements(); // the U_CHANNEL is a quarter of image resolution


        switch(mode)
        {
        case YUYV :
            ASSERT( (size == ima.size_x()*ima.size_y()*2*sizeof(T)), "Buffer size does not match image size" );
            for (std::size_t ii = 0; ii < nelems; ++ii)
            {
                *yy++ = *buffer++;
                *uu++ = *buffer++;
                *yy++ = *buffer++;
                *vv++ = *buffer++;
            }
            break;

        case UYVY :
            ASSERT( (size == ima.size_x()*ima.size_y()*2*sizeof(T)), "Buffer size does not match image size" );
            for (std::size_t ii = 0; ii < nelems; ++ii)
            {
                *uu++ = *buffer++;
                *yy++ = *buffer++;
                *vv++ = *buffer++;
                *yy++ = *buffer++;
            }
            break;

        default :
            throw ImagePlusNotImplemented("Buffer Color Mode not implemented");
            break;
        }
    }

    template<typename T>
    void export_to( const ImageYUV422<T>& ima,
                    T*                    buffer,
                    std::size_t           size,
                    ImportExportMode       mode ) throw (ImagePlusNotImplemented)
    {
        const T* yy = ima(0).data();
        const T* uu = ima(1).data();
        const T* vv = ima(2).data();

        std::size_t nelems = ima(1).num_elements(); // the U_CHANNEL is a quarter of image resolution

        switch(mode)
        {
        case YUYV :
            ASSERT( (size == ima.size_x()*ima.size_y()*2*sizeof(T)), "Buffer size does not match image size" );
            for (std::size_t ii = 0; ii < nelems; ++ii)
            {
                *buffer++ = *yy++;
                *buffer++ = *uu++;
                *buffer++ = *yy++;
                *buffer++ = *vv++;
            }
            break;

        case UYVY :
            ASSERT( (size == ima.size_x()*ima.size_y()*2*sizeof(T)), "Buffer size does not match image size" );
            for (std::size_t ii = 0; ii < nelems; ++ii)
            {
                *buffer++ = *uu++;
                *buffer++ = *yy++;
                *buffer++ = *vv++;
                *buffer++ = *yy++;
            }
            break;

        default :
            throw ImagePlusNotImplemented("Buffer Color Mode not implemented");
            break;
        }
    }
} // namespace imageplus


/*
 * Template instantiations
 */
namespace imageplus
{
    /*
     * ImageRGB - Export
     */
    template
    void export_to<uint8,uint8>(const ImageRGB<uint8>& ima, uint8*  buffer, std::size_t size, ImportExportMode mode);
    template
    void export_to<uint16,uint16>(const ImageRGB<uint16>& ima, uint16* buffer, std::size_t size, ImportExportMode mode);
    template
    void export_to<uint32,uint32>(const ImageRGB<uint32>& ima, uint32* buffer, std::size_t size, ImportExportMode mode);
    template
    void export_to<uint64,uint64>(const ImageRGB<uint64>& ima, uint64* buffer, std::size_t size, ImportExportMode mode);
    template
    void export_to<uint8,float64>(const ImageRGB<uint8 >& ima, float64*  buffer, std::size_t size, ImportExportMode mode);


    template
    void export_to<int8,int8>(const ImageRGB<int8 >& ima, int8*  buffer, std::size_t size, ImportExportMode mode);
    template
    void export_to<int16,int16>(const ImageRGB<int16>& ima, int16* buffer, std::size_t size, ImportExportMode mode);
    template
    void export_to<int32,int32>(const ImageRGB<int32>& ima, int32* buffer, std::size_t size, ImportExportMode mode);
    template
    void export_to<int64,int64>(const ImageRGB<int64>& ima, int64* buffer, std::size_t size, ImportExportMode mode);

    template
    void export_to<float64,float64>(const ImageRGB<float64>& ima, float64* buffer, std::size_t size, ImportExportMode mode);

    /*
     * ImageRGB - Import
     */
    template
    void import_from<uint8,uint8>( ImageRGB<uint8 >& ima, const uint8*  buffer, std::size_t size, ImportExportMode mode);
    template
    void import_from<uint16,uint16>( ImageRGB<uint16>& ima, const uint16* buffer, std::size_t size, ImportExportMode mode);
    template
    void import_from<uint32,uint32>( ImageRGB<uint32>& ima, const uint32* buffer, std::size_t size, ImportExportMode mode);
    template
    void import_from<uint64,uint64>( ImageRGB<uint64>& ima, const uint64* buffer, std::size_t size, ImportExportMode mode);

    template
    void import_from<int8,int8 >( ImageRGB<int8 >& ima, const int8*  buffer, std::size_t size, ImportExportMode mode);
    template
    void import_from<int16,int16>( ImageRGB<int16>& ima, const int16* buffer, std::size_t size, ImportExportMode mode);
    template
    void import_from<int32,int32>( ImageRGB<int32>& ima, const int32* buffer, std::size_t size, ImportExportMode mode);
    template
    void import_from<int64,int64>( ImageRGB<int64>& ima, const int64* buffer, std::size_t size, ImportExportMode mode);

    template
    void import_from<float64,float64>( ImageRGB<float64>& ima, const float64* buffer, std::size_t size, ImportExportMode mode);
    template
    void import_from<uint8,float64>( ImageRGB<uint8>& ima, const float64* buffer, std::size_t size, ImportExportMode mode);

    /*
     * ImageGray - Export
     */
    template
    void export_to<uint8 >(const ImageGray<uint8 >& ima, uint8*  buffer, std::size_t size, ImportExportMode mode);
    template
    void export_to<uint16>(const ImageGray<uint16>& ima, uint16* buffer, std::size_t size, ImportExportMode mode);
    template
    void export_to<uint32>(const ImageGray<uint32>& ima, uint32* buffer, std::size_t size, ImportExportMode mode);
    template
    void export_to<uint64>(const ImageGray<uint64>& ima, uint64* buffer, std::size_t size, ImportExportMode mode);

    template
    void export_to<int8 >(const ImageGray<int8 >& ima, int8*  buffer, std::size_t size, ImportExportMode mode);
    template
    void export_to<int16>(const ImageGray<int16>& ima, int16* buffer, std::size_t size, ImportExportMode mode);
    template
    void export_to<int32>(const ImageGray<int32>& ima, int32* buffer, std::size_t size, ImportExportMode mode);
    template
    void export_to<int64>(const ImageGray<int64>& ima, int64* buffer, std::size_t size, ImportExportMode mode);

    template
    void export_to<float64>(const ImageGray<float64>& ima, float64* buffer, std::size_t size, ImportExportMode mode);

    /*
     * ImageGray - Import
     */
    template
    void import_from<uint8 >( ImageGray<uint8 >& ima, const uint8*  buffer, std::size_t size, ImportExportMode mode);
    template
    void import_from<uint16>( ImageGray<uint16>& ima, const uint16* buffer, std::size_t size, ImportExportMode mode);
    template
    void import_from<uint32>( ImageGray<uint32>& ima, const uint32* buffer, std::size_t size, ImportExportMode mode);
    template
    void import_from<uint64>( ImageGray<uint64>& ima, const uint64* buffer, std::size_t size, ImportExportMode mode);

    template
    void import_from<int8 >( ImageGray<int8 >& ima, const int8*  buffer, std::size_t size, ImportExportMode mode);
    template
    void import_from<int16>( ImageGray<int16>& ima, const int16* buffer, std::size_t size, ImportExportMode mode);
    template
    void import_from<int32>( ImageGray<int32>& ima, const int32* buffer, std::size_t size, ImportExportMode mode);
    template
    void import_from<int64>( ImageGray<int64>& ima, const int64* buffer, std::size_t size, ImportExportMode mode);

    template
    void import_from<float64>( ImageGray<float64>& ima, const float64* buffer, std::size_t size, ImportExportMode mode);

    /*
     * ImageYUV422 - Import
     */
    template
    void import_from<uint8 >( ImageYUV422<uint8 >& ima, const uint8*  buffer, std::size_t size, ImportExportMode mode);
    template
    void import_from<uint16>( ImageYUV422<uint16>& ima, const uint16* buffer, std::size_t size, ImportExportMode mode);
    template
    void import_from<uint32>( ImageYUV422<uint32>& ima, const uint32* buffer, std::size_t size, ImportExportMode mode);
    template
    void import_from<uint64>( ImageYUV422<uint64>& ima, const uint64* buffer, std::size_t size, ImportExportMode mode);

    template
    void import_from<int8 >( ImageYUV422<int8 >& ima, const int8*  buffer, std::size_t size, ImportExportMode mode);
    template
    void import_from<int16>( ImageYUV422<int16>& ima, const int16* buffer, std::size_t size, ImportExportMode mode);
    template
    void import_from<int32>( ImageYUV422<int32>& ima, const int32* buffer, std::size_t size, ImportExportMode mode);
    template
    void import_from<int64>( ImageYUV422<int64>& ima, const int64* buffer, std::size_t size, ImportExportMode mode);

    template
    void import_from<float64>( ImageYUV422<float64>& ima, const float64* buffer, std::size_t size, ImportExportMode mode);

    /*
     * ImageYUV422 - Export
     */
    template
    void export_to<uint8 >(const ImageYUV422<uint8 >& ima, uint8*  buffer, std::size_t size, ImportExportMode mode);
    template
    void export_to<uint16>(const ImageYUV422<uint16>& ima, uint16* buffer, std::size_t size, ImportExportMode mode);
    template
    void export_to<uint32>(const ImageYUV422<uint32>& ima, uint32* buffer, std::size_t size, ImportExportMode mode);
    template
    void export_to<uint64>(const ImageYUV422<uint64>& ima, uint64* buffer, std::size_t size, ImportExportMode mode);

    template
    void export_to<int8 >(const ImageYUV422<int8 >& ima, int8*  buffer, std::size_t size, ImportExportMode mode);
    template
    void export_to<int16>(const ImageYUV422<int16>& ima, int16* buffer, std::size_t size, ImportExportMode mode);
    template
    void export_to<int32>(const ImageYUV422<int32>& ima, int32* buffer, std::size_t size, ImportExportMode mode);
    template
    void export_to<int64>(const ImageYUV422<int64>& ima, int64* buffer, std::size_t size, ImportExportMode mode);

    template
    void export_to<float64>(const ImageYUV422<float64>& ima, float64* buffer, std::size_t size, ImportExportMode mode);
}
