// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------

//!
//!  \file room.hpp
//!

#ifndef IMAGEPLUS_ROOM_HPP
#define IMAGEPLUS_ROOM_HPP

#include <imageplus/core/imageplus_types.hpp>
#include <imageplus/core/multiarray.hpp>
#include <imageplus/core/point.hpp>
#include <imageplus/core/volume.hpp>

namespace imageplus
{
    /*!
     * \brief Class to handle the discretization parameters of a 3D scene or room
     * 
     * The parameters are:
     * 
     * - dims:       The number of voxels per side of the grid
     * - voxel_size: The dimensions in cm of the voxel (cubic voxel)
     * - offset:     The Point3D where the discretization starts (an offset from the origin)
     * 
     * \todo The voxel size can be an array, so we will be able to work with non-cubic voxels
     * \todo Is this class somehow related to Quantizer?
     * 
     * \author Albert Gil Moreno <agil@gps.tsc.upc.edu>
     * \date   200-07-07
     */ 
    class Grid3D
    {
    public:
        
        /*!
         * \brief Default constructor
         */
        Grid3D()
        {}
        
        /*!
         * \brief Contructor with all the parameters
         *
         * \param[in] dims       : The number of voxels per side of the grid
         * \param[in] voxel_size : The dimensions in cm of the voxel (cubic voxel)
         * \param[in] offset     : The Point3D where the discretization starts (an offset from the origin)
         */
        Grid3D( const Coord3D<std::size_t>& dims, float64 voxel_size, const Point3D& offset)
                : _dims(dims), _voxel_size(voxel_size), _offset(offset)
        {}
        
        /*!
         * \returns The real position (non-discrete) of the voxel coordinate
         *
         * \param[in] voxel       : voxel coordinate
         * \param[in] step_factor : voxel size factor to be added (usually half voxel size: 0.5)
         *
         * \author Marcel Alcoverro <marcel@gps.tsc.upc.edu>
         * \date 15-05-2008
         */
        Point3D center_point(const Coord3D<>& voxel , float64  step_factor = 0.5 )
        {
            Point3D out( voxel.x(),voxel.y(),voxel.z() );
            
            product (out , _voxel_size, out);
            sum     (out , _offset,     out);
            sum     (out , _voxel_size * step_factor,    out);
            
            return out;
        }
        
        /*!
         * \returns the grid dimensions
         */
        const Coord3D<std::size_t>& dims() const 
        {
            return _dims;
        }

        /*!
         * \returns the voxel size
         */
        const float64& voxel_size() const
        {
            return _voxel_size;
        }
        
        /*!
         * \returns the origin offset
         */
        const Point3D& offset() const
        {
            return _offset;
        }
        
    private:
        Coord3D<std::size_t> _dims;       //!< the number of voxels per side of the grid
        float64              _voxel_size; //!< the dimensions in cm of the voxel (cubic voxel)
        Point3D              _offset;     //!< the Point3D where the discretization starts (an offset from the origin)
    };


    //!
    //! \brief base class to all rooms
    //!
    //! You should not instantiate this class (better use RoomGray, RoomRGB, etc.)
    //! unless you want to implement functions that work equally for all rooms
    //!
    //! Template T is the type of the data \n
    //! Template N is the number of channels in the room \n
    //!
    //! The declaration should be:
    //! \code
    //!    Room<uint8,3> a(400.0, 300.0, 200.0, 3.0, );
    //! \endcode
    //!
    //! This creates a room of uint8 values with 3 channels with size 400x300x200 cm,
    //! a voxel size of 3.0 cm and offset (0.0, 0.0, 0.0).
    //!
    //!
    //! \author Josep Ramon Morros <morros@gps.tsc.upc.edu>
    //!
    //! \date 23-1-2008
    //!
    template<typename T, int N>
    class Room
    {
    public:

        //!
        //! \brief Default constructor
        //!
        Room();

        //!
        //! \brief Constructor for 3 dimensions
        //!
        //! \param[in] sizeX      : X size of the room in cm
        //! \param[in] sizeY      : Y size of the room in cm
        //! \param[in] sizeZ      : Z size of the room in cm
        //! \param[in] voxel_size : voxel size in cm
        //! \param[in] offset     : Offset to the region of interest from origin
        //!
        Room(uint64 sizeX, uint64 sizeY, uint64 sizeZ, float64 voxel_size, Point3D offset);

        //!
        //! \brief Constructor for 3 dimensions (default offset=(0,0,0) )
        //!
        //! \param[in] sizeX      : X size of the room in cm
        //! \param[in] sizeY      : Y size of the room in cm
        //! \param[in] sizeZ      : Z size of the room in cm
        //! \param[in] voxel_size : voxel size in cm
        //!
        Room(uint64 sizeX, uint64 sizeY, uint64 sizeZ, float64 voxel_size);
        
        //!
        //! \brief Constructor for 3 dimensions (default offset=(0,0,0) )
        //!
        //! \param[in] grid3d     : Discretization parameters
        //!
        Room(const Grid3D& grid3d);

        //!
        //! \brief Copy constructor for Room
        //!
        //! \param[in] copy : Creates a copy (including values) of this room
        //!
        Room( const Room<T,N>& copy );

        //!
        //! \brief Destructor
        //!
        virtual
        ~Room();

        //!
        //! \brief Assignment operator for Room
        //!
        //! \param[in] copy : Creates a copy (size,channels and data) of this room
        //!
        //! \return Reference to (this) so a = b = c; works.
        //!
        const Room& operator=( const Room& copy ) throw (ImagePlusError);

        //!
        //! \brief Access to room dimensions
        //!
        //! \return The size of the X dimension (first)
        //!
        uint64 size_x() const;

        //!
        //! \brief Access to room dimensions
        //!
        //! \return The size of the Y dimension (second)
        //!
        uint64 size_y() const;

        //!
        //! \brief Access to room dimensions
        //!
        //! \return The size of the Z dimension (third)
        //!
        uint64 size_z() const;

        //!
        //! \brief Access to voxel size
        //!
        //! \return The voxel size in cm
        //!
        float64 voxel_size() const;

        //!
        //! \brief Access to Offset
        //!
        //! \return The voxel size in cm
        //!
        Point3D  offset() const;

        //!
        //! \brief Access to room volume
        //!
        //! \return Reference to the Volume of the room
        //!
        Volume<T,N>& volume();
        
        //!
        //! \brief  Access to constant members of room volume
        //!
        //! \return Reference to the Volume of the room
        //!
        const Volume<T,N>& volume() const;

    protected:
        
        //! Voxel size in cm
        float64       _voxel_size;

        //! Offset from origin to the region of interest
        Point3D  _offset;

        //! Discretized volume representing the room voxels
        Volume<T,N> _volume;
    };
} //namespace imageplus


#endif // IMAGEPLUS_ROOM_HPP
