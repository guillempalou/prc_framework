// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------

//!
//!  \file contrast.hpp
//!
//!  Add brief description of the file here
//! 

#ifndef IMAGEPLUS_DESCRIPTORS_COLOR_CONTRAST_HPP
#define IMAGEPLUS_DESCRIPTORS_COLOR_CONTRAST_HPP

#include <imageplus/core/visual_descriptors.hpp>
#include <imageplus/descriptors/geometry/area.hpp>

namespace imageplus
{
    namespace descriptors
    {

        //!
        //! \brief Class for visual descriptor that captures the contrast in the interior of the region
        //!
        //! This descriptor is obtained by computing the contrast (max. difference with its 4 neighbouring 
        //! pixels belonging to the same region) for each pixel of the region, adding the result and normalizing by region's area.
        //! Described in:\n
        //! J.-P. Cocquerez and S. Philipp, "Analyse d’images: filtrage et segmentation." Paris: Masson, 1995.\n
        //! See also: \n
        //! Sylvie Philipp-Foliguet, Laurent Guigues, "Multi-scale criteria for the evaluation of image segmentation algorithms"
        //! Journal of Multimedia 3(5), Dec. 2008\n
        //!
        //! \tparam InputType : TODO: Describe this template!! 
        //!
        //! The user may use the helper functions defined in visual_descriptors.hpp because of their simplicity.
        //!
        //! \author Ramon Morros <ramon.morros@upc.edu>
        //!
        //! \date 2010-08-02
        //!
        template<class InputModel>
        class IntraContrast : public DescriptorBase,
                              public boost::array<float64, InputModel::channels>
        {
            public:
            
                //!
                //! \brief Constructor
                //!
                //! \param[in] max_value : Maximum possible value for a pixel
                //!
                IntraContrast(uint64 max_value = 255) : DescriptorBase("IntraContrast",false), boost::array<float64, InputModel::channels>(), _max_value(max_value)
                {
                }

                //! \brief Calculates the intra-contrast of the region
                //!
                //! \tparam IteratorModel : TODO: Describe this template!! 
                //!
                //! \param[in] first : Iterator to the beginning of the region or image
                //! \param[in] last : Iterator to the end of the region or image
                //! \param[in] peer_descs : Pointer to CollVD, in principle is never 0x0 but it is a good idea to ASSERT it
                //!
                //! \return A reference to the visual descriptor
                //!
                template< class IteratorModel>
                void calculate(IteratorModel first, IteratorModel last, CollaborativeDescriptors* peer_descs)
                {
                    std::fill((*this).begin(), (*this).end(), 0.0);

                    // Calculate the area of the region
                    Area region_area = peer_descs->calculate(new Area(), first, last);

                    uint64 neighborhood_size = 4;
            
                    Neighborhood2D neighb;
                    neighb.resize(neighborhood_size);
            
                    neighb[0]=Neighborhood2D::CoordType( 1, 0);
                    neighb[1]=Neighborhood2D::CoordType( 0, 1);
                    neighb[2]=Neighborhood2D::CoordType(-1, 0);
                    neighb[3]=Neighborhood2D::CoordType( 0,-1);

                    // Create a padded region to avoid problems at region borders
                    // Inefficient!!!
                    boost::array<std::size_t, 2> borders2d = {{1,1}};
                    typename InputModel::Color cl = 0;
                    const Border< InputModel >& padded_reg = peer_descs->calculate(new Border< InputModel >(borders2d, cl, false), first, last);
                    typedef typename Border< InputModel >::template const_iterator<> BorderIterator;

                    // Iterators to the padded region
                    BorderIterator padded_first = padded_reg.colors_begin();
                    BorderIterator padded_last  = padded_reg.colors_end();


                    for (; padded_first != padded_last; ++padded_first)
                    {
                        typename BorderIterator::pixel_type::neighbor_iterator neigh_it     = (*padded_first).local_begin(neighb);
                        typename BorderIterator::pixel_type::neighbor_iterator neigh_it_end = (*padded_first).local_end(neighb);

                        boost::array < std::vector<float64>, InputModel::channels > dif;

                        for(; neigh_it!=neigh_it_end; ++neigh_it)
                        {
                            if ( !padded_reg.is_border ((*neigh_it).position()) )
                            {
                                for (uint64 ch=0; ch < InputModel::channels; ++ch) 
                                {
                                    dif[ch].push_back(std::abs((*padded_first).value(ch) - (*neigh_it).value(ch)));
                                } 
                            }
                        }
                        for (uint64 ch=0; ch!=InputModel::channels; ++ch) 
                        {
                            if ( dif[ch].size() != 0 ) 
                            {
                                (*this)[ch] += *(std::max_element (dif[ch].begin(), dif[ch].end()));
                            }
                        }
                    }

                    ASSERT (region_area != 0, "IntraContrast: empty region");

                    // Normalize by region's area
                    for (uint64 ch=0; ch!=InputModel::channels; ++ch) 
                    {
                        //(*this)[ch] = (*this)[ch] / (region_area * (_max_value - 1));
                        (*this)[ch] = (*this)[ch] / (region_area * _max_value);
                    }
                }

            private:
                //! Max value for the pixel
                uint64 _max_value;

        };


        //!
        //! \brief Class for visual descriptor that captures the contrast in the perimeter of the region
        //!
        //! This descriptor is obtained by computing the contrast (max. difference with its 4 neighbouring 
        //! pixels belonging to other regions) for each pixel of the border of the region, adding the result 
        //! and normalizing by region's perimeter.
        //! Described in:\n
        //! J.-P. Cocquerez and S. Philipp, "Analyse d’images: filtrage et segmentation." Paris: Masson, 1995.\n
        //! See also: \n
        //! Sylvie Philipp-Foliguet, Laurent Guigues, "Multi-scale criteria for the evaluation of image segmentation algorithms"
        //! Journal of Multimedia 3(5), Dec. 2008\n
        //!
        //! \tparam InputType : TODO: Describe this template!! 
        //!
        //! The user may use the helper functions defined in visual_descriptors.hpp because of their simplicity.
        //!
        //! \author Ramon Morros <ramon.morros@upc.edu>
        //!
        //! \date 2010-08-02
        //!
        template<class InputModel>
        class InterContrast : public DescriptorBase,
                              public boost::array<float64, InputModel::channels>
        {
            public:
            
                //!
                //! \brief Constructor
                //!
                //! \param[in] max_value : Maximum possible value for a pixel
                //!
                InterContrast(uint64 max_value = 255) : DescriptorBase("InterContrast",false), boost::array<float64, InputModel::channels>(), _max_value(max_value)
                {
                }

                //! \brief Calculates the inter-contrast
                //!
                //! \tparam IteratorModel :  TODO: Describe this template!! 
                //!
                //! \param[in] first : Iterator to the beginning of the region or image
                //! \param[in] last : Iterator to the end of the region or image
                //! \param[in] peer_descs : Pointer to CollVD, in principle is never 0x0 but it is a good idea to ASSERT it
                //!
                //! \return A reference to the visual descriptor
                //!
                template< class IteratorModel>
                void calculate(IteratorModel first, IteratorModel last, CollaborativeDescriptors* peer_descs)
                {
                    std::fill((*this).begin(), (*this).end(), 0.0);

                    uint64 neighborhood_size = 4;
            
                    Neighborhood2D neighb;
                    neighb.resize(neighborhood_size);
            
                    neighb[0]=Neighborhood2D::CoordType( 1, 0);
                    neighb[1]=Neighborhood2D::CoordType( 0, 1);
                    neighb[2]=Neighborhood2D::CoordType(-1, 0);
                    neighb[3]=Neighborhood2D::CoordType( 0,-1);

                    // Create a padded image to avoid problems at image borders
                    // Inefficient!!!
                    boost::array<std::size_t, 2> borders2d = {{1,1}};
                    typename InputModel::Color cl = 0;
                    
                    ASSERT(peer_descs!=0x0, "InterContrast calculate: peer_descs must be non null");
                    ASSERT(peer_descs->global_desc()!=0x0, "InterContrast calculate: peer_descs->global_desc() must be non null");

                    const Border< InputModel >& padded_ima = peer_descs->global_desc()->calculate(new Border< InputModel >(borders2d, cl, true), (*first).global_begin(), (*first).global_end());

                    // Create a padded region to check region borders
                    // Inefficient!!!
                    const Border< InputModel >& padded_reg = peer_descs->calculate(new Border< InputModel >(borders2d, cl, false), first, last);

                    typedef typename Border< InputModel >::template const_iterator<> BorderIterator;

                    // Iterators to the padded region
                    BorderIterator padded_first = padded_reg.colors_begin();
                    BorderIterator padded_last  = padded_reg.colors_end();

                    uint64 reg_perimeter = 0;
                    
                    for (; padded_first != padded_last; ++padded_first)
                    {
                        typename BorderIterator::pixel_type::neighbor_iterator neigh_it     = (*padded_first).local_begin(neighb);
                        typename BorderIterator::pixel_type::neighbor_iterator neigh_it_end = (*padded_first).local_end(neighb);

                        boost::array < std::vector<float64>, InputModel::channels > dif;

                        for(; neigh_it!=neigh_it_end; ++neigh_it)
                        {
                            if ( !padded_ima.is_border((*neigh_it).position()) ) // Check if neigh_it falls out of the borders of the image
                            {
                                if ( padded_reg.is_border((*neigh_it).position()) ) // Check that neighbor falls in another region
                                {
                                    for (uint64 ch=0; ch!=InputModel::channels; ++ch) 
                                    {
                                        dif[ch].push_back(std::abs((*padded_first).value(ch) - padded_ima((*neigh_it).position())[ch]));
                                    }
                                }
                            }
                        }

                        if ( dif[0].size() != 0 ) // Border pixel-
                        {
                            ++reg_perimeter;
                            for (uint64 ch=0; ch!=InputModel::channels; ++ch) 
                            {
                                (*this)[ch] += *(std::max_element (dif[ch].begin(), dif[ch].end()));
                            }
                        }
                    }

                    ASSERT (reg_perimeter != 0, "InterContrast: perimeter is zero");

                    for (uint64 ch=0; ch!=InputModel::channels; ++ch) 
                    {
                        //(*this)[ch] = (*this)[ch] / (reg_perimeter * (_max_value - 1));
                        (*this)[ch] = (*this)[ch] / (reg_perimeter * _max_value);
                    }
                }


            private:
                //! Max value for the pixel
                uint64 _max_value;
        };



        //!
        //! \brief Class for visual descriptor that captures the Zeboudj contrast
        //!
        //! This descriptor is obtained by combining the intra and inter contrasts defined avobe\n
        //! Described in:\n
        //! J.-P. Cocquerez and S. Philipp, "Analyse d’images: filtrage et segmentation." Paris: Masson, 1995.\n
        //! See also: \n
        //! Sylvie Philipp-Foliguet, Laurent Guigues, "Multi-scale criteria for the evaluation of image segmentation algorithms"
        //! Journal of Multimedia 3(5), Dec. 2008\n
        //!
        //! \tparam InputType : TODO: Describe this template!! 
        //!
        //! The user may use the helper functions defined in visual_descriptors.hpp because of their simplicity.
        //!
        //! \author Ramon Morros <ramon.morros@upc.edu>
        //!
        //! \date 2010-08-02
        //!
        template<class InputModel>
        class ZeboudjContrast : public DescriptorBase,
                                public boost::array<float64, InputModel::channels>
        {
            public:
            
                //!
                //! \brief Constructor
                //!
                //! \param[in] max_value : Maximum possible value for a pixel
                //!
                ZeboudjContrast(uint64 max_value = 255) : DescriptorBase("ZeboudjContrast",false), boost::array<float64, InputModel::channels>(), _max_value(max_value)
                {
                }

                //! \brief Calculates 
                //!
                //! \tparam IteratorModel : TODO: Describe this template!! 
                //!
                //! \param[in] first : Iterator to the beginning of the region or image
                //! \param[in] last : Iterator to the end of the region or image
                //! \param[in] peer_descs : Pointer to CollVD, in principle is never 0x0 but it is a good idea to ASSERT it
                //!
                //! \return A reference to the visual descriptor
                //!
                template< class IteratorModel>
                void calculate(IteratorModel first, IteratorModel last, CollaborativeDescriptors* peer_descs)
                {
                    ASSERT(peer_descs!=0x0, "InterContrast calculate: peer_descs must be non null");

                    std::fill((*this).begin(), (*this).end(), 0.0);

                    const IntraContrast<InputModel>& intra_cont = peer_descs->calculate(new IntraContrast< InputModel >(_max_value), first, last);
                    const InterContrast<InputModel>& inter_cont = peer_descs->calculate(new InterContrast< InputModel >(_max_value), first, last);
                    
                    for (uint64 ch=0; ch!=InputModel::channels; ++ch) 
                    {
                        if (intra_cont[ch] == 0)
                        {
                            (*this)[ch] = inter_cont[ch];
                        }
                        else if (inter_cont[ch] > intra_cont[ch]) 
                        {
                            (*this)[ch] = 1.0 - (intra_cont[ch] / inter_cont[ch]);
                        }
                        else
                        {
                            (*this)[ch] = 0.0;
                        }
                    }
                }

            private:
                //! Max value for the pixel
                uint64 _max_value;
        };

    }
}

#endif

