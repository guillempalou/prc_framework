/*
 * color_motion_distance.hpp
 *
 *  Created on: Oct 16, 2012
 *      Author: guillem
 */

#ifndef COLOR_MOTION_DISTANCE_HPP_
#define COLOR_MOTION_DISTANCE_HPP_


#include <imageplus/descriptors/descriptor_manager.hpp>

#include <imageplus/descriptors/geometry/area.hpp>
#include <imageplus/descriptors/color/color_mean.hpp>
#include <imageplus/descriptors/video/temporal_mean.hpp>
#include <imageplus/descriptors/color/color_signature.hpp>

#include <imageplus/math/optimization/emd.hpp>

#include <imageplus/bpt/models/bpt_distance_model.hpp>

namespace imageplus
{
    namespace video_segmentation
    {

        //! Class from which any model must inherit to work properly
        template<class SignalModel, class RegionModel, class OpticalFlowModel, typename order_type=float64>
        class MotionColorDistanceModel : public bpt::BaseDistanceModel<SignalModel, RegionModel, order_type>
        {
        	typedef VideoSignal<float64,1>	ReliabilityMap;

        	typedef descriptors::ColorSignature<SignalModel>	ColorSignatureDescritor;
        	typedef descriptors::Area							AreaDescriptor;
        	typedef descriptors::TemporalMean<OpticalFlowModel>	MotionMeanDescriptor;
        	typedef descriptors::TemporalMean<ReliabilityMap>	ReliabilityMeanDescriptor;

        public:

        	struct Parameters {
        		OpticalFlowModel optical_flow;
        		int64 num_colors;

        		float64 color_damping;
        		float64 motion_damping;
        		float64 spatial_damping;
        		float64 area_damping;

        		ReliabilityMap		flow_reliability; 	// the higher the more reliable

        		Parameters() : optical_flow(OpticalFlowModel::coord_type::Zero()), flow_reliability(ReliabilityMap::coord_type::Zero()) {

        		}
        	};

        	static const Parameters default_parameters() {
        		return Parameters();
        	}


        	MotionColorDistanceModel(const Parameters& pars = default_parameters()) {
        		_pars = pars;

        		EMDDistance distance(SignalModel::value_float_type::Ones()*_pars.color_damping);

        		_emd 		= math::optimization::EMD<EMDDistance>(distance);
        	}

            //! This function computes the order of a given link (edge of the RAG)
            //!
            //! \param reg1 : Region of one extremum of the link
            //! \param reg2 : Region of the other extremum of the link
            //! \param image : Image being processed
            //! \param bpt : Partition at the moment of the merging
            //! \return The order of the link
        	template<class BPT>
            order_type region_distance(RegionModel& reg1, RegionModel& reg2, SignalModel& image, BPT& bpt, descriptors::DescriptorManager& manager) {


        		float64 dc = color_distance(reg1,reg2,image,bpt,manager);

        		std::vector<float64> dsm = spatial_motion_distance(reg1,reg2,image,bpt,manager);

        		float64 dm = dsm[0];
        		//float64 ds = dsm.second;
        		//float64 reliability = dsm[2];

        		float64 da = area_distance(reg1,reg2,image,bpt,manager);

        		float64 gamma = 0.99;

        		return (1 - (1-dc*gamma)*(1-dm*gamma))*da;
        	}

        	template<class BPT>
        	float64 color_distance(RegionModel& reg1, RegionModel& reg2, SignalModel& image, BPT& bpt, descriptors::DescriptorManager& manager) {

        		typename ColorSignatureDescritor::Parameters signature_pars;
        		signature_pars.num_colors = _pars.num_colors;
        		signature_pars.weights = SignalModel::value_float_type::Ones()*(_pars.color_damping);

        		const typename ColorSignatureDescritor::type& color1 = manager.calc_descriptor<ColorSignatureDescritor>(image, reg1, signature_pars);
        		const typename ColorSignatureDescritor::type& color2 = manager.calc_descriptor<ColorSignatureDescritor>(image, reg2, signature_pars);

        		return _emd.calculate(color1,color2);
        	}

        	template<class BPT>
        	std::vector<float64> spatial_motion_distance(RegionModel& reg1, RegionModel& reg2, SignalModel& image, BPT& bpt, descriptors::DescriptorManager& manager) {

        		const typename MotionMeanDescriptor::type& motion1 = manager.calc_descriptor<MotionMeanDescriptor>(_pars.optical_flow, reg1);
        		const typename MotionMeanDescriptor::type& motion2 = manager.calc_descriptor<MotionMeanDescriptor>(_pars.optical_flow, reg2);

        		const typename ReliabilityMeanDescriptor::type& reliability1 = manager.calc_descriptor<ReliabilityMeanDescriptor>(_pars.flow_reliability, reg1);
        		const typename ReliabilityMeanDescriptor::type& reliability2 = manager.calc_descriptor<ReliabilityMeanDescriptor>(_pars.flow_reliability, reg2);

        		float64 motion_distance = 0;
        		float64 spatial_distance = 0;
        		float64 reliability;

        		int64 begin_frame = std::max(motion1.begin_frame, motion2.begin_frame);
        		int64 end_frame = std::min(motion1.end_frame, motion2.end_frame);

        		for (int64 f = begin_frame; f <= end_frame; f++) {

        			float64 r  = std::min(reliability1.mean(f)(0),reliability2.mean(f)(0));
        			r++;

        			float64 d = r*((motion1.mean(f) - motion2.mean(f)).norm())*_pars.motion_damping;
        			float64 ds = (motion1.centroid(f) - motion2.centroid(f)).squaredNorm();

        			d = 1 - std::exp(-d);

        			//std::cout << motion1.mean(f).transpose() << " --- " << motion2.mean(f).transpose() << " " << d << std::endl;

        			if (d > motion_distance) {
        				motion_distance = d;
        				reliability = r;
        			}

        			spatial_distance = std::max(spatial_distance,ds);
        		}
        		//std::cout << "----- " << begin_frame << " " << end_frame  << std::endl;

        		//if (begin_frame > end_frame) {
        		//	motion_distance = 1;
        		//}

        		spatial_distance = std::log(1+spatial_distance);

        		std::vector<float64> v(3);

        		v[0] = motion_distance;
        		v[1] = spatial_distance;
        		v[2] = reliability;

        		return v;
        	}


        	template<class BPT>
        	float64 area_distance(RegionModel& reg1, RegionModel& reg2, SignalModel& image, BPT& bpt, descriptors::DescriptorManager& manager) {
        		const typename AreaDescriptor::type area1 = manager.calc_descriptor<AreaDescriptor>(image,reg1);
        		const typename AreaDescriptor::type area2 = manager.calc_descriptor<AreaDescriptor>(image,reg2);

        		float64 d = std::min(area1,area2);// * _pars.area_damping;

        		//return 1 - std::exp(-d);
        		return std::log(1+d);
        	}

        private:

        	typedef typename SignalModel::value_float_type 																	ColorType;
        	typedef typename OpticalFlowModel::value_float_type 															MotionType;
        	typedef typename math::statistics::PerceptualDistance<ColorType, typename SignalModel::value_float_type>		EMDDistance;
        	typedef typename math::statistics::PerceptualDistance<MotionType, typename OpticalFlowModel::value_float_type>	EMDMotionDistance;

        	math::optimization::EMD<EMDDistance> 		_emd;
        	math::optimization::EMD<EMDMotionDistance>  _emd_motion;
        	Parameters 									_pars;

        };

    }
}

#endif /* COLOR_MOTION_DISTANCE_HPP_ */
