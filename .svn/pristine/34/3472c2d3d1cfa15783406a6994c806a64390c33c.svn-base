// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------

//!
//!  \file border.hpp
//!

#ifndef IMAGEPLUS_CORE_BORDER_HPP
#define IMAGEPLUS_CORE_BORDER_HPP

#include <imageplus/core/bounding_box.hpp>
#include <imageplus/core/mask.hpp>

#include <boost/lexical_cast.hpp>



namespace imageplus
{
    //!
    //! \brief Class to put borders to Inputs (images, regions, etc.)
    //!
	//! \tparam InputModel     : The input type: any ImaVol, Region, etc.
    //! \author Jordi Pont <jordi.pont@upc.edu>
    //!
    //! \date 06-04-2010
    template<class InputModel>
    class Border : public DescriptorBase, 
                   public InputModel
    {
    public:
        
        /*!
         * \brief Constructor
         * 
         * \tparam PaddingType : This template allows us to use any type of container to represent the borders dimensions.
         *                       You can use boost::array, or std::vector...
         * 
         * \tparam ImaVolEqualable : This template allows us to use any type to initialize the borders.
         *                           The new ImaVol with bvorders will be initialized with operator= to borders_value.
         * 
         * \param[in] border_sizes  : The borders dimensions
         * \param[in] padding_value : The borders value
         * \param[in] global: Whether the border size is the size of the global image or the region bounding box
         */
        template <class PaddingType, typename ImaVolEqualable>
        Border(const PaddingType& border_sizes, const ImaVolEqualable& padding_value, bool global=false) : DescriptorBase("", false)
        {
            ASSERT(border_sizes.size()==InputModel::dimensions, "Border, border_sizes must have " << InputModel::dimensions << " values");
            for( std::size_t dd = 0; dd < InputModel::dimensions; ++dd )
            {
                _border_sizes[dd] = border_sizes[dd];
            }
            _padding_value = padding_value;
            _global = global;
            _form_id(); 
        }

        /*!
         * Destructor
         */
        virtual ~Border()
        {
        }
        
        //! \brief Calculates the border of a region given a pair of iterators. 
        //!
        //! \param[in] first      : Iterator to the beginning of the region
        //! \param[in] last       : Iterator to the end of the region
        //! \param[in] peer_descs : Pointer to CollaborativeDescriptors, in principle is never 0x0 but it is a good idea to ASSERT it
        template< class IteratorModel >
        void calculate(IteratorModel first, IteratorModel last, CollaborativeDescriptors* peer_descs)
        {
            ASSERT(peer_descs!=0x0, "boundingbox calculate: peer_descs must be non null");

            BoundingBox<typename InputModel::CoordType> bb_coord;
            if(!_global)
            {
                bb_coord = peer_descs->calculate(new BoundingBox<typename InputModel::CoordType>(), first, last);
            }
            _mask = &(peer_descs->calculate(new Mask<typename InputModel::CoordType>(_border_sizes, _global), first, last, peer_descs->global_desc()));
            
            this->resize(_mask->dims());

            for(std::size_t ii = 0; ii < InputModel::channels; ii++)
            {
                (*this)(ii) = _padding_value[ii];
                (*this)(ii).reindex(bb_coord.origin()-_border_sizes);
            }  
              
            for(; first!=last; ++first)
            {
                typename IteratorModel::pixel_type curr_pixel = *first;
                for(std::size_t ch=0; ch<InputModel::channels; ++ch)
                    (*this)(curr_pixel.position())[ch] = curr_pixel.value(ch);
            }
        }   
        
        /*!
         * \cond SKIP_DOC
         */
        template<class RegionModel = ImaVolMask<InputModel::dimensions> >
        class iterator : public InputModel::template iterator<RegionModel>
        {
        public:
            iterator(const DataIteratorBase< RegionModel, InputModel, typename InputModel::data_type, Pixel< RegionModel, InputModel, typename InputModel::data_type> >& copy)
                : InputModel::template iterator<RegionModel>(copy)
            {
                
            }
                    
            iterator( InputModel* iv , typename InputModel::template iterator<RegionModel>::position_iterator it )
                    : InputModel::template iterator<RegionModel>(iv, it)
            {
            }
            
        };
        
        template<class RegionModel = ImaVolMask<InputModel::dimensions> >
        class const_iterator : public InputModel::template const_iterator<RegionModel>
        {
        public:
            const_iterator(const DataIteratorBase< RegionModel, InputModel, typename InputModel::data_type, Pixel< RegionModel, InputModel, typename InputModel::data_type> >& copy)
                : InputModel::template const_iterator<RegionModel>(copy)
            {
                
            }
                    
            const_iterator( const InputModel* const iv , typename InputModel::template iterator<RegionModel>::position_iterator it )
                    : InputModel::template const_iterator<RegionModel>(iv, it)
            {
            }
            
        };

        /*!
         * \endcond SKIP_DOC
         */
           
        /*!
         * See the \ref iterators_example.cpp "iterators and colors example" to know how to use it. 
         * 
         * \return an iterator to loop through the whole input skipping the borders.
         */
        iterator<> colors_begin() 
        {
            return iterator<>( static_cast<InputModel*>(this), _mask->begin() );
        }


        /*!
         * See the \ref iterators_example.cpp "iterators and colors example" to know how to use it.
         * 
         * \return an iterator pointing to the last+1 color.
         * 
         * \warning this iterator points to a non-valid position.
         */
        iterator<> colors_end() 
        {
            return iterator<>( static_cast<InputModel*>(this), _mask->end() );
        }
        
        /*!
         * See the \ref iterators_example.cpp "iterators and colors example" to know how to use it.
         * 
         * \tparam RegionModel : This template allows us to use any Region type.
         * 
         * \param[in] region : The RegionModel to iterate.  
         * 
         * \returns an iterator to loop to the desired region in the ImaVol skipping the borders
         */
        template< class RegionModel >
        iterator<RegionModel> colors_begin(const RegionModel& region) 
        {
            return iterator<RegionModel>( static_cast<InputModel*>(this), region.begin() );
        }

        /*!
         * See the \ref iterators_example.cpp "iterators and colors example" to know how to use it.
         * 
         * \param[in] region: Region to iterate
         *
         * \return the color iterator pointing to the last+1 element of a desired RegionModel
         *
         * \warning this iterator points to a non-valid position.
         */
        template< class RegionModel >
        iterator<RegionModel> colors_end(const RegionModel& region) 
        {
            return iterator<RegionModel>( static_cast<InputModel*>(this), region.end() );
        }

        
        /*!
         * See the \ref iterators_example.cpp "iterators and colors example" to know how to use it. 
         * 
         * \return the iterator to loop through the input skipping the borders (const access).
         */
        const_iterator<> colors_begin() const  
        {
            return const_iterator<>( static_cast<const InputModel*>(this), _mask->begin());
        }

        /*!
         * See the \ref iterators_example.cpp "iterators and colors example" to know how to use it.
         *
         * \return the color iterator pointing to the last+1 element (const access)
         *
         * \warning this iterator points to a non-valid position.
         */
        const_iterator<> colors_end() const 
        {
            return const_iterator<>( static_cast<const InputModel*>(this), _mask->end());
        }
        
        /*!
         * See the \ref iterators_example.cpp "iterators and colors example" to know how to use it.
         * 
         * \tparam RegionModel : This template allows us to use any Region type.
         * 
         * \param[in] region : The RegionModel to iterate.  
         * 
         * \return the iterator to loop to the desired region in the ImaVol (const access)
         */
        template< class RegionModel >
        const_iterator< RegionModel > colors_begin( const RegionModel& region ) const  
        {
            return const_iterator< RegionModel >( static_cast<const InputModel*>(this), region.begin() );
        }
        
        /*!
         * See the \ref iterators_example.cpp "iterators and colors example" to know how to use it.
         * 
         * \tparam RegionModel : This template allows us to use any Region type.
         * 
         * \param[in] region : The RegionModel to iterate.  
         * 
         * \return the color iterator pointing to the last+1 element of a desired RegionModel (const access)
         *
         * \warning this iterator points to a non-valid position.
         */
        template< class RegionModel >
        const_iterator< RegionModel > colors_end( const RegionModel& region ) const  
        {
            return const_iterator< RegionModel >( static_cast<const InputModel*>(this), region.end() );
        }
        
        /*!
         * \param[in] position : Coordinate to be checked
         * \return Given a coordinate, it returns whether it is border or not (useful in neighbor iterators)
         */
        bool is_border(typename InputModel::CoordType position) const
        {
            return !((*_mask)(MASK_CHANNEL)(position));
        }
        
            
    private:
        //! Padding value
        typename InputModel::Color _padding_value;
        
        //! Border sizes
        typename InputModel::CoordType _border_sizes;
        
        //! Mask defining the area to iterate
        const Mask<typename InputModel::CoordType>* _mask;
        
        //! Whether the descriptors i global or not
        bool _global;
        
        //! Private method to form the identifier depending on the parameters of the descriptor
        void _form_id()
        {
            if(_global)
            {
                this->_id =  "Border_global_";
            }
            else
            {
                this->_id =  "Border_";
            }
            
            for( std::size_t ch = 0; ch < InputModel::channels; ++ch )
            {
                this->_id = this->_id + boost::lexical_cast<std::string>((int)_padding_value[ch]) + "_";
            }
            for( std::size_t dd = 0; dd < InputModel::dimensions-1; ++dd )
            {
                this->_id = this->_id + boost::lexical_cast<std::string>((int)_border_sizes[dd]) + "_";
            }
            this->_id = this->_id + boost::lexical_cast<std::string>((int)_border_sizes[InputModel::dimensions-1]);
        }
    };
}

#endif


