// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------

//! 
//! \file bpt_creation.test
//!
//! Tests for BPT creation functions 
//!

#include <fstream>
#include <iostream>
#include <imageplus/segmentation/label_flatzone.hpp>
#include <imageplus/bpt/creation.hpp>
#include <imageplus/io/readimage.hpp>
#include <imageplus/io/readwritepartition.hpp>

#include <imageplus/descriptors/color/color_statistics.hpp>

BOOST_AUTO_TEST_SUITE ( BPTCreationSuite );

using namespace std;
using namespace imageplus;
using namespace bpt;
using namespace segmentation;

BOOST_AUTO_TEST_CASE( CreateBPT_im23_4neighbors )
{
    typedef ImageGray<uint8> InputType;
    typedef RegionContour<Coord2D<int64> > RegionType;
    typedef Partition<RegionType> partition_type;
    
    io::ReadImage ri(string(TEST_DATA_PATH_R) + "/bpt/im23.png");
    InputType my_image;
    ri >> my_image;
     
    BPTModels<InputType, RegionType> my_model_set(new ColorHomogeneity<InputType, RegionType, WSDM>());
    
    const FlatZone& my_part = calc_descriptor(new FlatZone(), my_image);
    
    partition_type my_bpt(my_part);

    create_bpt(my_bpt, my_image, my_model_set);
            
    // Check the base partition
    const ImagePartition<uint32>& base_partition = my_bpt.leaves_partition();
    BOOST_CHECK_EQUAL( base_partition.size_x() , (std::size_t)2 );
    BOOST_CHECK_EQUAL( base_partition.size_y() , (std::size_t)3 );
    
    BOOST_CHECK_EQUAL( base_partition(0)[0][0] , (uint32)1 );
    BOOST_CHECK_EQUAL( base_partition(0)[1][0] , (uint32)2 );
    BOOST_CHECK_EQUAL( base_partition(0)[0][1] , (uint32)3 );
    BOOST_CHECK_EQUAL( base_partition(0)[1][1] , (uint32)4 );
    BOOST_CHECK_EQUAL( base_partition(0)[0][2] , (uint32)5 );
    BOOST_CHECK_EQUAL( base_partition(0)[1][2] , (uint32)5 );

    // Check the tree    
    BOOST_CHECK_EQUAL( my_bpt.num_regions(), (std::size_t)9 );
    
    BOOST_CHECK_EQUAL(my_bpt[1].parent()->label(), (uint32)7);
    BOOST_CHECK_EQUAL(my_bpt[2].parent()->label(), (uint32)6);
    BOOST_CHECK_EQUAL(my_bpt[3].parent()->label(), (uint32)8);
    BOOST_CHECK_EQUAL(my_bpt[4].parent()->label(), (uint32)6);
    BOOST_CHECK_EQUAL(my_bpt[5].parent()->label(), (uint32)9);
    
    BOOST_CHECK_EQUAL(my_bpt[6].parent()->label(), (uint32)7);
    BOOST_CHECK((my_bpt[6].parts()[0]->label()==4 && my_bpt[6].parts()[1]->label()==2) || (my_bpt[6].parts()[0]->label()==2 && my_bpt[6].parts()[1]->label()==4));
    
    BOOST_CHECK_EQUAL(my_bpt[7].parent()->label(), (uint32)8);
    BOOST_CHECK((my_bpt[7].parts()[0]->label()==1 && my_bpt[7].parts()[1]->label()==6) || (my_bpt[7].parts()[0]->label()==6 && my_bpt[7].parts()[1]->label()==1));
    
    BOOST_CHECK_EQUAL(my_bpt[8].parent()->label(), (uint32)9);
    BOOST_CHECK((my_bpt[8].parts()[0]->label()==3 && my_bpt[8].parts()[1]->label()==7) || (my_bpt[8].parts()[0]->label()==7 && my_bpt[8].parts()[1]->label()==3));
    
    BOOST_CHECK(my_bpt[9].parent()==NULL);
    BOOST_CHECK((my_bpt[9].parts()[0]->label()==5 && my_bpt[9].parts()[1]->label()==8) || (my_bpt[9].parts()[0]->label()==8 && my_bpt[9].parts()[1]->label()==5));
    
}


BOOST_AUTO_TEST_CASE( CreateBPT_SE )
{
    typedef ImageRGB<uint8> InputType;
    typedef RegionContour<Coord2D<int64> > RegionType;
    typedef Partition<RegionType> partition_type;
    
    ImagePartition<> my_part;
    io::ReadImage ri( string(TEST_DATA_PATH_R) + "/bpt/BPT_partition.prl" );
    ri >> my_part;
    
    InputType my_image;
    ri.open( string(TEST_DATA_PATH_R) + "/bpt/BPT_image.png" );
    ri >> my_image;
    
    std::vector<float64> weights(3);
    weights[0] = 1.;
    weights[1] = 0.5;
    weights[2] = 0.5;
    BPTModels<InputType, RegionType> my_model_set(new ColorHomogeneity<InputType, RegionType, SE>(weights));
    
    partition_type my_bpt(my_part);
    create_bpt(my_bpt, my_image, my_model_set);
    
    // \todo Actually check it
}

BOOST_AUTO_TEST_CASE( CreateBPT_MSE )
{
    typedef ImageRGB<uint8> InputType;
    typedef RegionContour<Coord2D<int64> > RegionType;
    typedef Partition<RegionType> partition_type;
    
    ImagePartition<> my_part;
    io::ReadImage ri( string(TEST_DATA_PATH_R) + "/bpt/BPT_partition.prl" );
    ri >> my_part;
    
    InputType my_image;
    ri.open( string(TEST_DATA_PATH_R) + "/bpt/BPT_image.png" );
    ri >> my_image;
    
    std::vector<float64> weights(3);
    weights[0] = 1.;
    weights[1] = 0.5;
    weights[2] = 0.5;
    BPTModels<InputType, RegionType> my_model_set(new ColorHomogeneity<InputType, RegionType, MSE>(weights));
    
    partition_type my_bpt(my_part);
    create_bpt(my_bpt, my_image, my_model_set);
    
    // \todo Actually check it
}

BOOST_AUTO_TEST_CASE( CreateBPT_StopMerging )
{
    typedef ImageRGB<uint8> InputType;
    typedef RegionContour<Coord2D<int64> > RegionType;
    typedef Partition<RegionType> partition_type;
    
    ImagePartition<> part;
    io::ReadImage ri( string(TEST_DATA_PATH_R) + "/bpt/BPT_stopmerging_initial.prl" );
    ri >> part;
    
    ImagePartition<> ideal_part;
    ri.open( string(TEST_DATA_PATH_R) + "/bpt/BPT_stopmerging_ideal.prl" );
    ri >> ideal_part;

    InputType image;
    ri.open( string(TEST_DATA_PATH_R) + "/bpt/BPT_stopmerging_color.png" );
    ri >> image;
    
    std::vector<float64> weights(3);
    weights[0] = 1.;
    weights[1] = 0.5;
    weights[2] = 0.5;
    
    BPTModels<InputType, RegionType> model_set_combined;
    model_set_combined.add_model(new ColorHomogeneity<InputType, RegionType, WEDM>(weights), 1.0);
    StopMerging<InputType, RegionType>* stop_merging = new StopMerging<InputType, RegionType>(ideal_part);
    model_set_combined.add_model(stop_merging, 0.0);


    partition_type bpt(part);
    create_bpt(bpt, image, model_set_combined);
    
    // Build bpt with non mergings orders
    
    BPTModels<InputType, RegionType> model_set_combined2;
    model_set_combined2.add_model(new ColorHomogeneity<InputType, RegionType, WEDM>(weights), 1.0);
    StopMerging<InputType, RegionType>* stop_merging2 = new StopMerging<InputType, RegionType>(stop_merging->non_merging_order());
    model_set_combined2.add_model(stop_merging2, 0.0);

    partition_type bpt2(part);
    create_bpt(bpt2, image, model_set_combined2);

    BOOST_CHECK( bpt == bpt2 );
    
}


#ifdef USE_XML

BOOST_AUTO_TEST_CASE( CreateBPT_WSDM )
{
    typedef ImageRGB<uint8> InputType;
    typedef RegionContour<Coord2D<int64> > RegionType;
    typedef Partition<RegionType> partition_type;
    
    ImagePartition<> my_part;
    io::ReadImage ri( string(TEST_DATA_PATH_R) + "/bpt/BPT_partition.prl" );
    ri >> my_part;
    
    InputType my_image;
    ri.open( string(TEST_DATA_PATH_R) + "/bpt/BPT_image.png" );
    ri >> my_image;
    
    std::vector<float64> weights(3);
    weights[0] = 1.;
    weights[1] = 0.5;
    weights[2] = 0.5;
    BPTModels<InputType, RegionType> my_model_set(new ColorHomogeneity<InputType, RegionType, WSDM>(weights));
    
    partition_type my_bpt(my_part);
    create_bpt(my_bpt, my_image, my_model_set);
    
    partition_type my_bpt2;
    string filename = string(TEST_DATA_PATH_R) + "/bpt/out_WSDM.xml";
    io::ReadWritePartition rw_bpt( filename );
    rw_bpt.read(my_bpt2);
    
    BOOST_CHECK( my_bpt == my_bpt2 );
}


BOOST_AUTO_TEST_CASE( CreateBPT_WEDM )
{
    typedef ImageRGB<uint8> InputType;
    typedef RegionContour<Coord2D<int64> > RegionType;
    typedef Partition<RegionType> partition_type;
    
    ImagePartition<> my_part;
    io::ReadImage ri( string(TEST_DATA_PATH_R) + "/bpt/BPT_partition.prl" );
    ri >> my_part;
    
    InputType my_image;
    ri.open( string(TEST_DATA_PATH_R) + "/bpt/BPT_image.png" );
    ri >> my_image;
    
    std::vector<float64> weights(3);
    weights[0] = 1.;
    weights[1] = 0.5;
    weights[2] = 0.5;
    BPTModels<InputType, RegionType> my_model_set(new ColorHomogeneity<InputType, RegionType, WEDM>(weights));
  
    partition_type my_bpt(my_part);
    create_bpt(my_bpt, my_image, my_model_set);
    
    partition_type my_bpt2;
    string filename = string(TEST_DATA_PATH_R) + "/bpt/out_WEDM.xml";
    io::ReadWritePartition rw_bpt( filename );
    rw_bpt.read(my_bpt2);
    
    BOOST_CHECK( my_bpt == my_bpt2 );
}

BOOST_AUTO_TEST_CASE( CreateBPT_NWMC )
{     
    typedef ImageRGB<uint8> InputType;
    typedef RegionContour<Coord2D<int64> > RegionType;
    typedef Partition<RegionType> partition_type;

    ImagePartition<> my_part;
    io::ReadImage ri( string(TEST_DATA_PATH_R) + "/bpt/BPT_partition.prl" );
    ri >> my_part;
    
    InputType my_image;
    ri.open( string(TEST_DATA_PATH_R) + "/bpt/BPT_image.png" );
    ri >> my_image;
    
    
    // Compute maximum and minimum for each channel
    std::size_t sx = my_image.size_x();
    std::size_t sy = my_image.size_y();
    std::vector<uint8> curr_min(3,255);
    std::vector<uint8> curr_max(3,0);
    for (std::size_t jj=0; jj<sy; jj++)
    {
        for (std::size_t ii=0; ii<sx; ii++)
        {
            curr_max[0] = std::max(curr_max[0], my_image(0)[ii][jj]);
            curr_max[1] = std::max(curr_max[1], my_image(1)[ii][jj]);
            curr_max[2] = std::max(curr_max[2], my_image(2)[ii][jj]);
            
            curr_min[0] = std::min(curr_min[0], my_image(0)[ii][jj]);
            curr_min[1] = std::min(curr_min[1], my_image(1)[ii][jj]);
            curr_min[2] = std::min(curr_min[2], my_image(2)[ii][jj]);
        }
    }
    
    std::vector<float64> weights(3);
    
    weights[0] = 1./((float64)curr_max[0]-(float64)curr_min[0]);
    weights[1] = 1./((float64)curr_max[1]-(float64)curr_min[1]);
    weights[2] = 1./((float64)curr_max[2]-(float64)curr_min[2]);
    
    BPTModels<InputType, RegionType> my_model_set;
    my_model_set.add_model(new ColorHomogeneity<InputType, RegionType, WEDM>(weights), 0.25);
    my_model_set.add_model(new Contour<InputType, RegionType>(), 0.75);
    
    partition_type my_bpt(my_part);
    create_bpt(my_bpt, my_image, my_model_set);
    
    partition_type my_bpt2;
    string filename = string(TEST_DATA_PATH_R) + "/bpt/out_NWMC.xml";
    io::ReadWritePartition rw_bpt( filename );
    rw_bpt.read(my_bpt2);
    
    BOOST_CHECK( my_bpt == my_bpt2 );
}


BOOST_AUTO_TEST_CASE( CreateBPT_iid_bhat_un )
{   
    typedef ImageRGB<uint8> InputType;
    typedef RegionContour<Coord2D<int64> > RegionType;
    typedef Partition<RegionType> partition_type;
    
    ImagePartition<> my_part;
    io::ReadImage ri( string(TEST_DATA_PATH_R) + "/bpt/BPT_partition.prl" );
    ri >> my_part;
    
    ImageRGB<uint8> my_image;
    ri.open( string(TEST_DATA_PATH_R) + "/bpt/BPT_image.png" );
    ri >> my_image;
    
    BPTModels<InputType, RegionType> my_model_set(new ColorStatisticalIID<InputType, RegionType>(BHATTACHARYYA, UNWEIGHTED));
    my_model_set.add_model(new OutScale<InputType, RegionType>());
    
    partition_type my_bpt(my_part);
    create_bpt(my_bpt, my_image, my_model_set);
    
    
    partition_type my_bpt2;
    string filename = string(TEST_DATA_PATH_R) + "/bpt/out_iid_bhat_un.xml";
    io::ReadWritePartition rw_bpt( filename );
    rw_bpt.read(my_bpt2);
    
    BOOST_CHECK( my_bpt == my_bpt2 );
}


BOOST_AUTO_TEST_CASE( CreateBPT_iid_bhat_we )
{   
    typedef ImageRGB<uint8> InputType;
    typedef RegionContour<Coord2D<int64> > RegionType;
    typedef Partition<RegionType> partition_type;
    
    ImagePartition<> my_part;
    io::ReadImage ri( string(TEST_DATA_PATH_R) + "/bpt/BPT_partition.prl" );
    ri >> my_part;
    
    ImageRGB<uint8> my_image;
    ri.open( string(TEST_DATA_PATH_R) + "/bpt/BPT_image.png" );
    ri >> my_image;
    
    BPTModels<InputType, RegionType> my_model_set(new ColorStatisticalIID<InputType, RegionType>(BHATTACHARYYA, WEIGHTED));
    
    partition_type my_bpt(my_part);
    create_bpt(my_bpt, my_image, my_model_set);
    
    
    partition_type my_bpt2;
    string filename = string(TEST_DATA_PATH_R) + "/bpt/out_iid_bhat_we.xml";
    io::ReadWritePartition rw_bpt( filename );
    rw_bpt.read(my_bpt2);

    BOOST_CHECK( my_bpt == my_bpt2 );
}


BOOST_AUTO_TEST_CASE( CreateBPT_iid_kl_un )
{   
    typedef ImageRGB<uint8> InputType;
    typedef RegionContour<Coord2D<int64> > RegionType;
    typedef Partition<RegionType> partition_type;
    
    ImagePartition<> my_part;
    io::ReadImage ri( string(TEST_DATA_PATH_R) + "/bpt/BPT_partition.prl" );
    ri >> my_part;
    
    ImageRGB<uint8> my_image;
    ri.open( string(TEST_DATA_PATH_R) + "/bpt/BPT_image.png" );
    ri >> my_image;
    
    BPTModels<InputType, RegionType> my_model_set(new ColorStatisticalIID<InputType, RegionType>(KULLBACK_LEIBLER, UNWEIGHTED));
    my_model_set.add_model(new OutScale<InputType, RegionType>());
    
    partition_type my_bpt(my_part);
    create_bpt(my_bpt, my_image, my_model_set);
    
    
    partition_type my_bpt2;
    string filename = string(TEST_DATA_PATH_R) + "/bpt/out_iid_kl_un.xml";
    io::ReadWritePartition rw_bpt( filename );
    rw_bpt.read(my_bpt2);
    
    BOOST_CHECK( my_bpt == my_bpt2 );
}


BOOST_AUTO_TEST_CASE( CreateBPT_iid_kl_we )
{   
    typedef ImageRGB<uint8> InputType;
    typedef RegionContour<Coord2D<int64> > RegionType;
    typedef Partition<RegionType> partition_type;
    
    ImagePartition<> my_part;
    io::ReadImage ri( string(TEST_DATA_PATH_R) + "/bpt/BPT_partition.prl" );
    ri >> my_part;
    
    ImageRGB<uint8> my_image;
    ri.open( string(TEST_DATA_PATH_R) + "/bpt/BPT_image.png" );
    ri >> my_image;
    
    BPTModels<InputType, RegionType> my_model_set(new ColorStatisticalIID<InputType, RegionType>(KULLBACK_LEIBLER, WEIGHTED));
    
    partition_type my_bpt(my_part);
    create_bpt(my_bpt, my_image, my_model_set);
    
    
    partition_type my_bpt2;
    string filename = string(TEST_DATA_PATH_R) + "/bpt/out_iid_kl_we.xml";
    io::ReadWritePartition rw_bpt( filename );
    rw_bpt.read(my_bpt2);
    
    BOOST_CHECK( my_bpt == my_bpt2 );
}



BOOST_AUTO_TEST_CASE( CreateBPT_markov_bhat_un )
{   
    typedef ImageRGB<uint8> InputType;
    typedef RegionContour<Coord2D<int64> > RegionType;
    typedef Partition<RegionType> partition_type;
    
    ImagePartition<> my_part;
    io::ReadImage ri( string(TEST_DATA_PATH_R) + "/bpt/BPT_partition.prl" );
    ri >> my_part;
    
    ImageRGB<uint8> my_image;
    ri.open( string(TEST_DATA_PATH_R) + "/bpt/BPT_image.png" );
    ri >> my_image;
    
    BPTModels<InputType, RegionType> my_model_set(new ColorStatisticalMarkov<InputType, RegionType>(BHATTACHARYYA, UNWEIGHTED));
    my_model_set.add_model(new OutScale<InputType, RegionType>());
    
    partition_type my_bpt(my_part);
    create_bpt(my_bpt, my_image, my_model_set);
    
    
    partition_type my_bpt2;
    string filename = string(TEST_DATA_PATH_R) + "/bpt/out_markov_bhat_un.xml";
    io::ReadWritePartition rw_bpt( filename );
    rw_bpt.read(my_bpt2);
    
    BOOST_CHECK( my_bpt == my_bpt2 );
}


BOOST_AUTO_TEST_CASE( CreateBPT_markov_bhat_we )
{   
    typedef ImageRGB<uint8> InputType;
    typedef RegionContour<Coord2D<int64> > RegionType;
    typedef Partition<RegionType> partition_type;
       
    ImagePartition<> my_part;
    io::ReadImage ri( string(TEST_DATA_PATH_R) + "/bpt/BPT_partition.prl" );
    ri >> my_part;
       
    ImageRGB<uint8> my_image;
    ri.open( string(TEST_DATA_PATH_R) + "/bpt/BPT_image.png" );
    ri >> my_image;
       
    BPTModels<InputType, RegionType> my_model_set(new ColorStatisticalMarkov<InputType, RegionType>(BHATTACHARYYA, WEIGHTED));
    
    partition_type my_bpt(my_part);
    create_bpt(my_bpt, my_image, my_model_set);
    
    
    partition_type my_bpt2;
    string filename = string(TEST_DATA_PATH_R) + "/bpt/out_markov_bhat_we.xml";
    io::ReadWritePartition rw_bpt( filename );
    rw_bpt.read(my_bpt2);

    BOOST_CHECK( my_bpt == my_bpt2 );
}


BOOST_AUTO_TEST_CASE( CreateBPT_markov_kl_un )
{   
    typedef ImageRGB<uint8> InputType;
    typedef RegionContour<Coord2D<int64> > RegionType;
    typedef Partition<RegionType> partition_type;
    
    ImagePartition<> my_part;
    io::ReadImage ri( string(TEST_DATA_PATH_R) + "/bpt/BPT_partition.prl" );
    ri >> my_part;
    
    ImageRGB<uint8> my_image;
    ri.open( string(TEST_DATA_PATH_R) + "/bpt/BPT_image.png" );
    ri >> my_image;
    
    BPTModels<InputType, RegionType> my_model_set(new ColorStatisticalMarkov<InputType, RegionType>(KULLBACK_LEIBLER, UNWEIGHTED));
    my_model_set.add_model(new OutScale<InputType, RegionType>());
    
    partition_type my_bpt(my_part);
    create_bpt(my_bpt, my_image, my_model_set);
    
    
    partition_type my_bpt2;
    string filename = string(TEST_DATA_PATH_R) + "/bpt/out_markov_kl_un.xml";
    io::ReadWritePartition rw_bpt( filename );
    rw_bpt.read(my_bpt2);
    
    BOOST_CHECK( my_bpt == my_bpt2 );
}


BOOST_AUTO_TEST_CASE( CreateBPT_markov_kl_we )
{   
    typedef ImageRGB<uint8> InputType;
    typedef RegionContour<Coord2D<int64> > RegionType;
    typedef Partition<RegionType> partition_type;
       
    ImagePartition<> my_part;
    io::ReadImage ri( string(TEST_DATA_PATH_R) + "/bpt/BPT_partition.prl" );
    ri >> my_part;
       
    ImageRGB<uint8> my_image;
    ri.open( string(TEST_DATA_PATH_R) + "/bpt/BPT_image.png" );
    ri >> my_image;
       
    BPTModels<InputType, RegionType> my_model_set(new ColorStatisticalMarkov<InputType, RegionType>(KULLBACK_LEIBLER, WEIGHTED));
    
    partition_type my_bpt(my_part);
    create_bpt(my_bpt, my_image, my_model_set);
    
    
    partition_type my_bpt2;
    string filename = string(TEST_DATA_PATH_R) + "/bpt/out_markov_kl_we.xml";
    io::ReadWritePartition rw_bpt( filename );
    rw_bpt.read(my_bpt2);

    BOOST_CHECK( my_bpt == my_bpt2 );
 }


//++++++++++++++++++++


BOOST_AUTO_TEST_CASE( CreateBPT_iid_bhat_un_ash )
{   
    typedef ImageRGB<uint8> InputType;
    typedef RegionContour<Coord2D<int64> > RegionType;
    typedef Partition<RegionType> partition_type;
    
    ImagePartition<> my_part;
    io::ReadImage ri( string(TEST_DATA_PATH_R) + "/bpt/BPT_partition.prl" );
    ri >> my_part;
    
    ImageRGB<uint8> my_image;
    ri.open( string(TEST_DATA_PATH_R) + "/bpt/BPT_image.png" );
    ri >> my_image;
    
    BPTModels<InputType, RegionType> my_model_set(new ColorStatisticalIID<InputType, RegionType>(BHATTACHARYYA, UNWEIGHTED, 256, 40));
    my_model_set.add_model(new OutScale<InputType, RegionType>());
    
    partition_type my_bpt(my_part);
    create_bpt(my_bpt, my_image, my_model_set);
    
    
    partition_type my_bpt2;
    string filename = string(TEST_DATA_PATH_R) + "/bpt/out_iid_bhat_un_ash.xml";
    io::ReadWritePartition rw_bpt( filename );
    rw_bpt.read(my_bpt2);
    
    BOOST_CHECK( my_bpt == my_bpt2 );
}


BOOST_AUTO_TEST_CASE( CreateBPT_iid_bhat_we_ash )
{   
    typedef ImageRGB<uint8> InputType;
    typedef RegionContour<Coord2D<int64> > RegionType;
    typedef Partition<RegionType> partition_type;
   
    ImagePartition<> my_part;
    io::ReadImage ri( string(TEST_DATA_PATH_R) + "/bpt/BPT_partition.prl" );
    ri >> my_part;
   
    ImageRGB<uint8> my_image;
    ri.open( string(TEST_DATA_PATH_R) + "/bpt/BPT_image.png" );
    ri >> my_image;
   
    BPTModels<InputType, RegionType> my_model_set(new ColorStatisticalIID<InputType, RegionType>(BHATTACHARYYA, WEIGHTED, 256, 40));
   
    partition_type my_bpt(my_part);
    create_bpt(my_bpt, my_image, my_model_set);
   
   
    partition_type my_bpt2;
    string filename = string(TEST_DATA_PATH_R) + "/bpt/out_iid_bhat_we_ash.xml";
    io::ReadWritePartition rw_bpt( filename );
    rw_bpt.read(my_bpt2);

    BOOST_CHECK( my_bpt == my_bpt2 );
}


BOOST_AUTO_TEST_CASE( CreateBPT_iid_kl_un_ash )
{   
    typedef ImageRGB<uint8> InputType;
    typedef RegionContour<Coord2D<int64> > RegionType;
    typedef Partition<RegionType> partition_type;
    
    ImagePartition<> my_part;
    io::ReadImage ri( string(TEST_DATA_PATH_R) + "/bpt/BPT_partition.prl" );
    ri >> my_part;
    
    ImageRGB<uint8> my_image;
    ri.open( string(TEST_DATA_PATH_R) + "/bpt/BPT_image.png" );
    ri >> my_image;
    
    BPTModels<InputType, RegionType> my_model_set(new ColorStatisticalIID<InputType, RegionType>(KULLBACK_LEIBLER, UNWEIGHTED, 256, 40));
    my_model_set.add_model(new OutScale<InputType, RegionType>());
    
    partition_type my_bpt(my_part);
    create_bpt(my_bpt, my_image, my_model_set);
    
    
    partition_type my_bpt2;
    string filename = string(TEST_DATA_PATH_R) + "/bpt/out_iid_kl_un_ash.xml";
    io::ReadWritePartition rw_bpt( filename );
    rw_bpt.read(my_bpt2);
    
    BOOST_CHECK( my_bpt == my_bpt2 );
}


BOOST_AUTO_TEST_CASE( CreateBPT_iid_kl_we_ash )
{   
    typedef ImageRGB<uint8> InputType;
    typedef RegionContour<Coord2D<int64> > RegionType;
    typedef Partition<RegionType> partition_type;
   
    ImagePartition<> my_part;
    io::ReadImage ri( string(TEST_DATA_PATH_R) + "/bpt/BPT_partition.prl" );
    ri >> my_part;
   
    ImageRGB<uint8> my_image;
    ri.open( string(TEST_DATA_PATH_R) + "/bpt/BPT_image.png" );
    ri >> my_image;
   
    BPTModels<InputType, RegionType> my_model_set(new ColorStatisticalIID<InputType, RegionType>(KULLBACK_LEIBLER, WEIGHTED, 256, 40));
   
    partition_type my_bpt(my_part);
    create_bpt(my_bpt, my_image, my_model_set);
   
   
    partition_type my_bpt2;
    string filename = string(TEST_DATA_PATH_R) + "/bpt/out_iid_kl_we_ash.xml";
    io::ReadWritePartition rw_bpt( filename );
    rw_bpt.read(my_bpt2);
   
    BOOST_CHECK( my_bpt == my_bpt2 );
}


BOOST_AUTO_TEST_CASE( CreateBPT_markov_bhat_un_ash )
{   
#ifdef MSVC
    BOOST_WARN_MESSAGE(false, "CreateBPT_markov_bhat_un_ash DISABLED BECAUSE IT NEEDS TOO MUCH MEMORY (>6GB)");
#else
    typedef ImageRGB<uint8> InputType;
    typedef RegionContour<Coord2D<int64> > RegionType;
    typedef Partition<RegionType> partition_type;
    
    ImagePartition<> my_part;
    io::ReadImage ri( string(TEST_DATA_PATH_R) + "/bpt/BPT_partition.prl" );
    ri >> my_part;
    
    ImageRGB<uint8> my_image;
    ri.open( string(TEST_DATA_PATH_R) + "/bpt/BPT_image.png" );
    ri >> my_image;
    
    BPTModels<InputType, RegionType> my_model_set(new ColorStatisticalMarkov<InputType, RegionType>(BHATTACHARYYA, UNWEIGHTED, 256, 40));
    my_model_set.add_model(new OutScale<InputType, RegionType>());
    
    partition_type my_bpt(my_part);
    create_bpt(my_bpt, my_image, my_model_set);
    
    
    partition_type my_bpt2;
    string filename = string(TEST_DATA_PATH_R) + "/bpt/out_markov_bhat_un_ash.xml";
    io::ReadWritePartition rw_bpt( filename );
    rw_bpt.read(my_bpt2);
    
    BOOST_CHECK( my_bpt == my_bpt2 );
#endif //MSVC
}


BOOST_AUTO_TEST_CASE( CreateBPT_markov_bhat_we_ash )
{
#ifdef MSVC
    BOOST_WARN_MESSAGE(false, "CreateBPT_markov_bhat_we_ash DISABLED BECAUSE IT NEEDS TOO MUCH MEMORY (>6GB)");
#else
    typedef ImageRGB<uint8> InputType;
    typedef RegionContour<Coord2D<int64> > RegionType;
    typedef Partition<RegionType> partition_type;
   
    ImagePartition<> my_part;
    io::ReadImage ri( string(TEST_DATA_PATH_R) + "/bpt/BPT_partition.prl" );
    ri >> my_part;
   
    ImageRGB<uint8> my_image;
    ri.open( string(TEST_DATA_PATH_R) + "/bpt/BPT_image.png" );
    ri >> my_image;
   
    BPTModels<InputType, RegionType> my_model_set(new ColorStatisticalMarkov<InputType, RegionType>(BHATTACHARYYA, WEIGHTED, 256, 40));
   
    partition_type my_bpt(my_part);
    create_bpt(my_bpt, my_image, my_model_set);
   
    partition_type my_bpt2;
    string filename = string(TEST_DATA_PATH_R) + "/bpt/out_markov_bhat_we_ash.xml";
    io::ReadWritePartition rw_bpt( filename );
    rw_bpt.read(my_bpt2);
    
    BOOST_CHECK( my_bpt == my_bpt2 );
#endif //MSVC
}


BOOST_AUTO_TEST_CASE( CreateBPT_markov_kl_un_ash )
{   
#ifdef MSVC
    BOOST_WARN_MESSAGE(false, "CreateBPT_markov_kl_un_ash DISABLED BECAUSE IT NEEDS TOO MUCH MEMORY (>6GB)");
#else
    typedef ImageRGB<uint8> InputType;
    typedef RegionContour<Coord2D<int64> > RegionType;
    typedef Partition<RegionType> partition_type;
    
    ImagePartition<> my_part;
    io::ReadImage ri( string(TEST_DATA_PATH_R) + "/bpt/BPT_partition.prl" );
    ri >> my_part;
    
    ImageRGB<uint8> my_image;
    ri.open( string(TEST_DATA_PATH_R) + "/bpt/BPT_image.png" );
    ri >> my_image;
    
    BPTModels<InputType, RegionType> my_model_set(new ColorStatisticalMarkov<InputType, RegionType>(KULLBACK_LEIBLER, UNWEIGHTED, 256, 40));
    my_model_set.add_model(new OutScale<InputType, RegionType>());
    
    partition_type my_bpt(my_part);
    create_bpt(my_bpt, my_image, my_model_set);
    
    partition_type my_bpt2;
    string filename = string(TEST_DATA_PATH_R) + "/bpt/out_markov_kl_un_ash.xml";
    io::ReadWritePartition rw_bpt( filename );
    rw_bpt.read(my_bpt2);
    
    BOOST_CHECK( my_bpt == my_bpt2 );
#endif //MSVC
}


BOOST_AUTO_TEST_CASE( CreateBPT_markov_kl_we_ash )
{   
#ifdef MSVC
    BOOST_WARN_MESSAGE(false, "CreateBPT_markov_kl_we_ash DISABLED BECAUSE IT NEEDS TOO MUCH MEMORY (>6GB)");
#else
    typedef ImageRGB<uint8> InputType;
    typedef RegionContour<Coord2D<int64> > RegionType;
    typedef Partition<RegionType> partition_type;
   
    ImagePartition<> my_part;
    io::ReadImage ri( string(TEST_DATA_PATH_R) + "/bpt/BPT_partition.prl" );
    ri >> my_part;
   
    ImageRGB<uint8> my_image;
    ri.open( string(TEST_DATA_PATH_R) + "/bpt/BPT_image.png" );
    ri >> my_image;
   
    BPTModels<InputType, RegionType> my_model_set(new ColorStatisticalMarkov<InputType, RegionType>(KULLBACK_LEIBLER, WEIGHTED, 256, 40));
   
    partition_type my_bpt(my_part);
    create_bpt(my_bpt, my_image, my_model_set);
   
   
    partition_type my_bpt2;
    string filename = string(TEST_DATA_PATH_R) + "/bpt/out_markov_kl_we_ash.xml";
    io::ReadWritePartition rw_bpt( filename );
    rw_bpt.read(my_bpt2);
    
    BOOST_CHECK( my_bpt == my_bpt2 );
#endif //MSVC
}

BOOST_AUTO_TEST_CASE(CreateBPT_from_pixel_NON_LOCAL_MEANS_EMD)
{
	typedef ImageRGB<uint8> InputType;
	typedef RegionContour<Coord2D<int64> > RegionType;
	typedef Partition<RegionType> partition_type;
	
	ImageRGB<uint8> my_image;
	io::ReadImage ri( string(TEST_DATA_PATH_R) + "/bpt/bpt_image_nlm.png" );
	ri >> my_image;

    const FlatZone& my_part = calc_descriptor(new FlatZone(), my_image);

	
	// This test may last several seconds
	BPTModels<InputType, RegionType> my_model_set(new ColorStatisticalNLM<InputType, RegionType>()); // Testing with EMD distance and 64 bins

	partition_type my_bpt(my_part);
	create_bpt(my_bpt, my_image, my_model_set);

	partition_type my_bpt2;
	string filename = string(TEST_DATA_PATH_R) + "/bpt/out_NLM_EMD.xml";
	io::ReadWritePartition rw_bpt( filename );
	rw_bpt.read(my_bpt2);

	BOOST_CHECK( my_bpt == my_bpt2 );
	
}

BOOST_AUTO_TEST_CASE(CreateBPT_from_pixel_NON_LOCAL_MEANS_BHAT)
{
	typedef ImageRGB<uint8> InputType;
	typedef RegionContour<Coord2D<int64> > RegionType;
	typedef Partition<RegionType> partition_type;
	
	ImageRGB<uint8> my_image;
	io::ReadImage ri( string(TEST_DATA_PATH_R) + "/bpt/bpt_image_nlm.png" );
	ri >> my_image;

    const FlatZone& my_part = calc_descriptor(new FlatZone(), my_image);
	
	// This test may last several seconds
	BPTModels<InputType, RegionType> my_model_set(new ColorStatisticalNLM<InputType, RegionType>(BHATTACHARYYA, WEIGHTED, 256)); // Testing with EMD distance and 64 bins

	partition_type my_bpt(my_part);
	create_bpt(my_bpt, my_image, my_model_set);

	partition_type my_bpt2;
	string filename = string(TEST_DATA_PATH_R) + "/bpt/out_NLM_BHAT.xml";
	io::ReadWritePartition rw_bpt( filename );
	rw_bpt.read(my_bpt2);

	BOOST_CHECK( my_bpt == my_bpt2 );
}

#endif

BOOST_AUTO_TEST_SUITE_END ();


// //Piece of code to write the correct result once
// std::vector<std::string> uri_names;
// std::vector<std::string> uri_values;
// uri_names.push_back("ImageFile");
// uri_values.push_back("BPT_image.png");
// uri_names.push_back("PartitionSearchFile");
// uri_values.push_back("BPT_partition.prl");
// filename = string(TEST_DATA_PATH_R) + "/bpt/out_true.xml";
// io::ReadWritePartition write_bpt(filename, uri_names, uri_values, io::DO_NOT_CHECK_IMAGE_PART);
// write_bpt.write(my_bpt);
