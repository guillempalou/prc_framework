// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------

//!
//!  \file annotation.cpp
//!
//!  Annotation
//!

#include <string>

#include <boost/foreach.hpp>
#include <boost/lexical_cast.hpp>

#include <imageplus/core.hpp>
#include <imageplus/semantic/annotatedsemanticclass.hpp>
#include <imageplus/semantic/annotation.hpp>
#include <imageplus/semantic/ontology.hpp>

using namespace imageplus::semantic;

void imageplus::semantic::Annotation::set_ontology(const Ontology& o)
{
	_ontology = o;
}

const Ontology& imageplus::semantic::Annotation::get_ontology() const
{
	return _ontology;
}

AnnotatedSemanticClass& imageplus::semantic::Annotation::annotate(uint32 sc_id) throw (ImagePlusError)
{
	if(!_ontology.includes_semantic_class(sc_id)) {
		std::string semantic_class = boost::lexical_cast<std::string>(sc_id);
		throw ImagePlusError("Semantic Class '" + semantic_class + "' is not defined in '" + _ontology.get_name() + "' ontology.");
	}

	// Get or add the annotated semantic class for the given semantic class id
	Annotation::ASCSType::value_type new_asc(sc_id, AnnotatedSemanticClass(sc_id));
	return _annotated_semantic_classes.insert(_annotated_semantic_classes.begin(), new_asc)->second;
}

bool imageplus::semantic::Annotation::semantic_class_is_annotated(uint32 sc_id) const
{
	return _annotated_semantic_classes.find(sc_id) != _annotated_semantic_classes.end();
}

const AnnotatedSemanticClass& imageplus::semantic::Annotation::get_annotated_semantic_class(uint32 sc_id) const throw (ImagePlusError)
{
	Annotation::ASCConstIterator asc = _annotated_semantic_classes.find(sc_id);
	if (asc == _annotated_semantic_classes.end()) {
		std::string semantic_class = _ontology.get_semantic_class_name(sc_id);
		throw ImagePlusError("Semantic Class '" + semantic_class + "' is not annotated in this annotation.");
	}
	return asc->second;
}

Annotation::iterator imageplus::semantic::Annotation::begin() {
	return boost::make_transform_iterator(_annotated_semantic_classes.begin(),
			&get_value<Annotation::ASCSType::key_type,
					Annotation::ASCSType::mapped_type>);
}

Annotation::iterator imageplus::semantic::Annotation::end() {
	return boost::make_transform_iterator(_annotated_semantic_classes.end(),
			&get_value<Annotation::ASCSType::key_type,
					Annotation::ASCSType::mapped_type>);
}

Annotation::const_iterator imageplus::semantic::Annotation::begin() const {
	return boost::make_transform_iterator(_annotated_semantic_classes.begin(),
			&get_value<Annotation::ASCSType::key_type,
					Annotation::ASCSType::mapped_type> );
}

Annotation::const_iterator imageplus::semantic::Annotation::end() const {
	return boost::make_transform_iterator(_annotated_semantic_classes.end(),
			&get_value<Annotation::ASCSType::key_type,
					Annotation::ASCSType::mapped_type>);
}

std::ostream& imageplus::semantic::operator<<(std::ostream &os, const Annotation& a)
{
	os << "@@@ Annotation @@@" << std::endl;

	os << "> Annotated Ontology:" << std::endl;
	os << a._ontology << std::endl;

	os << "> Annotated Semantic Classes:" << std::endl;
	BOOST_FOREACH(const AnnotatedSemanticClass& asc, a)
		os << asc << std::endl;

	os << "@@@ End of Annotation @@@" << std::endl;
	return os;
}
