/*
 * image_test.cpp
 *
 *  Created on: Sep 5, 2012
 *      Author: guillem
 */

#include <imageplus/core/image_signal.hpp>
#include <imageplus/core/video_signal.hpp>
#include <imageplus/core/colorspace_converter.hpp>

#include <imageplus/optical_flow/flow_io.hpp>
#include <imageplus/optical_flow/occlusions/photo_consistency_error.hpp>
#include <imageplus/optical_flow/occlusions/flow_variation_error.hpp>
#include <imageplus/optical_flow/occlusions/reverse_endpoint_error.hpp>
#include <imageplus/optical_flow/occlusions/reverse_angle_error.hpp>
#include <imageplus/optical_flow/occlusions/bijective_error.hpp>

#include <boost/filesystem.hpp>
#include <imageplus/toolbox/tictoc.hpp>
#include <iostream>
#include <iomanip>

using namespace imageplus;

#define uint64 imageplus::uint64

typedef VideoSignal<float64,3> 																		VideoType;
typedef VideoSignal<float64,3>::ImageType															FrameType;
typedef VideoSignal<float64,2>																		OpticalFlowType;
typedef OpticalFlowType::ImageType																	OpticalFlowFrame;


typedef VideoType::coord_type 																		coord3d;

// The vector is of the same type
typedef VideoType::value_type																		lab_type;
typedef VideoType::value_type																		rgb_type;

FrameType convert_map_to_image(ImageSignal<float64,1>& s) {
	typedef ImageSignal<float64,1>::coord_type 	coord2d;
	FrameType res(s.sizes());
	for (ImageSignal<float64,1>::iterator p = s.begin(); p!=s.end(); ++p) {
		coord2d pos = p.pos();
		float64 value = (*p)(0);
		res(pos) = value*rgb_type(255,255,255);
	}

	return res;
}

int main(int argc, char* argv[]) {

	uint64 start = atoi(argv[1]);
	uint64 end = atoi(argv[2]);

	std::string path = argv[3];
	std::string result = argv[4];

	uint64 K = end+1;
	uint64 step = K;

	// create the necessary paths
	boost::filesystem::path result_path(result);
	boost::filesystem::create_directory(result_path);
	boost::filesystem::create_directory(result_path / "photo_consistency");
	boost::filesystem::create_directory(result_path / "reverse_endpoint");
	boost::filesystem::create_directory(result_path / "reverse_angle");
	boost::filesystem::create_directory(result_path / "flow_variation");
	boost::filesystem::create_directory(result_path / "bijectivity");

	//boost::filesystem::create_directory(p / "trees");

	//The algorithm assumes that the directory is structured
	// BasePath /
	//			/Frames/frame000.png ...
	//  		/Flows/flow_0_1.png
	for (uint64 i = start; i <= end; i+=step) {
		uint64 Nframes = std::min(K, end-i+1);

		VideoType video(Nframes);

		//Read frames
		for (uint64 k = i; k < Nframes; k++) {
			std::ostringstream os;
			os << path << "/frames/frame" << std::setw(3) << std::setfill('0') << k << ".png";
			video.read_frame(os.str(),k-i); // read frame k and put it to the position k-i of the current block
		}
		ColorSpaceConverter<VideoType> converter;
		converter.convert(video, ColorSpaceLAB);

		uint64 sx = video.size_x();
		uint64 sy = video.size_y();

		OpticalFlowType forward_flows(sx,sy,Nframes);
		OpticalFlowType backward_flows(sx,sy,Nframes);

		// Read forward optical flows
		for (uint64 k = i; k < Nframes-1; k++) {
			std::ostringstream os;
			os << path << "/flows/flow_" << k << "_" << k+1 << ".flo";
			OpticalFlowFrame flow = forward_flows.frame(k-i);
			optical_flow::read_optical_flow(flow, os.str());  // read flow k,k+1 and put it to the position k-i of the current block
			std::cout << "read forward " << k-i << std::endl;
		}

		// Read backward optical flows
		for (uint64 k = i+1; k < Nframes; k++) {
			std::ostringstream os;
			os << path << "/flows/flow_" << k << "_" << k-1 << ".flo";
			OpticalFlowFrame flow = backward_flows.frame(k-i);
			optical_flow::read_optical_flow(flow, os.str()); // read flow k,k-1 and put it to the position k-i of the current block
			std::cout << "read backward " << k-i << std::endl;
		}

		for (uint64 k = i; k < Nframes-1; k++) {
			std::ostringstream os;
			FrameType img1(video.frame(k-i));
			FrameType img2(video.frame(k-i+1));
			OpticalFlowFrame fwd(forward_flows.frame(k-i));
			OpticalFlowFrame bkwd(backward_flows.frame(k-i+1));

			//std::cout << fwd.lower_point().transpose() << " " << forward_flows.frame(k-i).lower_point().transpose() << std::endl;
			//exit(0);

			ImageSignal<float64,1> photo 	= optical_flow::photo_consistency_error(img1,img2,fwd);
			ImageSignal<float64,1> var 		= optical_flow::flow_variation_error(fwd);
			ImageSignal<float64,1> ep		= optical_flow::reverse_endpoint_error(fwd,bkwd);
			ImageSignal<float64,1> epa		= optical_flow::reverse_angle_error(fwd,bkwd);
			ImageSignal<float64,1> bij		= optical_flow::bijective_error(img1,img2,fwd);

			ImageSignal<float64,3> photo_img = convert_map_to_image(photo);
			ImageSignal<float64,3> var_img = convert_map_to_image(var);
			ImageSignal<float64,3> ep_img = convert_map_to_image(ep);
			ImageSignal<float64,3> epa_img = convert_map_to_image(epa);
			ImageSignal<float64,3> bij_img = convert_map_to_image(bij);

			os << result_path.string() << "/photo_consistency/" << std::setw(5) << std::setfill('0') << k << ".png"; photo_img.write(os.str()); os.str("");
			os << result_path.string() << "/flow_variation/" << std::setw(5) << std::setfill('0') << k << ".png"; var_img.write(os.str()); os.str("");
			os << result_path.string() << "/reverse_endpoint/" << std::setw(5) << std::setfill('0') << k << ".png"; ep_img.write(os.str()); os.str("");
			os << result_path.string() << "/reverse_angle/" << std::setw(5) << std::setfill('0') << k << ".png"; epa_img.write(os.str()); os.str("");
			os << result_path.string() << "/bijectivity/" << std::setw(5) << std::setfill('0') << k << ".png"; bij_img.write(os.str()); os.str("");

		}
	}

}
