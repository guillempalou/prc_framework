// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------

//! 
//! \file linear_convolution.test
//!
//! Tests for class LinearConvolution
//!


#include <iostream>
#include <typeinfo>

#include <imageplus/core.hpp>
#include <imageplus/io/readimage.hpp>
#include <imageplus/io/writeimage.hpp>
#include <imageplus/filters/linear_convolution.hpp>

BOOST_AUTO_TEST_SUITE ( LinearConvolutionSuite );

using namespace imageplus;
using namespace imageplus::io;
using namespace imageplus::filters;
using namespace std;

typedef boost::mpl::list<uint8,int64,float64> DataTypes;

BOOST_AUTO_TEST_CASE_TEMPLATE ( Convolution_by_Delta_Gray, T, DataTypes )
{
#if 0
    MultiArray<float64,2> kernel(5,5);

    kernel       = 0.0;
	kernel[2][2] = 1.0;


	LinearConvolution lc(kernel);

	ImageGray<T> in(10,10), out(10,10);

	for (size_t y=0; y<10; ++y)
    for (size_t x=0; x<10; ++x)
    {
        if (typeid(T)==typeid(uint8))
        {
            in[x][y]=static_cast<T>(255.0*rand()/RAND_MAX);
        }
        else
        {
            in[x][y]=static_cast<T>(pow(2.0,63.0)*(rand()/RAND_MAX-0.5));
        }
    }	

	out = lc.filter(in);

	BOOST_CHECK(in==out); 	 
#endif


    MultiArray<float64,2> k2(3,3);
	k2[0][0] =  1.0;
	k2[1][0] =  0.0;
	k2[2][0] = -1.0;
	k2[0][1] =  1.0;
	k2[1][1] =  0.0;
	k2[2][1] = -1.0;
	k2[0][2] =  1.0;
	k2[1][2] =  0.0;
	k2[2][2] = -1.0;

	MultiArray<int64,2> in2(3,3), out2;

    in2[0][0] = 1;
    in2[1][0] = 2;
    in2[2][0] = 3;
    in2[0][1] = 4;
    in2[1][1] = 5;
    in2[2][1] = 6;
    in2[0][2] = 7;
    in2[1][2] = 8;
    in2[2][2] = 9;

	LinearConvolution lc2(k2);

	out2 = lc2.filter(in2);

//    std::cout << "Interpolation" << std::endl;
//    std::cout << out2 << std::endl;
//    std::cout << "-------------" << std::endl;

}

#if 0
BOOST_AUTO_TEST_CASE ( Convolution_by_Delta_Gray_float)
{
	MultiArray<float64,2> kernel(5,5); 

    kernel       = 0.0;
	kernel[2][2] = 1.0;

	LinearConvolution lc(kernel);

	ImageGray<float64> in(10,10), out(10,10);

	for (size_t y=0; y<10; ++y)
    for (size_t x=0; x<10; ++x)
	{
        in[x][y]=rand()/RAND_MAX;
    }

	out = lc.filter(in);

	BOOST_CHECK(in == out); 
	 
}
#endif
BOOST_AUTO_TEST_CASE ( Convolution_Exception )
{
	MultiArray<float64,2> kernel(4,4);

	BOOST_CHECK_THROW(LinearConvolution lc(kernel), ImagePlusError);
}


BOOST_AUTO_TEST_CASE ( Kernel_constructors )
{
	Kernel<1> my_kernel;
	
	BOOST_CHECK_EQUAL(my_kernel.size(),        (std::size_t)1 );
	BOOST_CHECK_EQUAL(my_kernel.border_size(), (std::size_t)0 );
	BOOST_CHECK_EQUAL(my_kernel[0],                         1.);
	
	
	Kernel<1> my_kernel2(3);
	
	BOOST_CHECK_EQUAL(my_kernel2.size(),        (std::size_t)7);
	BOOST_CHECK_EQUAL(my_kernel2.border_size(), (std::size_t)3);
	BOOST_CHECK_EQUAL(my_kernel2[-3], 0.);
	BOOST_CHECK_EQUAL(my_kernel2[-2], 0.);
	BOOST_CHECK_EQUAL(my_kernel2[-1], 0.);
	BOOST_CHECK_EQUAL(my_kernel2[ 0], 0.);
	BOOST_CHECK_EQUAL(my_kernel2[ 1], 0.);
	BOOST_CHECK_EQUAL(my_kernel2[ 2], 0.);
	BOOST_CHECK_EQUAL(my_kernel2[ 3], 0.);
}

BOOST_AUTO_TEST_CASE( separable_linear_convolution_2d_test )
{

	MultiArray<float,2> input(5,3);
	MultiArray<float,2> output;
	input[0][0]= 0; input[1][0] = 0; input[2][0]= 0; input[3][0] = 0; input[4][0]=0;
	input[0][1]= 0; input[1][1] = 1; input[2][1]= 0; input[3][1] = 0; input[4][1]=0;
	input[0][2]= 0; input[1][2] = 0; input[2][2]= 3; input[3][2] = 0; input[4][2]=1;


	filters::Kernel<1> k1(1); /* Half size of the kernel is 1 */
	k1[-1] = 1.0/4.0;
	k1[ 0] = 2.0/4.0;
	k1[ 1] = 1.0/4.0;

	filters::Kernel<1> k2(1); /* Half size of the kernel is 1 */
	k2[-1] = 1.0/4.0;
	k2[ 0] = 2.0/4.0;
	k2[ 1] = 1.0/4.0;

	filters::SeparableLinearConvolution2D conv(k1);
	conv.calculate(input,output);

	BOOST_CHECK_EQUAL(output.dims(0), input.dims(0));
	BOOST_CHECK_EQUAL(output.dims(1), input.dims(1));

	BOOST_CHECK_EQUAL(output[0][0], 0.0625);
	BOOST_CHECK_EQUAL(output[1][0], 0.125);
	BOOST_CHECK_EQUAL(output[2][0], 0.0625);
	BOOST_CHECK_EQUAL(output[3][0], 0.0);
	BOOST_CHECK_EQUAL(output[4][0], 0.0);
	BOOST_CHECK_EQUAL(output[0][1], 0.125);
	BOOST_CHECK_EQUAL(output[1][1], 0.4375);
	BOOST_CHECK_EQUAL(output[2][1], 0.5);
	BOOST_CHECK_EQUAL(output[3][1], 0.25);
	BOOST_CHECK_EQUAL(output[4][1], 0.125);
	BOOST_CHECK_EQUAL(output[0][2], 0.0625);
	BOOST_CHECK_EQUAL(output[1][2], 0.5);
	BOOST_CHECK_EQUAL(output[2][2], 0.8125);
	BOOST_CHECK_EQUAL(output[3][2], 0.5);
	BOOST_CHECK_EQUAL(output[4][2], 0.25);

	filters::SeparableLinearConvolution2D conv2(k1,k2);
	conv2.calculate(input,output);

	BOOST_CHECK_EQUAL(output.dims(0), input.dims(0));
	BOOST_CHECK_EQUAL(output.dims(1), input.dims(1));

	BOOST_CHECK_EQUAL(output[0][0], 0.0625);
	BOOST_CHECK_EQUAL(output[1][0], 0.125);
	BOOST_CHECK_EQUAL(output[2][0], 0.0625);
	BOOST_CHECK_EQUAL(output[3][0], 0.0);
	BOOST_CHECK_EQUAL(output[4][0], 0.0);
	BOOST_CHECK_EQUAL(output[0][1], 0.125);
	BOOST_CHECK_EQUAL(output[1][1], 0.4375);
	BOOST_CHECK_EQUAL(output[2][1], 0.5);
	BOOST_CHECK_EQUAL(output[3][1], 0.25);
	BOOST_CHECK_EQUAL(output[4][1], 0.125);
	BOOST_CHECK_EQUAL(output[0][2], 0.0625);
	BOOST_CHECK_EQUAL(output[1][2], 0.5);
	BOOST_CHECK_EQUAL(output[2][2], 0.8125);
	BOOST_CHECK_EQUAL(output[3][2], 0.5);
	BOOST_CHECK_EQUAL(output[4][2], 0.25);



}









BOOST_AUTO_TEST_SUITE_END ();
