// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------

//!
//!  \file derivative.hpp
//!
//!  \brief Interface for derivative routines
//!

#ifndef IMAGEPLUS_MATH_NUMERIC_DERIVATIVE_HPP
#define IMAGEPLUS_MATH_NUMERIC_DERIVATIVE_HPP


#include <imageplus/core.hpp>
#include <imageplus/math/numeric/lu_decomposition.hpp>


namespace imageplus
{
    namespace math
    {
        namespace numeric
        {
            //! \brief Default epsilon
            const float64 BIGEPS= 1.0e-4;
            //!
            //! \brief 1-D Derivative for a Multiarray with function samples .
            //!
            //! \author Adolfo López <alopez@gps.tsc.upc.edu>
            //!
            //! \date 13-02-2008
            //!
            //! Derivative computes \f$ df/dx \f$ given the x samples and its corresponding values in the function
            //! which are stored in fvec.
            //!
            //! \f$ f(x)=x^2 \f$
            //! \code
            //!   
            //!  void f(float64 x, float64 *y)
            //!  {
            //!   (*y)=x*x;  
            //!  }
            //!
            //!  ******
            //!  //ten samples
            //!  MultiArray<float64,1> x(10);
            //!  MultiArray<float64,1> dx;
            //!  MultiArray<float64,1> fvec(10);
            //!
            //!  //Evaluation of the samples with the function f
            //!  for (uint64 i=0; i<10; i++)
            //!  {
            //!   x[i]=i;
            //!  }
            //!
            //!  dx=derivative(x, f);
            //! \endcode
            //!
            //! \param[in] x : Samples of the independent variable of the function.
            //! \param[in] function : The function that is going to be derivated. This parameter is a C function defined as
            //! void function(float64, float64*), where the first term is a single sample of x and the second is the returned
            //! value of the function in x (f(x)).
            //!
            //! \return a MultiArray vector with the result of the derivative
            //!
            MultiArray<float64,1> derivative(MultiArray<float64,1> x, void (*function)(float64, float64*));
            
            //!
            //! \brief N-Dimensional Jacobian with forward difference approximation .
            //!
            //! \author Adolfo López <alopez@gps.tsc.upc.edu>
            //!
            //! \date 13-02-2008
            //!
            //! The function computes the Jacobian matrix defined as:
            //!
            //! \f$ \frac{df_1}{dx_1} \frac{df_1}{dx_2} ... \frac{df_1}{dx_N}\f$ \n 
            //! \f$ \frac{df_2}{dx_1} \frac{df_2}{dx_2} ... \frac{df_2}{dx_N}\f$ \n
            //! \f$ \frac{df_M}{dx_1} \frac{df_M}{dx_2} ... \frac{df_M}{dx_N}\f$ \n 
            //!
            //! The resulting matrix is a Multiarray<float64,2> (m,n) where n is the dimensionality of the output space and
            //! n is the input space \f$ R^n-> R^m \f$.    
            //!
            //! \code
            //!  void fa(Point x, Point *f)
            //!  {
            //!   //R²->R³ function
            //!   // f(x,y)=(x²-2x+1,x+3y,xy)
            //!   (*f)(0)=x(0)*x(0)-2*x(0)+1;
            //!   (*f)(1)=3*x(1)+x(0);
            //!   (*f)(2)=x(1)*x(0);
            //!  }
            //!
            //!  ****
            //!
            //!  Point2D r;
            //!  Point3D func3;
            //!  MultiArray<float64,2> jcb3(3,2);
            //!
            //!  r(0)=2; //x=2
            //!  r(1)=1; //y=1
            //!
            //!  fa(r,&func3);
            //!
            //!  jcb3=fd_jacobian(r,func3, fa);
            //!
            //! \endcode
            //! \param[in] x : Samples of the N-dimensional independent variable.
            //! \param[in] fvec : M-dimensional evaluated sample of x (\f$ f(x) \f$).
            //! \param[in] function : The function \f$ R^n-> R^m \f$ which jacobian is going to be computed .
            //! This parameter is a C function defined as
            //! void function(Point, Point*), where the first term is a single sample of x and the second is the returned
            //! value of the function in x (\f$ f(x) \f$).
            //!
            //! \return a MultiArray matrix with the result (see complete description on how to declare this MultiArray).
            //!
            template < std::size_t N, std::size_t M >
            MultiArray<float64,2> fd_jacobian(Point<N> x, Point<M> fvec, void (*function)(Point<N> , Point<M>*));
            
            
            
            
            //!
            //! \brief N-Dimensional Jacobian with forward difference approximation .
            //!
            //! \author Adolfo López <alopez@gps.tsc.upc.edu>
            //!
            //! \date 13-02-2008
            //!
            //! The function computes the Jacobian matrix defined as:
            //!
            //! \f$ \frac{df_1}{dx_1} \frac{df_1}{dx_2} ... \frac{df_1}{dx_N}\f$ \n 
            //! \f$ \frac{df_2}{dx_1} \frac{df_2}{dx_2} ... \frac{df_2}{dx_N}\f$ \n
            //! \f$ \frac{df_M}{dx_1} \frac{df_M}{dx_2} ... \frac{df_M}{dx_N}\f$ \n 
            //!
            //! The resulting matrix is a Multiarray<float64,2> (m,n) where n is the dimensionality of the output space and
            //! n is the input space \f$ R^n-> R^m \f$.    
            //!
            //! \code
            //!  void fa(Point x, Point *f)
            //!  {
            //!   //R²->R³ function
            //!   // f(x,y)=(x²-2x+1,x+3y,xy)
            //!   (*f)(0)=x(0)*x(0)-2*x(0)+1;
            //!   (*f)(1)=3*x(1)+x(0);
            //!   (*f)(2)=x(1)*x(0);
            //!  }
            //!
            //!  ****
            //!
            //!  Point2D r;
            //!  Point3D func3;
            //!  MultiArray<float64,2> jcb3(3,2);
            //!
            //!  r(0)=2; //x=2
            //!  r(1)=1; //y=1
            //!
            //!  fa(r,&func3);
            //!
            //!  jcb3=fd_jacobian(r,func3, fa);
            //!
            //! \endcode
            //! \param[in] x : Samples of the N-dimensional independent variable.
            //! \param[in] fvec : M-dimensional evaluated sample of x (\f$ f(x) \f$).
            //! \param[in] function : The function \f$ R^n-> R^m \f$ which jacobian is going to be computed .
            //! This parameter is a C function defined as
            //! void function(Point, Point*), where the first term is a single sample of x and the second is the returned
            //! value of the function in x (\f$ f(x) \f$).
            //!
            //! \return a MultiArray matrix with the result (see complete description on how to declare this MultiArray).
            //!
            
            MultiArray<float64,2> fd_jacobian(MultiArray<float64,1> x, MultiArray<float64,1> fvec, void (*function)(MultiArray<float64,1> , MultiArray<float64,1>*));

            
            //!
            //! \brief Newton-Rhapson method for root finding .
            //!
            //! \author Adolfo López <alopez@gps.tsc.upc.edu>
            //!
            //! \date 18-02-2008
            //!
            //! The function computes a function root near a given point by means of its derivative.
            //! The algorithm requires a concrete number of trials to approximate the solution. In the
            //! case of non-convergence or slow convergence to the root the method throws an exception.
            //! 
            //! \param[in] ntrial : Number of iterations for the algorithm
            //! \param[in] x : Initial guess point
            //! \param[in] tolx : Permitted error for the independent variables.
            //! \param[in] tolf : Permitted error with respect the function value.
            //! \param[in] function : Required values of the function in which root has to be found. Its defined like in C:
            //! void function(Point, Point*, MultiArray<float64,2>*), where the first term is a single sample of x, the second is the returned
            //! value of the function in x (f(x)) and the third is the Jacobian of the function in x.
            //! An example of user defined function:
            //!
            //! \code
            //! void function_tuplet(Point x, Point *f, MultiArray<float64,2> *jacobian)
            //! {
            //!    some_function(x,f); //user function in which the root must be found.
            //!    (*fjac)=fd_jacobian(x,(*f),some_function); //note that "some_function has a compatible definition
            //!                                               //with fd_jacobian
            //! }
            //! \endcode
            //!
            //! \return a Point with the root
            //!
            template < std::size_t N, std::size_t M >
            Point<N> newton_rhapson(uint64 ntrial, Point<N> x, float64 tolx, float64 tolf, void (*function)(Point<N> ,Point<M>*, MultiArray<float64,2>*)) throw(ImagePlusError);
            
         
            
            //!
            //! \brief Newton-Rhapson method for root finding .
            //!
            //! \author Adolfo López <alopez@gps.tsc.upc.edu>
            //!
            //! \date 18-02-2008
            //!
            //! The function computes a function root near a given point by means of its derivative.
            //! The algorithm requires a concrete number of trials to approximate the solution. In the
            //! case of non-convergence or slow convergence to the root the method throws an exception.
            //! 
            //! \param[in] ntrial : Number of iterations for the algorithm
            //! \param[in] x : Initial guess point
            //! \param[in] tolx : Permitted error for the independent variables.
            //! \param[in] tolf : Permitted error with respect the function value.
            //! \param[in] function : Required values of the function in which root has to be found. Its defined like in C:
            //! void function(Point, Point*, MultiArray<float64,2>*), where the first term is a single sample of x, the second is the returned
            //! value of the function in x (f(x)) and the third is the Jacobian of the function in x.
            //! An example of user defined function:
            //!
            //! \code
            //! void function_tuplet(Point x, Point *f, MultiArray<float64,2> *jacobian)
            //! {
            //!    some_function(x,f); //user function in which the root must be found.
            //!    (*fjac)=fd_jacobian(x,(*f),some_function); //note that "some_function has a compatible definition
            //!                                               //with fd_jacobian
            //! }
            //! \endcode
            //!
            //! \return a Point with the root
            //!

            
            
            MultiArray<float64,1> newton_rhapson(uint64 ntrial, MultiArray<float64,1> x, float64 tolx, float64 tolf, void (*function)(MultiArray<float64,1> ,MultiArray<float64,1>*, MultiArray<float64,2>*)) throw(ImagePlusError);
            
            
            
            
            
            // fd_jacobian implementation
            
            template < std::size_t N, std::size_t M >
            MultiArray<float64,2> fd_jacobian(Point<N> x, Point<M> fvec, void (*function)(Point<N> , Point<M>*))
            {
                int64 i,j; //n is the dimension of the space);
                int64 n2=N, n1=M;
                float64 h,temp;
                Point<M> f(fvec);

                MultiArray<float64,2> df(n2,n1);

                for (j=0;j<n2;j++)
                {
                    temp=x[j];
                    h=BIGEPS*fabs(temp);
                    if (h == 0.0) h=BIGEPS;
                    x[j]=temp+h;                          //Trick to reduce finite precision error.
                    h=x[j]-temp;
                    
                    TRACE("Evaluated epsilonx " << x[j])
                    
                    //try f=function(x)
                    (*function)(x,&f);
                    x[j]=temp;

                    for (i=0;i<n1;i++)
                    {
                        df[j][i]=(f[i]-fvec[i])/h;
                        TRACE(" Derivative " << i << " over " << j << " = " << f[i] << "-" << fvec[i] << "/" << h)
                    }
                }
                return df;
            }

            
            
            
            template < std::size_t N, std::size_t M >
            Point<N> newton_rhapson(uint64 ntrial, Point<N> x, float64 tolx, float64 tolf, void (*function)(Point<N> ,Point<M>*, MultiArray<float64,2>*)) throw(ImagePlusError) 
            { 
                uint64 k,i; 
                float64 errx,errf; //d_aux; 
                uint64 n=x.dims();
                MultiArray<float64,2> fjac(n,n);
                Point<N> fvec(x);//, pn(x);
                //MultiArray<float64,1> sol((size_type)x.dims()), pn((size_type)x.dims());
                MultiArray<float64,1> sol((size_type) n), pn((size_type) n);
                MultiArray<int64,1> index(n);
              
                for (k=0;k<ntrial;k++) 
                {
                    (*function)(x,&fvec,&fjac);     //User defined function supplies function values at x in fvec and Jacobian matrix in fjac.
                    errf=0.0;                

                    for (i=0;i<n;i++)  
                        errf += fabs(fvec[i]);      //Check function convergence

                    if (errf <= tolf)   
                        return x; 

                    for (i=0;i<n;i++)
                        pn[i] = -fvec[i];           //Right hand-side of linear equations

                    //ludcmp(fjac,n,indx,&d_aux);   //Solve linear equations using LU decomposition
                    //lubksb(fjac,n,indx,pn); 
                    sol=lu_solve(fjac,pn);
             
                    errx=0.0;                     //Check root convergence & update solution
                    for (i=0;i<n;i++) 
                    { 
                        errx += fabs(sol[i]); 
                        x[i] += sol[i];      
                    } 
                    if (errx <= tolx)
                    {
                        return x;
                    }
                  
                }
                // TODO: define exception...
                #ifndef NDEBUG
                    throw ImagePlusError("Newton-Rhapson Method: Maximum Iterations Achieved");
                #endif
                return x;
            }

 
            
            
            
            
            
        }
    }
}


#endif // IMAGEPLUS_MATH_NUMERIC_DERIVATIVE_HPP
