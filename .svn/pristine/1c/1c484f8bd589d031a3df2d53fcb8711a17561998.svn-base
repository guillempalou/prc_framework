// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------

//!
//!  \file linear_convolution.cpp
//!
//!  Implementation for Filtering operations on MultiArray and ImageGray objects
//!


#include <imageplus/filters/linear_convolution.hpp>
#include <imageplus/math/numeric/numeric_util.hpp>
//#include <imageplus/core/multiarray_ostream.hpp>

using namespace imageplus;
using namespace imageplus::filters;

LinearConvolution::LinearConvolution()  :
        Filter<LinearConvolution>("LinearConvolution"), _size_x(0), _size_y(0)
{
}

LinearConvolution::LinearConvolution(const MultiArray<float64,2> & kernel) :
        Filter<LinearConvolution>("LinearConvolution"), _size_x(kernel.dims(0)), _size_y(kernel.dims(1)), _kernel(kernel)
{
	if (_size_x % 2 == 0 || _size_y%2 == 0) throw ImagePlusError("Kernel must have odd size");
}

LinearConvolution::~LinearConvolution()
{
}


///////////////////////////////////////////////////////////////////////////////
// 2D Convolution Fast
// In order to improve the performance, this function uses multple cursors of
// input signal. It avoids indexing input array during convolution. And, the
// input signal is partitioned to 9 different sections, so we don't need to
// check the boundary for every samples.
///////////////////////////////////////////////////////////////////////////////

template<typename T>
MultiArray<T,2> LinearConvolution::implementation( const MultiArray<T,2>& in) const throw (ImagePlusError)
{
    if (_size_x == 0 || _size_y == 0)
    {
        return in;
    }
    else
    {
        uint64 dataSizeX = in.dims(0);
        uint64 dataSizeY = in.dims(1);

        MultiArray<T, 2> out(in.dims());

        // find center position of kernel (half of kernel size)
        uint64 kCenterX = _size_x >> 1;
        uint64 kCenterY = _size_y >> 1;
        uint64 kSize = _size_x * _size_y;              // total kernel size

        // allocate memeory for multi-cursor
        MultiArray<const T*,1> inPtr(kSize);


        // set initial position of multi-cursor, NOTE: it is swapped instead of kernel
        const T* ptr = in.data() + (dataSizeX * kCenterY + kCenterX); // the first cursor is shifted (kCenterX, kCenterY)

        uint64 t = 0;
        for (uint64 m = 0; m < _size_y; ++m)
        {
            for(uint64 n = 0; n < _size_x; ++n, ++t)
            {
                inPtr[t] = ptr - n;
            }
            ptr -= dataSizeX;
        }

        // init working  pointers
        T* outPtr = out.data();


        // Requires kernel smaller than input signal

        // ending indices for section divider
        uint64 rowEnd = dataSizeY - kCenterY;                  // bottom row partition divider
        uint64 colEnd = dataSizeX - kCenterX;                  // right column partition divider



        // convolve rows from index=0 to index=kCenterY-1
        uint64 y = kCenterY;

        // Pointer to kernel data
        const float64* kernel = _kernel.data();

        for (uint64 i = 0; i < kCenterY; ++i)
        {
            // partition #1 ***********************************
            uint64 x = kCenterX;

            for (uint64 j = 0; j < kCenterX; ++j)                 // column from index=0 to index=kCenterX-1
            {
                float64 sum = 0.0;
                t   = 0;
                for (uint64 m = 0; m <= y; ++m)
                {
                    for(uint64 n = 0; n <= x; ++n)
                    {
                        sum += *inPtr[t] * kernel[t];
                        ++t;
                    }
                    t += (_size_x - x - 1);         // jump to next row
                }

                // store output

                *outPtr = std::numeric_limits<T>::is_integer ? math::numeric::mnint<T>(sum) : static_cast<T>(sum);
                ++outPtr;
                ++x;
                for (uint64 k=0; k < kSize; ++k)
                {
                    ++inPtr[k];    // move all cursors to next
                }
            }

            // partition #2 ***********************************
            for (uint64 j = kCenterX; j < colEnd; ++j)            // column from index=kCenterX to index=(dataSizeX-kCenterX-1)
            {
                float64 sum = 0.0;
                t = 0;
                for (uint64 m = 0; m <= y; ++m)
                {
                    for (uint64 n = 0; n < _size_x; ++n)
                    {
                        sum += *inPtr[t] * kernel[t];
                        ++t;
                    }
                }

                // store output
                *outPtr = std::numeric_limits<T>::is_integer ? math::numeric::mnint<T>(sum) : static_cast<T>(sum);
                ++outPtr;
                ++x;
                for (uint64 k=0; k < kSize; ++k)
                {
                    ++inPtr[k];    // move all cursors to next
                }
            }

            // partition #3 ***********************************
            x = 1;
            for (uint64 j=colEnd; j < dataSizeX; ++j)           // column from index=(dataSizeX-kCenter) to index=(dataSizeX-1)
            {
                float64 sum = 0.0;
                t = x;
                for (uint64 m = 0; m <= y; ++m)
                {
                    for(uint64 n = x; n < _size_x; ++n)
                    {
                        sum += *inPtr[t] * kernel[t];
                        ++t;
                    }
                    t += x;                             // jump to next row
                }

                // store output
                *outPtr = std::numeric_limits<T>::is_integer ? math::numeric::mnint<T>(sum) : static_cast<T>(sum);
                ++outPtr;
                ++x;
                for (uint64 k = 0; k < kSize; ++k)
                {
                    ++inPtr[k];    // move all cursors to next
                }
            }

            ++y;                                        // add one more row to convolve for next run
        }

        // convolve rows from index=kCenterY to index=(dataSizeY-kCenterY-1)
        for (uint64 i= kCenterY; i < rowEnd; ++i)               // number of rows
        {
            // partition #4 ***********************************
            uint64 x = kCenterX;
            for (uint64 j=0; j < kCenterX; ++j)                 // column from index=0 to index=kCenterX-1
            {
                float64 sum = 0.0;
                t = 0;
                for (uint64 m=0; m < _size_y; ++m)
                {
                    for (uint64 n=0; n <= x; ++n)
                    {
                        sum += *inPtr[t] * kernel[t];
                        ++t;
                    }
                    t += (_size_x - x - 1);
                }

                // store output
                *outPtr = std::numeric_limits<T>::is_integer ? math::numeric::mnint<T>(sum) : static_cast<T>(sum);
                ++outPtr;
                ++x;
                for (uint64 k=0; k < kSize; ++k)
                {
                    ++inPtr[k];    // move all cursors to next
                }
            }

            // partition #5 ***********************************
            for (uint64 j = kCenterX; j < colEnd; ++j)          // column from index=kCenterX to index=(dataSizeX-kCenterX-1)
            {
                float64 sum = 0.0;
                t = 0;
                for (uint64 m=0; m < _size_y; ++m)
                {
                    for (uint64 n=0; n < _size_x; ++n)
                    {
                        sum += *inPtr[t] * kernel[t];
                        ++inPtr[t]; // in this partition, all cursors are used to convolve. moving cursors to next is safe here
                        ++t;
                    }
                }

                // store output
                *outPtr = std::numeric_limits<T>::is_integer ? math::numeric::mnint<T>(sum) : static_cast<T>(sum);
                ++outPtr;
                ++x;
            }

            // partition #6 ***********************************
            x = 1;
            for (uint64 j=colEnd; j < dataSizeX; ++j)           // column from index=(dataSizeX-kCenter) to index=(dataSizeX-1)
            {
                float64 sum = 0.0;
                t = x;
                for (uint64 m=0; m < _size_y; ++m)
                {
                    for (uint64 n=x; n < _size_x; ++n)
                    {
                        sum += *inPtr[t] * kernel[t];
                        ++t;
                    }
                    t += x;
                }

                // store output
                *outPtr = std::numeric_limits<T>::is_integer ? math::numeric::mnint<T>(sum) : static_cast<T>(sum);
                ++outPtr;
                ++x;
                for (uint64 k=0; k < kSize; ++k)
                {
                    ++inPtr[k];    // move all cursors to next
                }
            }
        }

        // convolve rows from index=(dataSizeY-kCenterY) to index=(dataSizeY-1)
        y = 1;
        for (uint64 i = rowEnd; i < dataSizeY; ++i)               // number of rows
        {
            // partition #7 ***********************************
            uint64 x = kCenterX;
            for (uint64 j = 0; j < kCenterX; ++j)                 // column from index=0 to index=kCenterX-1
            {
                float64 sum = 0;
                t = _size_x * y;

                for (uint64 m = y; m < _size_y; ++m)
                {
                    for (uint64 n = 0; n <= x; ++n)
                    {
                        sum += *inPtr[t] * kernel[t];
                        ++t;
                    }
                    t += (_size_x - x - 1);
                }

                // store output
                *outPtr = std::numeric_limits<T>::is_integer ? math::numeric::mnint<T>(sum) : static_cast<T>(sum);
                ++outPtr;
                ++x;
                for (uint64 k = 0; k < kSize; ++k)
                {
                    ++inPtr[k];    // move all cursors to next
                }
            }

            // partition #8 ***********************************
            for (uint64 j = kCenterX; j < colEnd; ++j)            // column from index=kCenterX to index=(dataSizeX-kCenterX-1)
            {
                float64 sum = 0.0;
                t = _size_x * y;
                for (uint64 m=y; m < _size_y; ++m)
                {
                    for (uint64 n=0; n < _size_x; ++n)
                    {
                        sum += *inPtr[t] * kernel[t];
                        ++t;
                    }
                }

                // store output
                *outPtr = std::numeric_limits<T>::is_integer ? math::numeric::mnint<T>(sum) : static_cast<T>(sum);
                ++outPtr;
                ++x;
                for (uint64 k=0; k < kSize; ++k)
                {
                    ++inPtr[k];
                }
            }

            // partition #9 ***********************************
            x = 1;
            for (uint64 j=colEnd; j < dataSizeX; ++j)           // column from index=(dataSizeX-kCenter) to index=(dataSizeX-1)
            {
                float64 sum = 0.0;
                t = _size_x * y + x;
                for (uint64 m = y; m < _size_y; ++m)
                {
                    for (uint64 n = x; n < _size_x; ++n)
                    {
                        sum += *inPtr[t] * kernel[t];
                        ++t;
                    }
                    t += x;
                }

                // store output
                *outPtr = std::numeric_limits<T>::is_integer ? math::numeric::mnint<T>(sum) : static_cast<T>(sum);
                ++outPtr;
                ++x;
                for (uint64 k=0; k < kSize; ++k)
                {
                    ++inPtr[k];    // move all cursors to next
                }
            }

            ++y;                                        // the starting row index is increased
        }

        return out;


    }
}

template<typename T>
ImageGray<T> LinearConvolution::implementation( const ImageGray<T>& m) const throw (ImagePlusError)
{
    if (_size_x == 0 || _size_y == 0)
    {
        return m;
    }
    else
    {
    	ImageGray<T> out(m);
 		out(0)=this->implementation(m(0));
 		return out;
    }

}

// LinearConvolution instantiations
namespace imageplus
{

        template ImageGray<uint8>    LinearConvolution::implementation<uint8>( const ImageGray<uint8>&  ) const;
        template ImageGray<int64>    LinearConvolution::implementation<int64>( const ImageGray<int64>&  ) const;
    	template ImageGray<float64>    LinearConvolution::implementation<float64>( const ImageGray<float64>&  ) const;
        
        template MultiArray<uint8,2> LinearConvolution::implementation<uint8>( const MultiArray<uint8,2>& ) const;
        template MultiArray<int64,2> LinearConvolution::implementation<int64>( const MultiArray<int64,2>& ) const;
    	template MultiArray<float64,2> LinearConvolution::implementation<float64>( const MultiArray<float64,2>& ) const;
        
}






