/*
 * shortest_paths.hpp
 *
 *  Created on: Nov 9, 2011
 *      Author: guillem
 */

#ifndef SHORTEST_PATHS_HPP_
#define SHORTEST_PATHS_HPP_

#include <imageplus/math/graphs/graph.hpp>
#include <boost/graph/dijkstra_shortest_paths.hpp>
#include <boost/graph/bellman_ford_shortest_paths.hpp>
#include <boost/graph/johnson_all_pairs_shortest.hpp>
#include <boost/graph/floyd_warshall_shortest.hpp>

namespace imageplus {
	namespace math {
		namespace graphs {

	//! Dijkstra class to compute the shortest distance from one node to all the others
	//! No negative edges can be present
	//! \param Graph : BoostGraph class
	template <class Graph>
	class Dijkstra {

		//! Node type
		typedef typename Graph::Node Node;

		//! Edge type
		typedef typename Graph::Edge Edge;

	public:

		//! Calculate the Disktra algorithm
		//! \param[in] g: graph
		//! \param[in] source : source node
		void calculate(Graph& g, Node source) {
			// Compute the Dijkstra
			uint32 N = g.num_nodes();

			_parent.resize(N);
			_distance.resize(N);

			boost::dijkstra_shortest_paths(g.graph(), source, boost::predecessor_map(&_parent[0]).distance_map(&_distance[0]).
																weight_map(get(&Graph::EdgePropertiesType::weight, g.graph())));
		}

		//! Records the structure of the shortest path tree generated by the algorithm. Useful to recover shortest paths
		//! \return node parent vector
		const std::vector<Node>&	parents() {return _parent;}

		//! Records the minimum distance from the source to the nodes
		//! \return vector of minimum distances
		const std::vector<float64>& distances() {return _distance;}

		//! Parent of a given node
		//! \param[in] n : node
		//! \return node identifier
		inline const Node parent(Node n) {return _parent[n];}

		//! Minimum distance from source to a given node
		//! \param[in] n : node
		//! \return minimum distance
		inline const float64 distance(Node n) {return _distance[n];}

	private:
		//! parent vector
		std::vector<Node> _parent;

		//! distance vector
		std::vector<float64> _distance;
	};

	//! Bellman ford class to compute the shortest distance from one node to all the others
	//! Works with negative edges
	//! \param Graph : BoostGraph class
	template <class Graph>
	class BellmanFord {

		//! Node type
		typedef typename Graph::Node Node;

		//! Edge type
		typedef typename Graph::Edge Edge;

	public:

		//! Calculate the Disktra algorithm
		//! \param[in] g: graph
		//! \param[in] source : source node
		bool calculate(Graph& g, Node source) {
			// Compute the Dijkstra
			uint32 N = g.num_nodes();

			_parent.resize(N);
			_distance =  std::vector<float64>(N, (std::numeric_limits<float64>::max)());;

			_distance[(uint64)source] = 0;
			for (typename Graph::node_iterator n = g.nodes_begin(); n != g.nodes_end(); ++n) _parent[*n] = (uint64)*n;

			bool minimization_complete = boost::bellman_ford_shortest_paths(g.graph(), N, boost::predecessor_map(&_parent[0]).
					distance_map(&_distance[0]).
					weight_map(get(&Graph::EdgePropertiesType::weight, g.graph())));
			return minimization_complete;
		}

		//! Records the structure of the shortest path tree generated by the algorithm. Useful to recover shortest paths
		//! \return node parent vector
		const std::vector<Node>&	parents() {return _parent;}

		//! Records the minimum distance from the source to the nodes
		//! \return vector of minimum distances
		const std::vector<float64>& distances() {return _distance;}

		//! Parent of a given node
		//! \param[in] n : node
		//! \return node identifier
		inline const uint64 parent(Node n) {return _parent[n];}

		//! Minimum distance from source to a given node
		//! \param[in] n : node
		//! \return minimum distance
		inline const float64 distance(Node n) {return _distance[n];}

	private:
		//! parent vector
		std::vector<Node> _parent;

		//! distance vector
		std::vector<float64> _distance;
	};

	//! Floyd algorithm to compute all pairs - minimum distance
	//! Works with negative edges
	//! \param Graph : BoostGraph class
	template <class Graph>
	class FloydWarshall {

		//! Node type
		typedef typename Graph::Node Node;

		//! Edge type
		typedef typename Graph::Edge Edge;

	public:

		//! Calculate the Floyd algorithm
		//! \param[in] g: graph
		bool calculate(Graph& g) {
			// Compute the Dijkstra
			uint32 N = g.num_nodes();

			_distance = MultiArray<float64,2>(N,N);

			bool minimization_complete = boost::floyd_warshall_all_pairs_shortest_paths(g.graph(), _distance, boost::weight_map(get(&Graph::EdgePropertiesType::weight, g.graph())));
			return minimization_complete;
		}

		//! Records the minimum distance of any pair of nodes
		//! \return matrix of minimum distances
		const MultiArray<float64,2>& distances() {return _distance;}

		//! Minimum distance between two nodes
		//! \param[in] a : source node
		//! \param[in] b : source node
		//! \return minimum distance from a to b
		inline const float64 distance(Node a, Node b) {return _distance[a][b];}

	private:
		//! parent vector
		std::vector<std::vector<uint64> > _parent;

		//! distance vector
		MultiArray<float64,2> _distance;
	};

	//! Johnson algorithm to compute all pairs - minimum distance
	//! Works with negative edges and faster than Floyd if the graph is sparse
	//! \param Graph : BoostGraph class
	template <class Graph>
	class JohnsonAllPairs {

		//! Node type
		typedef typename Graph::Node Node;

		//! Edge type
		typedef typename Graph::Edge Edge;

	public:

		//! Calculate the Floyd algorithm
		//! \param[in] g: graph
		bool calculate(Graph& g) {
			// Compute the Dijkstra
			uint32 N = g.num_nodes();

			_distance = MultiArray<float64,2>(N,N);

			bool minimization_complete = boost::johnson_all_pairs_shortest_paths(g.graph(), _distance, boost::weight_map(get(&Graph::EdgePropertiesType::weight, g.graph())));
			return minimization_complete;
		}

		//! Records the minimum distance of any pair of nodes
		//! \return vector of vector of minimum distances
		const MultiArray<float64,2>& distances() {return _distance;}

		//! Minimum distance between two nodes
		//! \param[in] a : source node
		//! \param[in] b : source node
		//! \return minimum distance from a to b
		inline const float64 distance(Node a, Node b) {return _distance[a][b];}

	private:
		//! parent vector
		std::vector<std::vector<uint64> > _parent;

		//! distance matrix
		MultiArray<float64,2> _distance;
	};

		}
	}
}


#endif /* SHORTEST_PATHS_HPP_ */
