/*
 * flow_io.hpp
 *
 *  Created on: Dec 3, 2012
 *      Author: guillem
 */

#ifndef FLOW_IO_HPP_
#define FLOW_IO_HPP_

#include <stdio.h>
#include <stdlib.h>

#define TAG_FLOAT 202021.25  // check for this when READING the file
#define TAG_STRING "PIEH"    // use this when WRITING the file

namespace imageplus {
	namespace optical_flow {

		template<class OpticalFlow>
		void read_optical_flow(OpticalFlow flow, std::string path) {
			const char* filename = path.c_str();

			if (path == "") throw ImagePlusError("read_flow_file: empty filename");

			char *dot = strrchr(filename, '.');
			if (strcmp(dot, ".flo") != 0) throw ImagePlusError("read_flow_file: extension .flo expected");

			FILE *stream = fopen(filename, "rb");
			if (stream == 0) {throw ImagePlusError("read_flow_file: could not open"); }

			int width, height;
			float tag;

			if ((int)fread(&tag, sizeof(float), 1, stream) != 1 || (int)fread(&width,  sizeof(int),   1, stream) != 1 || (int)fread(&height, sizeof(int),   1, stream) != 1)
				throw ImagePlusError("read_flow_file: problem reading file");

			// another sanity check to see that integers were read correctly (99999 should do the trick...)
			if (width < 1 || width > 99999) throw ImagePlusError("read_flow_file: illegal width");
			if (height < 1 || height > 99999) throw ImagePlusError("read_flow_file: illegal height");

			typedef typename OpticalFlow::value_type optical_flow_type;
			for (int32 y = 0; y < height; y++) {
				for (int32 x = 0; x < width; x++) {
					float32 u,v;
					if ((int)fread(&u, sizeof(float), 1, stream) != 1) throw ImagePlusError("read_flow_file: file is too short");
					if ((int)fread(&v, sizeof(float), 1, stream) != 1) throw ImagePlusError("read_flow_file: file is too short");
					flow(x,y) = optical_flow_type(u,v);
				}
			}
			//exit(0);

			if (fgetc(stream) != EOF) throw ImagePlusError("read_flow_file: file is too long");

			fclose(stream);
		}

		template<class OpticalFlow>
		void write_optical_flow(const OpticalFlow& flow, std::string path) {
			const char* filename = path.c_str();
			if (filename == NULL) throw ImagePlusError("WriteFlowFile: empty filename");

			const char *dot = strrchr(filename, '.');
			if (dot == NULL) throw ImagePlusError("WriteFlowFile: extension required in filename ");

			if (strcmp(dot, ".flo") != 0) throw ImagePlusError("WriteFlowFile: filename should have extension '.flo'");

			int width = flow.size_x();
			int height = flow.size_y();
			int nBands = flow.value_dimensions;

			if (nBands != 2) throw ImagePlusError("WriteFlowFile: image must have 2 bands");

			FILE *stream = fopen(filename, "wb");
			if (stream == 0) throw ImagePlusError("WriteFlowFile: could not open");

			// write the header
			fprintf(stream, TAG_STRING);
			if ((int)fwrite(&width,  sizeof(int),   1, stream) != 1 || (int)fwrite(&height, sizeof(int),   1, stream) != 1)
				throw ImagePlusError("WriteFlowFile: problem writing header");

			// write the rows
			int n = nBands * width;
			for (int y = 0; y < height; y++) {
				float* ptr = &flow.data(typename OpticalFlow::coord_type(0, y)); // data with offset
				if ((int)fwrite(ptr, sizeof(float), n, stream) != n) throw ImagePlusError("WriteFlowFile: problem writing data");
			}

			fclose(stream);
		}

		inline ImageSignal<uint8,3> color_circle() {

			int32 RY = 15;
			int32 YG = 6;
			int32 GC = 4;
			int32 CB = 11;
			int32 BM = 13;
			int32 MR = 6;

			int32 ncols = RY + YG + GC + CB + BM + MR;

			ImageSignal<uint8,3> color_wheel(ncols,1); // r g b
			typedef ImageSignal<uint8,3>::value_type color_type;

			int32 col = 0;
			//RY
			for (int32 i = col; i < RY; i++) color_wheel(i,0) = color_type(255,255.0*i/RY,0);
			col = col+RY;
			//YG
			for (int32 i = col,k=0; i < RY+YG; i++,k++) color_wheel(i,0) = color_type(255-255.0*k/YG,255,0);
			col = col+YG;
			//GC
			for (int32 i = col,k=0; i < RY+YG+GC; i++,k++) color_wheel(i,0) = color_type(0,255,255.0*k/GC);
			col = col+GC;
			//CB
			for (int32 i = col,k=0; i < RY+YG+GC+CB; i++,k++) color_wheel(i,0) = color_type(0,255-255.0*k/CB,255);
			col = col+CB;
			//BM
			for (int32 i = col,k=0; i < RY+YG+GC+CB+BM; i++,k++) color_wheel(i,0) = color_type(255.0*k/BM,0,255);
			col = col+BM;
			//MR
			for (int32 i = col,k=0; i < ncols; i++,k++) color_wheel(i,0) = color_type(255,0,255-255.0*k/MR);

			return color_wheel;
		}

		inline ImageSignal<uint8,3>::value_type flow_to_color(float64 u, float64 v, ImageSignal<uint8,3>& colorwheel) {
			ImageSignal<uint8,3>::value_type rgb;

			if (isnan(u) || isnan(v)) {return rgb;}

			float64 r = 1-std::exp(-std::sqrt(u*u+v*v)/0.5);
			float64 a = atan2(-v,-u)/M_PI;
			float64 ncols = colorwheel.size_x();
			float64 fk = (a+1)/2 * (ncols-1);

			int32 k0 = (int32)(fk);                 // 1, 2, ..., ncols
			int32 k1 = k0+1;
			if (k1==ncols) k1 = 0;

			float64 f = fk - k0;
			for (int32 i = 0; i < 3; i++) {
				float64 col0 = colorwheel(k0,0)(i)*1.0/255;
				float64 col1 = colorwheel(k1,0)(i)*1.0/255;
				float64 col = (1-f)*col0 + f*col1;

				if (r <= 1)
					col = r*(1-col);    // increase brightness with radius
				else
					col = (1-col)*0.75;         // out of range

				rgb(i) = (uint8)(floor(255*col));
			}

			return rgb;
		}

		template<class OpticalFlow>
		void write_flow_image(OpticalFlow& flow, std::string path) {
			ImageSignal<uint8, 3> img(flow.sizes());

			int32 maxUV = 999;

			int32 sx = flow.size_x();
			int32 sy = flow.size_y();

			float64 maxrad = 0;

			for (int32 x = 0; x < sx; x++) {
				for (int32 y = 0; y < sy; y++) {
					float64 a = (abs(flow(x,y)(0)) > maxUV) ? maxUV : flow(x,y)(0);
					float64 b = (abs(flow(x,y)(1)) > maxUV) ? maxUV : flow(x,y)(1);
					float64 r = a*a + b*b;
					maxrad = (maxrad < r) ? r : maxrad;
				}
			}

			maxrad = std::sqrt(maxrad);

			ImageSignal<uint8,3> colorwheel = color_circle();
			typedef ImageSignal<uint8,3>::value_type color_type;
			float64 eps = 1e-6;
			for (int32 x = 0; x < sx; x++) {
				for (int32 y = 0; y < sy; y++) {
					color_type color = flow_to_color(flow(x,y)(0)/(maxrad + eps),flow(x,y)(1)/(maxrad + eps),colorwheel);
					if (flow(x,y)(0) != 1e20 && flow(x,y)(1) != 1e20) {
						img(x,y) = color;
					}
				}
			}

			img.write(path);
		}

	}
}


#endif /* FLOW_IO_HPP_ */
