// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------

/*!
 * \file write_sequence_yuv.test
 */

#include <imageplus/core.hpp>
#include <imageplus/io/write_sequence_yuv.hpp>
#include <imageplus/io/readsequence.hpp>


BOOST_AUTO_TEST_SUITE (writesequence_yuv_suite);

using namespace std;
using namespace imageplus;
using namespace imageplus::io; 
//using namespace imageplus::mviewcompr;


BOOST_AUTO_TEST_CASE (writesequence_yuv_default_constructor_test)
{
    WriteSequenceYUV seq; 
    
    BOOST_CHECK(seq.startframe() == 0);
    BOOST_CHECK(seq.endframe() == 0);
    BOOST_CHECK(seq.fps() == 0.0);
    BOOST_CHECK(seq.format() == UNKNOWN_SEQ_FORMAT);
    BOOST_CHECK(seq.frame_pointer() == 0);

    
}

BOOST_AUTO_TEST_CASE (writesequence_yuv_copy_constructor_test)
{
    std::string filename = std::string(TEST_DATA_PATH_W)+"/io_copy_constructor_s1_test420.yuv";
    const uint64 sizex = 20; 
    const uint64 sizey = 10;
    const uint64 totalframes = 10;
    const float64 fps = 10.0;
    const SeqFormat format = YUV420P;
    const std::string comment = "Sequence produced through WriteSequenceYUV copy constructor test";
    WriteSequenceYUV original (filename, sizex, sizey, totalframes, fps, format, comment); 
    
    
    //Trying output operators.
    
    //Situation 1: a copy is made after using the original a little bit.
    
    ImageYUV420<uint8> im1(20,10); 
    im1(Y_CHANNEL) = 1; 
    im1(U_CHANNEL) = 1; 
    im1(V_CHANNEL) = 1;
    
    ImageYUV420<uint8> im2(20,10); 
    im2(Y_CHANNEL) = 2; 
    im2(U_CHANNEL) = 2; 
    im2(V_CHANNEL) = 2;
    
    original << im1; 
    
    WriteSequenceYUV copy(original);
    
    copy << im2; 
    
    //Now, reading from the sequence we should read im1, im2.
    
    ReadSequence input_s1 (filename);
    
    ImageYUV420<uint8> re_im1, re_im2; 
    
    input_s1 >> re_im1 >> re_im2; 
    
//    BOOST_CHECK(re_im1 == im1); 
    BOOST_CHECK(re_im2 == im2);

    
    
    //Situation 2: a copy is made after creating the original object. 
    filename = std::string(TEST_DATA_PATH_W)+"/io_copy_constructor_s2_test420.yuv";
    WriteSequenceYUV original_s2 (filename, sizex, sizey, totalframes, fps, format, comment);
    WriteSequenceYUV copy_s2 (original_s2);
    
//    std::cout << "original_s2._framecount = " << original_s2.frame_pointer() << std::endl;
//    std::cout << "copy_s2._framecount = " << copy_s2.frame_pointer() << std::endl;
    
    original_s2 << im1; 
    copy_s2 << im2; 
    
    //Now, reading from the sequence should give only 1 picture, im2.
    ReadSequence input_s2 (filename);
    ImageYUV420<uint8> re_im3;
    
    input_s2 >> re_im3;
    
    BOOST_CHECK( re_im3 == im2);
}

BOOST_AUTO_TEST_CASE (writesequence_yuv_constructor_test)
{
    const std::string filename = string(TEST_DATA_PATH_W)+"/io_writesequence_test420.yuv";
    const uint64 sizex = 20; 
    const uint64 sizey = 10;
    const uint64 totalframes = 10;
    const float64 fps = 10.0;
    const SeqFormat format = YUV420P;
    const std::string comment = "Sequence produced through WriteSequenceYUV test";
    WriteSequenceYUV seq (filename, sizex, sizey, totalframes, fps, format,comment);
    //Checking member variables values: 
    BOOST_CHECK(seq.size_x() == sizex);
    BOOST_CHECK(seq.size_y() == sizey);
    BOOST_CHECK(seq.startframe() == 0);
    BOOST_CHECK(seq.endframe() == totalframes -1);
    BOOST_CHECK(seq.fps() == fps);
    BOOST_CHECK(seq.format() == format);
    BOOST_CHECK(seq.frame_pointer() == 0);
//    std::vector<std::string> channels = seq.channels(); 
//    BOOST_CHECK(channels.size() == 3);
//    BOOST_CHECK(channels[0] == "Y_CHANNEL");
//    BOOST_CHECK(channels[1] == "U_CHANNEL");
//    BOOST_CHECK(channels[2] == "V_CHANNEL");

}
BOOST_AUTO_TEST_CASE (writesequence_yuv_pointer_use_test)
{
    const std::string filename = string(TEST_DATA_PATH_W) + "/io_writesequence_pointer_use_test420.yuv";
    const uint64 sizex = 20; 
    const uint64 sizey = 10;
    const uint64 totalframes = 10;
    const float64 fps = 10.0;
    const SeqFormat format = YUV420P;
    const std::string comment = "Sequence produced through WriteSequenceYUV pointer use test";
//    const char ex_message[100] = "Can not change frame pointer to frame > endframe";
    
    WriteSequenceYUV seq(filename, sizex, sizey, totalframes, fps, format, comment);
    ImageYUV420<uint8> image1(sizex, sizey);
    ImageYUV420<uint8> blankimage(sizex, sizey);
    image1(Y_CHANNEL) = 85; 
    image1(U_CHANNEL) = 170;
    image1(V_CHANNEL) = 255; 
    blankimage = 0;
    
    //Check initial single write.
    seq << image1; 
    BOOST_CHECK(seq.frame_pointer() == 1);
    
    //Check formatted output.
    seq << image1 << blankimage << image1;
    BOOST_CHECK(seq.frame_pointer() == 4);
    
    //Check index pointing and writing: 
    seq[5]<<image1; 
    BOOST_CHECK(seq.frame_pointer() == 6);
    seq[7]<<image1;
    BOOST_CHECK(seq.frame_pointer() == 8);
    
    //Check index pointing.
    seq[0];
    BOOST_CHECK(seq.frame_pointer() == 0); 
    
}

BOOST_AUTO_TEST_CASE (writesequence_yuv_random_access_writing_test)
{
    try
    {
        //Open different sequence files for different tests.
        const std::string filename = string(TEST_DATA_PATH_W)+"/io_random_access420.yuv";
        const std::string comment = "WriteSequenceYUV test file to test random access.";
        
        WriteSequenceYUV rand_seq(filename, 10, 10, 10, 1, YUV420P, comment);
        
        //Creating images to fill the sequences.
        ImageYUV420<uint8> image1 (10,10); 
        image1(Y_CHANNEL) = 90;
        image1(U_CHANNEL) = 128;
        image1(V_CHANNEL) = 128;
        
        ImageYUV420<uint8> image2 (10,10);
        image2(Y_CHANNEL) = 85;
        image2(U_CHANNEL) = 170;
        image2(V_CHANNEL) = 255;
        
        ImageYUV420<uint8> image3 (10,10);
        image3(Y_CHANNEL) = 1; 
        image3(U_CHANNEL) = 2; 
        image3(V_CHANNEL) = 3;
        
        ImageYUV420<uint8> blankimage (10,10);
        blankimage = 0;
        
        //Testing random access 1.
        rand_seq[0];
        rand_seq << image3; 
        rand_seq[0];
        rand_seq << image2;
        rand_seq[4];
        rand_seq << image3; 
        rand_seq[2]; 
        rand_seq << image2;    
        //checking random access 1.  
        ReadSequence read_rand_seq(filename);
        ImageYUV420<uint8> read_image;
        
        read_rand_seq[0];
        read_rand_seq >> read_image;
        BOOST_CHECK(read_image == image2);
        read_rand_seq[4] >> read_image;
        BOOST_CHECK(read_image == image3);
        read_rand_seq[2] >> read_image;
        BOOST_CHECK(read_image == image2);
        read_rand_seq[1] >>read_image;
        BOOST_CHECK(read_image == blankimage);
        
       
    }
    catch (ImagePlusError e)
    {
        const std::string message = e.what();
        BOOST_ERROR(message);
    }
    catch (ImagePlusFileNotFound e)
    {
        const std::string message = e.what();
        BOOST_ERROR(message);
    }
    
}
BOOST_AUTO_TEST_CASE (writesequence_yuv_formatted_access_writing_test)
{
    const std::string filename = string(TEST_DATA_PATH_W) + "/io_format_access420.yuv";
    const std::string comment = "WriteSequenceYUV test file to test format access.";
    WriteSequenceYUV form_seq(filename, 10, 10, 10, 1, YUV420P, comment);
    
    //Creating images to fill the sequences.
    ImageYUV420<uint8> image1 (10,10); 
    image1(Y_CHANNEL) = 90;
    image1(U_CHANNEL) = 128;
    image1(V_CHANNEL) = 128;
    
    ImageYUV420<uint8> image2 (10,10);
    image2(Y_CHANNEL) = 85;
    image2(U_CHANNEL) = 170;
    image2(V_CHANNEL) = 255;
    
    ImageYUV420<uint8> image3 (10,10);
    image3(Y_CHANNEL) = 1; 
    image3(U_CHANNEL) = 2; 
    image3(V_CHANNEL) = 3;
    
    ImageYUV420<uint8> blankimage (10,10);
    blankimage = 0;

    //Testing formatted access.
    form_seq << image3;
    form_seq << image1;
    form_seq << image2;
    form_seq << blankimage;
    form_seq << image2;
    //checking random access.
    ImageYUV420<uint8> read_image;
    ReadSequence read_form_seq(filename);
    
    read_form_seq >> read_image;
    BOOST_CHECK(read_image == image3);
    read_form_seq >> read_image;
    BOOST_CHECK(read_image == image1);
    read_form_seq >> read_image;
    BOOST_CHECK(read_image == image2);
    read_form_seq >> read_image;
    BOOST_CHECK(read_image == blankimage);
    read_form_seq >> read_image;
    BOOST_CHECK(read_image == image2);
    
}

BOOST_AUTO_TEST_CASE (writesequence_yuv_sequential_access_writing_test)
{
    const std::string filename = string(TEST_DATA_PATH_W) + "/io_sequential_access420.yuv";
    const std::string comment = "WriteSequenceYUV test file to test sequential access.";
    WriteSequenceYUV sequ_seq(filename, 10, 10, 10, 1, YUV420P, comment);
    
    
    //Creating images to fill the sequences.
    ImageYUV420<uint8> image1 (10,10); 
    image1(Y_CHANNEL) = 90;
    image1(U_CHANNEL) = 128;
    image1(V_CHANNEL) = 128;
    
    //Testing sequential access. 
    
    while(!sequ_seq.eos())
    {
        sequ_seq << image1;        
    }
    //checking sequenctial access.
    ImageYUV420<uint8> read_image;
    ReadSequence read_sequ_seq(filename);
    
    while(!read_sequ_seq.eof())
    {
        read_sequ_seq >> read_image;
        BOOST_CHECK(read_image == image1);
    }
}

//! TODO : debug this test case. 

//BOOST_AUTO_TEST_CASE (writesequence_yuv_advanced_access_writing_test)
//{
//    const std::string filename = string(TEST_DATA_PATH_W) + "/io/advanced_access420.yuv";
//    const std::string comment = "WriteSequenceYUV test file to test advanced access.";
//    WriteSequenceYUV advn_seq(filename, 10, 10, 10, 1, YUV420P, comment);
//    
//    //Creating images to fill the sequences.
//    ImageYUV420<uint8> image3 (10,10);
//    image3(Y_CHANNEL) = 1; 
//    image3(U_CHANNEL) = 2; 
//    image3(V_CHANNEL) = 3;
//    
//    //testing of advanced use of pointer arithmetic.
//    uint64 i = 0; 
//    while(!advn_seq.eos())
//    {
//        uint64 j= (i%2)?0:i;
//        if(j)
//        {
//            advn_seq[j]<<image3;  //writing only frames in even locations. 
//        }
//        i++;
//    }
//    std::cout << "Test sequence written. Proceeding to read it..." << std::endl;
//    //checking results
//    ReadSequence read_advn_seq(filename);
//    ImageYUV420<uint8> read_image;
////    i= 0;
////    while(!read_advn_seq.eof())
////    {
////        uint64 j = (i%2)?0:i;
////        if(j && j < read_advn_seq.endframe())
////        {
////            read_advn_seq [j] >> read_image; //here we only check the positions that we know are written. 
////                                             //The frame locations with no frames (even frame locations) have unspecified content 
////                                             //(although, I've checked that they are filled with 0, but no assumption is made). 
////            BOOST_CHECK(read_image == image3);
////        }
////        i++;
////    }
//    for (uint64 i = 0; i < read_advn_seq.endframe()/2; i++)
//    {
//        read_advn_seq[2*i+1] >>read_image;
//        BOOST_CHECK(read_image == image3);
//    }
//}   

//BOOST_AUTO_TEST_CASE (writesequence_yuv_heavy_random_access_writing_test)
//{
//    const std::string filename = string(TEST_DATA_PATH_W) + "/io/heavy_rand_access420.yuv";
//    const std::string comment = "WriteSequenceYUV test file to test heavy random access.";
//    WriteSequenceYUV heavy_rand_seq(filename, 10, 10, 10, 1, YUV420P, comment);
//    std::vector<uint64> image_table(10); 
//    
//    //testing heavy random writing.
//    
//    //this test does the following: 
//    //- during 100 write cycles:
//    //  1- Generate a random number value.
//    //  2- Generate an YUV420 image filled with value in all channels.
//    //  2- Obtain a random frame pointer by calculating value%20.  
//    //  3- Writes the image generated into the generated frame pointer location. 
//    //
//    //As a result of those operations we get a sequence file of 10 images where
//    //the content of the images is a random number between [0,255] filling all the channels of the image.  
//     
//    
//    for(uint64 i = 0; i < 100 ; i++)
//    {
//        ImageYUV420<uint8> image(10,10);
//        uint64 value = rand(); 
//        uint64 fp = value%20; //generate a pointer
//        image = static_cast<uint8> (value); 
//        TRACE ("calculated frame pointer = "<< fp);
//        heavy_rand_seq[fp];
//        TRACE ("assigned frame pointer = " << heavy_rand_seq.frame_pointer());
//        heavy_rand_seq << image;
//        
//        if (fp >= 10)
//        {            
//            image_table[10] = value;
//        }
//        else
//        {
//            image_table[fp] = value;
//        }
//    }
//    //checking results
//    ReadSequence read_heavy_rand_seq(filename);
//    
//    for(uint64 i = 0; i < 10 ; i++)
//    {
//        ImageYUV420<uint8> reference_image(10,10);
//        ImageYUV420<uint8> recovered_image(10,10);
//        reference_image = static_cast<uint8> (image_table[i]); 
//        read_heavy_rand_seq[i] >> recovered_image;
//        BOOST_CHECK(reference_image == recovered_image);
//    }        
//}
//    
//BOOST_AUTO_TEST_CASE (writesequence_yuv_info_access_functions_test)
//{
//    //This test case checks the other functions used to retrieved class related information. 
//}


BOOST_AUTO_TEST_SUITE_END();

