// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------


/*
 * THIS IS NOT A REAL TEST!!
 * 
 * This is just a performance test.
 * It should be moved some other place!!
 */
#if 0


#include <iostream>
#include <time.h>
#include <boost/multi_array.hpp>
#include <boost/numeric/ublas/matrix.hpp>
#include <boost/numeric/ublas/io.hpp>

#include <imageplus/core.hpp>

using namespace imageplus;
using namespace std;
using namespace boost::numeric::ublas;


/*
void test_imageplus_channel (int s)
{
    ImageGray<uint8> a(s,s);
  
    clock_t start,end;

    std::vector<uint8>::iterator it;
    it = a[0].write_data();

    start = clock();
    while (it != a[0].end_data()) {
        *it++ = 4;
    }
    end = clock();
    cout << "iterator access = " << static_cast<double>(end-start)/CLOCKS_PER_SEC << endl;

    start = clock();
    for (int p = 0; p < s*s; p++) {    
        a(p) = 4;
    }
    end = clock();
    cout << "(p) access = " << static_cast<double>(end-start)/CLOCKS_PER_SEC << endl;
    

    start = clock();
    for (int32 p = 0; p < s*s; p++) {    
        a[0](p) = 4;
    }
    end = clock();
    cout << "[0](p) access = " << static_cast<double>(end-start)/CLOCKS_PER_SEC << endl;

    start = clock();
    for (int y = 0; y < s; y++) {    
        for (int x = 0; x < s; x++) {    
            a(x,y) = 4;
            }
        }
    end = clock();
    cout << "(x,y) access = " << static_cast<double>(end-start)/CLOCKS_PER_SEC << endl;
}
*/


void test_imageplus (int s)
{
 
    clock_t start,end;

        
    ImageGray<uint8> b2(s,s);
    start = clock();
    for (int x = 0; x < s; x++) {    
        for (int y = 0; y < s; y++) {    
            b2(0)[x][y] = 4;
            }
        }
    end = clock();
    cout << "ImageGray(0)[x][y] access (c raster) = " << static_cast<double>(end-start)/CLOCKS_PER_SEC << endl;

    ImageGray<uint8> b(s,s);
    start = clock();
    for (int y = 0; y < s; y++) {    
        for (int x = 0; x < s; x++) {    
            b(0)[x][y] = 4;
            }
        }
    end = clock();
    cout << "ImageGray(0)[x][y] access = " << static_cast<double>(end-start)/CLOCKS_PER_SEC << endl;

    ImageGray<uint8> c(s,s);
    start = clock();
    for (int y = 0; y < s; y++) {    
        for (int x = 0; x < s; x++) {    
            c[x][y] = 4;
            }
        }
    end = clock();
    cout << "ImageGray[x][y] access = " << static_cast<double>(end-start)/CLOCKS_PER_SEC << endl;

    ImageGray<uint8> a(s,s);
    uint8* it;
    it = a(0).data();
    start = clock();
    for (int32 p = 0; p < s*s; p++) {
        *it++ = 4;
    }
    end = clock();
    cout << "ImageGray pointer access = " << static_cast<double>(end-start)/CLOCKS_PER_SEC << endl;

}

void test_MultiArray (int s)
{
    clock_t start,end;

    MultiArray<uint8,2> b(s,s);
    start = clock();
    for (int x=0; x < s; x++) {
        for (int y=0; y < s; y++) {
            b[x][y] = 4;
        }
    }
    end = clock();
    cout << "MultiArray [x][y] access (c raster) = " << static_cast<double>(end-start)/CLOCKS_PER_SEC << endl;


    MultiArray<uint8,2> a(s,s);
    start = clock();
    for (int y=0; y < s; y++) {
        for (int x=0; x < s; x++) {
            a[x][y] = 4;
        }
    }
    end = clock();
    cout << "MultiArray [x][y] access = " << static_cast<double>(end-start)/CLOCKS_PER_SEC << endl;


    MultiArray<uint8,2> c(s,s);
    start = clock();
    for (int p=0; p < s*s; p++) {
            c.data()[p] = 4;
    }
    end = clock();
    cout << "MultiArray .data()[p] access = " << static_cast<double>(end-start)/CLOCKS_PER_SEC << endl;

}

void test_multiarray (int s)
{
    clock_t start,end;
    
    boost::multi_array<uint8,2> A(boost::extents[s][s]);
    start = clock();
    for (int y=0; y < s; y++) {
        for (int x=0; x < s; x++) {
            A[x][y] = 4;
        }
    }
    end = clock();
    cout << "multiarray [x][y] access (c raster) = " << static_cast<double>(end-start)/CLOCKS_PER_SEC << endl;


    boost::multi_array<uint8,2> B(boost::extents[s][s],boost::fortran_storage_order());
    start = clock();
    for (int y=0; y < s; y++) {
        for (int x=0; x < s; x++) {
            B[x][y] = 4;
        }
    }
    end = clock();
    cout << "multiarray [x][y] access = " << static_cast<double>(end-start)/CLOCKS_PER_SEC << endl;

    boost::multi_array<uint8,2> C(boost::extents[s][s],boost::fortran_storage_order());
    uint8 *pp = C.data();
    start = clock();    
    for (int p=0; p < s*s; p++) {
        *pp++ = 4;
    }
    end = clock();
    cout << "multiarray .data()[p] access = " << static_cast<double>(end-start)/CLOCKS_PER_SEC << endl;

}


void test_ublas (int s)
{
    clock_t start,end;
    matrix<uint8> D(s,s);

    start = clock();
    for (int y=0; y < s; y++) {
        for (int x=0; x < s; x++) {
            D(x,y) = 4;
        }
    }
    end = clock();
    cout << "ublas (x,y) access = " << static_cast<double>(end-start)/CLOCKS_PER_SEC << endl;

    start = clock();
    for (int x=0; x < s; x++) {
        for (int y=0; y < s; y++) {
            D(x,y) = 4;
        }
    }
    end = clock();
    cout << "ublas (x,y) access (c order)= " << static_cast<double>(end-start)/CLOCKS_PER_SEC << endl;

    matrix<uint8> E;
    E = D;
}

void test_multiarray_constructors (int s)
{
    clock_t start,end;

    
    start = clock();
    boost::multi_array<uint8,2> A(boost::extents[s][s]);
    end = clock();
    cout <<  "multi_array(xy)  = " << static_cast<double>(end-start)/CLOCKS_PER_SEC << endl;

    start = clock();
    MultiArray<uint8,2> B(s,s);
    end = clock();
    cout <<  "MultiArray(x,y)  = " << static_cast<double>(end-start)/CLOCKS_PER_SEC << endl;
    
    start = clock();
    boost::multi_array<uint8,3> AA(boost::extents[s/10][s/10][s/10]);
    end = clock();
    cout <<  "multi_array(xyz) = " << static_cast<double>(end-start)/CLOCKS_PER_SEC << endl;

    start = clock();
    MultiArray<uint8,3> BB(s/10,s/10,s/10);
    end = clock();
    cout <<  "MultiArray(x,y,z)= " << static_cast<double>(end-start)/CLOCKS_PER_SEC << endl;
    
    start = clock();
    boost::multi_array<uint8,2> AAA(A);
    end = clock();
    cout <<  "multi_array(cpy) = " << static_cast<double>(end-start)/CLOCKS_PER_SEC << endl;

    start = clock();
    MultiArray<uint8,2> BBB(B);
    end = clock();
    cout <<  "MultiArray(cpy)  = " << static_cast<double>(end-start)/CLOCKS_PER_SEC << endl;
    

    start = clock();
    ImageGray<uint8> gry(s,s);
    end = clock();
    cout <<  "ImageGray(x,y)   = " << static_cast<double>(end-start)/CLOCKS_PER_SEC << endl;
    
    start = clock();
    ImageGray<uint8> gry_cpy(gry);
    end = clock();
    cout <<  "ImageGray(cpy)   = " << static_cast<double>(end-start)/CLOCKS_PER_SEC << endl;
    
    start = clock();
    ImageRGB<uint8> rb(s,s);
    end = clock();
    cout <<  "ImageRGB(x,y)    = " << static_cast<double>(end-start)/CLOCKS_PER_SEC << endl;
    
    start = clock();
    ImageRGB<uint8> rgb_cpy(rb);
    end = clock();
    cout <<  "ImageRGB(cpy)    = " << static_cast<double>(end-start)/CLOCKS_PER_SEC << endl;
    
}


template< class ImageType >
void test_imageplus_iterators ( int s, string iv_str)
{
 
    clock_t start,end;
    
    typename ImageType::data_type  dat = 4;
    typename ImageType::data_type  ini = 0;
    
#ifdef ITERATORS
    typename ImageType::color_type color = dat;
#endif
    
    //ImageType test(s,s);
    ImageType ima(s,s);
    ImageType res(s,s);
    
    //res = val;
    res = dat;
    ima = ini;
    
    start = clock();
    for (size_t c = 0; c < ima.num_channels(); c++) 
    {
        for (int x = 0; x < s; x++) 
        {    
            for (int y = 0; y < s; y++) 
            {    
                ima(c)[x][y] = dat;
            }
        }
    }
    end = clock();
    cout << iv_str  << "(c)[x][y] access = " << static_cast<double>(end-start)/CLOCKS_PER_SEC << " (c raster)" << endl;
    
    if(! (ima == res) ) cout << "ERROR"  << endl;
    ima = ini;

    start = clock();
    for (size_t c = 0; c < ima.num_channels(); c++) 
    {
        for (int y = 0; y < s; y++) 
        {    
            for (int x = 0; x < s; x++) 
            {    
                ima(c)[x][y] = dat;
            }
        }
    }
    end = clock();
    cout << iv_str  << "(c)[x][y] access = " << static_cast<double>(end-start)/CLOCKS_PER_SEC << endl;


    
    if(! (ima == res) ) cout << "ERROR"  << endl;
    ima = ini;

    // this is not included in the time, but it should be!
    boost::array< uint8*, ImageType::channels > datas;
    for (size_t c = 0; c < ima.num_channels(); c++) 
    {
        datas[c] = ima(c).data();
    }

    start = clock();
    size_t size = s*s;
    for (size_t c = 0; c < ima.num_channels(); c++) 
    {
        for (size_t p = 0; p < size; p++) 
        {
            *(datas[c])++ = dat;
        }
    }
    end = clock();
    cout << iv_str  << " pointers access = " << static_cast<double>(end-start)/CLOCKS_PER_SEC << endl;

    
    if(! (ima == res) ) cout << "ERROR"  << endl;
    ima = ini;

    
#ifdef ITERATORS
    
    start = clock();
    for (typename ImageType::data_iterator it = ima.begin(); it != ima.end(); ++it) 
    {
        *it =  dat;
    }
    end = clock();
    cout << iv_str  << " iterator access = " << static_cast<double>(end-start)/CLOCKS_PER_SEC << endl;

    
    if(! (ima == res) ) cout << "ERROR"  << endl;
    ima = ini;

    start = clock();
    for (typename ImageType::data_iterator it = ima.begin(); it != ima.end(); ++it)
    {
        *it = color;
    }
    end = clock();
    cout << iv_str  << " col iter access = " << static_cast<double>(end-start)/CLOCKS_PER_SEC << endl;

    if(! (ima == res) ) cout << "ERROR"  << endl;
    ima = ini;

#if 0
    start = clock();
    for (size_t c = 0; c < ima.num_channels(); c++) 
    {
        for (typename ImageType::data_iterator it = ima.begin(); it != ima.end(); ++it) 
        {
            (*it)[c] =  dat;
        }
    }
    end = clock();
    cout << iv_str  << " iter[]   access = " << static_cast<double>(end-start)/CLOCKS_PER_SEC << endl;
    

    if(! (ima == res) ) cout << "ERROR"  << endl;
    ima = ini;

    
    start = clock();
    for (typename ImageType::data_iterator it = ima.begin(); it != ima.end(); ++it)
    {
        for (size_t c = 0; c < ima.num_channels(); c++)
        {
            (*it)[c] =  dat;
        }
    }
    end = clock();
    cout << iv_str  << " []iter   access = " << static_cast<double>(end-start)/CLOCKS_PER_SEC << endl;
    
    
    if(! (ima == res) ) cout << "ERROR"  << endl;
    //ima = ini;
    
#endif
#endif
    
    boost::array<std::size_t, 2> pad = {{1,1}};
    
    ImageType _ima_ = ima.with_borders(pad, 0);
    ImageType _res_ = res.with_borders(pad, 0);;

    start = clock();
    for (typename ImageType::data_iterator it = _ima_.begin(); it != _ima_.end(); ++it)
    {
        *it = color;
    }
    end = clock();
    cout << iv_str  << " border access   = " << static_cast<double>(end-start)/CLOCKS_PER_SEC << endl;

    if(! (_ima_ == _res_) ) cout << "ERROR"  << endl;
    ima = ini;

    
    
}


int main()
{
#if 0
    int s = 12000;

    cout << endl;
//    test_imageplus(s); cout << endl;
//    test_MultiArray(s); cout << endl;
//    test_multiarray(s); cout << endl;
//    //test_ublas(s); cout << endl;
    
    cout.precision(2);
    cout.setf(ios::fixed, ios::floatfield);
     
    //test_multiarray_constructors (s);cout << endl;
    
    test_imageplus_iterators< ImageGray<uint8> >(s, "ImageGray"); cout << endl;
    test_imageplus_iterators< ImageRGB<uint8> > (s, "ImageRGB"); cout << endl;
//    test_imageplus_iterators< Volume<uint8,1> > (s, "VolumeGray"); cout << endl;
//    test_imageplus_iterators< Volume<uint8,3> > (s, "VolumeRGB"); cout << endl;



    return 0;
    
#endif
    
}

  
#endif
