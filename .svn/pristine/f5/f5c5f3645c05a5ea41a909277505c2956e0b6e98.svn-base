// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------

//!
//!  \file draw_in_image.cpp
//!
//!  Image drawing basic tools
//!

#ifdef USE_IMAGEMAGICK
#include <Magick++.h>
#endif

#include <imageplus/toolbox/draw_in_image.hpp>

using namespace imageplus;
using namespace imageplus::toolbox;

void imageplus::toolbox::draw_geometric_shape ( ImageRGB<uint8>&               im, 
		                                        const GeometricShape<int64,2>& shape, 
                                                uint8                          R, 
                                                uint8                          G,
                                                uint8                          B )
{
    uint32 top_x=im(0).dims(0), top_y=im(0).dims(1);
    
    GeometricShape<int64,2>::const_iterator iter=shape.begin();
    GeometricShape<int64,2>::const_iterator  end=shape.end();
    
    while (iter!=end)
    {
        if ((*iter)[0] >=0 && (*iter)[0] < top_x && (*iter)[1] >=0 && (*iter)[1] < top_y)
        {
            im(0)(*iter)=R;
            im(1)(*iter)=G;
            im(2)(*iter)=B;
        }
        iter++;
    }
}


void imageplus::toolbox::draw_circle ( ImageRGB<uint8>&      im, 
		                               float64               radius, 
		                               const Coord<int64,2>& center,
		                               uint8                 R,
		                               uint8                 G,
		                               uint8                 B, 
                                       bool                  full_mode,
                                       float64               opacity )
{

#ifdef  USE_IMAGEMAGICK
    // Create a ImageMagick image from ImagePlus ImageRGB<uint8>
    std::size_t bsize = im.size_x() * im.size_y() * 3;
    uint8* data = new uint8[bsize];
    
    export_to(im, data, bsize*sizeof(uint8), RGB);

    Magick::Image magickImage ( im.size_x(), im.size_y(),
                                "RGB",
                                Magick::CharPixel, data );


    // Draw figure
    std::list<Magick::Drawable> draw_list;
    draw_list.push_back(Magick::DrawableStrokeColor (Magick::ColorRGB(R/255.,G/255.,B/255.))); // Outline color 
    draw_list.push_back(Magick::DrawableStrokeWidth (1));
    if ( full_mode )
    {
        draw_list.push_back(Magick::DrawableFillColor (Magick::ColorRGB(R/255.,G/255.,B/255.)));
        draw_list.push_back(Magick::DrawableFillOpacity (opacity));
    }

    draw_list.push_back(Magick::DrawableCircle(center[0], center[1], center[0] + radius, center[1]) );
    magickImage.draw(draw_list);


    // Copy data from ImageMagick image to ImagePlus image
    magickImage.write( 0, 0, im.size_x(), im.size_y(),
                       "RGB", Magick::CharPixel, data );

    import_from (im, data, bsize*sizeof(uint8), RGB);

    delete[] data;
#else
    uint32 x,y;
    uint32 top_x=im(0).dims(0), top_y=im(0).dims(1);
    float64 interval=0.2*3.1416/(radius);
    
    for (float64 j=0; j<2*3.1416; j=j+interval)
    {
        x=static_cast<uint32>(radius*cos(j))+center.x();
        y=static_cast<uint32>(radius*sin(j))+center.y();
        if (x>=0 && x < top_x && y>=0 && y<top_y)
        { 
            im(RED_CHANNEL)[x][y]=R;
            im(GREEN_CHANNEL)[x][y]=G;
            im(BLUE_CHANNEL)[x][y]=B;
        }
    }
#endif
}


void imageplus::toolbox::draw_line( ImageRGB<uint8>&      im,
		                            const Coord<int64,2>& c1_,
		                            const Coord<int64,2>& c2_,
                                    uint8                 R,
                                    uint8                 G,
                                    uint8                 B,
                                    int32                 step,
                                    float64               opacity )
{
    if (step <1) step=1;
    int32 dx, dy; /* relative displacement */
    int32 iy;     /* vertical increment, -1, 0 o 1 */
    int32 n;      /* decision */
    int32 count;  /* loop variable */
    int32 top_x=im(0).dims(0), top_y=im(0).dims(1);
    
    /* to avoid changing input parameters */
    Coord<int64,2> c1 = c1_;
    Coord<int64,2> c2 = c2_;
    
    /* ensure x2 > x1, otherwise, swap (x1,y1) and (x2,y2) */
    if (c2.x()< c1.x())
    {
        Coord<int64,2> tmp=c1;
        c1=c2;
        c2=tmp;
    }
    
    dx = c2.x()-c1.x();
    dy = c2.y()-c1.y();
    
    iy =(dy > 0 ? 1 : (dy < 0 ? -1 : 0));
    dy = std::abs(dy);
    
    /* paint line */
    
    if (dx >= dy)
    {
        /* dx >= dy.
         * the loop paint a point at (x1,y1).
         * Increment x1 in steps of 1 until x2 is reached.
         * En each step, add dy to n. When n is greater or equal to dx,
         * y1 is incremented by iy, and n is substracted to dx.
         * n is initialized to dx/2.
         */
    
        n = dx>>1, count = dx;
    
        do
        {
            if (c1.x()>=0 && c1.x()<top_x && c1.y()>=0 && c1.y()<top_y) 
            {

                im(RED_CHANNEL)  (c1) = opacity * R + (1.0 - opacity) * im(RED_CHANNEL)(c1);
                im(GREEN_CHANNEL)(c1) = opacity * G + (1.0 - opacity) * im(GREEN_CHANNEL)(c1);
                im(BLUE_CHANNEL) (c1) = opacity * B + (1.0 - opacity) * im(BLUE_CHANNEL)(c1);                
            }
            c1.x()+=step, n += dy;
            if (n>=dx)
            {
                n -= dx;
                c1.y() += step*iy;
            }
            count-=step;
        }
        while (count>0);
    }
    else
    {
        /* dy >= dx.
         * As in the previous case, changing x per y and vice-versa.
         */
    
        n = dy>>1, count = dy;
    
        do
        {
            if (c1.x()>=0 && c1.x()<top_x && c1.y()>=0 && c1.y()<top_y) 
            {

                im(RED_CHANNEL)  (c1) = opacity * R + (1.0 - opacity) * im(RED_CHANNEL)(c1);
                im(GREEN_CHANNEL)(c1) = opacity * G + (1.0 - opacity) * im(GREEN_CHANNEL)(c1);
                im(BLUE_CHANNEL) (c1) = opacity * B + (1.0 - opacity) * im(BLUE_CHANNEL)(c1);
            }
            c1.y() += step*iy, n += dx;
            if (n>=dy)
                n -= dy, c1.x()+=step;
            count-=step;
        }
        
        while (count>0);
    }
}

void imageplus::toolbox::draw_rectangle( ImageRGB<uint8>&      output_image, 
		                                 const Coord<int64,2>& center,
                                         float64               width, 
                                         float64               height,
                                         uint8                 R,
                                         uint8                 G,
                                         uint8                 B,
                                         int32                 step,
                                         bool                  full_mode,
                                         float64               opacity )
{
    Coord<int64,2> init, end;
    // Calculating the borders of the rectangle with the info given
    uint64 xi = static_cast< uint64 > ( center.x() - width/2 - height/2 );
    uint64 yi = static_cast< uint64 > ( center.y() - width/2 - height/2 );
    uint64 xf = static_cast< uint64 > ( center.x() + width/2 + height/2 );
    uint64 yf = static_cast< uint64 > ( center.y() + width/2 + height/2 );

#ifdef  USE_IMAGEMAGICK
    // Create a ImageMagick image from ImagePlus ImageRGB<uint8>
    std::size_t bsize = output_image.size_x() * output_image.size_y() * 3;
    uint8* data = new uint8[bsize];
    
    export_to(output_image, data, bsize*sizeof(uint8), RGB);

    Magick::Image magickImage ( output_image.size_x(), output_image.size_y(),
                                "RGB",
                                Magick::CharPixel, data );


    // Draw figure
    std::list<Magick::Drawable> draw_list;
    draw_list.push_back(Magick::DrawableStrokeColor (Magick::ColorRGB(R/255.,G/255.,B/255.))); // Outline color 
    draw_list.push_back(Magick::DrawableStrokeWidth (1));
    if ( full_mode )
    {
        draw_list.push_back(Magick::DrawableFillColor (Magick::ColorRGB(R/255.,G/255.,B/255.)));
        draw_list.push_back(Magick::DrawableFillOpacity (opacity));
    }

    draw_list.push_back(Magick::DrawableRectangle(xi,yi,xf,yf) );
    magickImage.draw(draw_list);


    // Copy data from ImageMagick image to ImagePlus image
    magickImage.write( 0, 0, output_image.size_x(), output_image.size_y(),
                       "RGB", Magick::CharPixel, data );

    import_from (output_image, data, bsize*sizeof(uint8), RGB);

    delete[] data;
#else
    // Drawing rectangle
    if( full_mode )
    {
    	for( uint64 i = yi; i <= yf; i++  )
    	{
    		init.x() = xi; init.y() = i; end.x() = xf; end.y() = i;
    		draw_line( output_image, init, end, R,G,B, step ); // Horizontal line
    	}
    }
    else
    {
    	init.x()=xi; init.y()=yi; end.x()=xf; end.y()=yi;
	    draw_line( output_image, init, end, R,G,B, step ); // Horizontal line from origin 
	    init.x()=xi; init.y()=yi; end.x()=xi; end.y()=yf;
	    draw_line( output_image, init, end, R,G,B, step ); // Vertical line from origin 
	    init.x()=xf; init.y()=yi; end.x()=xf; end.y()=yf;
	    draw_line( output_image, init, end, R,G,B, step ); // Vertical line from end 
	    init.x()=xi; init.y()=yf; end.x()=xf; end.y()=yf;
	    draw_line( output_image, init, end, R,G,B, step ); // Horizontal line from end
    }
#endif

}




void imageplus::toolbox::draw_rectangle( ImageRGB<uint8>&      output_image, 
		                                 const BBox2D&         rect, 
                                         uint8                 R,
                                         uint8                 G,
                                         uint8                 B,
                                         int32                 step,
                                         bool                  full_mode,
                                         float64               opacity )
{
#ifdef  USE_IMAGEMAGICK
    // Create a ImageMagick image from ImagePlus ImageRGB<uint8>
    std::size_t bsize = output_image.size_x() * output_image.size_y() * 3;
    uint8* data = new uint8[bsize];
    
    export_to(output_image, data, bsize*sizeof(uint8), RGB);

    Magick::Image magickImage ( output_image.size_x(), output_image.size_y(),
                                "RGB",
                                Magick::CharPixel, data );


    // Draw figure
    std::list<Magick::Drawable> draw_list;
    draw_list.push_back(Magick::DrawableStrokeColor (Magick::ColorRGB(R/255.,G/255.,B/255.))); // Outline color 
    draw_list.push_back(Magick::DrawableStrokeWidth (1));
    if ( full_mode )
    {
        draw_list.push_back(Magick::DrawableFillColor (Magick::ColorRGB(R/255.,G/255.,B/255.)));
        draw_list.push_back(Magick::DrawableFillOpacity (opacity));
    }

    draw_list.push_back(Magick::DrawableRectangle(rect.origin()[0],rect.origin()[1],rect.opposite()[0],rect.opposite()[1]) );
    magickImage.draw(draw_list);


    // Copy data from ImageMagick image to ImagePlus image
    magickImage.write( 0, 0, output_image.size_x(), output_image.size_y(),
                       "RGB", Magick::CharPixel, data );

    import_from (output_image, data, bsize*sizeof(uint8), RGB);

    delete[] data;
#else

    // avoid bbox exceeding the limits of the image
    BBox2D frame_bb(Coord<int64,2>(0,0), output_image.size_x(), output_image.size_y());
    BBox2D bb(rect); //rect is const. We need a copy to be able to modify it.

    imageplus::math::geometry::limit_bbox_to_bbox(frame_bb, bb);

    Coord2D<int64> init, end;

    // Drawing rectangle
    if ( full_mode )
    {
        init = bb.origin();
        end  = bb.opposite();

    	for( int64 i = bb.origin()[1]; i <= bb.opposite()[1]; ++i  )
    	{
            init[1] = i; end[1] = i;
    		draw_line( output_image, init, end, R,G,B, step, opacity ); // Horizontal line
    	}
    }
    else
    {
    	end[0]=bb.opposite()[0]; end[1]=bb.origin()[1];
	    draw_line( output_image, bb.origin(), end, R,G,B, step, opacity  ); // Horizontal line from origin 

	    end[0]=bb.origin()[0]; end[1]=bb.opposite()[1];
	    draw_line( output_image, bb.origin(), end, R,G,B, step, opacity  ); // Vertical line from origin 

	    init[0]=bb.opposite()[0]; init[1]=bb.origin()[1];
	    draw_line( output_image, init, bb.opposite(), R,G,B, step, opacity ); // Vertical line from end 

	    init[0]=bb.origin()[0]; init[1]=bb.opposite()[1];
	    draw_line( output_image, init, bb.opposite(), R,G,B, step, opacity  ); // Horizontal line from end
    }
#endif
}

void imageplus::toolbox::draw_cross( ImageRGB<uint8>&     output_image, 
		                            const Coord<int64,2>& center,
		                            float64               width,
					                float64               height,
					                uint8                 R,
					                uint8                 G,
					                uint8                 B,
					                int32                 step )
{
	// Calculating the borders of the rectangle with the info given
	uint64 xi = static_cast< uint64 > ( center.x() - 0.1 * ( width/2 - height/2 ) );
	uint64 yi = static_cast< uint64 > ( center.y() - 0.1 * ( width/2 - height/2 ) );
	uint64 xf = static_cast< uint64 > ( center.x() + 0.1 * ( width/2 + height/2 ) );
	uint64 yf = static_cast< uint64 > ( center.y() + 0.1 * ( width/2 + height/2 ) );
	
	// Error control for xi, xf, yi & yf to not exceed the limits of the image
	if ( xi < 0 ) xi = 0; else if ( xi >= output_image.size_x() ) xi = output_image.size_x() - 1;
	if ( xf < 0 ) xf = 0; else if ( xf >= output_image.size_x() ) xf = output_image.size_x() - 1;
	if ( yi < 0 ) yi = 0; else if ( yi >= output_image.size_y() ) yi = output_image.size_y() - 1;
	if ( yf < 0 ) yf = 0; else if ( yf >= output_image.size_y() ) yf = output_image.size_y() - 1;
	 
	// Drawing cross
	Coord2D<> origin_1( xi, yi ), origin_2( xi, yf );
	Coord2D<> end_1( xf, yf ), end_2( xf, yi );

	draw_line( output_image, origin_1, end_1, R, G, B, step );
	draw_line( output_image, origin_2, end_2, R, G, B, step );
}

void imageplus::toolbox::draw_point(ImageRGB<uint8>& im, const Coord<int64,2>&  pos, uint8 R, uint8 G, uint8 B)
{
	int64 i = static_cast< int64 > ( pos.x() );	
	int64 j = static_cast< int64 > ( pos.y() );

	im(0)[ i ][ j ] = R;		im(1)[ i ][ j ] = G;		im(2)[ i ][ j ] = B;
}

void imageplus::toolbox::draw_v_cross( ImageRGB<uint8>&   im, 
		const Coord<int64,2>&  pos,
		int64           	size,
		uint8             	R, 
		uint8            	G, 
		uint8             	B)
{
	int64 i =  (int64)( pos.x() );
	int64 j =  (int64)( pos.y() );

	//Vertical
	for( int64 v = std::max( i-(int64)size,(int64)0 ) ; v <= std::min( (int64)im.size_x()-1,i+(int64)size); v++)
    {
		draw_point(im, Coord<int64,2>( v, j), R, G, B);
	}
	for( int64 v = std::max( j-(int64)size,(int64)0 ) ; v <= std::min( (int64)im.size_y()-1,j+(int64)size); v++)
    {
		draw_point(im, Coord<int64,2>( i, v), R, G, B);
	}
}

void imageplus::toolbox::draw_bbox( ImageRGB<uint8>& im, 
                                    const BBox2D&    bbox, 
                                    uint8            R, 
                                    uint8            G, 
                                    uint8            B)
{
	draw_rectangle( im, bbox.center(), bbox.side_x(), bbox.side_y(), R,G,B, false);
}

void imageplus::toolbox::render_text (ImageRGB<uint8>&   image,
                                      const std::string& text, 
                                      const Coord2D<>&   pos,  
                                      uint8              R,
                                      uint8              G,
                                      uint8              B,
                                      const std::string& font,
                                      uint64             font_point_size,
                                      bool               under_box) 
{
#ifdef  USE_IMAGEMAGICK

    // Create a ImageMagick image from ImagePlus ImageRGB<uint8>
    std::size_t bsize = image.size_x() * image.size_y() * 3;
    uint8* data = new uint8[bsize];
    
    export_to(image, data, bsize*sizeof(uint8), RGB);

    Magick::Image magickImage ( image.size_x(), image.size_y(),
                                "RGB",
                                Magick::CharPixel, data );

    // Draw text
    std::list<Magick::Drawable> draw_list;
    draw_list.push_back(Magick::DrawableFont (font) );
    draw_list.push_back(Magick::DrawablePointSize (font_point_size) );
    draw_list.push_back(Magick::DrawableStrokeColor (Magick::Color() ));
    draw_list.push_back(Magick::DrawableFillColor (Magick::ColorRGB(R/255.,G/255.,B/255.) ));
    if ( under_box )
    {
        draw_list.push_back(Magick::DrawableTextUnderColor(Magick::ColorRGB(0,0,0) ));
    }
    draw_list.push_back(Magick::DrawableText(pos[0], pos[1], text) );
    magickImage.draw(draw_list);


    // Copy data from ImageMagick image to ImagePlus image
    magickImage.write( 0, 0, image.size_x(), image.size_y(),
                       "RGB", Magick::CharPixel, data );

    import_from (image, data, bsize*sizeof(uint8), RGB);

    delete[] data;
#else
    throw ImagePlusError("Function not implemented without ImageMagick");
#endif

}

