// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------
//!
//!  \file readroom.cpp
//!
//!  \brief Implementation of class ReadRoom
//!
#include <imageplus/io/readroom.hpp>

#include <cstdio>

using namespace imageplus;
using namespace imageplus::io;
using namespace imageplus::compress;
using namespace std;

ReadRoom::ReadRoom():_filename("")
{

}

ReadRoom::ReadRoom( const std::string& filename ) :
        _filename( filename )
{
}

ReadRoom::~ReadRoom()
{
}
void ReadRoom::open(const std::string& filename)
{
    FILE *fp=fopen(filename.c_str(), "rb");
    if (fp==NULL) throw ImagePlusFileNotFound( "ERROR(ReadRoom) : Cannot open  " + filename );
    else
    {
        fclose(fp);
        _filename=filename;
    }
}
template<typename T>
void ReadRoom::operator>>( Room<T,3>& r ) const
{
}


template<typename T>
void ReadRoom::operator>>( Room<T,1>& r ) const
{
    //Data Union for type conversion
    union _dataToCompress
    {
        T *dataVoxelOriginal;
        uint8 *dataVoxelsInChars;
    } dataToCompress;
    
    uint16 currentFileVersion =3; // file version (Hardcoded)
    uint16 fileVersion; 
    int32 headerSize=34; // header size in bytes (Hardcoded)
    uint32 cubesX, cubesY, cubesZ;
    float32 voxelSize;
    uint64 compressedSize;
    int64 fileSize;
    uint8 numChannels;
    uint8 dataType;
    float32 offsetX,offsetY,offsetZ;
    uint16 useCompress;
    
    size_t read_size;


    FILE *fp=fopen(_filename.c_str(),"rb");
    if (fp!=NULL)
    {
        
        fseek(fp,0,SEEK_END);
        fileSize=ftell(fp);
        rewind(fp);
        
        // Read file header
        read_size = fread(&fileVersion,sizeof(uint16),1,fp);
        if (read_size != 1)
        {
            throw ImagePlusError( "ERROR(ReadRoom) : Data read is not consistent");
        }   
        read_size = fread(&cubesX,sizeof(uint32),1,fp);
        if (read_size != 1)
        {
            throw ImagePlusError( "ERROR(ReadRoom) : Data read is not consistent");
        }   
        read_size = fread(&cubesY,sizeof(uint32),1,fp);
        if (read_size != 1)
        {
            throw ImagePlusError( "ERROR(ReadRoom) : Data read is not consistent");
        }   
        read_size = fread(&cubesZ,sizeof(uint32),1,fp);
        if (read_size != 1)
        {
            throw ImagePlusError( "ERROR(ReadRoom) : Data read is not consistent");
        }   
        read_size = fread(&numChannels,sizeof(uint8),1,fp);
        if (read_size != 1)
        {
            throw ImagePlusError( "ERROR(ReadRoom) : Data read is not consistent");
        }   
        read_size = fread(&dataType,sizeof(uint8),1,fp);
        if (read_size != 1)
        {
            throw ImagePlusError( "ERROR(ReadRoom) : Data read is not consistent");
        }   
        read_size = fread(&voxelSize,sizeof(float32),1,fp);
        if (read_size != 1)
        {
            throw ImagePlusError( "ERROR(ReadRoom) : Data read is not consistent");
        }   
        read_size = fread(&offsetX,sizeof(float32),1,fp);
        if (read_size != 1)
        {
            throw ImagePlusError( "ERROR(ReadRoom) : Data read is not consistent");
        }   
        read_size = fread(&offsetY,sizeof(float32),1,fp);
        if (read_size != 1)
        {
            throw ImagePlusError( "ERROR(ReadRoom) : Data read is not consistent");
        }   
        read_size = fread(&offsetZ,sizeof(float32),1,fp);
        if (read_size != 1)
        {
            throw ImagePlusError( "ERROR(ReadRoom) : Data read is not consistent");
        }   
        read_size = fread(&useCompress,sizeof(uint16),1,fp);
        if (read_size != 1)
        {
            throw ImagePlusError( "ERROR(ReadRoom) : Data read is not consistent");
        }   
        
        if(fileVersion!=currentFileVersion)
        {
           throw ImagePlusError( "ERROR(ReadRoom) : Incompatible version" );
        }
        
        switch(dataType)
        {
            case 0: //unsigned char
                if(typeid(T)!= typeid(uint8))
                {
                    throw ImagePlusError( "ERROR(ReadRoom) : Reading not correct format");
                }
                else break;
            case 1: //char
                if(typeid(T)!= typeid(int8))
                {
                    throw ImagePlusError( "ERROR(ReadRoom) : Reading not correct format");
                }
                else break;
            case 2: //unsigned short
                if(typeid(T)!= typeid(uint16))
                {
                    throw ImagePlusError( "ERROR(ReadRoom) : Reading not correct format");
                }
                else break;
            case 3: //short
                if(typeid(T)!= typeid(int16))
                {
                    throw ImagePlusError( "ERROR(ReadRoom) : Reading not correct format");
                }
                else break;
            case 4: //unsigned int
                if(typeid(T)!= typeid(uint32))
                {
                    throw ImagePlusError( "ERROR(ReadRoom) : Reading not correct format");
                }
                else break;
            case 5: //int
                if(typeid(T)!= typeid(int32))
                {
                    throw ImagePlusError( "ERROR(ReadRoom) : Reading not correct format");
                }
                else break;
            case 6: //float
                if(typeid(T)!= typeid(float32))
                {
                    throw ImagePlusError( "ERROR(ReadRoom) : Reading not correct format");
                }
                else break;
            case 7: //double
                if(typeid(T)!= typeid(float64))
                {
                    throw ImagePlusError( "ERROR(ReadRoom) : Reading not correct format");
                }
                else break;
        }
        
        if(numChannels != 1)
        {
            throw ImagePlusError( "ERROR(ReadRoom) : Reading not correct number of channels");
        }
        
        Point3D offset(static_cast<float64> (offsetX),static_cast<float64>(offsetY),static_cast<float64> (offsetZ));
        //Reallocation of the room given file parameters
        r=Room<T,1>(static_cast<uint64>(cubesX),static_cast<uint64>(cubesY),static_cast<uint64>(cubesZ), static_cast<float64>(voxelSize),offset);
        
        if(useCompress == 1)
        {            
            //calculate total amount of compressed data stored in the file
            compressedSize = fileSize - headerSize;
            //Allocate a data buffer
            uint8 *buffer = new uint8[compressedSize];
            //Pointer to data
            dataToCompress.dataVoxelOriginal=r.volume()(0).data();
            //Read all Data as a single block
            read_size = fread (buffer,sizeof(uint8),compressedSize,fp);
            if (read_size != compressedSize)
            {
                throw ImagePlusError( "ERROR(ReadRoom) : Data read is not consistent");
            }   

            //Uncompress data
            Rle uncompressor;
            uncompressor.uncompress (buffer,dataToCompress.dataVoxelsInChars,compressedSize);
            //Free memory
            delete [] buffer;          
         }
         else
         {
            T *dataVoxel = r.volume()(0).data();
            uint64 numVoxels = cubesX*cubesY*cubesZ;    
            read_size = fread(dataVoxel,sizeof(T),numVoxels,fp);
            if (read_size != numVoxels)
            {
                throw ImagePlusError( "ERROR(ReadRoom) : Data read is not consistent");
            }
                
         }  
        fclose(fp);
    }
    else throw ImagePlusFileNotFound( "ERROR(ReadRoom) : Cannot open  " + _filename );    
}

template<typename T>
void ReadRoom::read_rle_v2( Room<T,1>& r ) const
{
    
    size_t read_size;

    //Data Union for type conversion
        union _dataToCompress
        {
            T *dataVoxelOriginal;
            uint8 *dataVoxelsInChars;
        } dataToCompress;

        uint32 CubesX, CubesY, CubesZ;
        float64 VoxelSize;

        FILE *fp=fopen(_filename.c_str(), "rb");
        if (fp!=NULL)
        {
            imageplus::uint32 r_size;

            // Read file header
            uint16 usInputVersion;
            read_size = fread(&usInputVersion,sizeof(uint16),1,fp);
            if (read_size != 1)
            {
                throw ImagePlusError( "ERROR(ReadRoom) : Data read is not consistent");
            }   

            // Check file version
    //  if(usInputVersion!=FileVersion)
    //  {
    //   throw ImagePlusError( "ERROR(ReadRoom) : Incompatible version );
    //  }
            //Read Header from file
            fileheader header;
            read_size = fread(&header,sizeof(fileheader),1,fp);
            if (read_size != 1)
            {
                throw ImagePlusError( "ERROR(ReadRoom) : Data read is not consistent");
            }   

            CubesX=header.cubes_x;
            CubesY=header.cubes_y;
            CubesZ=header.cubes_z;
            VoxelSize=header.voxel_size;
            //Consistency check: Size of Data Type
            if (header.data_size!=sizeof(T))
            {
                throw ImagePlusError( "ERROR(ReadRoom) : Inconsistent Data Size " + _filename );
            }

            //Reallocation of the room given file parameters
            r=Room<T,1>(CubesX,CubesY,CubesZ, VoxelSize);

            //Read sizeo of the total amount of data stored in the file
            read_size = fread(&r_size,sizeof(uint32),1,fp);
            if (read_size != 1)
            {
                throw ImagePlusError( "ERROR(ReadRoom) : Data read is not consistent");
            }   

            //Allocate a data buffer
            uint8 *buffer = new uint8[r_size];
            //Pointer to data
            dataToCompress.dataVoxelOriginal=r.volume()(0).data();
            //Read all Data as a single block
            read_size = fread (buffer,1,r_size,fp);
            if (read_size != r_size)
            {
                throw ImagePlusError( "ERROR(ReadRoom) : Data read is not consistent");
            }   

            //Uncompress data
            Rle uncompressor;
            uncompressor.uncompress (buffer,dataToCompress.dataVoxelsInChars,r_size);
            //Free memory
            delete [] buffer;
            //delete[] header;
            //Close file
            fclose(fp);
        }
        else throw ImagePlusFileNotFound( "ERROR(ReadRoom) : Cannot open  " + _filename ); 
    
}



//ReadRoom instantiations
namespace imageplus
{
    namespace io
    {

        template void ReadRoom::operator>><uint8>(Room<uint8,1>&) const;
        template void ReadRoom::operator>><uint8>(Room<uint8,3>&) const;

        template void ReadRoom::operator>><uint32>(Room<uint32,1>&) const;
        template void ReadRoom::operator>><uint32>(Room<uint32,3>&) const;

        template void ReadRoom::operator>><int32>(Room<int32,1>&) const;
        template void ReadRoom::operator>><int32>(Room<int32,3>&) const;

        
        template void ReadRoom::operator>><int64>(Room<int64,1>&) const;
        template void ReadRoom::operator>><int64>(Room<int64,3>&) const;

        template void ReadRoom::operator>><float64>(Room<float64,1>&) const;
        template void ReadRoom::operator>><float64>(Room<float64,3>&) const;
        
        template void ReadRoom::read_rle_v2<uint8>(Room<uint8,1>&) const;
        

        template void ReadRoom::read_rle_v2<int64>(Room<int64,1>&) const;
        

        template void ReadRoom::read_rle_v2<float64>(Room<float64,1>&) const;
        
        

    }
}

