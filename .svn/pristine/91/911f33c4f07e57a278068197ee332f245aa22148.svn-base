/*
 * joint_region_pruner.hpp
 *
 *  Created on: Dec 18, 2012
 *      Author: gpalou
 */

#ifndef JOINT_REGION_PRUNER_HPP_
#define JOINT_REGION_PRUNER_HPP_

#include <imageplus/bpt/pruning/bpt_pruner.hpp>

namespace imageplus {
	namespace bpt {

	//! Simple class that prunes the BPT at given sets of regions
	//! \param BPT: tree type
	//! \param ImageModel : image type
	template<class BPT, class ImageModel>
	class JointRegionPruner : public BPTPruner<BPT,ImageModel>{

		typedef BPTPruner<BPT,ImageModel> Pruner;
		typedef typename Pruner::RegionsIDs RegionsIDs;

	public:

		//! sets the two sets of regions
		//! \param[in] rA : set A of regions
		//! \param[in] rA : set B of regions
		void regions(RegionsIDs& rA, RegionsIDs& rB) {_rA = rA; _rB = rB;}

		//! Auxiliar function that returns all the descendants from a node
		//! \param[in] bpt: tree
		//! \param[in] terminals: regions restricting the tree
		//! \param[in] id: region id
		RegionsIDs descendants_of_node(BPT& bpt, RegionsIDs& terminals, uint64 id) {
			std::deque<uint64> q;
			q.push_back(id);
			RegionsIDs leaves;

			while(!q.empty()) {
				uint64 r = q.front(); q.pop_front();
				leaves.insert(r);
				if (terminals.find(r) != terminals.end()) {continue;}
				if (bpt[r].parts().size() != 0) {
					q.push_back(bpt[r].parts()[0]->id());
					q.push_back(bpt[r].parts()[1]->id());
				}
			}
			return leaves;
		}

		//! Functions that finds the regions to prune
		//! \param[in] bpt: tree
		//! \param[in] img: image
		//! \param[in] reg_id: id of the root to begin to count (normally the root of the tree)
		const RegionsIDs& find_pruned_regions(BPT& bpt, ImageModel& img, uint64 reg_id) {
			RegionsIDs dA = descendants_of_node(bpt,_rA,reg_id);
			RegionsIDs dB = descendants_of_node(bpt,_rB,reg_id);

			std::vector<uint64> dU;
			RegionsIDs leaves;

			std::set_union(dA.begin(), dA.end(), dB.begin(), dB.end(), std::back_inserter(dU));

			RegionsIDs ddU(dU.begin(), dU.end());

			for (typename RegionsIDs::iterator nodes = ddU.begin(); nodes != ddU.end(); nodes++) {
				if (bpt[*nodes].parts().size() == 0) {
					leaves.insert(*nodes);
					continue;
				}
				uint64 s1 = bpt[*nodes].parts()[0]->id();
				uint64 s2 = bpt[*nodes].parts()[1]->id();
				if (ddU.find(s1) == ddU.end()) leaves.insert(*nodes);
				if (ddU.find(s2) == ddU.end()) leaves.insert(*nodes);
			}

			RegionPruner<BPT,ImageModel> pruner(leaves);

			Pruner::_regions = pruner.find_pruned_regions(bpt,false);
		}

	private:

		//! Region sets
		RegionsIDs _rA, _rB;

	};

	}
}

#endif /* JOINT_REGION_PRUNER_HPP_ */
