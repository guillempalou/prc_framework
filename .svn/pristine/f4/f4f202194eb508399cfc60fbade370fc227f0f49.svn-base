// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------

//!
//!  \file multiarray_operations.test
//!
//!  multiarray tests
//!

#include <iostream>
#include <imageplus/core.hpp>
#include <imageplus/math/numeric/products.hpp>
#include <imageplus/math/numeric/norms.hpp>
#include <imageplus/math/numeric/transformations.hpp>
#include <imageplus/math/numeric/matrices.hpp>
#include <imageplus/math/numeric/lu_decomposition.hpp>

#include <boost/test/floating_point_comparison.hpp>

BOOST_AUTO_TEST_SUITE ( numericSuite );

using namespace std;
using namespace imageplus;
using namespace imageplus::math::numeric;


typedef boost::mpl::list<uint8,int64,float64> DataTypes;


BOOST_AUTO_TEST_CASE_TEMPLATE( MultiArray_prod, T, DataTypes )
{
    
    for (uint32 size = 1; size < 10; size++) 
    {

        MultiArray<T,2> ma(size,size),I2d;
        
        I2d = identity_matrix<T>(size);
        
        ma = static_cast<T>(5);
        
        MultiArray<T,2> r2d;
        
        r2d = prod(I2d,ma);
        BOOST_CHECK_EQUAL(ma,r2d);
        BOOST_CHECK_EQUAL(r2d,static_cast<T>(5));
        
        r2d = prod(ma,I2d);
        BOOST_CHECK_EQUAL(ma,r2d);
        BOOST_CHECK_EQUAL(r2d,static_cast<T>(5));
        
        //Matrix-vector product test
        MultiArray<T,1> v(size), w(size) , r1d(size);
        
        v = w = 1;
        
        r1d=prod(ma,v);
        BOOST_CHECK_EQUAL(r1d.dims(0),size);
        BOOST_CHECK_EQUAL(r1d,static_cast<T>(5*size));
        
        r1d = prod(w,ma);
        BOOST_CHECK_EQUAL(r1d.dims(0),size);
        BOOST_CHECK_EQUAL(r1d,static_cast<T>(5*size));
    }
}    

BOOST_AUTO_TEST_CASE_TEMPLATE( MultiArray_norm, T, DataTypes )
{

    for (uint32 size = 1; size < 10; size++) 
    {
        
        //Matrix-vector product test
        MultiArray<T,1> v(size);
        v = 1;

        //Vector norm
        BOOST_CHECK_CLOSE( norm(v), (float64)sqrt((float64)size), 0.00001 );
    }
}

BOOST_AUTO_TEST_CASE_TEMPLATE( MultiArray_trans, T, DataTypes )
{
    for (uint32 size = 1; size < 10; size++) 
    {

        // Transposition
        MultiArray<T,2> ma(size,size),ma1(size,size),ma2(size,size);
        T val = static_cast<T>(0);

        ma = static_cast<T>(1);
        for (uint32 y = 0; y < size; y++) {
            for (uint32 x = 0; x < size; x++) {
                ma1[x][y] = static_cast<T>(val++);
            }
        }
        val = static_cast<T>(0);
        for (uint32 x = 0; x < size; x++) {
            for (uint32 y = 0; y < size; y++) {
                ma2[x][y] = static_cast<T>(val++);
            }
        }
        
        BOOST_CHECK_EQUAL(trans(ma),ma);
        BOOST_CHECK_EQUAL(trans(ma1),ma2);
        BOOST_CHECK_EQUAL(trans(ma2),ma1);
        
    }
}
    
BOOST_AUTO_TEST_CASE( MultiArray_invert )
{
    //Matrix invert
    for (uint32 size = 1; size < 10; size++) 
    {
        MultiArray<float64,2> I(size,size);    
        I = identity_matrix<float64>(size);
        BOOST_CHECK_EQUAL(invert_matrix(I),I);
    }
}

BOOST_AUTO_TEST_CASE_TEMPLATE( MultiArray_cross, T, DataTypes )
{
    // cross product
    MultiArray<T,1> u1(3),u2(3),t(3);

    u1[0] = static_cast<T>(3); u1[1] = static_cast<T>(0); u1[2] = static_cast<T>(0);
    u2[0] = static_cast<T>(0); u2[1] = static_cast<T>(2); u2[2] = static_cast<T>(0);
    t[0]  = static_cast<T>(0); t[1]  = static_cast<T>(0); t[2]  = static_cast<T>(6);
    BOOST_CHECK_EQUAL(cross_prod3(u1,u2),t);

}

BOOST_AUTO_TEST_CASE( MultiArray_lu_solve )
{
    MultiArray<float64,2> a(2,2);
    MultiArray<float64,2> sol(2,2);
    MultiArray<float64,1> indep(2), vsol(2);

    //Data
    a[0][0]=4;
    a[0][1]=6;
    a[1][0]=3;
    a[1][1]=3;
    indep[0]=1;
    indep[1]=0;
    
    //Evaluation of solution
    vsol=lu_solve(a,indep);
    BOOST_CHECK_EQUAL(vsol[0], -0.5);
    BOOST_CHECK_EQUAL(vsol[1], 1);
}

BOOST_AUTO_TEST_CASE_TEMPLATE( MultiArray_scalar_prod, T, DataTypes )
{
    // scalar product
    MultiArray<T,1> u1(3),u2(3);
    T result;

    u1[0] = static_cast<T>(3); u1[1] = static_cast<T>(1); u1[2] = static_cast<T>(2);
    u2[0] = static_cast<T>(1); u2[1] = static_cast<T>(2); u2[2] = static_cast<T>(0);
    result=static_cast<T>(5);
    BOOST_CHECK_EQUAL(scalar_prod(u1,u2),result);
}

BOOST_AUTO_TEST_CASE( MultiArray_det )
{
    // cross product
    MultiArray<float64,2> u1(3,3);

    u1[0][0] = static_cast<float64>(5.0);
    u1[1][0] = static_cast<float64>(4.0);
    u1[2][0] = static_cast<float64>(7.0);
    u1[0][1] = static_cast<float64>(2.0);
    u1[1][1] = static_cast<float64>(5.0);
    u1[2][1] = static_cast<float64>(8.0);
    u1[0][2] = static_cast<float64>(3.0);
    u1[1][2] = static_cast<float64>(6.0);
    u1[2][2] = static_cast<float64>(9.0);

    float64 res;
    res = lu_det(u1);

    BOOST_CHECK_CLOSE(res, static_cast<float64>(-12.0), 1e5);
}


BOOST_AUTO_TEST_SUITE_END ();
