/*
 * merging_sequence_pruner.hpp
 *
 *  Created on: Jan 2, 2013
 *      Author: gpalou
 */

#ifndef MERGING_SEQUENCE_PRUNER_HPP_
#define MERGING_SEQUENCE_PRUNER_HPP_

#include <imageplus/bpt/pruning/bpt_pruner.hpp>
#include <imageplus/descriptors/descriptor_manager.hpp>
#include <imageplus/descriptors/geometry/area.hpp>

namespace imageplus {
	namespace bpt {

	//! Class that prunes the BPT such that it matches the merging sequence
	//! \param BPT: BT type
	//! \param ImageModel: Image type
	template<class BPT, class ImageModel>
	class MergingSequencePruner : public BPTPruner<BPT,ImageModel> {

		//! Base class
		typedef BPTPruner<BPT,ImageModel> Pruner;

		//! RegionIDs type
		typedef typename Pruner::RegionsIDs RegionsIDs;

	public:

		//! Constructor
		//! \param[in] th : minimum area
		MergingSequencePruner(uint64 n, bool prune) : Pruner(prune) {_num_regions = n-1;}

		//! Sets the area threshold
		//! \param[in] n: number of regions
		void set_num_regions(uint64 n) {_num_regions = n-1;}

		//! Base function to find the regions to prune
		//! \param[in] bpt: the tree
		//! \param[in] img: the image where the regions belong
		const RegionsIDs& find_pruned_regions(BPT& bpt, ImageModel& img, uint64 reg_id, uint64 region_objective) {
			return find_pruned_regions(bpt,img);
		}

		//! Base function to find the regions to prune
		//! \param[in] bpt: the tree
		//! \param[in] img: the image where the regions belong
		const RegionsIDs& find_pruned_regions(BPT& bpt, ImageModel& img) {

			uint64 n_process = 1;
			uint64 n_pruned = 0;

			std::set<uint64> regions;

			regions.insert(bpt.max_label());

			while (regions.size()!=0) {
				// find the largest index and divide it
				std::set<uint64>::reverse_iterator max_element = regions.rbegin();
				uint64 r = *max_element;
				regions.erase(--max_element.base());
				//std::cout << "examining " << r << " " << n_process << " " << n_pruned << _num_regions << std::endl;
				n_process--;
				if (bpt(r).children().size() > 0) {
					if (n_pruned + n_process == _num_regions) {Pruner::_regions.insert(r); n_pruned++;}
					if (n_pruned + n_process < _num_regions) {
						uint64 son1 = bpt(r).child(0)->label();
						uint64 son2 = bpt(r).child(1)->label();
						regions.insert(son1);
						regions.insert(son2);
						n_process+=2;
					}
				} else {
					Pruner::_regions.insert(r);
					n_pruned++;
				}
			}

			return Pruner::_regions;
		}

	private:
		//! threshold
		float64 _num_regions;

	};

	}
}

#endif /* MERGING_SEQUENCE_PRUNER_HPP_ */
