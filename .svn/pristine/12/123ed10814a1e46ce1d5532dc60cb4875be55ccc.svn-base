// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------

/*!
 * \file flows_sf2.hpp
 */

#ifndef IMAGEPLUS_TOOLBOX_FLOWS_SF2_HPP
#define IMAGEPLUS_TOOLBOX_FLOWS_SF2_HPP

#ifdef USE_SMARTFLOW
/*!
 * \cond AGIL_SKIP
 */

/*
 * Imageplus include
 */
#include <imageplus/core.hpp>
#include <imageplus/toolbox/client_config_sf2.hpp>

#ifdef USE_TOF
#include <imageplus/io/capture_tof.hpp>
#endif //USE_TOF

namespace imageplus
{
namespace toolbox
{
    class ImageMetadata
    {
    public:
        const static Metadata id = MD_IMAGE;
        
        std::size_t width;
        std::size_t height;
        std::size_t channels;
    };

    template<std::size_t D>
    class MultiArrayMetadata
    {
    public:
        const static Metadata id = MD_MULTIARRAY;
        
        boost::array<std::size_t, D> dimensions;
        static const std::size_t num_dimensions = D;
    };

    /*
     * To send and receive ANY type of images
     */
    template< typename T, std::size_t D>
    void send_flow( const MultiArray<T, D>& ma, ImagePlusFlow& flow)
    {
        /*
         * Setting and sendding the metadata
         */
        MultiArrayMetadata<D> mdata;
        for(std::size_t d=0; d<D; ++d)
        {
            mdata.dimensions[d]=ma.dims(d);
        }
        flow.push_metadata(&mdata);

        /*
         * Send the real data
         */
        flow.push_data(ma.data(), ma.num_elements()*sizeof(T));
    }

    template<typename T, std::size_t D>
    void receive_flow( MultiArray<T, D>& ma, ImagePlusFlow& flow)
    {
        /*
         * Receive and check the metadata
         */
        MultiArrayMetadata<D> mdata;
        flow.pop_metadata(&mdata);
        
        /*
         * Checking metadata and ajusting data
         */
        if( mdata.num_dimensions != D )
        {
            IMAGEPLUS_ERROR("Number of dimensions differ. Expectd: " << D << " - Received: " << mdata.num_dimensions );
        }

        /*
         * Resize the output if necessary
         */
        for(std::size_t d = 0; d<D; ++d)
        {
            if( ma.dims(d) != mdata.dimensions[d] )
            {
                CLIENT_TRACE( "Resizing multiarray get the flow" );
                ma.resize(mdata.dimensions);
            }
        }
        
        /*
         * Recive the real data
         */
        flow.pop_data( ma.data() );
    }

    /*
     * To send and receive ANY type of images
     */
    template< typename T, std::size_t N>
    void send_flow( const Image<T, N>& ima, ImagePlusFlow& flow)
    {
        /*
         * Setting and sendding the metadata
         */
        ImageMetadata mdata;
        mdata.width    = ima.size_x();
        mdata.height   = ima.size_y();
        mdata.channels = ima.num_channels();

        flow.push_metadata(&mdata);

        /*
         * Send the real data
         */
        uint64 channel_size = ima.size_x() * ima.size_y() * sizeof(T);
        for( std::size_t ch = 0; ch < ima.num_channels(); ++ch)
        {
            flow.push_data(ima(ch).data(), channel_size);
        }
    }

    template<typename T, std::size_t N>
    void receive_flow( Image<T, N>& ima, ImagePlusFlow& flow)
    {
        /*
         * Receive and check the metadata
         */
        ImageMetadata mdata;
        flow.pop_metadata(&mdata);
        
        /*
         * Checking metadata and ajusting data
         */
        if( mdata.channels != ima.num_channels() )
        {
            IMAGEPLUS_ERROR("Number of channels differ. Expected: " << mdata.channels << " - Received: " << ima.num_channels() );
        }
        if( ima.size_x() != mdata.width ||
            ima.size_y() != mdata.height )
        {
            CLIENT_TRACE( "Resizing image to get the flow: %d %d" , mdata.width, mdata.height );
            ima.resize(mdata.width, mdata.height);
        }
        
        for(std::size_t ch=0; ch < mdata.channels; ++ch)
        {
            /*
             * Receive the data
             */
            flow.pop_data( ima(ch).data() );
        }
    }

#ifdef USE_TOF
    inline
    void send_flow( const io::CaptureTOF::Frame & frame, ImagePlusFlow& flow)
    {
        send_flow(frame.depth , flow);
        send_flow(frame.conf  , flow);
        send_flow(frame.ampl  , flow);
        send_flow(frame.points, flow);
    }

    inline
    void receive_flow( io::CaptureTOF::Frame & frame, ImagePlusFlow& flow)
    {
        receive_flow(frame.depth , flow);
        receive_flow(frame.conf  , flow);
        receive_flow(frame.ampl  , flow);
        receive_flow(frame.points, flow);
    }
#endif // USE_TOF

} // ns toolbox
} // ns imageplus

/*!
 * \endcond AGIL_SKIP
 */

#endif // USE_SMARTFLOW
#endif // IMAGEPLUS_TOOLBOX_FLOWS_SF2_HPP
