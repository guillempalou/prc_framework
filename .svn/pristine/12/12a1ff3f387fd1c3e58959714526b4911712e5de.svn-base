
// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------

//!
//!  \file contour_shape.hpp
//!
#include <imageplus/core/visual_descriptors.hpp>
#include <imageplus/core/mask.hpp>
#include <imageplus/descriptors/geometry/area.hpp>
#include <imageplus/filters/gaussian.hpp>
#include <imageplus/io/xml_auxiliar.hpp>


#ifndef IMAGEPLUS_DESCRIPTORS_GEOMETRY_CONTOUR_SHAPE_HPP
#define IMAGEPLUS_DESCRIPTORS_GEOMETRY_CONTOUR_SHAPE_HPP

namespace imageplus
{
    namespace descriptors
    {
    
        //!
        //! Contour Shape descriptor is based on the Curvature Scale-Space(CSS) representation of the contour. 
        //! The CSS representation descomposes the contour into convex and concave sections by determining the inflection points (e.g. points at which curvature is zero)
        //! This is done in a multiresolution fashion, where the contour is analyzed at various scales, obtained by a smoothing process.
        //! The descriptor consists of the eccentricity and circularity values of the original and filtered contour, the index indicating the number of peaks in the CSS image, the magnitude of the largest peak and the x-positions, y-positions and height on the remaining peaks (positions are relative to the highest and height is related to the previous peak's height)
        //!
        //! \author Carles Ventura <alcarles@gps.tsc.upc.edu>
        //!
        //! \date 09-10-2009 
        template<class PositionModel>
        class ContourShape : public DescriptorBase
        {
        public:
            //! Type of coordinate
            typedef PositionModel CoordType;
            
            //!
            //! \brief Default constructor
            //!
            ContourShape() : DescriptorBase("ContourShape",false), _circularity(), _eccentricity(), _circularity_smoothed(), _eccentricity_smoothed(), _peaks(), _smooth(), _no_zeros(false), _count(0)
            {
        
            }        
            
            //! \brief It computes CSS Image and its parameters.
            //!
            //! \param[in] first      : Iterator to the beginning of the region
            //! \param[in] last       : Iterator to the end of the region
            //! \param[in] peer_descs : Pointer to CollaborativeDescriptors, in principle is never 0x0 but it is a good idea to ASSERT it
            template< class IteratorModel >
            void calculate(IteratorModel first, IteratorModel last, CollaborativeDescriptors* peer_descs)
            {
                ASSERT(peer_descs!=0x0, "ContourShape calculate: peer_descs must be non null");

                Area area = peer_descs->calculate(new Area(), first, last);
                const ContourMask<CoordType>& desc = peer_descs->calculate(new ContourMask<CoordType>(), first, last);
                ImaVolMask<2> mask = desc.value();

                std::vector<int64> x;
                std::vector<int64> y;

                //Arc_length parameterization
                _arclength_param(mask,x,y);

                uint64 perim = x.size();
                //We compute circularity
                _circularity = (perim*perim)/(float64)area;

                //We quantize circularity with 6 bits
                Quantizer<float64> q1(12.0,110.0,64);
                _circularity = q1.bin(_circularity);

                //We compute eccentricity
                _eccentricity = _calc_eccentricity(x,y);

                //We quantize eccentricity with 6 bits
                Quantizer<float64> q2(1.0,10.0,64);
                _eccentricity = q2.bin(_eccentricity);

                //Computing curvature function with original curve
                if(_compute_curvature_sigma0(x,y))
                {
                    _circularity_smoothed = _circularity;
                    _eccentricity_smoothed = _eccentricity;
                    _smooth.push_back(0);
                }
                else
                {
                    std::vector<float64> curvature;
                    curvature.resize(perim);
                    uint64 perim_tmp = perim;
                    
                    //x_smoothed contains the result of x and gaussian convolution
                    std::vector<float64> x_smoothed;
                    
                    //y_smoothed contains the result of y and gaussian convolution
                    std::vector<float64> y_smoothed;
                    
                    float64 sigma = 1.0;
                    std::vector<std::vector<float64> > css;
                    
                    float64 inc_sigma = _sigma_resolution(x,y);
                    
                    while(!_no_zeros/*sigma < 256.0*/)
                    {
                        _no_zeros = true;
                        
                        //We compute the number of samples which we need for gaussians
                        int64 size=2*static_cast<int64>(3.0*sigma)+1;
                        if(size < 3)
                        {
                            size = 3;
                        }
                        
                        //We compute 1-d gaussian and its first and second derivative
                        MultiArray<float64,1> gaussian = imageplus::filters::gaussian_mask_1d(sigma,size);
                        MultiArray<float64,1> gaussian_u(size);
                        int64 center=(size-1)/2;
                        for(int64 i = 0; i<size; i++)
                        {
                            gaussian_u[i] =  -1.0/(sigma*sigma)*(i-center)*gaussian[i];
                        }
                        MultiArray<float64,1> gaussian_uu(size);
                        for(int64 i = 0; i<size; i++)
                        {
                            gaussian_uu[i] =  ((i-center)*(i-center)/(sigma*sigma*sigma*sigma)-1.0/(sigma*sigma))*gaussian[i];
                        }
                        
                        uint64 inc_i = 1;
                        
                        //We decide downsampling result of convolution for high values of sigma.
                        //This decision have been taken in order to reduce computational cost because the number of samples of gaussian is proportional to sigma.
                        //This decision is based in the fact that samples are more concentrated where the sign of curvature function changes, so this desition does not affect the result.
                        if(sigma >= 32.0)
                        {
                            inc_i = static_cast<uint64>(sigma/16);
                            perim_tmp = (uint64)(std::ceil((float64)perim / inc_i));
                        }
                        //x_u contains the first derivative of the result of x and gaussian convolution
                        std::vector<float64> x_u;
                        //x_uu contains the second derivative of the result of x and gaussian convolution
                        std::vector<float64> x_uu;
                        x_smoothed.resize(perim_tmp);
                        x_u.resize(perim_tmp);
                        x_uu.resize(perim_tmp);
                        //y_u contains the first derivative of the result of y and gaussian convolution
                        std::vector<float64> y_u;
                        //y_uu contains the second derivative of the result of y and gaussian convolution
                        std::vector<float64> y_uu;
                        y_smoothed.resize(perim_tmp);
                        y_u.resize(perim_tmp);
                        y_uu.resize(perim_tmp);
                        
                        for(std::size_t i = 0; i<perim_tmp; i++)
                        {
                            x_u[i] = 0;
                            x_uu[i] = 0;
                            y_u[i] = 0;
                            y_uu[i] = 0;
                            x_smoothed[i] = 0;
                            y_smoothed[i] = 0;
                            
                            for(int64 j = 0; j<size; j++)
                            {
                                int64 tmppp = i*inc_i + j - center;
                                while(tmppp<0)
                                {
                                    tmppp=tmppp+perim;
                                }
                                if(tmppp>=(int64)perim)
                                {
                                    tmppp = tmppp%perim;
                                }
                                x_smoothed[i] = x_smoothed[i] + gaussian[j]*x[tmppp];
                                x_u[i] = x_u[i] + gaussian_u[j]*x[tmppp];
                                x_uu[i] = x_uu[i] + gaussian_uu[j]*x[tmppp];
                                y_smoothed[i] = y_smoothed[i] + gaussian[j]*y[tmppp];
                                y_u[i] = y_u[i] + gaussian_u[j]*y[tmppp];
                                y_uu[i] = y_uu[i] + gaussian_uu[j]*y[tmppp];
                            }
                        }
                        
                        float64 max=0.0;
                        //We compute curvature function
                        curvature.resize(perim_tmp);
                        for(std::size_t i=0; i<perim_tmp; i++)
                        {
                            curvature[i]=(x_u[i]*y_uu[i]-x_uu[i]*y_u[i])/(std::pow(x_u[i]*x_u[i]+y_u[i]*y_u[i], 1.5 ));
                            if(std::abs(curvature[i])>max)
                            {
                                max = std::abs(curvature[i]);
                            }
                        }
                        
                        _zeros.resize(0);
                        //The zero crossings of the curvature function are computed applying Bolzano's theorem.
                        _zero_crossings(curvature,max,inc_i);

                        uint64 num_zeros = _zeros.size();
                        if(num_zeros>0)
                        {
                            css.push_back(_zeros);
                        }
                        
                        //We incremenent sigma
                        sigma = sigma + inc_sigma;
                    }

                    uint64 pos_min_x = 0;
                    uint64 pos_max_x = 0;
                    float64 max_x = x_smoothed[0];
                    float64 min_x = x_smoothed[0];
                    for(std::size_t i=1; i<perim_tmp; i++)
                    {
                        if(x_smoothed[i]>max_x)
                        {
                            max_x = x_smoothed[i];
                            pos_max_x = i;
                        }
                        if(x_smoothed[i]<min_x)
                        {
                            min_x = x_smoothed[i];
                            pos_min_x = i;
                        }
                    }
                    
                    //We compute the area of the smoothed curve with Riemann integration method and the perimeter as sum of the distances between the samples
                    uint64 aux = pos_min_x;
                    float64 area1 = 0.0;
                    float64 perim_smoothed = 0.0;
                    while(aux!=pos_max_x)
                    {
                        float64 tmp = x_smoothed[(aux+1)%perim_tmp]-x_smoothed[aux];
                        area1 = area1 + (y_smoothed[aux]+y_smoothed[(aux+1)%perim_tmp])*(std::abs(tmp))*0.5;
                        perim_smoothed = perim_smoothed + std::sqrt((x_smoothed[(aux+1)%perim_tmp]-x_smoothed[aux])*(x_smoothed[(aux+1)%perim_tmp]-x_smoothed[aux])+(y_smoothed[(aux+1)%perim_tmp]-y_smoothed[aux])*(y_smoothed[(aux+1)%perim_tmp]-y_smoothed[aux]));
                        aux = (aux+1)%perim_tmp;
                    }
                    aux = pos_max_x;
                    float64 area2 = 0.0;
                    while(aux!=pos_min_x)
                    {
                        float64 tmp = x_smoothed[aux]-x_smoothed[(aux+1)%perim_tmp];
                        area2 = area2 + (y_smoothed[aux]+y_smoothed[(aux+1)%perim_tmp])*(std::abs(tmp))*0.5;
                        perim_smoothed = perim_smoothed + std::sqrt((x_smoothed[(aux+1)%perim_tmp]-x_smoothed[aux])*(x_smoothed[(aux+1)%perim_tmp]-x_smoothed[aux])+(y_smoothed[(aux+1)%perim_tmp]-y_smoothed[aux])*(y_smoothed[(aux+1)%perim_tmp]-y_smoothed[aux]));
                        aux = (aux+1)%perim_tmp;
                    }

                    float64 area_smoothed = std::abs(area2-area1);

                    //We compute its circularity
                    _circularity_smoothed = (perim_smoothed*perim_smoothed)/area_smoothed;
                    
                    //Circularity quantization with 8 bits
                    _circularity_smoothed = q1.bin(_circularity_smoothed);
                    
                    //We compute its eccentricity
                    _eccentricity_smoothed = _calc_eccentricity(x_smoothed, y_smoothed);
                    
                    //Eccentricity quantization with 8 bits
                    _eccentricity_smoothed = q2.bin(_eccentricity_smoothed);
                    
                    //Peaks detection
                    _peaks_detection(css,inc_sigma,perim);
                    
                    //Quantization of peaks' localization relative of the highest (clockwise) and peaks' height relative to the previous peak's height
                    Quantizer<float64> q3(0,perim,64);
                    Quantizer<float64> q4(0,1,8);
                    if(_count > 0)
                    {
                        float64 tmp_smooth = _smooth[0];
                        for(uint64 n=0; n<_peaks.size()-1;n++)
                        {
                            _peaks[n+1] = (_peaks[n+1]-_peaks[0]);
                            if(_peaks[n+1]<0)
                            {
                                _peaks[n+1]=_peaks[n+1]+perim;
                            }
                            _smooth[n] = _smooth[n+1]/_smooth[n];
                        }
                        for(uint64 n=_peaks.size()-1;n>0;n--)
                        {
                            _smooth[n]=_smooth[n-1];
                        }
                        _smooth[0]=tmp_smooth;
                        for(uint64 n=1; n<_peaks.size();n++)
                        {
                            _peaks[n]=q3.bin(_peaks[n]);
                            _smooth[n]=q4.bin(_smooth[n]);
                        }
                    }
                    else
                    {
                        _smooth.push_back(0);
                    }
                }
            }
            
            //! \brief Returns the eccentricity of the original contour
            //!
            //! \return The eccentricity of the original contour
            const float64 eccentricity() const
            {
                return _eccentricity;
            }
            
            //! \brief Returns the eccentricity of the filtered contour
            //!
            //! \return The eccentricity of the filtered contour
            const float64 eccentricity_smoothed() const
            {
                return _eccentricity_smoothed;
            }
            
            //! \brief Returns the circularity of the original contour
            //!
            //! \return The circularity of the original contour
            const float64 circularity() const
            {
                return _circularity;
            }
            
            //! \brief Returns the circularity of the filtered contour
            //!
            //! \return The circularity of the filtered contour
            const float64 circularity_smoothed() const
            {
                return _circularity_smoothed;
            }
            
            //! \brief Returns the localization of the peaks
            //!
            //! \return The localization of the peaks
            const std::vector<float64>& peaks() const
            {
                return _peaks;
            }
            
            //! \brief Returns the height of the peaks
            //!
            //! \return The height of the peaks
            const std::vector<float64>& smooth() const
            {
                return _smooth;
            }
            
            
            
            
        #ifdef USE_XML    
            //! Returns the name of the descriptor to be written to the XML descriptors file
            //! \return Name of the identifier
            std::string xml_name() const
            {
                return "ContourShapeType";
            }
            //! Writes the value of the descriptor. 
            //! \param[in] doc: Pointer to the XML document we are writing 
            //! \param[in] vdElem: Pointer to the XML element referring to the region whose descriptors we are writing
            void xml_write(XERCES_CPP_NAMESPACE::DOMDocument *doc, XERCES_CPP_NAMESPACE::DOMElement *vdElem) const
            {
                XERCES_CPP_NAMESPACE::DOMElement* dataElem;
                XERCES_CPP_NAMESPACE::DOMText* textElem;
                std::string append, append2;
                std::string space(" ");
               
                dataElem = doc->createElement(io::fromNative("GlobalCurvature").c_str());
                vdElem->appendChild(dataElem);
                append = boost::lexical_cast<std::string>(_circularity);
                append2 = boost::lexical_cast<std::string>(_eccentricity);
                append = append + space + append2;
                textElem = doc->createTextNode(io::fromNative(append.c_str()).c_str());
                dataElem->appendChild(textElem);
                
                dataElem = doc->createElement(io::fromNative("PrototypeCurvature").c_str());
                vdElem->appendChild(dataElem);
                append = boost::lexical_cast<std::string>(_circularity_smoothed);
                append2 = boost::lexical_cast<std::string>(_eccentricity_smoothed);
                append = append + space + append2;
                textElem = doc->createTextNode(io::fromNative(append.c_str()).c_str());
                dataElem->appendChild(textElem);
                
                
                dataElem = doc->createElement(io::fromNative("HighestPeakY").c_str());
                vdElem->appendChild(dataElem);
                append = boost::lexical_cast<std::string>(_smooth[0]);
                textElem = doc->createTextNode(io::fromNative(append.c_str()).c_str());
                dataElem->appendChild(textElem);
                
                uint64 num_peaks = _peaks.size();
                if(num_peaks > 63)
                {
                    num_peaks = 63;
                }
                
                for(std::size_t i=1; i < num_peaks; i++)
                {
                    dataElem = doc->createElement(io::fromNative("Peak").c_str());
                    vdElem->appendChild(dataElem);
                    
                    append = boost::lexical_cast<std::string>(_peaks[i]);
                    dataElem->setAttribute(io::fromNative("PeakX").c_str(), io::fromNative(append.c_str()).c_str());
                    append = boost::lexical_cast<std::string>(_smooth[i]);
                    dataElem->setAttribute(io::fromNative("PeakY").c_str(), io::fromNative(append.c_str()).c_str());
                }
            }
        #endif
                      
        private:
            
            //! \brief It computes the curvature function with sigma = 0 to know if the original contour is totally convex.
            //!
            //! \param[in] x       : x parameterization of the contour
            //! \param[in] y       : y parameterization of the contour
            //!
            //! \return A boolean that is true if the original contour is totally convex
            bool _compute_curvature_sigma0(std::vector<int64>& x,std::vector<int64>& y)
            {
                
                uint64 perim = x.size();
                std::vector<float64> x_deriv1;
                std::vector<float64> x_deriv2;
                std::vector<float64> y_deriv1;
                std::vector<float64> y_deriv2;
                x_deriv1.resize(perim);
                x_deriv2.resize(perim);
                y_deriv1.resize(perim);
                y_deriv2.resize(perim);
                
                for(uint64 j=1; j<perim-1; j++)
                {
                    x_deriv1[j]=((int64)x[j+1]-(int64)x[j-1])/2.0;
                    y_deriv1[j]=((int64)y[j+1]-(int64)y[j-1])/2.0;
                }
                x_deriv1[perim-1]=((int64)x[0]-(int64)x[perim-2])/2.0;
                y_deriv1[perim-1]=((int64)y[0]-(int64)y[perim-2])/2.0;  
                x_deriv1[0]=((int64)x[1]-(int64)x[perim-1])/2.0;
                y_deriv1[0]=((int64)y[1]-(int64)y[perim-1])/2.0;
                for(uint64 j=1; j<perim-1; j++)
                {
                    x_deriv2[j]=(x_deriv1[j+1]-x_deriv1[j-1])/2.0;
                    y_deriv2[j]=(y_deriv1[j+1]-y_deriv1[j-1])/2.0;
                }
                x_deriv2[perim-1]=(x_deriv1[0]-x_deriv1[perim-2])/2.0;
                y_deriv2[perim-1]=(y_deriv1[0]-y_deriv1[perim-2])/2.0;  
                x_deriv2[0]=(x_deriv1[1]-x_deriv1[perim-1])/2.0;
                y_deriv2[0]=(y_deriv1[1]-y_deriv1[perim-1])/2.0;
                
                std::vector<float64> curvature2;
                curvature2.resize(perim);
                float64 max = 0.0;
                for(uint64 j=0;j<perim;j++)
                {
                    curvature2[j]=x_deriv1[j]*y_deriv2[j]-x_deriv2[j]*y_deriv1[j];
                    curvature2[j]=curvature2[j]/(std::pow(x_deriv1[j]*x_deriv1[j]+y_deriv1[j]*y_deriv1[j], 1.5 ));
                    if(std::abs(curvature2[j])>max)
                    {
                        max = std::abs(curvature2[j]);
                    }
                }
                bool no_zeros = _no_zero_crossings(curvature2,max);
                return no_zeros;
            }
            
            //! \brief It computes the value we will increment sigma in each smoothing step. It will be directly proportional to the value of sigma when the curvature function has no zeros. The objective is reduce the computational cost.
            //!
            //! \param[in] x       : x parameterization of the contour
            //! \param[in] y       : y parameterization of the contour
            //!
            //! \return The value we will increment sigma in each smoothing step.
            float64 _sigma_resolution(std::vector<int64>& x,std::vector<int64>& y)
            {
                
                bool no_zeros = false;
                float64 inc_sigma = 0.0;
                float64 sigma = 8.0;
                uint64 perim = x.size();
                std::vector<float64> curvature;
                curvature.resize(perim);
                bool first = true;
                
                float64 max_x = 50;
                float64 min_x = 0;
                float64 max_y = 50;
                float64 min_y = 0;
                uint64 pos_max_x = 0;
                uint64 pos_min_x = 0;
                uint64 pos_max_y = 0;
                uint64 pos_min_y = 0;
                
                while(!no_zeros&&(((max_x-min_x)>3.0)||((max_y-min_y)>3.0)))
                {
                    //We compute the number of samples which we need for gaussians
                    int64 size=2*static_cast<int64>(3.0*sigma)+1;
                    if(size < 3)
                    {
                        size = 3;
                    }
                    
                    //We compute 1-d gaussian and its first and second derivative
                    MultiArray<float64,1> gaussian = imageplus::filters::gaussian_mask_1d(sigma,size);
                    MultiArray<float64,1> gaussian_u(size);
                    int64 center=(size-1)/2;
                    for(int64 i = 0; i<size; i++)
                    {
                        gaussian_u[i] =  -1.0/(sigma*sigma)*(i-center)*gaussian[i];
                    }
                    MultiArray<float64,1> gaussian_uu(size);
                    for(int64 i = 0; i<size; i++)
                    {
                        gaussian_uu[i] =  ((i-center)*(i-center)/(sigma*sigma*sigma*sigma)-1.0/(sigma*sigma))*gaussian[i];
                    }
                    
                    //x_u contains the first derivative of the result of x and gaussian convolution
                    std::vector<float64> x_u;
                    //x_uu contains the second derivative of the result of x and gaussian convolution
                    std::vector<float64> x_uu;
                    x_u.resize(perim);
                    x_uu.resize(perim);
                    //y_u contains the first derivative of the result of y and gaussian convolution
                    std::vector<float64> y_u;
                    //y_uu contains the second derivative of the result of y and gaussian convolution
                    std::vector<float64> y_uu;
                    y_u.resize(perim);
                    y_uu.resize(perim);
                    
                    std::vector<float64> x_smoothed;
                    std::vector<float64> y_smoothed;
                    x_smoothed.resize(perim);
                    y_smoothed.resize(perim);
                    
                    
                    for(std::size_t i = 0; i<perim; i++)
                    {
                        x_u[i] = 0;
                        x_uu[i] = 0;
                        y_u[i] = 0;
                        y_uu[i] = 0;
                       
                        x_smoothed[i] = 0;
                        y_smoothed[i] = 0;
                        
                        for(int64 j = 0; j<size; j++)
                        {
                            int64 tmppp = i + j - center;
                            while(tmppp<0)
                            {
                                tmppp=tmppp+perim;
                            }
                            if(tmppp>=(int64)perim)
                            {
                                tmppp = tmppp%perim;
                            }
                            x_u[i]  = x_u[i] + gaussian_u[j]*x[tmppp];
                            x_uu[i] = x_uu[i] + gaussian_uu[j]*x[tmppp];
                            y_u[i]  = y_u[i] + gaussian_u[j]*y[tmppp];
                            y_uu[i] = y_uu[i] + gaussian_uu[j]*y[tmppp];
                            
                            x_smoothed[i] = x_smoothed[i] + gaussian[j]*x[tmppp];
                            y_smoothed[i] = y_smoothed[i] + gaussian[j]*y[tmppp];
                            
                        }
                    }
                    
                    if(first)
                    {
                        max_x = x_smoothed[0];
                        min_x = x_smoothed[0];
                        max_y = y_smoothed[0];
                        min_y = y_smoothed[0];
                        for(std::size_t i=1; i<perim; i++)
                        {
                            if(x_smoothed[i]>max_x)
                            {
                                max_x = x_smoothed[i];
                                pos_max_x = i;
                            }
                            if(x_smoothed[i]<min_x)
                            {
                                min_x = x_smoothed[i];
                                pos_min_x = i;
                            }
                            if(y_smoothed[i]>max_y)
                            {
                                max_y = y_smoothed[i];
                                pos_max_y = i;
                            }
                            if(y_smoothed[i]<min_y)
                            {
                                min_y = y_smoothed[i];
                                pos_min_y = i;
                            }
                        }
                        first = false;
                    }
                    else
                    {
                        max_x = x_smoothed[pos_max_x];
                        min_x = x_smoothed[pos_min_x];
                        max_y = y_smoothed[pos_max_y];
                        min_y = y_smoothed[pos_min_y];
                    }
        
                    float64 max = 0.0;
                    //We compute curvature function
                    for(std::size_t i=0; i<perim; i++)
                    {
                        curvature[i]=(x_u[i]*y_uu[i]-x_uu[i]*y_u[i])/(std::pow(x_u[i]*x_u[i]+y_u[i]*y_u[i], 1.5 ));
                        if(std::abs(curvature[i])>max)
                        {
                            max = std::abs(curvature[i]);
                        }
                    }
                    
                    no_zeros = _no_zero_crossings(curvature, max);
                    if(!no_zeros)
                    {
                        sigma = sigma*2;
                    }
                }
                
                inc_sigma = sigma / 64.0;
                return inc_sigma;
        
            }
            
            
            
            //! \brief It computes the zeros of function curvature. A histeresis cycle has been implemented to avoid some errors (e.g. some very small positive and negatuve values)  due to work with discrete signals.
            //!
            //! \param[in] curvature        : function which we want compute its zeros
            //! \param[in] max              : maximum value of curvature (it will be used to determine histeresis cycle)
            //! \param[in] downsampling_step: downsampling factor (it will be used to estimate the position of the zeros found )
            //!
            void _zero_crossings(std::vector<float64>& curvature, float64 max, uint64 downsampling_step = 1)
            {
                uint64 perim = curvature.size();
                uint64 target = 0;
                uint64 source = 0;
                int64 found = -1;
                while(target<perim)
                {
                    if(curvature[source]>(max/500.0))
                    {
                        if(found==-1)
                        {
                            found = source;
                        }
                        while(source < perim && curvature[source]>(max/500.0) )
                        {
                            source++;
                            target++;
                        }
                        if(source < perim)
                        {
                            source--;
                            while(target < perim && curvature[target]>=(-1.0*(max/500.0)) )
                            {
                                if(curvature[target]>(max/500.0))
                                {
                                    source = target;
                                }
                                target++;
                            }
                            if(target < perim)
                            {
                                float64 pendent = (curvature[target]-curvature[source])/(target-source);
                                float64 increment_x = (0.0-curvature[source])/pendent;
                                _zeros.push_back((source+increment_x)*downsampling_step);
                                _no_zeros = false;
                                source = target;
                                _count++;
                            }
                        }
                    }
                    else if(curvature[source]<(-1.0*(max/500.0)))
                    {
                        if(found==-1)
                        {
                            found = source;
                        }
                        while(source < perim && curvature[source]<(-1.0*(max/500.0)))
                        {
                            source++;
                            target++;
                        }
                        if(source < perim)
                        {
                            source--;
                            while(target < perim && curvature[target]<=(max/500.0))
                            {
                                if(curvature[target]<(-1.0*(max/500.0)))
                                {
                                    source = target;
                                }
                                target++;
                            }
                            if(target < perim)
                            {
                                float64 pendent = (curvature[target]-curvature[source])/(target-source);
                                float64 increment_x = (0.0-curvature[source])/pendent;
                                _zeros.push_back((source+increment_x)*downsampling_step);
                                _no_zeros = false;
                                source = target;
                                _count++;
                            }
                        }
                    }
                    else
                    {
                        source++;
                        target++;
                    }
                }
                //we have to consider that the signal is circular
                if(found!=-1)
                {
                    target = perim-1;
                    if(curvature[found]>0)
                    {
                    	while((curvature[target]>=(-1.0*(max/500.0))) && (curvature[target]<=(max/500.0)) && (int64)target > found)
                        {
                            target--;
                        }
                    	if(((int64)target > found)&&(curvature[target]<0))
                        {
                            float64 pendent = (curvature[found]-curvature[target])/(found+perim-target);
                            float64 increment_x = (0.0-curvature[target])/pendent;
                            float64 aux = target + increment_x;
                            if(aux>=perim)
                            {
                                aux = aux - perim;
                            }
                            _zeros.push_back(aux*downsampling_step);
                            _no_zeros = false;
                            _count++;
                        }
                    }
                    if(curvature[found]<0)
                    {
                    	while((curvature[target]<=(max/500.0)) && (curvature[target]>=(-1.0*(max/500.0))) && (int64)target > found)
                        {
                            target--;
                        }
                        if(((int64)target > found)&&(curvature[target]>0))
                        {
                            float64 pendent = (curvature[found]-curvature[target])/(found+perim-target);
                            float64 increment_x = (0.0-curvature[target])/pendent;
                            float64 aux = target + increment_x;
                            if(aux>=perim)
                            {
                                aux = aux - perim;
                            }
                            _zeros.push_back(aux*downsampling_step);
                            _no_zeros = false;
                            _count++;
                        }
                    }
                }
            }
            
            /*!
             * It computes if there are no zeros on curvature function.
             *
             * A hysteresis cycle has been implemented to avoid some errors (e.g. some very small
             * positive and negative values) due to work with discrete signals.
             *
             * \param[in] curvature : function which we want compute its zeros
             * \param[in] max       : maximum value of curvature (it will be used to determine hysteresis cycle)
             *
             * \returns true if there are no zeros on curvature function
             */
            bool _no_zero_crossings(std::vector<float64>& curvature, float64 max)
            {
                /*
                 * AGIL: Take care of the order of the operands evaluation:
                 *
                 * C++03 Section 5.14 Paragraph 1
                 *   The && operator groups left-to-right. The operands are both implicitly
                 *   converted to type bool (clause 4). The result is true if both operands
                 *   are true and false otherwise. Unlike &, && guarantees left-to-right
                 *   evaluation: the second operand is not evaluated if the first operand
                 *   is false.
                 *
                 * C++03 Section 5.15 Paragraph 1
                 *   The || operator groups left-to-right. The operands are both implicitly
                 *   converted to bool (clause 4). It returns true if either of its operands
                 *   is true, and false otherwise. Unlike |, || guarantees left-to-right
                 *   evaluation; moreover, the second operand is not evaluated if the first
                 *   operand evaluates to true.
                 *
                 * C99 Section 6.5.13 Paragraph 4
                 *   Unlike the bitwise & operator, the && operator guarantees left-to-right
                 *   evaluation; there is a sequence point after the evaluation of the first
                 *   operand. If the first operand compares equal to 0, the second operand
                 *   is not evaluated.
                 *
                 * C99 Section 6.5.14 Paragraph 4
                 *   Unlike the bitwise | operator, the || operator guarantees left-to-right
                 *   evaluation; there is a sequence point after the evaluation of the first
                 *   operand. If the first operand compares unequal to 0, the second operand
                 *   is not evaluated.
                 */

                uint64 perim = curvature.size();
                uint64 source = 0;
                bool no_zeros = false;
                while(source<perim && curvature[source]<(max/500.0) && curvature[source]>(-1.0*(max/500.0)))
                {
                    source++;
                }
                if(source==perim)
                {
                    no_zeros = true;
                }
                else
                {
                    if(curvature[source]>0)
                    {
                        source++;
                        while(source < perim && curvature[source]>=(-1.0*(max/500.0)))
                        {
                            source++;
                        }
                        if(source == perim)
                        {
                            no_zeros = true;
                        }
                        else
                        {
                            no_zeros = false;
                        }
                    }
                    else if(curvature[source]<0)
                    {
                        source++;
                        while(source < perim && curvature[source]<(max/500.0) )
                        {
                            source++;
                        }
                        if(source == perim)
                        {
                            no_zeros = true;
                        }
                        else
                        {
                            no_zeros = false;
                        }
                    }
                }
                
                return no_zeros;
            }
            
            
            //! \brief It computes the arc length parameterization of the contour
            //!
            //! \param[in] mask     : Mask of the border pixels of the region
            //! \param[out] x       : x parameterization of the contour
            //! \param[out] y       : y parameterization of the contour
            //!
            void _arclength_param(ImaVolMask<2>& mask, std::vector<int64>& x,std::vector<int64>& y)
            {
                boost::array<std::size_t, 2> borders2d = {{1,1}};
                Border<ImaVolMask<2> >& mask_with_border = calc_descriptor(new Border<ImaVolMask<2> >(borders2d, false), mask);

                Coord<int64, 2> pos = *(mask_with_border.begin());
                
                x.resize(0);
                y.resize(0);
                std::vector<bool> direction;
                direction.resize(4);
                //last indicates which was the previous move ( 0(up), 1(rigth), 2(down), 3(left) )
                uint8 last = 0; 
                uint8 counter = 0;
                
                //We add the first position
                x.push_back(pos[0]+1);
                y.push_back(pos[1]+1);
                
                //The first time we always move to the rigth
                pos[0]++;
                x.push_back(pos[0]+1);
                y.push_back(pos[1]+1);
                last = 1;
                
                //Arc-length parameterization is computed
                while((pos[0]!=x[0]-1)||(pos[1]!=y[0]-1))
                {
                    if(((mask_with_border(0)[pos[0]-1][pos[1]-1])&&(!mask_with_border(0)[pos[0]][pos[1]-1]))||((!mask_with_border(0)[pos[0]-1][pos[1]-1])&&(mask_with_border(0)[pos[0]][pos[1]-1])))
                    {
                        direction[0] = true;
                        counter++;
                    }
                    if(((mask_with_border(0)[pos[0]][pos[1]-1])&&(!mask_with_border(0)[pos[0]][pos[1]]))||((!mask_with_border(0)[pos[0]][pos[1]-1])&&(mask_with_border(0)[pos[0]][pos[1]])))
                    {
                        direction[1] = true;
                        counter++;
                    }
                    if(((mask_with_border(0)[pos[0]][pos[1]])&&(!mask_with_border(0)[pos[0]-1][pos[1]]))||((!mask_with_border(0)[pos[0]][pos[1]])&&(mask_with_border(0)[pos[0]-1][pos[1]])))
                    {
                        direction[2] = true;
                        counter++;
                    }
                    if(((mask_with_border(0)[pos[0]-1][pos[1]])&&(!mask_with_border(0)[pos[0]-1][pos[1]-1]))||((!mask_with_border(0)[pos[0]-1][pos[1]])&&(mask_with_border(0)[pos[0]-1][pos[1]-1])))
                    {
                        direction[3] = true;
                        counter++;
                    }
                    if(counter==2)
                    {
                        for(uint8 i = 0; i < 4; i++)
                        {
                            if(direction[i]&&i!=((last+2)%4))
                            {
                                switch(i)
                                {
                                    case 0: 
                                        pos[1]--;
                                        break;
                                    case 1:
                                        pos[0]++;
                                        break;
                                    case 2:
                                        pos[1]++;
                                        break;
                                    case 3:
                                        pos[0]--;
                                        break;
                                }
                                last = i;
                                x.push_back(pos[0]+1);
                                y.push_back(pos[1]+1);
                                break;
                            }
                        }
                    }
                    else if(counter==4)
                    {
                        last = (last+3)%4;
                        switch(last)
                        {
                            case 0: 
                                pos[1]--;
                                break;
                            case 1:
                                pos[0]++;
                                break;
                            case 2:
                                pos[1]++;
                                break;
                            case 3:
                                pos[0]--;
                                break;
                        }
                        x.push_back(pos[0]+1);
                        y.push_back(pos[1]+1);
                    }
                    for(uint8 i = 0; i < 4; i++)
                    {
                        direction[i]=false;
                    }
                    counter=0;
                }
                x.pop_back();
                y.pop_back();
            }
            
            //! \brief It computes the eccentricity of a contour
            //!
            //! \param[in] x       : x parameterization of the contour
            //! \param[in] y       : y parameterization of the contour
            //!
            //! \return Eccentricity value
            template<class T>
            float64 _calc_eccentricity(std::vector<T>& x,std::vector<T>& y)
            {
                float64 centroid_x = 0.0;
                float64 centroid_y = 0.0;
                uint64 perim = x.size();
                for(uint64 i = 0; i<perim; i++)
                {
                    centroid_x = centroid_x + x[i];
                    centroid_y = centroid_y + y[i];
                }
                centroid_x = centroid_x/perim;
                centroid_y = centroid_y/perim;
                
                float64 i_02 = 0.0;
                float64 i_11 = 0.0;
                float64 i_20 = 0.0;
                
                for(std::size_t i = 0; i<perim; i++)
                {
                    i_02 = i_02 + (y[i]-centroid_y)*(y[i]-centroid_y);
                    i_11 = i_11 + (x[i]-centroid_x)*(y[i]-centroid_y);
                    i_20 = i_20 + (x[i]-centroid_x)*(x[i]-centroid_x);
                }
                
                return std::sqrt((i_20+i_02+std::sqrt(i_20*i_20+i_02*i_02-2*i_20*i_02+4*i_11*i_11))/(i_20+i_02-std::sqrt(i_20*i_20+i_02*i_02-2*i_20*i_02+4*i_11*i_11)));
            }
            
            //! \brief It computes the localization and the heigth of the CSS Image's peaks.
            //!
            //! \param[in] css       : CSS Image
            //! \param[in] inc_sigma : value we increment sigma in each smoothing step.
            //! \param[in] perim     : perimeter of the original contour
            //!
            void _peaks_detection(std::vector<std::vector<float64> >& css, float64 inc_sigma, uint64 perim)
            {
                uint64 min1=0;
                uint64 min2=1;
                float64 dmin1=0.0;
                float64 dmin2=0.0;
                float64 tmp = 0.0;
                std::vector<bool> removed_zeros;
                uint64 previous_zeros=0;
                bool end = false;
                float64 initial_sigma = (css.size()-1)*inc_sigma + 1.0;
                float64 final_sigma = 0.05*initial_sigma;
                for(int64 i=css.size()-1; i>=0 && end == false ;i--)
                {
                    float64 actual_sigma = i*inc_sigma + 1.0;
                    if(actual_sigma < final_sigma)
                    {
                        end = true;
                    }
                    else
                    {
                        if(css[i].size()>previous_zeros) 
                        {                                   
                            previous_zeros = css[i].size();
                            
                            removed_zeros.resize(css[i].size());
                            for(std::size_t j=0; j<css[i].size(); j++)
                            {
                                removed_zeros[j]=false;
                            }
                            
                            //We obtain the zeros which belong to the previous peaks computed
                            for(uint64 j=0; j<_peaks.size();j++)
                            {
                                dmin1=(float64)perim;
                                dmin2=(float64)perim;
                                for(uint64 l=0; l<css[i].size(); l++)
                                {
                                    if(!removed_zeros[l])
                                    {
                                    	float64 tmp1 = std::abs(css[i][l]-_peaks[j]);
                                        if(tmp1 > perim/2.0)
                                        {
                                            tmp1 = perim - tmp1;
                                        }
                                        if(tmp1<dmin1)
                                        {
                                            dmin2=dmin1;
                                            min2=min1;
                                            dmin1=tmp1;
                                            min1=l;
                                        }
                                        else if(tmp1<dmin2)
                                        {
                                            dmin2=tmp1;
                                            min2=l;
                                        }
                                    }
                                }
                                removed_zeros[min1]=true;
                                removed_zeros[min2]=true;
                                
                            }
                            //We compute the new peaks with the zeros not belonging to the previous computed peaks
                            if(!removed_zeros[0]&&!removed_zeros[removed_zeros.size()-1])
                            {
                                if(removed_zeros[1])
                                {
                                    tmp = (css[i][0]+perim+css[i][removed_zeros.size()-1])/2.0;
                                    if(tmp>perim)
                                    {
                                        tmp = tmp - perim;
                                    }
                                    _peaks.push_back(tmp);
                                    _smooth.push_back(i*inc_sigma+1.0);
                                    removed_zeros[0]=true;
                                    removed_zeros[removed_zeros.size()-1]=true;
                                }
                                else
                                {
                                    dmin1 = css[i][0]+perim-css[i][removed_zeros.size()-1];
                                    dmin2 = css[i][1]-css[i][0];
                                    if(dmin1<dmin2)
                                    {
                                        tmp = (css[i][0]+perim+css[i][removed_zeros.size()-1])/2.0;
                                        if(tmp>perim)
                                        {
                                            tmp = tmp - perim;
                                        }
                                        _peaks.push_back(tmp);
                                        _smooth.push_back(i*inc_sigma+1.0);
                                        removed_zeros[0]=true;
                                        removed_zeros[removed_zeros.size()-1]=true;
                                    }
                                    else
                                    {
                                        tmp = (css[i][0]+css[i][1])/2.0;
                                        _peaks.push_back(tmp);
                                        _smooth.push_back(i*inc_sigma+1.0);
                                        removed_zeros[0]=true;
                                        removed_zeros[1]=true;
                                    }
                                }
                            }
                            for(uint64 k=0; k<removed_zeros.size()-1;)
                            {
                                if(!removed_zeros[k])
                                {
                                    uint64 k_tmp = k;
                                    k++;
                                    while(removed_zeros[k])
                                    {
                                    	k++;
                                    }
                                	tmp = (css[i][k_tmp] + css[i][k])/2.0;
                                    _peaks.push_back(tmp);
                                    _smooth.push_back(i*inc_sigma+1.0);
                                    removed_zeros[k_tmp]=true;
                                    removed_zeros[k]=true;
                                    k++;
                                }
                                else
                                {
                                    k++;
                                }
                            }
                        }
                    }
                }
            }
            
            //! Circularity of original contour
            float64 _circularity;
            
            //! Eccentricity of the original contour
            float64 _eccentricity;
            
            //! Circularity of filtered contour
            float64 _circularity_smoothed;
            
            //! Eccentricity of the filtered contour
            float64 _eccentricity_smoothed;
            
            //! Localization of the peaks ( according arc length parameterization ) 
            std::vector<float64> _peaks;
            
            //! Height of the peaks
            std::vector<float64> _smooth;
            
            //! Localization of the zeros of curvature function
            std::vector<float64> _zeros;
            
            //! Bool that is true if there are no zeros
            bool _no_zeros;
            
            //! Total number of zeros found
            uint64 _count;
        
        };

    } // Namespace descriptors
}// Namespace imageplus

#endif

