/*
 * color_volume.hpp
 *
 *  Created on: Sep 3, 2012
 *      Author: guillem
 */

#ifndef COLOR_VOLUME_HPP_
#define COLOR_VOLUME_HPP_


// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------

#include <imageplus/descriptors/descriptor_base.hpp>
#include <imageplus/math/math_types.hpp>

namespace imageplus
{
    namespace descriptors
    {
        //!
        //! \brief Area visual descriptor
        //!
        //! \author Jordi Pont <jpont@gps.tsc.upc.edu>, Guillem Palou <guillem.palou@gmail.com>
        //!
        //! \date 02-06-2009
    	template<class Signal>
        class ColorVolume : public DescriptorBase
        {
        public:

        	//! base structur for descriptors using parameters
        	struct ColorVolumeDescriptorParameters {
        	};

        	typedef ColorVolumeDescriptorParameters 	Parameters;

            //! Type to refer to the type of data which will be returned by this descriptor
            typedef typename Signal::value_type 							value_type;
            typedef Eigen::Matrix<float64, value_type::RowsAtCompileTime, 1>	type;


            //! function returning the id given a set of parameters
            //! \param[in] pars: parameters to the descriptors (null in this case)
            static const std::string id(const Parameters& pars = default_parameters()) {
            	return "color_volume";
            }

            //! Default parameters for descriptors
            static const Parameters default_parameters() {
            	return Parameters();
            }

            //!
            //! \brief Default constructor
            //!
            ColorVolume(const Parameters& pars = default_parameters()) : DescriptorBase(true), _value(type::Zero()){};

            //! Virtual destructor
            ~ColorVolume(){};

            //! \brief Calculates the area of a region, given a pair of iterators.
            //!
            //! \param[in] first      : Iterator to the beginning of the region
            //! \param[in] last       : Iterator to the end of the region
            //! \param[in] peer_descs : Pointer to CollaborativeDescriptors, in principle is never 0x0 but it is a good idea to ASSERT it
            template< class SignalModel, class RegionModel>
            void calculate(SignalModel& signal, RegionModel& region, const Parameters& pars, typename DescriptorBase::ManagerType* manager)
            {
                //ASSERT(manager!=0x0, "Area calculate: manager must be non null");

                _value = type::Zero();

                typename SignalModel::template region_iterator<RegionModel>::type	first 	= signal.begin(region);
                typename SignalModel::template region_iterator<RegionModel>::type	last 	= signal.end(region);

                for(; first!=last; ++first) {
                	std::string s;
                	value_type p = (*first);

                	_value += p.template cast<float64>();
                }
            }

            //!
            //! \brief Calculates recursively area of the father region given the sons ones.
            //!
            //! \param[in] son1_descs : CollaborativeDescriptors of the son 1
            //! \param[in] son2_descs : CollaborativeDescriptors of the son 2
            //! \param[in] peer_descs : Pointer to CollaborativeDescriptors, in principle is never 0x0 but it is a good idea to ASSERT it
            template<class SignalModel, class RegionModel, class ChildContainer>
            void recursive_calculate(SignalModel& signal, RegionModel& region, ChildContainer& childs, const Parameters& pars, typename DescriptorBase::ManagerType* manager)
            {
                 _value = type::Zero();

                 //std::cout << "Computing " << region.label() << std::endl;
                 for (typename ChildContainer::iterator child = childs.begin(); child != childs.end(); ++child) {
                	 _value += manager->calc_descriptor<ColorVolume<SignalModel> >(signal,**child, pars);
                 }
                 //std::cout << "Computed " << region.label() << std::endl;
            }

            const type& value() const {
            	return _value;
            }

        private:
            //! Area of the region
            type _value;
        };
    }
}

#endif /* COLOR_VOLUME_HPP_ */
