// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------

//!
//!  \file multiarray_arithmetic.hpp
//!
//!  Overloaded arithmetic operators for imageplus multiarrays
//!

#ifndef IMAGEPLUS_CORE_MULTIARRAY_ARITHMETIC_HPP
#define IMAGEPLUS_CORE_MULTIARRAY_ARITHMETIC_HPP


#include <imageplus/core/multiarray.hpp>
#include <imageplus/core/config.hpp>

namespace imageplus
{
    //!
    //! \brief Overloading of operator + for two imageplus multiarrays
    //!
    //! \tparam T : the type of the data \n
    //! \tparam D : the number of dimensions (2 for images, 3 for volumes) \n
    //!
    //! \param[in] input1 : First operand (multiarray)
    //! \param[in] input2 : Second operand (multiarray)
    //!
    //! \return Sum of the input operands (multiarray)
    //!
    //! \author Josep Ramon Morros <ramon.morros@upc.edu>
    //!
    //! \date 10-1-2008
    //!
    template<typename T, std::size_t D>
    MultiArray<T,D> operator+( const MultiArray<T,D>& input1, const MultiArray<T,D>& input2);

    //!
    //! \brief Overloading of operator += for two imageplus multiarrays
    //!
    //! \tparam T : the type of the data \n
    //! \tparam D : the number of dimensions (2 for images, 3 for volumes) \n
    //!
    //! \param[in] input1 : First operand (multiarray)
    //! \param[in] input2 : Second operand (multiarray)
    //!
    //! \return Sum of the input operands (multiarray)
    //!
    //! \author Josep Ramon Morros <ramon.morros@upc.edu>
    //!
    //! \date 10-1-2010
    //!
    template<typename T, std::size_t D>
    const MultiArray<T,D>& operator+=( MultiArray<T,D>& input1, const MultiArray<T,D>& input2);

    //!
    //! \brief Overloading of operator + for a imageplus multiarray and a scalar
    //!
    //! \tparam T : the type of the scalar, input and output multiarrays \n
    //! \tparam D : the number of dimensions (2 for images, 3 for volumes) \n
    //!
    //! \param[in] input1 : First operand (multiarray)
    //! \param[in] val    : Second operand (scalar)
    //!
    //! \return Sum of the input operands (multiarray)
    //! 
    //! \author Josep Ramon Morros <ramon.morros@upc.edu>
    //!
    //! \date 10-1-2008
    //!
    template<typename T, std::size_t D>
    MultiArray<T,D> operator+( const MultiArray<T,D>& input1, T val );

    //!
    //! \brief Overloading of operator += for a imageplus multiarray and a scalar
    //!
    //! \tparam T : the type of the scalar, input and output multiarrays \n
    //! \tparam D : the number of dimensions (2 for images, 3 for volumes) \n
    //!
    //! \param[in] input1 : First operand (multiarray)
    //! \param[in] val    : Second operand (scalar)
    //!
    //! \return Sum of the input operands (multiarray)
    //! 
    //! \author Josep Ramon Morros <ramon.morros@upc.edu>
    //!
    //! \date 10-1-2010
    //!
    template<typename T, std::size_t D>
    const MultiArray<T,D>& operator+=( MultiArray<T,D>& input1, T val );

    //!
    //! \brief Overloading of operator + for a scalar and a imageplus multiarray
    //!
    //! \tparam T : the type of the scalar, input and output multiarrays \n
    //! \tparam D : the number of dimensions (2 for images, 3 for volumes) \n
    //!
    //! \param[in] val    : First operand (multiarray)
    //! \param[in] input1 : Second operand (scalar)
    //!
    //! \return Sum of the input operands (multiarray)
    //!
    //! \author Josep Ramon Morros <ramon.morros@upc.edu>
    //!
    //! \date 10-1-2008
    //!
    template<typename T, std::size_t D>
    MultiArray<T,D> operator+( T val, const MultiArray<T,D>& input1);

    //!
    //! \brief Overloading of operator - for two imageplus multiarrays
    //!
    //! \tparam T : the type of the data \n
    //! \tparam D : the number of dimensions (2 for images, 3 for volumes) \n
    //!
    //! \param[in] input1 : First operand (multiarray)
    //! \param[in] input2 : Second operand (multiarray)
    //!
    //! \return Difference between the input operands (multiarray)
    //!
    //! \author Josep Ramon Morros <ramon.morros@upc.edu>
    //!
    //! \date 10-1-2008
    //!
    template<typename T, std::size_t D>
    MultiArray<T,D> operator-( const MultiArray<T,D>& input1, const MultiArray<T,D>& input2);

    //!
    //! \brief Overloading of operator -= for two imageplus multiarrays
    //!
    //! \tparam T : the type of the data \n
    //! \tparam D : the number of dimensions (2 for images, 3 for volumes) \n
    //!
    //! \param[in] input1 : First operand (multiarray)
    //! \param[in] input2 : Second operand (multiarray)
    //!
    //! \return Difference between the input operands (multiarray)
    //!
    //! \author Josep Ramon Morros <ramon.morros@upc.edu>
    //!
    //! \date 10-1-2010
    //!
    template<typename T, std::size_t D>
    const MultiArray<T,D>& operator-=( MultiArray<T,D>& input1, const MultiArray<T,D>& input2);

    //!
    //! \brief Overloading of operator - for a imageplus multiarray and a scalar
    //!
    //! \tparam T : the type of the scalar, input and output multiarrays \n
    //! \tparam D : the number of dimensions (2 for images, 3 for volumes) \n
    //!
    //! \param[in] input1 : First operand (multiarray)
    //! \param[in] val    : Second operand (scalar)
    //!
    //! \return Difference between the input operands (multiarray)
    //!
    //! \author Josep Ramon Morros <ramon.morros@upc.edu>
    //!
    //! \date 10-1-2008
    //!
    template<typename T, std::size_t D>
    MultiArray<T,D> operator-( const MultiArray<T,D>& input1, T val );

    //!
    //! \brief Overloading of operator -= for a imageplus multiarray and a scalar
    //!
    //! \tparam T : the type of the scalar, input and output multiarrays \n
    //! \tparam D : the number of dimensions (2 for images, 3 for volumes) \n
    //!
    //! \param[in] input1 : First operand (multiarray)
    //! \param[in] val    : Second operand (scalar)
    //!
    //! \return Difference between the input operands (multiarray)
    //!
    //! \author Josep Ramon Morros <ramon.morros@upc.edu>
    //!
    //! \date 10-1-2010
    //!
    template<typename T, std::size_t D>
    const MultiArray<T,D>& operator-=( MultiArray<T,D>& input1, T val );
    
    //!
    //! \brief Overloading of operator - for a imageplus multiarray and a scalar
    //!
    //! \tparam T : the type of the scalar, input and output multiarrays \n
    //! \tparam D : the number of dimensions (2 for images, 3 for volumes) \n
    //!
    //! \param[in] val    : First operand (scalar)
    //! \param[in] input1 : Second operand (multiarray)
    //!
    //! \return Difference between the input operands (multiarray)
    //!
    //! \author Gloria Haro <gloria@gps.tsc.upc.edu>
    //!
    //! \date 9-4-2008
    //!
    template<typename T, std::size_t D>
    MultiArray<T,D> operator-( T val, const MultiArray<T,D>& input1 );

    //!
    //! \brief Overloading of operator * for two imageplus multiarrays
    //!
    //! \tparam T : the type of the data \n
    //! \tparam D : the number of dimensions (2 for images, 3 for volumes) \n
    //!
    //! \param[in] input1 : First operand (multiarray)
    //! \param[in] input2 : Second operand (multiarray)
    //!
    //! \return Element product of the input operands (multiarray)
    //!
    //! \author Josep Ramon Morros <ramon.morros@upc.edu>
    //!
    //! \date 10-1-2008
    //!
    template<typename T, std::size_t D>
    MultiArray<T,D> operator*( const MultiArray<T,D>& input1, const MultiArray<T,D>& input2 );

    //!
    //! \brief Overloading of operator *= for two imageplus multiarrays
    //!
    //! \tparam T : the type of the data
    //! \tparam D : the number of dimensions (2 for images, 3 for volumes)
    //!
    //! \param[in] input1 : First operand (multiarray)
    //! \param[in] input2 : Second operand (multiarray)
    //!
    //! \return Element product of the input operands (multiarray)
    //!
    //! \author Josep Ramon Morros <ramon.morros@upc.edu>
    //!
    //! \date 10-1-2010
    //!
    template<typename T, std::size_t D>
    const MultiArray<T,D>& operator*=( MultiArray<T,D>& input1 , const MultiArray<T,D>& input2 );

    //!
    //!
    //! \brief Overloading of operator * for a imageplus multiarray and a scalar
    //!
    //! \tparam T : the type of the scalar, the input and the output multiarrays \n
    //! \tparam D : the number of dimensions (2 for images, 3 for volumes) \n
    //!
    //! \param[in] input1 : First operand (multiarray)
    //! \param[in] val    : Second operand (scalar)
    //!
    //! \return Product between the input operands (multiarray)
    //!
    //! \author Josep Ramon Morros <ramon.morros@upc.edu>
    //!
    //! \date 18-1-2008
    //!
    template<typename T, std::size_t D>
    MultiArray<T,D> operator*( const MultiArray<T,D>& input1, T val );

    //!
    //!
    //! \brief Overloading of operator *= for a imageplus multiarray and a scalar
    //!
    //! \tparam T : the type of the scalar, the input and the output multiarrays \n
    //! \tparam D : the number of dimensions (2 for images, 3 for volumes) \n
    //!
    //! \param[in] input1 : First operand (multiarray)
    //! \param[in] val    : Second operand (scalar)
    //!
    //! \return Product between the input operands (multiarray)
    //!
    //! \author Josep Ramon Morros <ramon.morros@upc.edu>
    //!
    //! \date 18-1-2010
    //!
    template<typename T, std::size_t D>
    const MultiArray<T,D>& operator*=( MultiArray<T,D>& input1 , T val );

    //!
    //! \brief Overloading of operator * for a scalar and a imageplus multiarray
    //!
    //! \tparam T : the type of the scalar, the input and the output multiarrays \n
    //! \tparam D : the number of dimensions (2 for images, 3 for volumes) \n
    //!
    //! \param[in] val    : First operand (multiarray)
    //! \param[in] input1 : Second operand (scalar)
    //!
    //! \return Product between the input operands (multiarray)
    //!
    //! \author Josep Ramon Morros <ramon.morros@upc.edu>
    //!
    //! \date 18-1-2008
    //!
    template<typename T, std::size_t D>
    MultiArray<T,D> operator*( T val, const MultiArray<T,D>& input1);

    //!
    //! \brief Overloading of operator / for two imageplus multiarrays
    //!
    //! \tparam T : the type of the data \n
    //! \tparam D : the number of dimensions (2 for images, 3 for volumes) \n
    //!
    //! \param[in] input1 : First operand (multiarray)
    //! \param[in] input2 : Second operand (multiarray)
    //!
    //! \return Quocient of the input operands (multiarray)
    //!
    //! \author Josep Ramon Morros <ramon.morros@upc.edu>
    //!
    //! \date 10-1-2008
    //!
    template<typename T, std::size_t D>
    MultiArray<T,D> operator/( const MultiArray<T,D>& input1, const MultiArray<T,D>& input2 );


    //!
    //! \brief Overloading of operator /= for two imageplus multiarrays
    //!
    //! \tparam T : the type of the data \n
    //! \tparam D : the number of dimensions (2 for images, 3 for volumes) \n
    //!
    //! \param[in] input1 : First operand (multiarray)
    //! \param[in] input2 : Second operand (multiarray)
    //!
    //! \return Quocient of the input operands (multiarray)
    //!
    //! \author Josep Ramon Morros <ramon.morros@upc.edu>
    //!
    //! \date 10-1-2010
    //!
    template<typename T, std::size_t D>
    const MultiArray<T,D>& operator/=( MultiArray<T,D>& input1 , const MultiArray<T,D>& input2 );


    //!
    //! \brief Overloading of operator / for a imageplus multiarray and a scal
    //!
    //! \tparam T : the type of the data \n
    //! \tparam D : the number of dimensions (2 for images, 3 for volumes) \n
    //!
    //! \param[in] input1 : First operand (multiarray)
    //! \param[in] val    : Second operand (scalar)
    //!
    //! \return Quocient of the input operands (multiarray)
    //!
    //! \author Josep Ramon Morros <ramon.morros@upc.edu>
    //!
    //! \date 10-1-2008
    //!
    template<typename T, std::size_t D>
    MultiArray<T,D> operator/( const MultiArray<T,D>& input1, T val );


    //!
    //! \brief Overloading of operator /= for a imageplus multiarray and a scal
    //!
    //! \tparam T : the type of the data \n
    //! \tparam D : the number of dimensions (2 for images, 3 for volumes) \n
    //!
    //! \param[in] input1 : First operand (multiarray)
    //! \param[in] val    : Second operand (scalar)
    //!
    //! \return Quocient of the input operands (multiarray)
    //!
    //! \author Josep Ramon Morros <ramon.morros@upc.edu>
    //!
    //! \date 10-1-2010
    //!
    template<typename T, std::size_t D>
    const MultiArray<T,D>& operator/=( MultiArray<T,D>& input1, T val );
    
	//!
    //! \brief Overloading of operator * for a generic multiarray and a bool multiarray
    //!
    //! \tparam T : the type of the data \n
    //! \tparam D : the number of dimensions (2 for images, 3 for volumes) \n
    //!
    //! \param[in] input1 : First operand (multiarray<bool,D>)
    //! \param[in] input2 : Second operand (multiarray<T,D>)
    //!
    //! \return Element product of the input operands (multiarray)
    //!
    //! \author Josep Ramon Morros <ramon.morros@upc.edu>
    //!
    //! \date 12-2-2008
    //!
    template<typename T, std::size_t D>
    MultiArray<T,D> operator*( const MultiArray<bool,D>& input2 , const MultiArray<T,D>& input1 );

    //!
    //! \brief Overloading of operator * for a generic multiarray and a bool multiarray
    //!
    //! \tparam T : the type of the data \n
    //! \tparam D : the number of dimensions (2 for images, 3 for volumes) \n
    //!
    //! \param[in] input1 : First operand (multiarray<T,D>)
    //! \param[in] input2 : Second operand (multiarray<bool,D>)
    //!
    //! \return Element product of the input operands (multiarray)
    //!
    //! \author Josep Ramon Morros <ramon.morros@upc.edu>
    //!
    //! \date 12-2-2008
    //!
    template<typename T, std::size_t D>
    MultiArray<T,D> operator*( const MultiArray<T,D>& input1, const MultiArray<bool,D>& input2 );
    
    //!
    //! \brief sum function for two imageplus multiarrays
    //!
    //! \tparam T : the type of the data \n
    //! \tparam D : the number of dimensions (2 for images, 3 for volumes) \n
    //!
    //! \param[in] input1 : First operand (multiarray)
    //! \param[in] input2 : Second operand (multiarray)
    //! \param[out] output : sum of the input operands (multiarray)
    //!
    //! \return Reference to the output result
    //!
    //! \author Marcel Alcoverro <marcel@gps.tsc.upc.edu>
    //!
    //! \date 14-5-2008
    //!
    template<typename T, std::size_t D>
    const MultiArray<T,D>& sum( const MultiArray<T,D>& input1, const MultiArray<T,D>& input2, MultiArray<T,D>& output );

    //!
    //! \brief sum function for a imageplus multiarray and a scalar
    //!
    //! \tparam T : Type of the data
    //! \tparam D : Number of dimensions (2 for images, 3 for volumes)
    //!
    //! \param[in] input1 : First operand (multiarray)
    //! \param[in] val : Second operand (scalar)
    //! \param[out] output :  sum of the input operands (multiarray)
    //!
    //! \return Reference to the output result
    //!
    //! \author Marcel Alcoverro <marcel@gps.tsc.upc.edu>
    //!
    //! \date 14-5-2008
    //!
    template<typename T, std::size_t D>
    const MultiArray<T,D>& sum( const MultiArray<T,D>& input1, T val, MultiArray<T,D>& output );
    
    //!
    //! \brief sum function for  a scalar and a imageplus multiarray
    //!
    //! \tparam T : the type of the data \n
    //! \tparam D : the number of dimensions (2 for images, 3 for volumes) \n
    //!
    //! \param[in] val : Second operand (scalar)
    //! \param[in] input1 : First operand (multiarray)
    //! \param[out] output : sum of the input operands (multiarray)
    //!
    //! \return Reference to the output result
    //!
    //! \author Marcel Alcoverro <marcel@gps.tsc.upc.edu>
    //!
    //! \date 14-5-2008
    //!
    template<typename T, std::size_t D>
    const MultiArray<T,D>& sum( T val,const MultiArray<T,D>& input1, MultiArray<T,D>& output );

    //!
    //! \brief substraction function for  two imageplus multiarrays
    //!
    //! \tparam T : the type of the data \n
    //! \tparam D : the number of dimensions (2 for images, 3 for volumes) \n
    //!
    //! \param[in] input1 : First operand (multiarray)
    //! \param[in] input2 : Second operand (multiarray)
    //! \param[out] output : Difference between the input operands (multiarray)
    //!
    //! \return Difference between the input operands (multiarray)
    //!
    //! \author Marcel Alcoverro <marcel@gps.tsc.upc.edu>
    //!
    //! \date 14-5-2008
    //!
    template<typename T, std::size_t D>
    const MultiArray<T,D>& substract( const MultiArray<T,D>& input1, const MultiArray<T,D>& input2, MultiArray<T,D>& output);

    //!
    //! \brief substraction function for a imageplus multiarray and a scalar
    //!
    //! \tparam T : the type of the data \n
    //! \tparam D : the number of dimensions (2 for images, 3 for volumes) \n
    //!
    //! \param[in] input1 : First operand (multiarray)
    //! \param[in] val : Second scalar (multiarray)
    //! \param[in] output : Difference between the input operands (multiarray)
    //!
    //! \return Difference between the input operands (multiarray)
    //!
    //! \author Marcel Alcoverro <marcel@gps.tsc.upc.edu>
    //!
    //! \date 14-5-2008
    //!
    template<typename T, std::size_t D>
    const MultiArray<T,D>& substract( const MultiArray<T,D>& input1, T val, MultiArray<T,D>& output);
    
    //!
    //! \brief substraction function for a imageplus scalar and a multiarray
    //!
    //! \tparam T : the type of the data \n
    //! \tparam D : the number of dimensions (2 for images, 3 for volumes) \n
    //!
    //! \param[in] val : First operand (scalar)
    //! \param[in] input1 : Second operand (multiarray)
    //! \param[in] output : Difference between the input operands (multiarray)
    //!
    //! \return Reference to the output result
    //!
    //! \author Marcel Alcoverro <marcel@gps.tsc.upc.edu>
    //!
    //! \date 14-5-2008
    //!
    template<typename T, std::size_t D>
    const MultiArray<T,D>& substract(  T val,const MultiArray<T,D>& input1, MultiArray<T,D>& output);
    
    //!
    //! \brief product function for two imageplus multiarrays
    //!
    //! \tparam T : the type of the data \n
    //! \tparam D : the number of dimensions (2 for images, 3 for volumes) \n
    //!
    //! \param[in] input1 : First operand (multiarray)
    //! \param[in] input2 : Second operand (multiarray)
    //! \param[in] output : product of the input operands (multiarray)
    //!
    //! \return Reference to the output result
    //!
    //! \author Marcel Alcoverro <marcel@gps.tsc.upc.edu>
    //!
    //! \date 14-5-2008
    //!
    template<typename T, std::size_t D>
    const MultiArray<T,D>& product( const MultiArray<T,D>& input1, const MultiArray<T,D>& input2, MultiArray<T,D>& output );

    //!
    //! \brief product function for a imageplus multiarray and a scalar
    //!
    //! \tparam T : the type of the data \n
    //! \tparam D : the number of dimensions (2 for images, 3 for volumes) \n
    //!
    //! \param[in] input1 : First operand (multiarray)
    //! \param[in] val : Second operand (scalar)
    //! \param[in] output :  product of the input operands (multiarray)
    //!
    //! \return Reference to the output result
    //!
    //! \author Marcel Alcoverro <marcel@gps.tsc.upc.edu>
    //!
    //! \date 14-5-2008
    //!
    template<typename T, std::size_t D>
    const MultiArray<T,D>& product( const MultiArray<T,D>& input1, T val, MultiArray<T,D>& output );
    
    //!
    //! \brief product function for  a scalar and a imageplus multiarray
    //!
    //! \tparam T : the type of the data \n
    //! \tparam D : the number of dimensions (2 for images, 3 for volumes) \n
    //!
    //! \param[in] val : first operand (scalar)
    //! \param[in] input1 : second operand (multiarray)
    //! \param[in] output : product of the input operands (multiarray)
    //!
    //! \return Reference to the output result
    //!
    //! \author Marcel Alcoverro <marcel@gps.tsc.upc.edu>
    //!
    //! \date 14-5-2008
    //!
    template<typename T, std::size_t D>
    const MultiArray<T,D>& product( T val,const MultiArray<T,D>& input1, MultiArray<T,D>& output );
    
    //!
    //! \brief division function for two imageplus multiarrays
    //!
    //! \tparam T : the type of the data \n
    //! \tparam D : the number of dimensions (2 for images, 3 for volumes) \n
    //!
    //! \param[in] input1 : First operand (multiarray)
    //! \param[in] input2 : Second operand (multiarray)
    //! \param[in] output : division of the input operands (multiarray)
    //!
    //! \return Reference to the output result
    //!
    //! \author Marcel Alcoverro <marcel@gps.tsc.upc.edu>
    //!
    //! \date 14-5-2008
    //!
    template<typename T, std::size_t D>
    const MultiArray<T,D>& division( const MultiArray<T,D>& input1, const MultiArray<T,D>& input2, MultiArray<T,D>& output );

    //!
    //! \brief division function for a imageplus multiarray and a scalar
    //!
    //! \tparam T : the type of the data \n
    //! \tparam D : the number of dimensions (2 for images, 3 for volumes) \n
    //!
    //! \param[in] input1 : First operand (multiarray)
    //! \param[in] val : Second operand (scalar)
    //! \param[in] output :  division of the input operands (multiarray)
    //!
    //! \return Reference to the output result
    //!
    //! \author Marcel Alcoverro <marcel@gps.tsc.upc.edu>
    //!
    //! \date 14-5-2008
    //!
    template<typename T, std::size_t D>
    const MultiArray<T,D>& division( const MultiArray<T,D>& input1, T val, MultiArray<T,D>& output );

    //!
    //! \brief product function for  a scalar and a imageplus multiarray
    //!
    //! \tparam T : the type of the data \n
    //! \tparam D : the number of dimensions (2 for images, 3 for volumes) \n
    //!
    //! \param[in] val : first operand (scalar)
    //! \param[in] input1 : second operand (multiarray)
    //! \param[in] output : division of the input operands (multiarray)
    //!
    //! \return Reference to the output result
    //!
    //! \author Marcel Alcoverro <marcel@gps.tsc.upc.edu>
    //!
    //! \date 14-5-2008
    //!
    template<typename T, std::size_t D>
    const MultiArray<T,D>& division( T val,const MultiArray<T,D>& input1, MultiArray<T,D>& output );
    
    //!
    //! \brief product function for a bool multiarray and a generic multiarray
    //!
    //! \tparam T : the type of the data \n
    //! \tparam D : the number of dimensions (2 for images, 3 for volumes) \n
    //!
    //! \param[in] input1 : First operand (multiarray)
    //! \param[in] input2 : Second operand (multiarray)
    //! \param[in] output : product of the input operands (multiarray)
    //!
    //! \return Reference to the output result
    //!
    //! \author Marcel Alcoverro <marcel@gps.tsc.upc.edu>
    //!
    //! \date 14-5-2008
    //!
    template<typename T, std::size_t D>
    const MultiArray<T,D>& product( const MultiArray<bool,D>& input1, const MultiArray<T,D>& input2, MultiArray<T,D>& output );
    
    //!
    //! \brief product function for a generic multiarray and a bool multiarray
    //!
    //! \tparam T : the type of the data \n
    //! \tparam D : the number of dimensions (2 for images, 3 for volumes) \n
    //!
    //! \param[in] input1 : First operand (multiarray)
    //! \param[in] input2 : Second operand (multiarray)
    //! \param[in] output : product of the input operands (multiarray)
    //!
    //! \return Reference to the output result
    //!
    //! \author Marcel Alcoverro <marcel@gps.tsc.upc.edu>
    //!
    //! \date 14-5-2008
    //!
    template<typename T, std::size_t D>
    const MultiArray<T,D>& product( const MultiArray<T,D>& input1, const MultiArray<bool,D>& input2, MultiArray<T,D>& output );
}



//
//  Implementation of template functions
//
namespace imageplus
{
    template<typename T, std::size_t D>
    const MultiArray<T,D>& operator+=( MultiArray<T,D>& input1, const MultiArray<T,D>& input2 )
    {
        // Use the STL algorithm 'transform' with the function object 'plus()'
        std::transform(input1.data(),
                       input1.data()+input1.num_elements(),
                       input2.data(),
                       input1.data(),
                       std::plus<T>());

        return input1;
    }


    template<typename T, std::size_t D>
    MultiArray<T,D> operator+( const MultiArray<T,D>& input1, const MultiArray<T,D>& input2 )
    {
        // Create sum as a copy of input1
        MultiArray<T,D> out(input1);
        return out += input2;
    }

    template<typename T, std::size_t D>
    const MultiArray<T,D>& operator+=( MultiArray<T,D>& input1, T val )
    {
        // Use the STL algorithm 'transform' with the function object 'plus()'
        std::transform(input1.data(),
                       input1.data() + input1.num_elements(),
                       input1.data(),
                       std::bind2nd(std::plus<T>(),val));

        return input1;
    }

    template<typename T, std::size_t D>
    MultiArray<T,D> operator+( const MultiArray<T,D>& input1, T val )
    {
        MultiArray<T,D> out(input1);
        return out += val;
    }


    template<typename T, std::size_t D>
    MultiArray<T,D> operator+( T val, const MultiArray<T,D>& input1 )
    {
        // Create sum as a copy of input1
        MultiArray<T,D> sum(input1);
        return sum += val;
    }

    template<typename T, std::size_t D>
    const MultiArray<T,D>& operator-=( MultiArray<T,D>& input1, const MultiArray<T,D>& input2 )
    {
        // Use the STL algorithm 'transform' with the function object 'minus()'
        std::transform (input1.data(),
                        input1.data()+input1.num_elements(),
                        input2.data(),
                        input1.data(),
                        std::minus<T>());

        return input1;
    }

    template<typename T, std::size_t D>
    MultiArray<T,D> operator-( const MultiArray<T,D>& input1, const MultiArray<T,D>& input2 )
    {
        MultiArray<T,D> out(input1);
        return out -= input2;
    }


    template<typename T, std::size_t D>
    const MultiArray<T,D>& operator-=( MultiArray<T,D>& input1, T val )
    {
        // Use the STL algorithm 'transform' with the function object 'plus()'
        std::transform(input1.data(),
                       input1.data() + input1.num_elements(),
                       input1.data(),
                       std::bind2nd(std::minus<T>(),val));

        return input1;
    }

    template<typename T, std::size_t D>
    MultiArray<T,D> operator-( const MultiArray<T,D>& input1, T val )
    {
        MultiArray<T,D> out(input1);
        return out -= val;
    }


    template<typename T, std::size_t D>
    MultiArray<T,D> operator-( T val, const MultiArray<T,D>& input1 )
    {
    	// Create sum as a copy of input1
        MultiArray<T,D> minus(input1);
        minus = val;

        // Use the STL algorithm 'transform' with the function object 'plus()'
        std::transform(minus.data(),
                      minus.data() + minus.num_elements(),
                      input1.data(),
                      minus.data(),
                      std::minus<T>());

       return minus;
    }


    template<typename T, std::size_t D>
    const MultiArray<T,D>& operator*=( MultiArray<T,D>& input1, const MultiArray<T,D>& input2 )
    {
        // Use the STL algorithm 'transform' with the function object 'multiplies()'
        std::transform(input1.data(),
                       input1.data()+input1.num_elements(),
                       input2.data(),
                       input1.data(),
                       std::multiplies<T>());

        return input1;
    }

    template<typename T, std::size_t D>
    MultiArray<T,D> operator*( const MultiArray<T,D>& input1, const MultiArray<T,D>& input2 )
    {
        MultiArray<T,D> out(input1);
        return out *= input2;
    }

    template<typename T, std::size_t D>
    const MultiArray<T,D>& operator*=( MultiArray<T,D>& input1, T val )
    {
        // Use the STL algorithm 'transform' with the function object 'multiplies()'
        std::transform(input1.data(),
                       input1.data() + input1.num_elements(),
                       input1.data(),
                       std::bind2nd(std::multiplies<T>(),val));

        return input1;
    }

    template<typename T, std::size_t D>
    MultiArray<T,D> operator*( const MultiArray<T,D>& input1, T val )
    {
        MultiArray<T,D> out(input1);
        return out *= val;
    }


    template<typename T, std::size_t D>
    MultiArray<T,D> operator*( T val, const MultiArray<T,D>& input1 )
    {
        // Create sum as a copy of input1
        MultiArray<T,D> mul(input1);

        // Use the STL algorithm 'transform' with the function object 'multiplies()'
        std::transform(input1.data(),
                       input1.data() + input1.num_elements(),
                       mul.data(),
                       std::bind2nd(std::multiplies<T>(),val));

        return mul;
    }


    template<typename T, std::size_t D>
    const MultiArray<T,D>& operator/=( MultiArray<T,D>& input1, const MultiArray<T,D>& input2 )
    {
        // Use the STL algorithm 'transform' with the function object 'divides()'
        std::transform(input1.data(),
                       input1.data()+input1.num_elements(),
                       input2.data(),
                       input1.data(),
                       std::divides<T>());
        return input1;
    }

    template<typename T, std::size_t D>
    MultiArray<T,D> operator/( const MultiArray<T,D>& input1, const MultiArray<T,D>& input2 )
    {
        MultiArray<T,D> out(input1);
        return out /= input2;
    }
 

    template<typename T, std::size_t D>
    const MultiArray<T,D>& operator/=( MultiArray<T,D>& input1, T val )
    {
        // Use the STL algorithm 'transform' with the function object 'multiplies()'
        std::transform(input1.data(),
                       input1.data() + input1.num_elements(),
                       input1.data(),
                       std::bind2nd(std::divides<T>(),val));

        return input1;
    }

    template<typename T, std::size_t D>
    MultiArray<T,D> operator/( const MultiArray<T,D>& input1, T val )
    {
        MultiArray<T,D> out(input1);
        return out /= val;
    }


    template<typename T, std::size_t D>
    MultiArray<T,D> operator*( const MultiArray<T,D>& input1, const MultiArray<bool,D>& input2 )
    {
        // Create sum as a copy of input1
        MultiArray<T,D> mult(input1);

        // Use the STL algorithm 'transform' with the function object 'multiplies()'
        std::transform(input1.data(),
                  input1.data()+input1.num_elements(),
                  input2.data(),
                  mult.data(),
                  std::multiplies<T>());

        return mult;
    }


    template<typename T, std::size_t D>
    MultiArray<T,D> operator*( const MultiArray<bool,D>& input2, const MultiArray<T,D>& input1 )
    {
        // Create sum as a copy of input1
        MultiArray<T,D> mult(input1);

        // Use the STL algorithm 'transform' with the function object 'multiplies()'
        transform(input1.data(),
                  input1.data()+input1.num_elements(),
                  input2.data(),
                  mult.data(),
                  std::multiplies<T>());

        return mult;
    }


    template<typename T, std::size_t D>
    const MultiArray<T,D>& sum( const MultiArray<T,D>& input1, const MultiArray<T,D>& input2, MultiArray<T,D>& output )
    {
        ASSERT((input1.num_elements() == input2.num_elements()) &&( input1.num_elements() == output.num_elements()), "ERROR different number of elements in inputs" );
        // Use the STL algorithm 'transform' with the function object 'plus()'
        std::transform(input1.data(),
                       input1.data()+input1.num_elements(),
                       input2.data(),
                       output.data(),
                       std::plus<T>());
        return output;
    }

    
    template<typename T, std::size_t D>
    const MultiArray<T,D>& sum( const MultiArray<T,D>& input1, T val, MultiArray<T,D>& output )
    {
        ASSERT(input1.num_elements() == output.num_elements(), "ERROR different number of elements in inputs" );

        std::transform(input1.data(),
                       input1.data() + input1.num_elements(),
                       output.data(),
                       std::bind2nd(std::plus<T>(),val));
        return output;
    }


    template<typename T, std::size_t D>
    const MultiArray<T,D>& sum( T val,const MultiArray<T,D>& input1, MultiArray<T,D>& output )
    {
        ASSERT(input1.num_elements() == output.num_elements(), "ERROR different number of elements in inputs" );

        std::transform(input1.data(),
                       input1.data() + input1.num_elements(),
                       output.data(),
                       std::bind2nd(std::plus<T>(),val));        
        return output;
    }
    

    template<typename T, std::size_t D>
    const MultiArray<T,D>& substract( const MultiArray<T,D>& input1, const MultiArray<T,D>& input2, MultiArray<T,D>& output)
    {
        ASSERT((input1.num_elements() == input2.num_elements()) &&( input1.num_elements() == output.num_elements()), "ERROR different number of elements in inputs" );
        // Use the STL algorithm 'transform' with the function object 'plus()'
        std::transform(input1.data(),
                       input1.data()+input1.num_elements(),
                       input2.data(),
                       output.data(),
                       std::minus<T>());
        return output;
    }

    
    template<typename T, std::size_t D>
    const MultiArray<T,D>& substract( const MultiArray<T,D>& input1, T val, MultiArray<T,D>& output)
    {
        ASSERT(input1.num_elements() == output.num_elements(), "ERROR different number of elements in inputs" );
        std::transform(input1.data(),
                       input1.data() + input1.num_elements(),
                       output.data(),
                       std::bind2nd(std::minus<T>(),val));
        return output;
    }

    
    template<typename T, std::size_t D>
    const MultiArray<T,D>& substract(  T val,const MultiArray<T,D>& input1, MultiArray<T,D>& output)
    {
        ASSERT(input1.num_elements() == output.num_elements(), "ERROR different number of elements in inputs" );
        
        output = val;
        // Use the STL algorithm 'transform' with the function object 'plus()'
        std::transform(output.data(),
                      output.data() + output.num_elements(),
                      input1.data(),
                      output.data(),
                      std::minus<T>());
        return output;
    }

        
    template<typename T, std::size_t D>
    const MultiArray<T,D>& product( const MultiArray<T,D>& input1, const MultiArray<T,D>& input2, MultiArray<T,D>& output )
    {
        ASSERT((input1.num_elements() == input2.num_elements()) &&( input1.num_elements() == output.num_elements()), "ERROR different number of elements in inputs" );
        // Use the STL algorithm 'transform' with the function object 'plus()'
        std::transform(input1.data(),
                       input1.data()+input1.num_elements(),
                       input2.data(),
                       output.data(),
                       std::multiplies<T>());
        return output;
    }

    
    template<typename T, std::size_t D>
    const MultiArray<T,D>& product( const MultiArray<T,D>& input1, T val, MultiArray<T,D>& output )
    {
        ASSERT(input1.num_elements() == output.num_elements(), "ERROR different number of elements in inputs" );

        std::transform(input1.data(),
                       input1.data() + input1.num_elements(),
                       output.data(),
                       std::bind2nd(std::multiplies<T>(),val));
        return output;
    }

    
    template<typename T, std::size_t D>
    const MultiArray<T,D>& product( T val,const MultiArray<T,D>& input1, MultiArray<T,D>& output )
    {
        ASSERT(input1.num_elements() == output.num_elements(), "ERROR different number of elements in inputs" );

        std::transform(input1.data(),
                       input1.data() + input1.num_elements(),
                       output.data(),
                       std::bind2nd(std::multiplies<T>(),val));
        return output;
    }

    
    template<typename T, std::size_t D>
    const MultiArray<T,D>& division( const MultiArray<T,D>& input1, const MultiArray<T,D>& input2, MultiArray<T,D>& output )
    {
        ASSERT((input1.num_elements() == input2.num_elements()) &&( input1.num_elements() == output.num_elements()), "ERROR different number of elements in inputs" );
        // Use the STL algorithm 'transform' with the function object 'divides()'
        std::transform(input1.data(),
                       input1.data()+input1.num_elements(),
                       input2.data(),
                       output.data(),
                       std::divides<T>());
        return output;

    }

    
    template<typename T, std::size_t D>
    const MultiArray<T,D>& division( const MultiArray<T,D>& input1, T val, MultiArray<T,D>& output )
    {
        ASSERT(input1.num_elements() == output.num_elements(), "ERROR different number of elements in inputs" );

        std::transform(input1.data(),
                       input1.data() + input1.num_elements(),
                       output.data(),
                       std::bind2nd(std::divides<T>(),val));
        return output;
    }


    template<typename T, std::size_t D>
    const MultiArray<T,D>& division( T val,const MultiArray<T,D>& input1, MultiArray<T,D>& output )
    {
        ASSERT(input1.num_elements() == output.num_elements(), "ERROR different number of elements in inputs" );
        
        output = val;
        // Use the STL algorithm 'transform' with the function object 'plus()'
        std::transform(output.data(),
                       output.data() + output.num_elements(),
                      input1.data(),
                      output.data(),
                      std::divides<T>());
        return output;
    }

    
    template<typename T, std::size_t D>
    const MultiArray<T,D>& product( const MultiArray<bool,D>& input1, const MultiArray<T,D>& input2, MultiArray<T,D>& output )
    {
        ASSERT((input1.num_elements() == input2.num_elements()) &&( input1.num_elements() == output.num_elements()), "ERROR different number of elements in inputs" );
        // Use the STL algorithm 'transform' with the function object 'plus()'
        std::transform(input1.data(),
                       input1.data()+input1.num_elements(),
                       input2.data(),
                       output.data(),
                       std::multiplies<T>());
        return output;
    }


    template<typename T, std::size_t D>
    const MultiArray<T,D>& product( const MultiArray<T,D>& input1, const MultiArray<bool,D>& input2, MultiArray<T,D>& output )
    {
        ASSERT((input1.num_elements() == input2.num_elements()) &&( input1.num_elements() == output.num_elements()), "ERROR different number of elements in inputs" );
        // Use the STL algorithm 'transform' with the function object 'plus()'
        std::transform(input1.data(),
                       input1.data()+input1.num_elements(),
                       input2.data(),
                       output.data(),
                       std::multiplies<T>());
        return output;
    }
}


#endif
