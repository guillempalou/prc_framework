// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------

//!
//!  \file quadratic_function.test
//!
//!  Tests for the math operations on BBox classs
//!

#include <imageplus/math/statistics/signature.hpp>
#include <imageplus/math/optimization/emd.hpp>

BOOST_AUTO_TEST_SUITE ( emd );

using namespace imageplus;
using namespace imageplus::math;
using namespace imageplus::math::optimization;
using namespace imageplus::math::statistics;

BOOST_AUTO_TEST_CASE( emd_test )
{
	uint64 D = 3;
	uint64 N = 8;

	Signature<> s1,s2;

	s1.features.resize(N);
	s1.weights.resize(N);
	s2.features.resize(N);
	s2.weights.resize(N);

	Eigen::Matrix< float64, 1, Eigen::Dynamic> r(3);

	r << 5.80422,  1.01782,    0.133406;
	s1.features[0] = r.transpose();
	r << 9.88382,  7.396,      5.51415;
	s1.features[1] = r.transpose();
	r << 4.10222,  9.9963,     1.28624;
	s1.features[2] = r.transpose();
	r << 0.536133, 6.63091,    5.34848;
	s1.features[3] = r.transpose();
	r << 0.891839, 2.5243,     5.89522;
	s1.features[4] = r.transpose();
	r << 7.74357,  7.51912,    8.30184;
	s1.features[5] = r.transpose();
	r << 7.45415,  3.02601,    2.44425;
	s1.features[6] = r.transpose();
	r << 5.80364,  6.42521,    1.46641;
	s1.features[7] = r.transpose();

	r << 8.57978,  3.07032,    7.51295;
	s2.features[0] = r.transpose();
	r << 4.77943,  0.217983,   8.29754;
	s2.features[1] = r.transpose();
	r << 0.119682, 6.02221,    9.31535;
	s2.features[2] = r.transpose();
	r << 0.253088, 5.90602,    6.71135;
	s2.features[3] = r.transpose();
	r << 5.76724,  0.00824207, 6.70766;
	s2.features[4] = r.transpose();
	r << 7.05347,  0.544375,   3.33857;
	s2.features[5] = r.transpose();
	r << 2.40195,  1.43621,    5.86288;
	s2.features[6] = r.transpose();
	r << 8.29717,  9.17979,    3.38199;
	s2.features[7] = r.transpose();

	for (uint64 k = 0; k < N; k++) {
		s1.weights[k] = 1.0/N;
		s2.weights[k] = 1.0/N;
	}

	EMD<> emd;

	EMD<>::DistanceType distance(D,1/14.0); // arbitrary weight

	emd.set_distance(distance);

	float64 d = emd.calculate(s1,s2);

	BOOST_CHECK_CLOSE(d, 0.650135, 1e-2);

	d = emd.calculate(s1,s1);

	BOOST_CHECK( d == 0);
}

BOOST_AUTO_TEST_SUITE_END ();
