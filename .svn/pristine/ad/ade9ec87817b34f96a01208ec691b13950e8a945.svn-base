// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------

//! 
//! \file readsequence.test
//!
//! Tests for class ReadSequence 
//!

#include <iostream>

#include <imageplus/core.hpp>
#include <imageplus/io/readsequence.hpp>
#include <imageplus/io/readimage.hpp>

using namespace imageplus;
using namespace std;
using namespace imageplus::io;

BOOST_AUTO_TEST_SUITE ( ReadSequenceSuite );



BOOST_AUTO_TEST_CASE( ReadSequenceGeneral )
{   
    ReadSequence rseq;
    
    rseq.open(string(TEST_DATA_PATH_R) + "/readsequence/seq444.yuv");
        
    // Create an empty image
    ImageGray<uint8> g(10,10);

    // then you can read a specific frame
    rseq[0] >> g; // <- frame 0 is read
    
    BOOST_CHECK_EQUAL(g.size_x(),(uint64)12);
    BOOST_CHECK_EQUAL(g.size_y(),(uint64)8);
    BOOST_CHECK_EQUAL(rseq.frame_pointer(),(uint64)1);

    // Check reading dimensions
    BOOST_CHECK_EQUAL(rseq.dims(0),(uint64)12);
    BOOST_CHECK_EQUAL(rseq.dims(1),(uint64)8);
    std::vector<uint64> v = rseq.dims();
    BOOST_CHECK_EQUAL(v.size(),(uint64)2);
    BOOST_CHECK_EQUAL(v[0],(uint64)12);
    BOOST_CHECK_EQUAL(v[1],(uint64)8);

    // or
    rseq[7] >> g; // <- frame 7 is read
    BOOST_CHECK_EQUAL(rseq.frame_pointer(),(uint64)8);
    
    // you can also use >> to read frame by frame
    rseq >> g; // <- frame 8 is read
    BOOST_CHECK_EQUAL(rseq.frame_pointer(),(uint64)9);
    
    // So next time you use >> the next frame is read
    rseq >> g; // <- frame 9 is read, etc.
    BOOST_CHECK_EQUAL(rseq.frame_pointer(),(uint64)10);

    // Yo can set the frame pointer like
    rseq[5];
    BOOST_CHECK_EQUAL(rseq.frame_pointer(),(uint64)5);
    
    // so next time you use
    rseq >> g; // <- frame 5 is read
    BOOST_CHECK_EQUAL(rseq.frame_pointer(),(uint64)6);
    

    // To read all frames do something like
    rseq[0];  // <- reset to 0 (not needed if recently opened)
    uint64 i = 0;
    while ( !rseq.eof() ) 
    {
        rseq >> g;
        BOOST_CHECK_EQUAL(g(0),static_cast<uint8>(i));
        // The test sequence has luminance values equal to the frame number
        i++;
    }

    // To read sequencially two or more sequences since 'operator >>' returns 
    // a reference to the instanciated class.
    rseq[0];  // <- reset to 0 (not needed if recently opened)
    ImageGray<uint8> g0, g1, g2;
    rseq >> g0 >> g1 >> g2;
    BOOST_CHECK_EQUAL(rseq.frame_pointer(),(uint64)3);
        
}	

BOOST_AUTO_TEST_CASE( ReadSequenceGeneralSkip )
{   
    ReadSequence rseq;
    
    rseq.open(string(TEST_DATA_PATH_R) + "/readsequence/seq444.yuv", 1);
        
    // Create an empty image
    ImageYUV<uint8> ima444;

    // then you can read a specific frame
    rseq >> ima444; // <- frame 0 is read
    BOOST_CHECK_NO_THROW( check_size_yuv(ima444) );
    BOOST_CHECK_EQUAL(ima444(Y_CHANNEL), static_cast<uint8>(0));
    BOOST_CHECK_EQUAL(ima444(U_CHANNEL), static_cast<uint8>(0+50));
    BOOST_CHECK_EQUAL(ima444(V_CHANNEL), static_cast<uint8>(0+100));

    rseq >> ima444; // <- frame 2 is read
    BOOST_CHECK_NO_THROW( check_size_yuv(ima444) );
    BOOST_CHECK_EQUAL(ima444(Y_CHANNEL), static_cast<uint8>(2));
    BOOST_CHECK_EQUAL(ima444(U_CHANNEL), static_cast<uint8>(2+50));
    BOOST_CHECK_EQUAL(ima444(V_CHANNEL), static_cast<uint8>(2+100));

    rseq >> ima444; // <- frame 4 is read
    BOOST_CHECK_NO_THROW( check_size_yuv(ima444) );
    BOOST_CHECK_EQUAL(ima444(Y_CHANNEL), static_cast<uint8>(4));
    BOOST_CHECK_EQUAL(ima444(U_CHANNEL), static_cast<uint8>(4+50));
    BOOST_CHECK_EQUAL(ima444(V_CHANNEL), static_cast<uint8>(4+100));

}	


BOOST_AUTO_TEST_CASE( ReadSequencePrintfStart )
{
    ReadSequence rseq;
    ImageGray<uint8> g;

    // use printf style
    rseq.open(string(TEST_DATA_PATH_R) + "/readsequence/perfect_%03d.png",2,9);

    uint64 i = 3;
    while ( !rseq.eof() ) 
    {
        rseq >> g;
        BOOST_CHECK_EQUAL(rseq.frame_pointer(),(uint64)i);
        i++;
    }
    rseq[3] >> g;
    BOOST_CHECK_EQUAL(rseq.frame_pointer(),(uint64)4);

    // Check reading dimensions
    BOOST_CHECK_EQUAL(rseq.dims(0),(uint64)352);
    BOOST_CHECK_EQUAL(rseq.dims(1),(uint64)240);
    std::vector<uint64> v = rseq.dims();
    BOOST_CHECK_EQUAL(v.size(),(uint64)2);
    BOOST_CHECK_EQUAL(v[0],(uint64)352);
    BOOST_CHECK_EQUAL(v[1],(uint64)240);
}

BOOST_AUTO_TEST_CASE( ReadSequencePrintfSkip )
{
    ReadSequence rseq;
    ImageGray<uint8> g;

    // use printf style
    rseq.open(string(TEST_DATA_PATH_R) + "/readsequence/perfect_%03d.png",2,9,1);

    uint64 i = 2+2;
    while ( !rseq.eof() ) 
    {
        rseq >> g;
        BOOST_CHECK_EQUAL(rseq.frame_pointer(),(uint64)i);
        i += 2;
    }
}

BOOST_AUTO_TEST_CASE ( ReadSequence400 )
{
    // test yuv400 reading
    ReadSequence rseq;
    ImageGray<uint8> p;
    rseq.open(string(TEST_DATA_PATH_R) + "/readsequence/seq400.yuv");
    uint64 i = 0;
    while ( !rseq.eof() ) 
    {
        rseq >> p;
        BOOST_CHECK_EQUAL(p(0), static_cast<uint8>(i));
        i++;
    }
}

BOOST_AUTO_TEST_CASE ( ReadSequence420 )
{
    // test yuv420 reading
    ReadSequence rseq;
    ImageYUV420<uint8> ima420;
    rseq.open(string(TEST_DATA_PATH_R) + "/readsequence/seq420.yuv");
    uint64 i = 0;
    while ( !rseq.eof() ) 
    {
        rseq >> ima420;
        BOOST_CHECK_NO_THROW( check_size_yuv420(ima420) );
        BOOST_CHECK_EQUAL(ima420(Y_CHANNEL), static_cast<uint8>(i));
        BOOST_CHECK_EQUAL(ima420(U_CHANNEL), static_cast<uint8>(i+50));
        BOOST_CHECK_EQUAL(ima420(V_CHANNEL), static_cast<uint8>(i+100));
        i++;
    }
}

BOOST_AUTO_TEST_CASE ( ReadSequence444 )
{
    // test yuv444 reading
    ReadSequence rseq;
    ImageYUV<uint8> ima444;
    rseq.open(string(TEST_DATA_PATH_R) + "/readsequence/seq444.yuv");
    uint64 i = 0;
    while ( !rseq.eof() ) 
    {
        rseq >> ima444;
        BOOST_CHECK_NO_THROW( check_size_yuv(ima444) );
        BOOST_CHECK_EQUAL(ima444(Y_CHANNEL), static_cast<uint8>(i));
        BOOST_CHECK_EQUAL(ima444(U_CHANNEL), static_cast<uint8>(i+50));
        BOOST_CHECK_EQUAL(ima444(V_CHANNEL), static_cast<uint8>(i+100));
        i++;
    }
}

BOOST_AUTO_TEST_CASE ( ReadSequenceYUVtoRGB )
{
    // Test reading to rgb from 400 sequences
    ReadSequence rseq;
    ImageRGB<uint8> imargb;
    rseq.open(string(TEST_DATA_PATH_R) + "/readsequence/seq400.yuv");
    uint64 i = 0;
    while ( !rseq.eof() ) 
    {
        rseq >> imargb;
        BOOST_CHECK_NO_THROW( check_size_rgb(imargb) );
        BOOST_CHECK_EQUAL(imargb(RED_CHANNEL),   static_cast<uint8>(i));
        BOOST_CHECK_EQUAL(imargb(GREEN_CHANNEL), static_cast<uint8>(i));
        BOOST_CHECK_EQUAL(imargb(BLUE_CHANNEL),  static_cast<uint8>(i));
        i++;
    }
}


#ifdef USE_FFMPEG
BOOST_AUTO_TEST_CASE(ReadSequenceFfmpegReading)
{   
    ReadSequence rseqffmpeg;
    rseqffmpeg.open(string(TEST_DATA_PATH_R) + "/readsequence/perfect.mpg");

    ReadSequence rseqpng;
    rseqpng.open(string(TEST_DATA_PATH_R) + "/readsequence/perfect_%03d.png",1,9);

    // Check reading dimensions
    BOOST_CHECK_EQUAL(rseqffmpeg.dims(0),(uint64)352);
    BOOST_CHECK_EQUAL(rseqffmpeg.dims(1),(uint64)240);
    std::vector<uint64> v = rseqffmpeg.dims();
    BOOST_CHECK_EQUAL(v.size(),(uint64)2);
    BOOST_CHECK_EQUAL(v[0],(uint64)352);
    BOOST_CHECK_EQUAL(v[1],(uint64)240);

    ImageRGB<uint8> imaffmpeg;
    ImageRGB<uint8> imapng;
    for (uint64 f = 1; f < 10; f++)
    {
        rseqffmpeg >> imaffmpeg;
        rseqpng >> imapng;

        // check rgb types
        BOOST_CHECK_NO_THROW( check_size_rgb(imaffmpeg) );
        BOOST_CHECK_NO_THROW( check_size_rgb(imapng) );

        // check sizes
        BOOST_CHECK( imaffmpeg.size_x() == imapng.size_x() );
        BOOST_CHECK( imaffmpeg.size_y() == imapng.size_y() );

        // check pixels
        int64 FFMPEG_TOLERANCE = 2;
        for(uint32 c=0; c<2; c++ )
        {
            for(uint32 y=0; y < imaffmpeg.size_y(); y++ )
            {
                for(uint32 x=0; x < imaffmpeg.size_x(); x++ )
                {
                    int64 d = (int64)imaffmpeg(c)[x][y] - (int64)imapng(c)[x][y];
                    BOOST_CHECK( d < FFMPEG_TOLERANCE);
                    BOOST_CHECK( d > -FFMPEG_TOLERANCE);
                }
            }
        }

    }
}
#endif

BOOST_AUTO_TEST_SUITE_END ();
