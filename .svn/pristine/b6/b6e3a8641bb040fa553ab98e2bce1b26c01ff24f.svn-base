// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------
//!
//!  \file circle_geometry.cpp
//!
//!  Implementation of circle geometry functions and methods
//!

#include <imageplus/math/geometry/circle_geometry.hpp>
#include <imageplus/math/geometry/point_geometry.hpp>
#include <imageplus/math/geometry/bbox_math.hpp>

#include <vector>

using namespace imageplus;

size_type imageplus::math::geometry::points_on_circle(const Point2D& center, const float64 radius,
						const BBox2D& bbox, MultiArray<Coord2D<> , 1>& point) throw (ImagePlusError) {

    ASSERT(radius >= 0.71, "Circle radius must be at least 0.71 so that one point is returned")
	
    size_type num_points = 0;
    
    // Calculate the nearest point
    Coord2D<>  nearest_point;
    nearest_point.x() = (int64)(center.x() + ((center.x() >= 0)?0.5:-0.5) );
    nearest_point.y() = (int64)(center.y() + ((center.y() >= 0)?0.5:-0.5) );

    // Compute pow radius
    float64 pow2_radius = radius*radius;

    // If circle is completely outside the box:
    if ( !on_circle(nearest_point, center, pow2_radius) ) {

	// The nearest pixel is returned
	point[0] = nearest_point;
	return 1;
    }

    // For the next line the circle is partial or completely inside the box:

    // Calculate the circle bounding box:
    BBox2D circle_bbox = imageplus::math::geometry::circle_bbox(center, radius);
    limit_bbox_to_bbox(bbox, circle_bbox);

    // Update bounding box with circle boudaries:
    // Get the first points that is interior to circle
    Coord2D<>  orig = circle_bbox.origin();
    Coord2D<>  opp = circle_bbox.opposite();
    
    while ( !on_circle(nearest_point.x(), orig.y(), center, pow2_radius)) orig.y()++;
    while ( !on_circle(nearest_point.x(), opp.y(), center, pow2_radius)) opp.y()--;
    while ( !on_circle(orig.x(), nearest_point.y(), center, pow2_radius)) orig.x()++;
    while ( !on_circle(opp.x(), nearest_point.y(), center, pow2_radius)) opp.x()--;

    // Calculate the number of maximum points possible, and create MultiArray
    // that can fit them all.
    size_type max_n_points = (opp.x() - orig.x() + 1) * (opp.y() - orig.y() + 1);
    std::vector<imageplus::size_type> dim(1); dim[0] = max_n_points;
    point.resize(dim);

    // Setup segment
    int64 x_begin = nearest_point.x(), x_end = x_begin, y = orig.y();
    
    // Expand x_end - x_begin
    while (y <= nearest_point.y()) {
	while (on_circle(x_begin - 1, y, center, pow2_radius) && x_begin-1 >= orig.x()) x_begin--;
	while (on_circle(x_end + 1, y, center, pow2_radius) && x_end+1 <= opp.y()) x_end++;

	num_points = horizontal_segment_points(x_begin, x_end, y, point, num_points);
	y++;
    }

    // Shrink x_end - x_begin
    while (y <= opp.y()) {
	while ( !on_circle(x_begin, y, center, pow2_radius)) x_begin++;
	while ( !on_circle(x_end, y, center, pow2_radius)) x_end--;

	num_points = horizontal_segment_points(x_begin, x_end, y, point, num_points);
	y++;
    }

    return num_points;
}
