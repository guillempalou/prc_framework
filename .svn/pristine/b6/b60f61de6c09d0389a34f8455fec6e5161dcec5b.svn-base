// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------

//!
//! \file merging_orders.test
//!
//! Tests for BPT merging order analysis functions
//!
#include <imageplus/core/imagegray.hpp>
#include <imageplus/core/partition.hpp>
#include <imageplus/core/partition_functions.hpp>

#include <imageplus/bpt/creation.hpp>
#include <imageplus/bpt/analysis/merging_orders.hpp>

BOOST_AUTO_TEST_SUITE ( MergingOrderSuite );

using namespace imageplus;
using namespace bpt;
using namespace std;

BOOST_AUTO_TEST_CASE( calculate_merging_orders_amc_test )
{
    typedef RegionContour<Coord2D<int64> > region_type;

    ImageGray<uint8> image(2,2);
    image(GRAY_CHANNEL)[0][0] = 0;       image(GRAY_CHANNEL)[1][0] = 2;
    image(GRAY_CHANNEL)[0][1] = 10;      image(GRAY_CHANNEL)[1][1] = 100;

    ImagePartition<> part(2,2);
    part(PARTITION_CHANNEL)[0][0] = 1;  part(PARTITION_CHANNEL)[1][0] = 2;
    part(PARTITION_CHANNEL)[0][1] = 3;  part(PARTITION_CHANNEL)[1][1] = 4;

    Partition<region_type> bpt(part);

    merge_regions(1,2,20, bpt);
    merge_regions(3,4,21, bpt);
    merge_regions(20,21,22, bpt);

    BPTModels<ImageGray<uint8>, region_type>
      merging_model_se(new ColorHomogeneity<ImageGray<uint8>, region_type, SE>());


    // ***** TEST calculate_merging_orders with different bpt_models *****
    // ***** SE *****
    std::vector<float64> merging_orders_se(3);
    calculate_merging_orders(bpt, image, merging_model_se, merging_orders_se);

    BOOST_CHECK(merging_orders_se[0] == 2   );  // (0-1)^2 + (2-1)^2
    BOOST_CHECK(merging_orders_se[1] == 4050);  // (10-55)^2 + (100-55)^2
    BOOST_CHECK(merging_orders_se[2] == 6968);  // (0-28)^2 + (2-28)^2 + (10-28)^2 + (100-28)^2

    BPTModels<ImageGray<uint8>, region_type>
      merging_model_mse(new ColorHomogeneity<ImageGray<uint8>, region_type, MSE>());


    // ***** MSE *****
    std::vector<float64> merging_orders_mse(3);
    calculate_merging_orders(bpt, image, merging_model_mse, merging_orders_mse);

    BOOST_CHECK(merging_orders_mse[0] == 2./2   );  // SE/(N1+N2)
    BOOST_CHECK(merging_orders_mse[1] == 4050./2);
    BOOST_CHECK(merging_orders_mse[2] == 6968./4);


    // ***** TEST calculate_amc with different bpt_models *****
    // ***** SE *****
    std::vector<float64> amc_se(3);
    calculate_amc(bpt, image, merging_model_se, amc_se);

    BOOST_CHECK(amc_se[0] == 2              );
    BOOST_CHECK(amc_se[1] == 2 + 4050       );
    BOOST_CHECK(amc_se[2] == 2 + 4050 + 6968);

    calculate_amc(merging_orders_se, amc_se);

    BOOST_CHECK(amc_se[0] == 2              );
    BOOST_CHECK(amc_se[1] == 2 + 4050       );
    BOOST_CHECK(amc_se[2] == 2 + 4050 + 6968);


    // ***** MSE *****
    std::vector<float64> amc_mse(3);
    calculate_amc(bpt, image, merging_model_mse, amc_mse);

    BOOST_CHECK(amc_mse[0] == 2./2                    );
    BOOST_CHECK(amc_mse[1] == 2./2 + 4050./2          );
    BOOST_CHECK(amc_mse[2] == 2./2 + 4050./2 + 6968./4);

    calculate_amc(merging_orders_mse, amc_mse);

    BOOST_CHECK(amc_mse[0] == 2./2                    );
    BOOST_CHECK(amc_mse[1] == 2./2 + 4050./2          );
    BOOST_CHECK(amc_mse[2] == 2./2 + 4050./2 + 6968./4);
}


BOOST_AUTO_TEST_CASE( calculate_importance_weight_test )
{
    typedef RegionContour<Coord2D<int64> > region_type;

    ImageGray<uint8> image(2,3);
    image(GRAY_CHANNEL)[0][0] =   0;    image(GRAY_CHANNEL)[1][0] =   0;
    image(GRAY_CHANNEL)[0][1] =   2;    image(GRAY_CHANNEL)[1][1] =   4;
    image(GRAY_CHANNEL)[0][2] = 190;    image(GRAY_CHANNEL)[1][2] = 255;

    ImagePartition<> part(2,3);
    part(PARTITION_CHANNEL)[0][0] = 1;  part(PARTITION_CHANNEL)[1][0] = 2;
    part(PARTITION_CHANNEL)[0][1] = 3;  part(PARTITION_CHANNEL)[1][1] = 4;
    part(PARTITION_CHANNEL)[0][2] = 5;  part(PARTITION_CHANNEL)[1][2] = 6;

    Partition<region_type> bpt(part);

    merge_regions( 1, 2,20, bpt);
    merge_regions( 3, 4,21, bpt);
    merge_regions(20,21,22, bpt);
    merge_regions( 5, 6,23, bpt);
    merge_regions(22,23,24, bpt);

    BPTModels<ImageGray<uint8>, region_type>
      merging_model_iid(new ColorStatisticalIID<ImageGray<uint8>, region_type>());

    std::vector<float64> importance_weight(5);
    calculate_importance_weight(bpt, image, merging_model_iid, importance_weight);

    BOOST_CHECK_EQUAL(importance_weight[0], 0.);
    BOOST_CHECK_EQUAL(importance_weight[1], 0.);
    BOOST_CHECK_EQUAL(importance_weight[2], 0.);
    BOOST_CHECK_EQUAL(importance_weight[3], 0.);
    BOOST_CHECK_CLOSE(importance_weight[4], 0.75488757494143988, 1e-10);
}


BOOST_AUTO_TEST_CASE( calculate_psnr_test )
{
    typedef RegionContour<Coord2D<int64> > region_type;

    ImageGray<uint8> image(2,2);
    image(GRAY_CHANNEL)[0][0] = 0;       image(GRAY_CHANNEL)[1][0] = 2;
    image(GRAY_CHANNEL)[0][1] = 10;      image(GRAY_CHANNEL)[1][1] = 100;

    ImagePartition<> part(2,2);
    part(PARTITION_CHANNEL)[0][0] = 1;  part(PARTITION_CHANNEL)[1][0] = 2;
    part(PARTITION_CHANNEL)[0][1] = 3;  part(PARTITION_CHANNEL)[1][1] = 4;

    Partition<region_type> bpt(part);

    merge_regions(1,2,20, bpt);
    merge_regions(3,4,21, bpt);
    merge_regions(20,21,22, bpt);

    std::vector<float64> psnr_evolution(4);
    calculate_psnr_evolution(bpt, image, psnr_evolution);

    BOOST_CHECK_EQUAL(std::numeric_limits<float64>::infinity(), psnr_evolution[0]);
    BOOST_CHECK_CLOSE(psnr_evolution[1], 49.891716199235915, 1e-10);
    BOOST_CHECK_CLOSE(psnr_evolution[2], 16.8253217889933, 1e-10);
    BOOST_CHECK_CLOSE(psnr_evolution[3], 14.470934735879659, 1e-10);
}

BOOST_AUTO_TEST_SUITE_END ();

