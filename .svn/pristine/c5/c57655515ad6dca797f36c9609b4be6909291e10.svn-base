// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------

#define IMAGEPLUS_TOOL_CONFIG_NAME  texture_video_coding
#define IMAGEPLUS_TOOL_CONFIG_GROUP coding
#include <imageplus/toolbox/tool_config.hpp>

/*
 * STL headers
 */
#include <iostream>
#include <fstream>

/*
 * Boost headers
 */
#include <boost/format.hpp>

/*
 * ImagePlus headers
 */
#include <imageplus/core.hpp>
#include <imageplus/io.hpp>
#include <imageplus/coding.hpp>
#include <imageplus/coding/texture/texture_codec.hpp>
#include <imageplus/coding/texture/ortho_basis_codec.hpp>

#include <imageplus/math/statistics/multiarray_statistics.hpp> // min/max val
#include <imageplus/math/numeric/error_measures.hpp>           //mse


/*
 * Namespaces
 */
using namespace std;
using namespace imageplus;
using namespace imageplus::coding;
using namespace imageplus::coding::texture;
using namespace imageplus::compress;

namespace mn = imageplus::math::numeric;


IMAGEPLUS_TOOL_CONFIG_BRIEF()
    
    "Encodes texture from a video.\n";

IMAGEPLUS_TOOL_CONFIG_DESCRIPTION()

    "Encodes texture of a video.                \n" +
    "It uses a previously computed segmentation \n";

IMAGEPLUS_TOOL_CONFIG_PARAMETERS()

    // Options
    std::vector<uint64> cams_number;

    string input_texture;
    string input_segmentation_files;
    uint64 first_frame;
    uint64 last_frame;
    uint64 skip_frames;
    string output_bitstream;
    string output_texture;

    int64 texture_codec_type;
    int64 orthobasis_order;
    int64 regiondct_num_coeffs;
    int32 qmap;

    int64 ac_model;

    uint64 gop_size;

    float64 fps;

    // Flags:
    // bool flag;

    // Arguments
    
IMAGEPLUS_TOOL_CONFIG_DEFAULT_VALUES()

    for (uint64 i = 0; i < 8; i++)
    {
      cams_number.push_back(i);
    }

    input_texture  = "-";
    input_segmentation_files  = "-";
    
    first_frame = 15;
    last_frame  = 100;
    skip_frames = 15; // <- one every frames
	
    gop_size = 12;

    output_bitstream = "-";
    output_texture = "-";

    texture_codec_type = ORTHOBASIS_CODEC; 
    orthobasis_order = 2;
    regiondct_num_coeffs = 5;
    qmap = 1;

    ac_model = 1;

    fps = 15.0;

IMAGEPLUS_TOOL_CONFIG_OPTIONS()

    //
    // Here you have to define your OPTIONS, with a description 
    // and an optional abreviature
    //

    IMAGEPLUS_TOOL_CONFIG_OPTION_ABV ( cams_number, "Camera numbers, this should be a vector with the camera number for all cameras", 'r');

    IMAGEPLUS_TOOL_CONFIG_OPTION     ( input_texture,       "The original texture sequence, right now only gray images (Y in yuv) and printf style from cam number" );
    IMAGEPLUS_TOOL_CONFIG_OPTION     ( input_segmentation_files,  "The files segmentation of the sequence above (printf style for cam number and frame number)" );

    IMAGEPLUS_TOOL_CONFIG_OPTION_ABV ( first_frame, "First frame of the sequence", 'f' );
    IMAGEPLUS_TOOL_CONFIG_OPTION_ABV ( last_frame , "Last frame of the sequence", 'l' );
    IMAGEPLUS_TOOL_CONFIG_OPTION_ABV ( skip_frames, "Skip frames (0 none)", 's' );

    IMAGEPLUS_TOOL_CONFIG_OPTION     ( gop_size,  "Size of the gop. Arithmetic Encoding, for instance, will be reset each gop_size frames. Note that the actual number of frames in the GoP will be this gop_size * number_of_views.");

    IMAGEPLUS_TOOL_CONFIG_OPTION     ( output_bitstream,  "Name of the output bitstream for each frame (printf style for cam number and frame number. Both must be present and in that order)." );
    IMAGEPLUS_TOOL_CONFIG_OPTION     ( output_texture,    "Name of the output decoded texture in yuv 400 format (printf style for cam number). Use \"-\" for no output." );
    
    IMAGEPLUS_TOOL_CONFIG_OPTION     ( texture_codec_type,  "0: orthobasis, 1: single-dct, 2: block-dct" );
    IMAGEPLUS_TOOL_CONFIG_OPTION     ( orthobasis_order,  "Order of the orthobasis method" );
    IMAGEPLUS_TOOL_CONFIG_OPTION     ( regiondct_num_coeffs,  "Number of DCT coefficients kept for each region" );
    IMAGEPLUS_TOOL_CONFIG_OPTION     ( qmap,    "Quantification parameter for *ALL* regions" );

    IMAGEPLUS_TOOL_CONFIG_OPTION     ( ac_model,    "Use arithmetic coding (0: no, 1: yes single model, 2: yes one model per coefficient" );

    IMAGEPLUS_TOOL_CONFIG_OPTION     ( fps, "Frames per second of the input sequence (only used for reporting data)" );

IMAGEPLUS_TOOL_CONFIG_FLAGS()

    //
    // Here you have to define your FLAGS, with a description 
    // and an optional abreviature
    //

IMAGEPLUS_TOOL_CONFIG_ARGUMENTS()

    //
    // Here you have to define your ARGUMENTS with a description. 
    // You should put them in the DESIRED ORDER in the command-line
    //
    // Note that an argument that is a vector should be the last and no more
    // argument can be added later. Think: is impossible to parser arguments 
    // afters an unknown size vector!
    // If you need more than one vector, use "options" instead of arguments.
    //
         
IMAGEPLUS_TOOL_CONFIG_READ_PARAMETERS()

    //
    // Here you have to read all your parameters
    //
    // DO NOT FORGET THIS STEP!!
    //
        
    IMAGEPLUS_TOOL_CONFIG_READ( cams_number );

    IMAGEPLUS_TOOL_CONFIG_READ( input_texture );
    IMAGEPLUS_TOOL_CONFIG_READ( input_segmentation_files );
    
    IMAGEPLUS_TOOL_CONFIG_READ( first_frame );
    IMAGEPLUS_TOOL_CONFIG_READ( last_frame );
    IMAGEPLUS_TOOL_CONFIG_READ( skip_frames );

    IMAGEPLUS_TOOL_CONFIG_READ( gop_size );

    IMAGEPLUS_TOOL_CONFIG_READ( output_bitstream );
    IMAGEPLUS_TOOL_CONFIG_READ( output_texture );

    IMAGEPLUS_TOOL_CONFIG_READ( texture_codec_type );
    IMAGEPLUS_TOOL_CONFIG_READ( orthobasis_order );
    IMAGEPLUS_TOOL_CONFIG_READ( regiondct_num_coeffs );
    IMAGEPLUS_TOOL_CONFIG_READ( qmap );

    IMAGEPLUS_TOOL_CONFIG_READ( ac_model );

    IMAGEPLUS_TOOL_CONFIG_READ( fps );

//
// This is the "main" function of your tool.
//
// You can access to all your parameters (options, flags, and arguments)
// with the "cfg" object (see the code.)
//
// Run the example with "--help" to see your configuration.
//
IMAGEPLUS_TOOL_CONFIG_MAIN()
{	
    std::cout << "Input parameters: " << std::endl;
    std::cout << "  cams_number = [";
    for (uint64 i = 0; i < cfg.cams_number.size(); i++)
    {
        std::cout << cfg.cams_number[i];
        if ( i < cfg.cams_number.size() - 1) 
        {
            std::cout << ",";
        }
    }
    std::cout << "]" << std::endl;
    std::cout << "  input_texture  = " << cfg.input_texture << std::endl;
    std::cout << "  input_segmentation_files = " << cfg.input_segmentation_files << std::endl;
    std::cout << "  first_frame  = " << cfg.first_frame << std::endl;
    std::cout << "  last_frame   = " << cfg.last_frame << std::endl;
    std::cout << "  skip_frames  = " << cfg.skip_frames << std::endl;
    std::cout << "  gop_size     = " << cfg.gop_size << std::endl;
    std::cout << "  output_bitstream = " << cfg.output_bitstream << std::endl;
    std::cout << "  output_texture = " << cfg.output_texture << std::endl;
    std::cout << "  texture_codec_type = " << cfg.texture_codec_type << std::endl;
    std::cout << "  orthobasis_order = " << cfg.orthobasis_order << std::endl;
    std::cout << "  regiondct_num_coeffs = " << cfg.regiondct_num_coeffs << std::endl;
    std::cout << "  qmap = " << cfg.qmap << std::endl;
    std::cout << "  arithmetic coding model = " << cfg.ac_model << std::endl;
    std::cout << "  fps = " << cfg.fps << std::endl;
    std::cout << std::endl;

    // Model for all coefficients
    uint64 ac_num_models = 1;
    if (cfg.ac_model==2)
    {
        switch (cfg.texture_codec_type)
        {
            case ORTHOBASIS_CODEC:
                ac_num_models = (cfg.orthobasis_order+1)*(cfg.orthobasis_order+1);
                break;
            case REGIONDCT_CODEC: 
                ac_num_models = cfg.regiondct_num_coeffs;
                break;
            default:
                throw ImagePlusError("texture codec not supported");
                break;
        }
    }
    
    std::vector<Adaptive_Data_Model> amodels(ac_num_models);
    for (uint64 i=0; i < ac_num_models; i++)
    {
        amodels[i].set_alphabet(256);
    }
    
    uint64 gop_size = cfg.gop_size * cfg.cams_number.size();

    if ( (cfg.qmap < 1) || (cfg.qmap > 10) )
    {
        throw ImagePlusError ("qmap must be between 1-10");
    }

    float64 total_bits   = 0.0;
    float64 total_mse    = 0.0;
    uint64  total_frames = 0;
    
    io::ReadImage readimg_seg;
    io::WriteImage writeImage;

    std::vector<io::ReadSequence>     readseq_texture(cfg.cams_number.size());
    std::vector<io::WriteSequenceYUV> wseq_texture(cfg.cams_number.size());

    for (uint64 i = 0; i < cfg.cams_number.size(); i++)
    {
        // Texture is a YUV sequence or a list of files
        if ( boost::filesystem::extension(cfg.input_texture) == ".yuv" )
        {
            readseq_texture[i].open(boost::str( boost::format(cfg.input_texture) % cfg.cams_number[i] ));
        }

        // Segmentation is a list of mult images (not used, read from image)
        //readseq_seg[i].open( boost::str( boost::format(cfg.input_segmentation_folder) % i ) + cfg.input_segmentation_files, 
        //                     cfg.first_frame, cfg.last_frame, cfg.skip_frames);

        // Out Texture in case a YUV sequence is used
        if ( cfg.output_texture != "-" )
        {
            if ( boost::filesystem::extension(cfg.output_texture) == ".yuv" )
            {
                wseq_texture[i].open(boost::str( boost::format(cfg.output_texture) % cfg.cams_number[i] ), 
                                     readseq_texture[i].dims(0), 
                                     readseq_texture[i].dims(1), 
                                     (cfg.last_frame - cfg.first_frame + 1) / (cfg.skip_frames + 1),
                                     cfg.fps,
                                     io::YUV400P,
                                     "");
            }
        }

    }
        
    std::cout << std::setiosflags ( std::ios_base::right);
    std::cout << "Cam# Frame#  Nregions   Bits   PSNR" << std::endl; 

    OrthoBasisCodec obc(cfg.orthobasis_order, cfg.ac_model, gop_size, cfg.qmap);

    for (uint64 frame_number=cfg.first_frame ; frame_number <= cfg.last_frame ; frame_number += cfg.skip_frames+1)
    {

        for (uint64 i_cam = 0; i_cam < cfg.cams_number.size(); i_cam++)
        {
            
            std::cout << std::setw(2) << i_cam << "  ";

            ImageGray<uint8> in_texture;
            ImageGray<uint8> out_texture;
            ImagePartition<uint32> label;
            
            // Read input texture image
            if ( boost::filesystem::extension(cfg.input_texture) == ".yuv" ) 
            {
                readseq_texture[i_cam][frame_number] >> in_texture;
            } else {
                io::ReadImage ri;
                ri.open(boost::str( boost::format(cfg.input_texture) % cfg.cams_number[i_cam] % frame_number ));
                ri >> in_texture;
            }

            // Read partition (always in a list of files)
            readimg_seg.open( boost::str( boost::format(cfg.input_segmentation_files) %  cfg.cams_number[i_cam] % frame_number ));
            readimg_seg >> label;

            // Check that partition starts at 1
            if ( math::statistics::minval (label(PARTITION_CHANNEL)) == 0 )
                throw ImagePlusError("Partition must start at label >=1");

            // Open output bitstream 
            io::WriteBitStream writeBS_texture_coding;
            writeBS_texture_coding.open(boost::str(boost::format(cfg.output_bitstream) % cfg.cams_number[i_cam] % frame_number));             
            const uint32 maxlabel = math::statistics::maxval (label(PARTITION_CHANNEL));
            
            MultiArray<uint8,1> qmap(maxlabel+1);
            QTextureCoeffs<1> coeffs;

            uint64 num_bits = 0;

            // Use quantizer step 1 on all regions
            qmap = (uint8)cfg.qmap;
            
            switch (cfg.texture_codec_type)
            {
                case ORTHOBASIS_CODEC:
                {
                    out_texture = obc.encode(in_texture, label, qmap, coeffs);
                    num_bits = obc.compress(label,
                                            coeffs,
                                            writeBS_texture_coding);
                    break;
                }
                case REGIONDCT_CODEC: 
                {
                    throw ImagePlusError("Not implemented");
                    break;
                }
                default:
                {
                    throw ImagePlusError("texture codec not supported");
                    break;
                }
            }
            
            std::cout << std::setw(5) << frame_number << "  " << "  " << std::setw(3) << maxlabel << " ";
            
            std::cout << std::setw(10) << num_bits << "   ";
                
            total_bits += (float64)num_bits;
                
            //Compute the MSE frame per frame
            float64 mse = mn::mse(in_texture(0),out_texture(0));
            total_mse += mse;
            std::cout << 10.0 * std::log10(255.0*255.0/mse);
            
            // Finish the bitstream
            writeBS_texture_coding.force_write();
            writeBS_texture_coding.close();	
            
            // Save the texture
            if ( cfg.output_texture != "-" )
            {
                if ( boost::filesystem::extension(cfg.output_texture) == ".yuv" )
                {
                    wseq_texture[i_cam] << out_texture;
                } else {
                    writeImage.open(boost::str( boost::format(cfg.output_texture) % cfg.cams_number[i_cam] % frame_number));
                    writeImage << out_texture;
                }
            }
            
            total_frames++;

            std::cout << std::endl;
        }

    }

    std::cout << std::endl;
    std::cout << "Total bits = "                    <<  (uint64)total_bits << std::endl;
    std::cout << "Average bitrate (single view) = " <<  std::fixed << total_bits / (float64)total_frames * cfg.fps / 1000.0
                                                    << " kbps" << std::endl;
    std::cout << "Average bitrate (all views) = "   <<  std::fixed << total_bits / (float64)total_frames * cfg.fps / 1000.0 * (float64)cfg.cams_number.size()
                                                    << " kbps" << std::endl;
    std::cout << "Average PSNR = "                  << 10.0 * std::log10(255.0*255.0/(total_mse/(float64)total_frames))
                                                    << " dB" << std::endl;
}

IMAGEPLUS_TOOL_CONFIG_END()
