/*
 * graph.hpp
 *
 *  Created on: Oct 20, 2011
 *      Author: guillem
 */

#ifndef GRAPH_HPP_
#define GRAPH_HPP_

#include <boost/graph/adjacency_list.hpp>
#include <imageplus/math/graphs/graph_properties.hpp>

namespace imageplus {
	namespace math {
		namespace graphs {


		//! \brief Wrapper class for boost graph
		// Do not change the default properties unless you know what you are doing
		template<class DirectedS = DefaultGraphType, class NodeProperties = NodeDefaultProperties, class EdgeProperties = EdgeDefaultProperties> // should be boost::directedS, boost::undirectedS, or boost::bidirectionalS (default)
		class BoostGraph {

		public:

		//! an adjacency_list boost graph. basic structure
		typedef typename 	boost::adjacency_list<
							boost::listS, // edge container allow parallel edges
							boost::vecS, // vertex container
							DirectedS,
							NodeProperties,
							EdgeProperties
							> GraphContainer;

		//! Node Properties
		typedef NodeProperties	NodePropertiesType;

		//!Edge properties
		typedef EdgeProperties  EdgePropertiesType;

		// There are only the most typical ones

		//! Node type
		typedef typename boost::graph_traits<GraphContainer>::vertex_descriptor 				Node;

		//! Edge type
		typedef typename boost::graph_traits<GraphContainer>::edge_descriptor 					Edge;

		//! Auxiliary types
		typedef typename std::pair<Node, Node> 													NodePair;

		//! Auxiliary types
		typedef typename std::pair<Edge, Edge> 													EdgePair;

		// Iterators

		//! boost iterator for all nodes of the graph
		typedef typename boost::graph_traits<GraphContainer>::vertex_iterator 		boost_node_iterator;

		//! boost iterator for adjacency nodes
		typedef typename boost::graph_traits<GraphContainer>::adjacency_iterator 	boost_adjacency_iterator;

		//! boost iterator for out edges of a node
		typedef typename boost::graph_traits<GraphContainer>::out_edge_iterator 	boost_out_edge_iterator;

		//! boost iterator for in edges of a node
		typedef typename boost::graph_traits<GraphContainer>::in_edge_iterator 	boost_in_edge_iterator;

		// Properties

		// constructors etc.
		//! default constructor
		BoostGraph() {

		}

		/*!
		 * Constructor taking the number of nodes
		 *
		 * \param[in] N : number of graph nodes;
		 */
		BoostGraph(uint32 N) : _graph(N) {

		}

		/*!
		 * Copy constructor
		 * \param[in] : another BoostGraph
		 *
		 */
		BoostGraph(const BoostGraph& g) : _graph(g._graph) {

		}

		//! Default Constructor
		virtual ~BoostGraph() {

		}

		// Node Information methods

		//! \brief Number of nodes
		//! \return The number of the nodes in the graph
		uint64 num_nodes() {
			return boost::num_vertices(_graph);
		}

		// Edge Information methods

		//! \brief Number of edges
		//! \return The number of the edges in the graph
		uint64 num_edges() {
			return boost::num_edges(_graph);
		}

		//! \brief Number of edges going out of a node
		//! \return The number of the edges goind of a node
		uint64 num_out_edges(Node n) {
			return boost::out_degree(n, _graph);
		}

		//! \brief Number of edges entering a node
		//! \return The number gof edges going inside a node
		uint64 num_in_edges(Node n) {
			return boost::in_degree(n, _graph);
		}

		//! \brief Source of an edge (A->B)
		//! \return The source of an edge (in this case A)
		Node source(Edge e) {
			return boost::source(e, _graph);
		}

		//! \brief Target of an edge (A->B)
		//! \return The target of an edge (in this case B)
		Node target(Edge e) {
			return boost::target(e, _graph);
		}

		//! \brief Check if an edge between Node A and Node B exists
		//! \return true if it exists
		bool edge_exists(Node a, Node b) {
			return boost::edge(a,b,_graph).second;
		}

		//! \brief Edge from node A to B
		//! \return Edge between A and B
		Edge edge(Node a, Node b) {
			return boost::edge(a,b,_graph).first;
		}

		/*
		 * structure modification methods
		 */

		//! \brief Erases all nodes and edges
		void clear() {
			_graph.clear();
		}

		//! \brief Adds a node to the graph
		//! \returns Reference to the node
		Node add_node() {
			return boost::add_vertex(_graph);
		}

		//! \brief Removes a node A from the graph
		void remove_node(Node a) {
			boost::clear_vertex(a,_graph);
			boost::remove_vertex(a,_graph);
		}

		//! Adds an edge to the graph
		//! \param[in] e : reference to an edge. use with caution
		Edge add_edge(Edge e) { // Be careful with this function. The edge to be added is an edge of the same graph (deleted a priori, for example)
			return boost::add_edge(boost::source(e,_graph), boost::target(e,_graph), edge_properties(e), _graph).first;
		}

		//! Adds an edge to the graph
		//! \param[in] a : source node
		//! \param[in] b : target node
		//! \param[in] p : Properties of the edge
		Edge add_edge(Node a, Node b, EdgePropertiesType p) {
			return boost::add_edge(a, b, p, _graph).first;
		}

		//! Adds an edge to the graph
		//! \param[in] a : source node
		//! \param[in] b : target node
		Edge add_edge(Node a, Node b) {
			return boost::add_edge(a, b, EdgePropertiesType(), _graph).first;
		}

		//! Adds an edge to the graph
		//! \param[in] e : reference to an edge. use with caution
		void remove_edge(Edge e) {
			boost::remove_edge(e,_graph);
		}

		//! Removes an edge of the graph
		//! \param[in] a : source node
		//! \param[in] b : target node
		void remove_edge(Node a, Node b) {
			boost::remove_edge(a,b,_graph);
		}

		//! Removes an edge with given properties
		//! \param[in] a : source node
		//! \param[in] b : target node
		//! \param[in] p : properties
		void remove_edge(Node a, Node b, EdgePropertiesType& p) {
			for (out_edge_iterator e = out_edges_begin(a); e != out_edges_end(a); ++e) {
				if (edge_properties(*e) == p && target(*e) == b) {
					remove_edge(*e);
					break;
				}
			}
		}

		//! Removes an edge and its reverse of the graph
		//! \param[in] a : source node
		//! \param[in] b : target node
		void remove_undirected_edge(Node a, Node b) {
			boost::remove_edge(a,b,_graph);
			boost::remove_edge(b,a,_graph);
		}

		//! Getter method for the boost graph structure (used for the algorithms)
		//! \return adjacency list
		GraphContainer& graph() {
			return _graph;
		}

		//! Getter method for the boost graph structure (used for the algorithms)
		//! \return adjacency list
		const GraphContainer& graph() const {
			return _graph;
		}

		/*
		 * Properties modifiers
		 */

		//! Properties of a node
		//! \return NodeProperties structure for the node n
		NodeProperties& node_properties(Node n) {
			return _graph[n];
		}

		//! Properties of an edge
		//! \return EdgeProperties structure for the edge e
		EdgeProperties& edge_properties(Edge e) {
			return _graph[e];
		}

		/*!
		 * Wrapper to the boost iterators
		 * Making them look more like the STL iterators
		 */

		/*!
		 * \cond SKIP_DOC
		 *
		 * Private common implementation. It works as an ordeinary STL iterator.  The only thing you should use is the de-reference operator
		 */
		template<class boost_iterator_type>
		class node_iterator_base : public std::iterator<std::forward_iterator_tag, Node> {

		//! auxiliary typedef
		typedef typename std::pair<boost_iterator_type,boost_iterator_type>			node_iterator_pair;
		public:

			//!
			node_iterator_base(node_iterator_pair p) : it(p) {
			}

			node_iterator_base(boost_iterator_type a, boost_iterator_type b) : it(a,b) {
			}

			node_iterator_base& operator++() {
				++it.first;
				return *this;
			}

			bool operator==(node_iterator_base& v) {
				return *it.first == *v.it.first;
			}

			bool operator!=(const node_iterator_base& v) const {
				return *it.first != *v.it.first;
			}

			//! Dereference node iterator
			//! \return
			Node operator*() {
				return (*it.first);
			}

		private:

			node_iterator_pair it;
		};
		/*!
		 * \endcond SKIP_DOC
		 */

		/*Types of node iterators*/

		//! Iterator of all the nodes in the graph
		typedef node_iterator_base<boost_node_iterator> 		node_iterator;

		//! Iterator of adjacent nodes of a given node
		typedef node_iterator_base<boost_adjacency_iterator> 	adjacent_node_iterator;

		//! Beginning of the nodes in the graph
		//! \return node iterator pointing to the first node in the graph
		node_iterator nodes_begin() {
			return node_iterator(boost::vertices(_graph));
		}

		//! ending of the nodes in the graph
		//! \return node iterator pointing to the end of the graph
		node_iterator nodes_end() {
			return node_iterator(boost::vertices(_graph).second, boost::vertices(_graph).second);
		}

		//! Beginning of adjacent nodes of a given node in the graph
		//! \param[in] n : node to search its adjacent nodes for
		//! \return node iterator pointing to the first node in the graph
		adjacent_node_iterator adjacent_nodes_begin(Node n) {
			return adjacent_node_iterator(boost::adjacent_vertices(n,_graph));
		}

		//! Beginning of adjacent nodes of a given node in the graph
		//! \param[in] n : node to search its adjacent nodes for
		//! \return node iterator pointing to the first node in the graph
		adjacent_node_iterator adjacent_nodes_end(Node n) {
			return adjacent_node_iterator(boost::adjacent_vertices(n,_graph).second, boost::adjacent_vertices(n,_graph).second);
		}

		/*!
		 * Wrapper to the Edge iterator class
		 */

		/*!
		 * \cond SKIP_DOC
		 *
		 * Private common implementation. It works as an ordeinary STL iterator. The only thing you should use is the de-reference operator
		 */
		template<class boost_iterator_type>
		class edge_iterator_base : public std::iterator<std::forward_iterator_tag, Edge> {

			typedef typename std::pair<boost_iterator_type,boost_iterator_type>					edge_iterator_pair;

			/*typedef typename boost::graph_traits<GraphContainer>::out_edge_iterator 			boost_out_edge_iterator;
			typedef typename std::pair<boost_out_edge_iterator,boost_out_edge_iterator>			out_edge_iterator_pair;*/

		public:
			edge_iterator_base(edge_iterator_pair e) : it(e) {}
			edge_iterator_base(boost_iterator_type a,boost_iterator_type b) : it(a,b) {}

			edge_iterator_base& operator++() {
				++it.first;
				return *this;
			}

			bool operator==(edge_iterator_base& v) {
				return *it.first == *v.it.first;
			}

			bool operator!=(const edge_iterator_base& v) const {
				return *it.first != *v.it.first;
			}

			Edge operator*() {
				return (*it.first);
			}
		private:
			edge_iterator_pair it;
		};
		/*!
		 * \endcond SKIP_DOC
		 */


		//! Iterator for all the edges in the graph
		typedef edge_iterator_base<typename boost::graph_traits<GraphContainer>::edge_iterator> 		edge_iterator;

		//! Iterator for all the out edges of a given node
		typedef edge_iterator_base<typename boost::graph_traits<GraphContainer>::out_edge_iterator> 	out_edge_iterator;

		//! Iterator for all the in edges of a given node
		typedef edge_iterator_base<typename boost::graph_traits<GraphContainer>::in_edge_iterator> 		in_edge_iterator;

		/*Types of edge iterators*/

		//! Beginning of the edges in the graph
		//! \return edge iterator pointing to the first edge in the graph
		edge_iterator edges_begin() {
			return edge_iterator(boost::edges(_graph));
		}

		//! Ending of the edges in the graph
		//! \return edge iterator pointing to the end of the edges in the graph
		edge_iterator edges_end() {
			return edge_iterator(boost::edges(_graph).second, boost::edges(_graph).second);
		}


		//! Beginning of the edges going out of a node in the graph
		//! \param[in] n : source node
		//! \return edge iterator pointing to the first out edge for the node
		out_edge_iterator out_edges_begin(Node n) {
			return out_edge_iterator(boost::out_edges(n, _graph));
		}

		//! Ending of the edges going out of a node in the graph
		//! \param[in] n : source node
		//! \return edge iterator pointing to the end of the out edges  for the node
		out_edge_iterator out_edges_end(Node n) {
			return out_edge_iterator(boost::out_edges(n, _graph).second, boost::out_edges(n, _graph).second);
		}

		//! Beginning of the edges going in of a node in the graph
		//! \param[in] n : target node
		//! \return edge iterator pointing to the first in edge for the node
		in_edge_iterator in_edges_begin(Node n) {
			return in_edge_iterator(boost::in_edges(n, _graph));
		}

		//! Ending of the edges going in of a node in the graph
		//! \param[in] n : target node
		//! \return edge iterator pointing to the end of the in edges  for the node
		in_edge_iterator in_edges_end(Node n) {
			return in_edge_iterator(boost::in_edges(n, _graph).second, boost::in_edges(n, _graph).second);
		}

		protected:
			//! Main graph structure
			GraphContainer _graph;
		};

		}
	}
}


#endif /* GRAPH_HPP_ */
