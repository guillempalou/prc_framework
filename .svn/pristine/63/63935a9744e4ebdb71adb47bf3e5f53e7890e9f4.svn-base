// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------

//!
//!  \file multiview_auxiliar.cpp
//!
//! \author Marcel Alcoverro <marcel@gps.tsc.upc.edu>
//!
//!
//!


#include <multiview_auxiliar.hpp>

#include <imageplus/math/numeric/lu_decomposition.hpp>
#include <imageplus/math/numeric/products.hpp>

using namespace imageplus;
using namespace imageplus::multiview;
using namespace imageplus::math::numeric;

MultiView<float64> imageplus::multiview::eval_ray_distance_error(const MultiView<Point3D>& ray_points, const MultiView<Point3D >& director_vectors, const Point3D& x)
{
    // TODO: Assert or check cameras of diferents MultiView<> inputs
    
    uint64 i;
    MultiView<float64> error(ray_points.size());
    Point3D vect_prod, b; 
    
    float64 auxNum, auxDen, auxErr;

    for (i=0,auxErr=0.0; i < ray_points.size(); i++)
    {
        b[0]=ray_points(i).x() - x.x(); 
        b[1]=ray_points(i).y() - x.y();
        b[2]=ray_points(i).z() - x.z();
        
        vect_prod=cross_prod3(director_vectors(i), b);        
        auxNum = scalar_prod(vect_prod,vect_prod);
        auxDen = scalar_prod(director_vectors(i),director_vectors(i));

        error(i) = auxNum/auxDen;
        auxErr+=auxNum/auxDen;
    }
    
    return(error);
}

Point3D imageplus::multiview::min_ray_distance_error_3d_point(const MultiView<Point2D>& mv_points, const MultiView<uint8>& is_object_in_cam)
{
    // TODO: Assert or check cameras of diferents MultiView<> inputs
    
    std::vector< MultiArray<float64,1> > A(3, MultiArray<float64,1>(3));
    MultiArray <float64,2> eq_system(3,3);
    MultiArray <float64,1> b(3), Arow(3);
    float64 baux, auxDen;
    
    MultiArray<float64,1> X(3);
    uint64 num_valid_cameras=0;
    uint64 num_cameras=mv_points.size();
    uint64 i,j;

    for (i = 0; i < num_cameras; i++)
    {
        if(is_object_in_cam(i)==1)
            num_valid_cameras++;
    }

    std::vector<Point3D> ray_points(num_valid_cameras); //3d points of the camera centers
    std::vector< Point3D > director_vectors(num_valid_cameras);
    MultiArray<float64,1> error(num_valid_cameras); //Distance to each line
   
    for(i=0, j=0; i<num_cameras; i++)
    {
        if(is_object_in_cam(i)==1)
        {
            back_projected_ray(mv_points.cam(i), mv_points.view(i), ray_points[j], director_vectors[j]); 
            j++;
        }
    }  
    
    for (i=0; i<3; i++) A[i]=0.0;
    b=0.0;

    //Start computing coefficients of the system Ax=b
    Point3D origin;
    origin.x()=0.0;
    origin.y()=0.0;
    origin.z()=0.0;
    
    for(i=0, j=0; i<num_cameras; i++)
    {
        if(is_object_in_cam(i)==1)
        {
            
            
            auxDen=scalar_prod(director_vectors[j],director_vectors[j]); 
            //d/dx equation coefficients
            Arow[0]= director_vectors[j][1]*director_vectors[j][1]+director_vectors[j][2]*director_vectors[j][2];
            Arow[1]=-director_vectors[j][1]*director_vectors[j][0];
            Arow[2]=-director_vectors[j][2]*director_vectors[j][0];
           
            baux=scalar_prod((ray_points[j]-origin), Arow);      
            
            A[0]=A[0]+(1.0/auxDen)*Arow;
            b[0]+=baux/auxDen;
    
            //d/dy equation coefficients
            Arow[0]=-director_vectors[j][1]*director_vectors[j][0];
            Arow[1]= director_vectors[j][0]*director_vectors[j][0]+director_vectors[j][2]*director_vectors[j][2];      
            Arow[2]=-director_vectors[j][2]*director_vectors[j][1];
         
            baux=scalar_prod((ray_points[j]-origin), Arow);      
        
            A[1]=A[1]+(1.0/auxDen)*Arow;
            b[1]+=baux/auxDen;
    
            //d/dz equation coefficients
            Arow[0]=-director_vectors[j][2]*director_vectors[j][0];
            Arow[1]=-director_vectors[j][2]*director_vectors[j][1];
            Arow[2]= director_vectors[j][0]*director_vectors[j][0]+director_vectors[j][1]*director_vectors[j][1];      
            
            baux=scalar_prod((ray_points[j]-origin), Arow);
      
            A[2]=A[2]+(1.0/auxDen)*Arow;
            b[2]+=baux/auxDen;
    
            j++;  
        }
    }
    //Solve linear equations
    //Cp A in a MultiArray Matrix
    for (j=0; j<3; j++)
    {
        for (i=0; i<3; i++)
        {
            eq_system[i][j]=A[i][j]; //be careful with matrix order
        }
    }
    X=lu_solve(eq_system,b);
    //Create output point
    Point3D out(X);
    return out;
}


Point3D imageplus::multiview::min_ray_distance_error_3d_point_outlier_rej(const MultiView<Point2D>& mv_points, const MultiView<uint8>& is_object_in_cam, const float64& alpha)
{
    // TODO: Assert or check cameras of diferents MultiView<> inputs
    
    //int32 *work_is_object_in_cam; //MA
    uint64 numCameras=mv_points.size();
    MultiView<uint8> work_is_object_in_cam(numCameras);
    float64 mean_error=0.0;
    float64 sigma_error=1000.0;
    Point3D final_point;
    uint64 i,j;
    uint64 numValidCameras;
    
    
    MultiView<Point3D> ray_points(numCameras); //3d points of the camera centers
    //MultiArray<float64,1> *director_vectors=new MultiArray<float64,1>[cams.dims(0)];//vector of director_vectors 
    MultiView<Point3D > director_vectors(numCameras);
    MultiView<float64> error(numCameras); //distance error to each ray
    float64 max_error;
    uint64 max_error_idx = 0;
    
   

    for (i=0, numValidCameras=0; i<numCameras; i++)
    {
        work_is_object_in_cam(i)=is_object_in_cam(i);
        if (work_is_object_in_cam(i)==1)
        {
            numValidCameras++;
        }
    }
    while (numValidCameras >= 2)
    {
        for (i=0; i<numCameras; i++)
        {
            if (work_is_object_in_cam(i)==1)
            {
                back_projected_ray(mv_points.cam(i), mv_points(i), ray_points(i),director_vectors(i));
            }
        }
        
        final_point=min_ray_distance_error_3d_point(mv_points, work_is_object_in_cam);

        //Compute mean error
        error=eval_ray_distance_error(ray_points, director_vectors, final_point);
        
        for (i=0,j=0,mean_error=0.0; i<numCameras; i++)
        {
            if (work_is_object_in_cam(i)==1)
            {
                //printf("Error on camera %d: %24.16le\n",i,fError[j]);
                mean_error += error(j);
                j++;
            }
        }
        mean_error /= static_cast<float64>(numValidCameras);

        //Compute sigma_error (variance of the error).
        for (i = 0, sigma_error=0.0, j=0; i < numCameras; i++)
        {
            if (work_is_object_in_cam(i)==1)
            {
                sigma_error+=(error(j)-mean_error)*(error(j)-mean_error);
                j++;
            }
        }
        sigma_error/=static_cast<float64>(numValidCameras);
        sigma_error=std::sqrt(sigma_error);

        //Look for maximum error and set that camera to invalid.
        max_error=error(0)-1.0;
        for (i = 0,j=0; i < numCameras; i++)
        {
            if (work_is_object_in_cam(i)==1)
            {
                if (max_error < error(j))
                {
                    max_error=error(j);
                    max_error_idx=i;
                }
                j++;
            }
        }
        //In case the variance of the error is inferior to a certain bound (given by alpha)
        //and maximum error is below the maximum error allowed, we consider the point a good
        //approximation
        if ((mean_error*alpha > sigma_error) && (max_error < MAX3DRAYERROR))
            break;

        work_is_object_in_cam(max_error_idx)=0;
        numValidCameras--;
    }
    return final_point;

}
