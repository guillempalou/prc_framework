// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------

//!
//!  \file imageyuv420.cpp
//!
//!  Implementation for ImageYUV420 class
//!

#include <imageplus/core/check_size.hpp>

#include <imageplus/core/imageyuv420.hpp>

using namespace imageplus;

template<typename T>
ImageYUV420<T>::ImageYUV420()
        : Image<T,3>()
{
}


template<typename T>
ImageYUV420<T>::ImageYUV420 ( uint64 width, uint64 height ) throw (ImagePlusError)
        : Image<T,3>()
{
    if ( (width % 2) != 0 )
    {
        throw ImagePlusError("width dimension must be even for 420 images");
    }
    if ( (height % 2) != 0 )
    {
        throw ImagePlusError("height dimension must be even for 420 images");
    }

    (*this)(0) = MultiArray<T,2>(width,height);
    (*this)(1) = MultiArray<T,2>(width/2,height/2);
    (*this)(2) = MultiArray<T,2>(width/2,height/2);
}


template<typename T>
ImageYUV420<T>:: ImageYUV420(const ImaVol<T,3,2>& copy)  throw (ImagePlusError)
        : Image<T,3>(copy)
{
    check_size_yuv420(copy);
}

template<typename T>
ImageYUV420<T>::ImageYUV420(const Image<T,3>& copy) throw (ImagePlusError)
        : Image<T,3>(copy)
{
    check_size_yuv420(copy);
}


template<typename T>
ImageYUV420<T>::ImageYUV420(const ImageYUV420<T>& copy)
        : Image<T,3>(copy)
{
#ifndef NDEBUG
    check_size_yuv420(copy);
#endif
}


template<typename T>
inline ImageYUV420<T>::ImageYUV420(const std::vector< std::vector<uint64> >& dims) throw (ImagePlusError)
        : Image<T,3>(dims)
{
    if ( (dims[0][0] != 2*dims[1][0]) || (dims[0][1] != 2*dims[1][1]) )
    {
        throw ImagePlusError("ImageYUV420(dims): U channel dimensions must be half Y channel dimensions (420)");
    }

    if ( (dims[0][0] != 2*dims[2][0]) || (dims[0][1] != 2*dims[2][1]) )
    {
        throw ImagePlusError("ImageYUV420(dims): V channel dimensions must be half Y channel dimensions (420)");
    }
}


template<typename T>
ImageYUV420<T>::~ImageYUV420()
{
}


template<typename T>
void ImageYUV420<T>::resize ( uint64 width, uint64 height )
{
    if ( (width % 2) != 0 )
    {
        throw ImagePlusError("Width dimension must be even for YUV420 images");
    }
    if ( (height % 2) != 0 )
    {
        throw ImagePlusError("Height dimension must be even for YUV420 images");
    }
    
    std::vector<uint64> dims;
    dims.push_back(width);
    dims.push_back(height);
    
    (*this)(0).resize( dims );

    dims.resize(0);
    dims.push_back(width/2);
    dims.push_back(height/2);
    
    (*this)(1).resize( dims );
    (*this)(2).resize( dims );
}



template<typename T>
void ImageYUV420<T>::resize ( const std::vector< std::vector<uint64> >& dims )
{
    if ( dims.size() != 3 )
    {
        throw ImagePlusError("Dimensions of dims must be equal to the number of channels");
    }
    
    for (uint64 c=0; c < 3; c++)
    {
        if (dims[c].size() != 2)
        {
            throw ImagePlusError("Dimensions for each dims[i] must be equal to 2");
        }
        
    }
   
    if ( (dims[0][0] != 2*dims[1][0]) || (dims[0][1] != 2*dims[1][1]) )
    {
        throw ImagePlusError("resize(dims): U channel dimensions must be half Y channel dimensions (YUV420)");
    }

    if ( (dims[0][0] != 2*dims[2][0]) || (dims[0][1] != 2*dims[2][1]) )
    {
        throw ImagePlusError("resize(dims): V channel dimensions must be half Y channel dimensions (YUV420)");
    }
    
    (*this)(0).resize( dims[0] );
    (*this)(1).resize( dims[1] );
    (*this)(2).resize( dims[2] );
}



template<typename T>
const ImageYUV420<T>& ImageYUV420<T>::operator=( const ImaVol<T,3,2>& copy ) throw (ImagePlusError)
{
    check_size_yuv420(copy);

    (*this).Image<T,3>::operator=( copy );

    return *this;
}

template<typename T>
const ImageYUV420<T>& ImageYUV420<T>::operator=( const Image<T,3>& copy ) throw (ImagePlusError)
{
    check_size_yuv420(copy);

    (*this).Image<T,3>::operator=( copy );

    return *this;
}

template<typename T>
const ImageYUV420<T>& ImageYUV420<T>::operator=( const ImageYUV420<T>& copy )
{
#ifndef NDEBUG
    check_size_yuv420(copy);
#endif

    (*this).Image<T,3>::operator=( copy );

    return *this;
}

template<typename T>
const T& ImageYUV420<T>::operator=(const T& val)
{
    (*this).Image<T,3>::operator=( val );

    return val;
}


// ImageYUV420 instantiations
namespace imageplus
{

    // images
    template class ImageYUV420<uint8>;
    template class ImageYUV420<int64>;
    template class ImageYUV420<float64>;

}
