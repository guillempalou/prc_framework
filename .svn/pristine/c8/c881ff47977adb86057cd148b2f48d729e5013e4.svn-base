/*
 * trajectory_error.hpp
 *
 *  Created on: Feb 5, 2013
 *      Author: gpalou
 */

#ifndef TRAJECTORY_ERROR_HPP_
#define TRAJECTORY_ERROR_HPP_

#include <imageplus/core/image_signal.hpp>
#include <imageplus/segmentation/partition/partition.hpp>
#include <fstream>

namespace imageplus {
	namespace motion_segmentation {

	// Adapted from Brox & Malik
	template<class PartitionModel>
	class TrajectoryClusteringError {

		typedef typename PartitionModel::coord_type coord_type;
		typedef ImageSignal<float64,1>				ImagePartition;

		class SimpleTrack {
		public:
			SimpleTrack() {}
			uint64 label;
			std::vector<coord_type> points;
		};

		class CCoverage {
		public:
			CCoverage() {}
			CCoverage(int aRegion, int aCoverage) : mRegion(aRegion),mCoverage(aCoverage) {}
			int mRegion;
			int mCoverage;

			bool operator<(const CCoverage& a) const {
				return mCoverage < a.mCoverage;
			}
		};



	public:

		struct ErrorStruct {

			uint64 number_of_frames;
			uint64 labeled_frames;

			float64 density;
			float64 overall_error;
			std::vector<float64> clustering_region_error;
			float64 average_clustering_error;
			uint64 number_of_clusters_needed;
			uint64 less_than_10_percent;

			uint64 visible_regions;
		};


		void compute_error(PartitionModel& p, std::string shot_definition, std::string result_file) {
			aOut.open(result_file.c_str());

			_read_ground_truth(shot_definition);
			_create_tracks_from_partition(p);
			_evaluate_tracks(p);

		}

		std::vector<ImageSignal<float64,3> > assignments() {
			return _assignments;
		}


	private:

		int64 _read_ground_truth(std::string shot_definition) {
			std::string aPath = shot_definition;
			if (aPath.find_last_of('/') < aPath.length())
				aPath.erase(aPath.find_last_of('/'),aPath.length());
			else
				aPath = ".";
			aPath += '/';
			std::ifstream aPropFile(shot_definition.c_str());
			if (!aPropFile.is_open()) {
				std::cerr << "Definition file " << shot_definition << "  not found." << std::endl;
				return -1;
			}
			// Read header
			char dummy[300];
			aPropFile.getline(dummy,300);
			aPropFile.getline(dummy,300);
			// Number of regions
			aPropFile.getline(dummy,300);
			aPropFile >> _region_number;
			aPropFile.getline(dummy,300);

			_color_2_region.resize(256);

			_penalty = math::Matrix(_region_number,_region_number);
			// Region color
			for (uint64 i = 0; i < _region_number; i++) {
				aPropFile.getline(dummy,300);
				uint64 a;
				aPropFile >> a;
				aPropFile.getline(dummy,300);
				_color_2_region[a] = i;
			}
			// Confusion penalty matrix
			aPropFile.getline(dummy,300);
			aPropFile.getline(dummy,300);
			for (uint64 j = 0; j < _region_number; j++)
				for (uint64 i = 0; i < _region_number; i++)
					aPropFile >> _penalty(i,j);

			// Number of frames in shot
			aPropFile.getline(dummy,300);
			aPropFile.getline(dummy,300);
			aPropFile.getline(dummy,300);
			aPropFile >> _total_frame_number;
			aPropFile.getline(dummy,300);

			// Number of labeled frames
			aPropFile.getline(dummy,300);
			aPropFile >> _labeled_frames_number;
			aPropFile.getline(dummy,300);

			_labeled_frame.resize(_labeled_frames_number);

			_regions.resize(_labeled_frames_number);

			// Read frame number and annotation
			for (uint64 i = 0; i < _labeled_frames_number; i++) {
				aPropFile.getline(dummy,300);
				aPropFile >> _labeled_frame[i];
				aPropFile.getline(dummy,300);
				aPropFile.getline(dummy,300);
				std::string s;
				aPropFile >> s;
				_regions[i].read((aPath+s).c_str());
				_regions[i].write("test.png");
				aPropFile.getline(dummy,300);
				aPropFile.getline(dummy,300);
				aPropFile.getline(dummy,300);
			}
			return 0;
		}

		uint64 _create_tracks_from_partition(PartitionModel& partition) {
			uint64 Nframes = partition.sizes()(2);
			std::cout << "Creating tracks" << std::endl;

			_evaluate_frames = Nframes;

			/*if (Nframes == 10) _evaluate_frames = 10;
			else if (Nframes == 50) _evaluate_frames = 50;
			else if (Nframes == 200) _evaluate_frames = 200;
			else if (Nframes == _total_frame_number) _evaluate_frames = _total_frame_number;
			else {
				std::cerr << "Length of tracked sequence does not match a typical evaluation length (10,50,200,all frames)." << std::endl;
				return false;
			}*/

			std::vector<SimpleTrack> list_tracks;

			_cluster_number = 0;

			for (typename PartitionModel::iterator p = partition.begin(); p != partition.end(); ++p) {
				uint64 idx = (*p)(0);
				if (_correspondence.find(idx) == _correspondence.end()) {
					_correspondence[idx] = _cluster_number;
					idx = _cluster_number++;
				}
				else
					idx = _correspondence[idx];
			}
			//_cluster_number++;


			for (typename PartitionModel::iterator p = partition.begin(); p != partition.end(); ++p) {
				SimpleTrack track;
				track.points.push_back(p.pos());
				track.label = _correspondence[(*p)(0)];
				_tracks.push_back(track);
			}

			//_tracks.clear();
			/*uint64 N = 0;
			for (uint64 i = 0; i < _cluster_number; i++) {
				if (list_tracks[i].points.size() > 1) {
					_tracks.push_back(list_tracks[i]);
					_tracks[N].label = N;
					N++;
				}
			}*/

			//_cluster_number = N;
			//std::cout << "Video size " << partition.sizes().transpose() << std::endl;
			std::cout << "Found a total of " << _tracks.size() << " tracks and " << _cluster_number << " clusters " << std::endl;
			return 0;
		}

		uint64 _read_tracks() {
			//! TODO
			return 0;
		}

		void _evaluate_tracks(PartitionModel& partition) {
			ErrorStruct e;

			math::Matrix aRegionClusterOverlap  = math::Matrix::Zero(_region_number,_cluster_number);

			std::vector<std::vector<uint64> > aAssignCluster(_cluster_number);
			std::vector<uint64> aClusterSize(_cluster_number,0);
			std::vector<uint64> aRegionSize(_region_number,0);
			uint64 aUsedLabeledFrames = 0;
			uint64 aDoubleOccupation = 0;

			// Measure coverage of regions (ground truth) by clusters (estimated track labels)
			std::cout << "Measure coverage of regions (ground truth) by clusters (estimated track labels)" << std::endl;

			//_labeled_frames_number = 1;

			for (uint64 t = 0; t < _labeled_frames_number; t++) {
				if (_labeled_frame[t] > _evaluate_frames && _evaluate_frames > 0) break;
				aUsedLabeledFrames++;
				uint64 sx = _regions[t].size_x();
				uint64 sy = _regions[t].size_y();

				math::Matrix aOccupied = math::Matrix::Zero(sx,sy);
				for (typename ImagePartition::iterator p = _regions[t].begin(); p != _regions[t].end(); ++p) {
					uint64 l = _color_2_region[_correspondence[(*p)(0)]];
					aRegionSize[l]++;
				}

				for (uint64 i = 0; i < _tracks.size(); i++) {
					uint64 N = _tracks[i].points.size();
					if 	(_tracks[i].points[0](2) > (int64)_labeled_frame[t] || _tracks[i].points[N-1](2) < (int64)_labeled_frame[t]) continue;

					uint64 t2 = _labeled_frame[t]-_tracks[i].points[0](2);
					uint64 x = _tracks[i].points[t2](0);
					uint64 y = _tracks[i].points[t2](1);
					if (x < 0 || y < 0 || x >= sx || y >= sy) continue;
					int64 aRegion = _color_2_region[_regions[t](x,y)(0)];
					aRegionClusterOverlap(aRegion,_tracks[i].label)++;
					aClusterSize[_tracks[i].label]++;
					// Count double occupation of pixels, so it does not increase the density
					if (aOccupied(x,y)) aDoubleOccupation++;
					aOccupied(x,y) = true;
				}
			}

			// Order regions by their total coverage and assign to each ground truth its best jaccard index
			std::cout << "Getting the best jaccard index" << std::endl;
			for (uint64 i = 0; i < _region_number; i++) {
				int64 	bestj = -1;
				float64 bestCoverage = 0;
				for (uint64 j = 0; j < _cluster_number; j++) {
					// compute jaccard index
					uint64 jaccard = aRegionClusterOverlap(i,j) / (aClusterSize[j] + aRegionSize[i] - aRegionClusterOverlap(i,j));
					if (jaccard > bestCoverage) {
						bestCoverage = jaccard;
						bestj = j;
					}
				}
				if (bestj >= 0) aAssignCluster[bestj].push_back(i);
			}

			// Now counting positives and negatives for each region
			std::cout << "Now counting positives and negatives for each region" << std::endl;
			std::vector<uint64> 	aPositives(_region_number,0);
			std::vector<float64> 	aWeightedNegatives(_region_number,0);
			std::vector<uint64> 	aNegatives(_region_number,0);
			int aOversegmentationPenalty = 0;

			math::Matrix correct = math::Matrix::Zero(_region_number, _cluster_number);

			for (uint64 j = 0; j < _cluster_number; j++) {
				if (aClusterSize[j] == 0) continue;
				// 1. cluster assigned exactly once (correct)
				if (aAssignCluster[j].size() == 1) {
					uint64 i = aAssignCluster[j][0];
					aPositives[i] += aRegionClusterOverlap(i,j);

					correct(i,j) = 1;

					// Some points of this cluster may cover other regions -> negatives
					for (uint64 i2 = 0; i2 < _region_number; i2++) {
						aWeightedNegatives[i2] += aRegionClusterOverlap(i2,j)*_penalty(i,i2);
						if (i2 != i) {
							aNegatives[i2] += aRegionClusterOverlap(i2,j);
							correct(i2,j) = -1;
						}
					}
				}
				// 2. cluster assigned multiple times (undersegmentation)
				else if (aAssignCluster[j].size() > 1) {
					// Find the most covered region
					uint64 best = 0;
					uint64 i = 0;
					for (unsigned int k = 0; k < aAssignCluster[j].size(); k++)
						if (aRegionClusterOverlap(aAssignCluster[j][k],j) > best) {
							best = aRegionClusterOverlap(aAssignCluster[j][k],j);
							i = aAssignCluster[j][k];
						}
					// This region counts positive
					aPositives[i] += aRegionClusterOverlap(i,j);
					correct(i,j) = 1;
					// All points assigned to other regions count negative
					for (uint64 i2 = 0; i2 < _region_number; i2++) {
						aWeightedNegatives[i2] += aRegionClusterOverlap(i2,j)*_penalty(i,i2);
						if (i2 != i){
							aNegatives[i2] += aRegionClusterOverlap(i2,j);
							correct(i2,j) = -1;
						}
					}
				}
				// 3. cluster not assigned at all (oversegmentation)
				else {
					// Increase the counter for oversegmented regions
					aOversegmentationPenalty++;
					// Find the most covered region
					uint64 best = 0;
					uint64 i = 0;
					for (uint64 i2 = 0; i2 < _region_number; i2++)
						if (aRegionClusterOverlap(i2,j) > best) {
							best = aRegionClusterOverlap(i2,j);
							i = i2;
						}
					// This region counts positive
					aPositives[i] += aRegionClusterOverlap(i,j);
					correct(i,j) = 1;
					// All points assigned to other regions count negative
					for (uint64 i2 = 0; i2 < _region_number; i2++) {
						aWeightedNegatives[i2] += aRegionClusterOverlap(i2,j)*_penalty(i,i2);
						if (i2 != i) {
							aNegatives[i2] += aRegionClusterOverlap(i2,j);
							correct(i2,j) = -1;
						}
					}
				}
			}
			//std::cout << correct << std::endl;
			//std::cout << "Computing mask" << std::endl;

			_assignments.resize(_labeled_frame.size());

			for (uint64 i = 0; i < _labeled_frame.size(); i++) {
				ImageSignal<float64,3> img(_regions[i].sizes());

				//std::cout << "Image size " << img.sizes().transpose() << " " << _labeled_frame[i] << std::endl;

				if ((uint64)_labeled_frame[i] >= (uint64)partition.sizes()(2))
					break;
				for (ImageSignal<float64,3>::iterator v = img.begin(); v != img.end(); ++v) {

					int64 id_region  = _color_2_region[_regions[i](v.pos())(0)];
					int64 id_cluster = _correspondence[partition(v.pos()(0), v.pos()(1), _labeled_frame[i])(0)];

					//std::cout << id_region << " " << id_cluster << std::endl;
					if (correct(id_region, id_cluster) == 1) {
						(*v) = ImageSignal<float64,3>::value_type(0,255,0);
					}
					if (correct(id_region, id_cluster) == -1) {
						(*v) = ImageSignal<float64,3>::value_type(0,0,255);
					}
				}

				_assignments[i] = img;
				//std::cout << "done" << std::endl;
			}

			// Compute final numbers
			std::cout << "Compute final numbers" << std::endl;
			int aTotalCoverage = 0;

			for (uint64 i = 0; i < (uint64)aRegionClusterOverlap.size(); i++)
				aTotalCoverage += aRegionClusterOverlap.data()[i];

			aTotalCoverage -= aDoubleOccupation;
			float64 aDensity = 100.0f*aTotalCoverage/(aUsedLabeledFrames*(_regions[0].size_x()*_regions[0].size_y()));
			int64 aTotalPositives = 0;
			int64 aTotalNegatives = 0;
			float64 aTotalWeightedNegatives = 0;
			for (uint64 i = 0; i < _region_number; i++) {
				aTotalPositives += aPositives[i];
				aTotalNegatives += aNegatives[i];
				aTotalWeightedNegatives += aWeightedNegatives[i];
			}

			float64 aOverallError = 0.0f;
			if (aTotalNegatives+aTotalPositives > 0) aOverallError = 100.0f*aTotalWeightedNegatives/(aTotalNegatives+aTotalPositives);
			std::vector<float64> aPerRegionError(_region_number);
			float aAverageError = 0;
			int aVisibleRegions = _region_number;
			int aCoveredRegions = 0;
			int aLessThan10Percent = 0;
			for (uint64 i = 0; i < _region_number; i++) {
				// Do not count regions not visible in the evaluated part of the sequence
				if (aRegionSize[i] == 0) {
					aVisibleRegions--;
					continue;
				}
				// Regions covered by at last one cluster
				if (aPositives[i] > 0) {
					aPerRegionError[i] = 100.0f*aNegatives[i]/(aNegatives[i]+aPositives[i]);
					aCoveredRegions++;
				}
				// Regions not covered at all: 100% error
				else aPerRegionError[i] = 100.0f;
				aAverageError += aPerRegionError[i];
				if (aPerRegionError[i] < 10) aLessThan10Percent++;
			}
			aAverageError *= 1.0f/aVisibleRegions;
			if (aLessThan10Percent > 0) aLessThan10Percent -= 1;

			aOut << "Evaluation results :" << std::endl;
			aOut << "MoSegEval Version 1.0" << std::endl << std::endl;
			aOut << "Number of frames used from the sequence:" << std::endl;
			aOut << _evaluate_frames << std::endl;
			aOut << "Number of labeled frames in this time window:" << std::endl;
			aOut << aUsedLabeledFrames << std::endl;
			aOut << "--------------------------" << std::endl;
			aOut << "Density (in percent):" << std::endl;
			aOut << aDensity << std::endl;
			aOut << "--------------------------" << std::endl;
			aOut << "Overall (per pixel) clustering error (in percent):" << std::endl;
			aOut << aOverallError << std::endl;
			aOut << "--------------------------" << std::endl;
			aOut << "Clustering error per region (in percent):" << std::endl;
			for (uint64 i = 0; i < _region_number; i++) {
				aOut << "Region " << i << ": " << std::endl;
				if (aRegionSize[i] == 0) aOut << "not visible" << std::endl;
				else aOut << aPerRegionError[i] << std::endl;
			}
			aOut << "Visible regions in the evaluated part of the shot:" << std::endl;
			aOut << aVisibleRegions << std::endl;
			aOut << "--------------------------" << std::endl;
			aOut << "Average (per region) clustering error (in percent):" << std::endl;
			aOut << aAverageError << std::endl;
			aOut << "--------------------------" << std::endl;
			aOut << "Number of clusters merged to obtain this result (oversegmentation error):" << std::endl;
			aOut << aOversegmentationPenalty << std::endl;
			aOut << "--------------------------" << std::endl;
			aOut << "Number of regions with less than 10% error (excluding background):" << std::endl;
			aOut << aLessThan10Percent << std::endl;
		}

	private:

		std::vector<ImageSignal<float64,3> > _assignments;

		std::map<uint64,uint64> _correspondence;

		uint64 _region_number;
		uint64 _total_frame_number;
		uint64 _evaluate_frames;
		uint64 _labeled_frames_number;
		uint64 _cluster_number;

		std::vector<uint64>						_color_2_region;
		std::vector<uint64>						_labeled_frame;
		std::vector<ImageSignal<float64,1> > 	_regions;

		std::vector<SimpleTrack> _tracks;

		std::ofstream aOut;

		math::Matrix _penalty;
	};

	}
}

#endif /* TRAJECTORY_ERROR_HPP_ */
