// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------

//!
//!  \file dwt.hpp
//!
//!  Interface for DWT (Discrete Wavelet Transform) class
//!

#ifndef IMAGEPLUS_CORE_DWT_HPP
#define IMAGEPLUS_CORE_DWT_HPP

#include <vector>
#include <imageplus/core/convert_types.hpp>
#include <imageplus/core/imagegray.hpp>
#include <imageplus/core/imageplus_types.hpp>
#include <imageplus/core/border.hpp>
#include <imageplus/core/colorspace_descriptors.hpp>
#include <boost/array.hpp>

#include <sstream>

// Needed by MSVC
#include <imageplus/math.hpp>


namespace imageplus
{
	namespace math
	{
	    namespace transforms
	    {
	        //! Constants identifying the DWT mode
	        enum Mode {DECIMATE, UNDECIMATE};

    		//!
            //! \brief Class for 2D Discrete Wavelet Transform 
            //!
            //! Template DWTModel is the model of wavelet used. HAAR and DB2 are implemented and the rest of
            //! wavelets can be easily implemented by the user. 
            //!
            //! Template mode is the DECIMATE if we want to obtained the images decimated and UNDECIMATE if we only want to obtain the images without decimate.
            //!
            //! Template N is the number of levels of the multi-level descomposition.
            //! 
            //! The declaration by the haar wavelet should be:
            //! \code
            //!    HAAR haar;
            //!    DWT<HAAR, UNDECIMATE, 3> my_dwt(haar);
            //! \endcode
            //!
            //! \author Carles Ventura <alcarles@gps.tsc.upc.edu>
            //!
            //! \date 29-5-2009
    	    template< class DWTModel, std::size_t mode, std::size_t N = 1>
    	    class DWT
    	    {};
    	
    	    class HAAR;
    	    
    	    //! Template specialization for the DECIMATE case
    	    template< class DWTModel, std::size_t N>
    	    class DWT<DWTModel, DECIMATE, N> : public DescriptorBase
    	    {
    	    	public:
    	    		
    	    		//!
    	    		//! \brief DWT Constructor
    	    		//!
    	    		//! \param[in] dwtmodel : Class defining the Wavelet type.
    	    		//!
    	    		DWT(DWTModel dwtmodel) : DescriptorBase("DWT_decimate", false)
    	    		{
    	    		    // Form id
    	                std::ostringstream os;
    	                os << "DWT_decimate_" << N;
    	                this->_id = os.str();

    	    			_dwtmodel = dwtmodel;
                        ImageGray<float64>::Color cl = 0;
    	    			_aux1.resize(N, Border<ImageGray<float64> >(dwtmodel.borders2d(), cl));
    	    			_aux2.resize(N, Border<ImageGray<float64> >(dwtmodel.borders2d(), cl));
    	    			_approx.resize(N, Border<ImageGray<float64> >(dwtmodel.borders2d(), cl));
    	    			_vert.resize(N, Border<ImageGray<float64> >(dwtmodel.borders2d(), cl));
    	    			_horiz.resize(N, Border<ImageGray<float64> >(dwtmodel.borders2d(), cl));
    	    			_diag.resize(N, Border<ImageGray<float64> >(dwtmodel.borders2d(), cl));
    	    			_approx_decim.resize(N);
    	    			_vert_decim.resize(N);
    	    			_horiz_decim.resize(N);
    	    			_diag_decim.resize(N);
    	    		}
    	    		
    	    		//!
    	    		//! \brief It copies the model of wavelet passed by the user.
    	    		//!
    	    		//! \param[in] dwtmodel : Model of wavelet passed by the user to be copied.
    	    		//!
    	    		void dwt_model(DWTModel dwtmodel)
    	    		{
    	    			_dwtmodel = dwtmodel;
    	    		}
    	    		
    	    		
    	    	    //!
    	    		//! \brief It calculates the images resulting of filtering using the Decomposition low-pass and high-pass filters by rowns and columns before decimating.
    	    		//!
    	    		//! The borders of image must be added previously by the user.
    	    		//!
    	    		//! \param[in] first : Iterator at the beginning of the imavol which we want to transform.
    	    		//! \param[in] last : Iterator at the end of the imavol which we want to transform.
    	            //! \param[in] peer_descs : Pointer to CollaborativeDescriptors, in principle is never 0x0 but it is a good idea to ASSERT it
    	    		//!
    	    		template<class IteratorModel>
    	    	    void calculate(IteratorModel first, IteratorModel last, CollaborativeDescriptors* peer_descs)
    	    		{
                        ASSERT(peer_descs!=0x0, "DWT calculate: peer_descs must be non null");

                        // Convert to gray
                        typedef ImageGray<typename IteratorModel::imavol_type::data_type> gray_type;
                        gray_type im_gray = peer_descs->calculate(new VDImageGray<typename IteratorModel::imavol_type>(), first, last);

                        // Add borders
                        boost::array<std::size_t, 2> borders2d = {{1,1}};
                        typename gray_type::Color cl = 0;
                        const Border<gray_type>& im_gray_borders = calc_descriptor(new Border<gray_type>(borders2d, cl), im_gray);

                        // Allocate data with borders
                        // Used as reference to allocate the data with borders (it is float64)
                        // We store it in the class because it contains the mask to which all borders will point
                        // When the copy copies the mask, this will not be necessary
                        _aux_im.resize(im_gray.dims());
                        typename ImageGray<float64>::Color cl2 = 0;
                        Border<ImageGray<float64> > tmp = calc_descriptor(new Border<ImageGray<float64> >(_dwtmodel.borders2d(), cl2), _aux_im);
                        for(std::size_t level = 0; level < N ; ++level)
                        {
                            _aux1[level] = tmp;
                            _aux2[level] = tmp;
                            _approx[level] = tmp;
                            _horiz[level] = tmp;
                            _diag[level] = tmp;
                            _vert[level] = tmp;
                        }

                        // Calculate level 0
    	    		    _calculate(im_gray_borders.colors_begin(), im_gray_borders.colors_end(), 0);
    	    		    _decimate(_approx[0], _approx_decim[0]);
    	    		    _decimate(_horiz[0], _horiz_decim[0]);
    	    		    _decimate(_vert[0], _vert_decim[0]);
    	    		    _decimate(_diag[0], _diag_decim[0]);

                        // Calculate the rest of levels
    	    		    for(std::size_t level = 1; level < N ; ++level)
    	    		    {
                            // Calculate level i from i-1
    	    		        _calculate(_approx[level-1].colors_begin(), _approx[level-1].colors_end(), level);

    	    		        ImageGray<float64> im_aux;

    	    		        _decimate(_approx[level], im_aux);
    	    		        _decimate_N_times(im_aux, _approx_decim[level],level);

    	    		        _decimate(_horiz[level], im_aux);
    	    		        _decimate_N_times(im_aux, _horiz_decim[level],level);

    	    		        _decimate(_vert[level], im_aux);
    	    		        _decimate_N_times(im_aux, _vert_decim[level],level);

    	    		        _decimate(_diag[level], im_aux);
    	    		        _decimate_N_times(im_aux, _diag_decim[level],level);
    	    		    }
    	    		}

    	    		
    	    	    //!
    	    		//! \brief It puts the four images resulting of the first level of dwt in a unique image. It is necessary that approx(), horiz(), vert() and diag() methods have been called previously.
    	    		//!
    	    		//! \param[out] image_out : Image formed by the next images: approx (top left), horiz (top right), vert (bottom left), diag (bottom right). They are quantified.
    	    		//!
    	    	    void mosaic(ImageGray<uint8>& image_out) const
    	    	    {
    	    	    	std::size_t size_x = _approx_decim[0].size_x();
    	    	    	std::size_t size_y = _approx_decim[0].size_y();
    	    	    	image_out.resize(2*size_x,2*size_y);
    	    	    	std::size_t i,j;
    	    	    	ImageGray<uint8> tmp(size_x,size_y);
    	    	    	
    	    	    	for( j = 0; j< size_y; j++)
    	    	    	{
    	    	    		_quant(_approx_decim[0], tmp);
    	    	    		for( i = 0; i< size_x; i++)
    	    	    		{
    	    	    			image_out[i][j]=tmp[i][j];
    	    	    		}
    	    	    		_quant(_horiz_decim[0], tmp);
    	    	    		for(; i< 2*size_x; i++)
    	    	    		{
    	    	    			image_out[i][j]=tmp[i-size_x][j];
    	    	    		}
    	    	    	}
    	    	    	for(;j< 2*size_y; j++)
    	    	    	{
    	    	    		_quant(_vert_decim[0], tmp);
    	    	    		for( i = 0; i< size_x; i++)
    	    	    		{
    	    	    			image_out[i][j]=tmp[i][j-size_y];
    	    	    		}
    	    	    		_quant(_diag_decim[0], tmp);
    	    	    		for(; i< 2*size_x; i++)
    	    	    		{
    	    	    			image_out[i][j]=tmp[i-size_x][j-size_y];
    	    	    		}	    	    		
    	    	    	}
    	    	    }
    	    	    
    	    		/*!
    	    		 * \param[in] level: Specific level which we want to obtain the approximate decimated image from.
    	    		 *
    	    		 * \return the approximate decimated image from a specific level
    	    		 */
    	    	    const ImageGray<float64>& approx(std::size_t level = 0) const
                    {
                        return _approx_decim[level];
                    }

    	    	    /*!
    	    	     * \param[in] level: Specific level
    	    	     *
    	    	     * \return the horizontal details decimated image from a specific level
    	    	     */
                    const ImageGray<float64>& horiz(std::size_t level = 0) const
                    {
                        return _horiz_decim[level];
                    }

    	    	    /*!
    	    	     * \param[in] level: Specific level
    	    	     *
    	    	     * \returns the vertical details decimated image from a specific level
    	    	     */
                    const ImageGray<float64>& vert(std::size_t level = 0) const
                    {
                        return _vert_decim[level];
                    }

    	    	    /*!
    	    	     * \param[in] level: Specific level
    	    	     *
    	    	     * \return the diagonal details decimated image from a specific level
    	    	     */
                    const ImageGray<float64>& diag(std::size_t level = 0) const
                    {
                        return _diag_decim[level];
                    }
    	    	    
    	    	    //!
    	    		//! \brief It returns the image resulting of the low-pass filter by rows before decimating from a specific level.
    	    		//!
    	    	    //! \param[in] level: Specific level which we want to obtain the image resulting.
    	    	    //!
    	    	    //! \return Image resulting of the low-pass filter by rows before decimating from a specific level.
    	    	    const Border<ImageGray<float64> >& aux1_before_decim(std::size_t level = 0) const
    	    	    {
    	    	    	return _aux1[level];
    	    	    }
    	    	    
    	    	    //!
    	    		//! \brief It returns the image resulting of the high-pass filter by rows before decimating from a specific level.
    	    		//!
    	    	    //! \param[in] level: Specific level which we want to obtain the image resulting.
    	    	    //!
    	    	    //! \return Image resulting of the high-pass filter by rows before decimating.
    	    	    const Border<ImageGray<float64> >& aux2_before_decim(std::size_t level = 0) const
    	    	    {
    	    	    	return _aux2[level];
    	    	    }
    	    	    
    	    	    //!
    	    		//! \brief It returns the approximate image before decimating from a specific level.
    	    		//!
    	    	    //! \param[in] level: Specific level which we want to obtain the image resulting.
    	    	    //!
    	    	    //! \return Approximate image before decimating.
    	    	    const Border<ImageGray<float64> >& approx_before_decim(std::size_t level = 0) const
    	    	    {
    	    	    	return _approx[level];
    	    	    }
    	    		
    	    	    //!
    	    		//! \brief It returns the horizontal image before decimating from a specific level.
    	    		//!
    	    	    //! \param[in] level: Specific level which we want to obtain the image resulting.
    	    	    //!
    	    	    //! \return Horizontal image before decimating.
    	    	    const Border<ImageGray<float64> >& horiz_before_decim(std::size_t level = 0) const
    	    	    {
    	    	    	return _horiz[level];
    	    	    }
    	    	    
    	    	    //!
    	    		//! \brief It returns the vertical image before decimating from a specific level.
    	    		//!
    	    	    //! \param[in] level: Specific level which we want to obtain the image resulting.
    	    	    //!
    	    	    //! \return Vertical image before decimating.
    	    	    const Border<ImageGray<float64> >& vert_before_decim(std::size_t level = 0) const
    	    	    {
    	    	    	return _vert[level];
    	    	    }
    	    	    
    	    	    //!
    	    		//! \brief It returns the diagonal image before decimating from a specific level.
    	    		//!
    	    	    //! \param[in] level: Specific level which we want to obtain the image resulting.
    	    	    //!
    	    	    //! \return Diagonal image before decimating.
    	    	    const Border<ImageGray<float64> >& diag_before_decim(std::size_t level = 0) const
    	    	    {
    	    	    	return _diag[level];
    	    	    }
    	    	    
    	    	    //! \returns the internal DWTModel
    	    	    const DWTModel& dwt_model() const
    	    	    {
    	    	        return _dwtmodel;
    	    	    }
    	    	    
    	    	private:
    	    		//! Decimates N times
    	    		//!
    	    		//! \param image_in  : Image to decimate
    	    		//! \param image_out : Decimated image
    	    		//! \param times     : Number of times to be decimated
                    void _decimate_N_times(const ImageGray<float64>& image_in, ImageGray<float64>& image_out, std::size_t times)
                    {
                        std::size_t aux_x = image_in.size_x();
                        std::size_t aux_y = image_in.size_y();
                        for(std::size_t m = 0; m < times; m++)
                        {
                            aux_x = (aux_x+1)/2;
                            aux_y = (aux_y+1)/2;
                        }
                        image_out.resize(aux_x,aux_y);
                        ImageGray<float64>::iterator<> it = image_out.colors_begin();
                        std::size_t step = 1 << times;
                        for(std::size_t j = 0; j<image_in.size_y(); j=j+step )
                        {
                            for(std::size_t i = 0; i<image_in.size_x(); i=i+step )
                            {
                                (*it).value() = image_in(0)[i][j];
                                ++it;
                            }
                        } 
                    }
    	    	    
    	    	    //!
    	    		//! \brief It calculates the images resulting of filtering using the Decomposition low-pass and high-pass filters by rowns and columns before decimating at specific level from the result of the previous level 
    	    		//!
    	    		//! \param[in] first : Iterator at the beginning of the imavol which we want to transform.
    	    		//! \param[in] last : Iterator at the end of the imavol which we want to transform.
    	    		//! \param[in] level: Level at which we want to calculate the images resulting of filtering using the Decomposition low-pass and high-pass filters by rowns and columns before decimating
    	    		//!
    	    		template<class IteratorModel>
    	    	    void _calculate(IteratorModel first, IteratorModel last, std::size_t level)
    	    	    {
    	    	    	float64 value1, value2, value3, value4;
    	    	    	
    	    			typename DWTModel::filter_container::const_reverse_iterator lfit = _dwtmodel.low_filter().rbegin();
    	    			typename DWTModel::filter_container::const_reverse_iterator hfit = _dwtmodel.high_filter().rbegin();
    	    			value1 = value2 = value3 = value4 = 0;
    	    			
    	    			Neighborhood2D ngb2d_horiz = _dwtmodel.ngb2d_horiz();
    	    			for(IteratorModel it=first; it!=last; ++it)
    	    			{
    	    				for(typename IteratorModel::pixel_type::neighbor_iterator nit = (*it).local_begin(ngb2d_horiz); nit != (*it).local_end(ngb2d_horiz); ++nit, ++lfit, ++hfit)
    	    				{
    	    					value1 = value1 + static_cast<float64>((*nit).value(0))*(*lfit);    					
    	    					value2 = value2 + static_cast<float64>((*nit).value(0))*(*hfit);
    	    				}
    	    				_aux1[level](0)((*it).position()) = value1;
    	    				_aux2[level](0)((*it).position()) = value2;
    	    				value1=value2=0;
    	        			lfit = _dwtmodel.low_filter().rbegin();
    	        			hfit = _dwtmodel.high_filter().rbegin();
    	    			}
    	    			
    	
    	
    	    			Neighborhood2D ngb2d_vert = _dwtmodel.ngb2d_vert();
    	    			for(IteratorModel it = first; it!=last; ++it)
    	    			{
    	    				for(typename IteratorModel::pixel_type::neighbor_iterator nit = (*it).local_begin(ngb2d_vert); nit != (*it).local_end(ngb2d_vert); ++nit, ++lfit, ++hfit)
    	    				{
    	    					value1 = value1 + static_cast<float64>(_aux1[level](0)((*nit).position()))*(*lfit);
    	    					value2 = value2 + static_cast<float64>(_aux1[level](0)((*nit).position()))*(*hfit);
    	    					value3 = value3 + static_cast<float64>(_aux2[level](0)((*nit).position()))*(*lfit);
    	    					value4 = value4 + static_cast<float64>(_aux2[level](0)((*nit).position()))*(*hfit);
    	    				}
    	    				_approx[level](0)((*it).position()) = value1;
    	    				_horiz[level](0)((*it).position()) = value2;
    	    				_vert[level](0)((*it).position()) = value3;
    	    				_diag[level](0)((*it).position()) = value4;
    	    				value1 = value2 = value3 = value4 = 0;
    	        			lfit = _dwtmodel.low_filter().rbegin();
    	        			hfit = _dwtmodel.high_filter().rbegin();
    	    			}    	
    	    	    }
    	    		
    				
    	    	    //!
    	    		//! \brief It keeps the even rows and columns of the image.
    	    		//!
    	    		//! \param[in] image_in : Image we want to decimate.
    	    		//! \param[out] image_out : Image decimated.
    	    		//!
    	    	    void _decimate(const Border<ImageGray<float64> >& image_in, ImageGray<float64>& image_out)
    	    	    {
    	    	    	image_out.resize((image_in.size_x()-2*_dwtmodel.borders2d()[0] + 1)/2 , (image_in.size_y()-2*_dwtmodel.borders2d()[1] + 1)/2);
    	    	    	ImageGray<float64>::iterator<> it = image_out.colors_begin();
    	    	    	for(std::size_t j = 0; j<image_in.size_y()-2*_dwtmodel.borders2d()[1]; j=j+2 )
    	    	    	{
    	    	    		for(std::size_t i = 0; i<image_in.size_x()-2*_dwtmodel.borders2d()[0]; i=i+2 )
    	    	    		{
    	    	    			(*it).value() = image_in(0)[i][j];
    	    	    			++it;
    	    	    		}
    	    	    	}    	    	
    	    	    }
    	    	    
    	    	    //!
    	    		//! \brief It quantifies an image in order to be displayed.
    	    		//!
    	    		//! \param[in] image_in : Image we want to quantify.
    	    		//! \param[out] image_out : Image quantified.
    	    		//!
    	    	    void _quant(const ImageGray<float64>& image_in, ImageGray<uint8>& image_out) const
    	    	    {
    	    	    	ImageGray<float64>::const_iterator<> it = image_in.colors_begin();
    	    	    	float64 min, max;
    	    	    	min = max = static_cast<float64>((*it).value(0));
    	    	    	
    	    	    	
    	    	    	for (;it!=image_in.colors_end();++it)
    	    	    	{
    	    	    		if(static_cast<float64>((*it).value(0)) < min)
    	    	    		{
    	    	    			min = static_cast<float64>((*it).value(0));
    	    	    		}
    	    	    		if(static_cast<float64>((*it).value(0)) > max)
    	    	    		{
    	    	    			max = static_cast<float64>((*it).value(0));
    	    	    		}
    	    	    	}
        	    	    ImageGray<float64> tmp;
        	    	    tmp(0) = (image_in(0) - min)*(255./(max-min));
    	    	        image_out(0) = convert<uint8>(tmp(0)); 
    	    	    }
    	    	    
    	    	    //! Copy of the model of the wavelet used (HAAR, DB2 ...) 
    	    		DWTModel _dwtmodel;
    	    		
    	    		//! Auxiliar image to contain the mask of all teh borders computed
    	    		//! If the collaborative descriptors copied their dependencies, this would not be necessary
    	    		ImageGray<float64> _aux_im;

    	    		//! Vector with the images resulting of the low-pass filter by rows from each level of the multilevel decomposition before decimating.
    				std::vector<Border<ImageGray<float64> > > _aux1;
    				
    				//! Vector with the images resulting of the high-pass filter by rows from each level of the multilevel decomposition before decimating.
    				std::vector<Border<ImageGray<float64> > > _aux2;
    				
    				//! Vector with the approximate images from each level of the multilevel decomposition before decimating.
    				std::vector<Border<ImageGray<float64> > > _approx;
    				
    				//! Vector with the vertical images from each level of the multilevel decomposition before decimating.
    				std::vector<Border<ImageGray<float64> > > _vert;
    				
    				//! Vector with the horizontal images from each level of the multilevel decomposition before decimating.
    				std::vector<Border<ImageGray<float64> > > _horiz;
    				
    				//! Vector with the diagonal images from each level of the multilevel decomposition before decimating.
    				std::vector<Border<ImageGray<float64> > > _diag;
    				
    				//! Vector with the approximate images from each level of the multilevel decomposition after decimating.
    				std::vector<ImageGray<float64> > _approx_decim;
    				
    				//! Vector with the vertical images from each level of the multilevel decomposition after decimating.
    				std::vector<ImageGray<float64> > _vert_decim;
    				
    				//! Vector with the horizontal images from each level of the multilevel decomposition after decimating.
    				std::vector<ImageGray<float64> > _horiz_decim;
    				
    				//! Vector with the diagonal images from each level of the multilevel decomposition after decimating.
    				std::vector<ImageGray<float64> > _diag_decim;
    	    };
    	    








    	    //! Template specialization for the UNDECIMATE case
    	    template< class DWTModel, std::size_t N>
    	    class DWT<DWTModel, UNDECIMATE, N> : public DescriptorBase
    	    {
    	    	public:

    	    		//!
    	    		//! \brief DWT Constructor
    	    		//!
    	    		//! \param[in] dwtmodel : Class defining the Wavelet type.
    	    		//!
    	    		DWT(DWTModel dwtmodel)  : DescriptorBase("", false)
    	    		{
                        // Form id
                        std::ostringstream os;
                        os << "DWT_undecimate_" << N;
                        this->_id = os.str();

    	    			_dwtmodel = dwtmodel;
                        ImageGray<float64>::Color cl = 0;
    	    			_aux1.resize(N, Border<ImageGray<float64> >(dwtmodel.borders2d(), cl));
    	    			_aux2.resize(N, Border<ImageGray<float64> >(dwtmodel.borders2d(), cl));
    	    			_approx.resize(N, Border<ImageGray<float64> >(dwtmodel.borders2d(), cl));
    	    			_vert.resize(N, Border<ImageGray<float64> >(dwtmodel.borders2d(), cl));
    	    			_horiz.resize(N, Border<ImageGray<float64> >(dwtmodel.borders2d(), cl));
    	    			_diag.resize(N, Border<ImageGray<float64> >(dwtmodel.borders2d(), cl));
    	    		}

    	    		//!
    	    		//! \brief It copies the model of wavelet passed by the user.
    	    		//!
    	    		//! \param[in] dwtmodel : Model of wavelet passed by the user to be copied.
    	    		//!
    	    		void dwt_model(DWTModel dwtmodel)
    	    		{
    	    			_dwtmodel = dwtmodel;
                        ImageGray<float64>::Color cl = 0;
                        _aux1.resize(N, Border<ImageGray<float64> >(dwtmodel.borders2d(), cl));
                        _aux2.resize(N, Border<ImageGray<float64> >(dwtmodel.borders2d(), cl));
                        _approx.resize(N, Border<ImageGray<float64> >(dwtmodel.borders2d(), cl));
                        _vert.resize(N, Border<ImageGray<float64> >(dwtmodel.borders2d(), cl));
                        _horiz.resize(N, Border<ImageGray<float64> >(dwtmodel.borders2d(), cl));
                        _diag.resize(N, Border<ImageGray<float64> >(dwtmodel.borders2d(), cl));
    	    		}


    	    	    //!
    	    		//! \brief It calculates the images resulting of filtering using the Decomposition low-pass and high-pass filters by rowns and columns without decimating.
    	    		//!
    	    		//! The borders of image must be added previously by the user.
    	    		//!
    	    		//! \param[in] first : Iterator at the beginning of the imavol which we want to transform.
    	    		//! \param[in] last : Iterator at the end of the imavol which we want to transform.
    	            //! \param[in] peer_descs : Pointer to CollaborativeDescriptors, in principle is never 0x0 but it is a good idea to ASSERT it
    	    		//!
                    template<class IteratorModel>
                    void calculate(IteratorModel first, IteratorModel last, CollaborativeDescriptors* peer_descs)
                    {
                        ASSERT(peer_descs!=0x0, "DWT calculate: peer_descs must be non null");

                        typedef ImageGray<typename IteratorModel::imavol_type::data_type> gray_type;
                        gray_type im_gray = peer_descs->calculate(new VDImageGray<typename IteratorModel::imavol_type>(), first, last);
                        boost::array<std::size_t, 2> borders2d = {{1,1}};
                        typename gray_type::Color cl = 0;
                        Border<gray_type>& im_gray_borders = calc_descriptor(new Border<gray_type>(borders2d, cl), im_gray);

                        // Allocate data with borders
                        // Used as reference to allocate the data with borders (it is float64)
                        // We store it in the class because it contains the mask to which all borders will point
                        // When the copy copies the mask, this will not be necessary
                        _aux_im.resize(im_gray.dims());
                        typename ImageGray<float64>::Color cl2 = 0;
                        Border<ImageGray<float64> > tmp = calc_descriptor(new Border<ImageGray<float64> >(_dwtmodel.borders2d(), cl2), _aux_im);
                        for(std::size_t level = 0; level < N ; ++level)
                        {
                            _aux1[level] = tmp;
                            _aux2[level] = tmp;
                            _approx[level] = tmp;
                            _horiz[level] = tmp;
                            _diag[level] = tmp;
                            _vert[level] = tmp;
                        }

    		    		_calculate(im_gray_borders.colors_begin(), im_gray_borders.colors_end(), 0);
    	    			for(std::size_t i = 1; i < N ; i++)
    		    		{
    	    			    _calculate(_approx[i-1].colors_begin(), _approx[i-1].colors_end(), i);
    		    		}
    	    		}



    	    	    //!
    	    		//! \brief It returns the image resulting of the low-pass filter by rows without decimating from a specific level.
    	    		//!
    	    	    //! \param[in] level: Specific level which we want to obtain the image resulting.
    	    	    //!
    	    	    //! \return Image resulting of the low-pass filter by rows without decimating from a specific level.
    	    	    const Border<ImageGray<float64> >& aux1(std::size_t level = 0) const
    	    	    {
    	    	    	return _aux1[level];
    	    	    }

    	    	    //!
    	    		//! \brief It returns the image resulting of the high-pass filter by rows without decimating from a specific level.
    	    		//!
    	    	    //! \param[in] level: Specific level which we want to obtain the image resulting.
    	    	    //!
    	    	    //! \return Image resulting of the high-pass filter by rows without decimating from a specific level.
    	    	    const Border<ImageGray<float64> >& aux2(std::size_t level = 0) const
    	    	    {
    	    	    	return _aux2[level];
    	    	    }

    	    	    //!
    	    		//! \brief It returns the approximate image without decimating from a specific level.
    	    		//!
    	    	    //! \param[in] level: Specific level which we want to obtain the image resulting.
    	    	    //!
    	    	    //! \return Approximate image without decimating.
    	    	    const Border<ImageGray<float64> >& approx(std::size_t level = 0) const
    	    	    {
    	    	    	return _approx[level];
    	    	    }

    	    	    //!
    	    		//! \brief It returns the horizontal image without decimating from a specific level.
    	    		//!
    	    	    //! \param[in] level: Specific level which we want to obtain the image resulting.
    	    	    //!
    	    	    //! \return Horizontal image without decimating.
    	    	    const Border<ImageGray<float64> >& horiz(std::size_t level = 0) const
    	    	    {
    	    	    	return _horiz[level];
    	    	    }

    	    	    //!
    	    		//! \brief It returns the vertical image without decimating from a specific level.
    	    		//!
    	    	    //! \param[in] level: Specific level which we want to obtain the image resulting.
    	    	    //!
    	    	    //! \return Vertical image without decimating.
    	    	    const Border<ImageGray<float64> >& vert(std::size_t level = 0) const
    	    	    {
    	    	    	return _vert[level];
    	    	    }

    	    	    //!
    	    		//! \brief It returns the diagonal image without decimating from a specific level.
    	    		//!
    	    	    //! \param[in] level: Specific level which we want to obtain the image resulting.
    	    	    //!
    	    	    //! \return Diagonal image without decimating.
    	    	    const Border<ImageGray<float64> >& diag(std::size_t level = 0) const
    	    	    {
    	    	    	return _diag[level];
    	    	    }

    	    	private:

    	    	    //!
    	    		//! \brief It calculates the images resulting of filtering using the Decomposition low-pass and high-pass filters by rowns and columns before decimating at specific level from the result of the previous level
    	    		//!
    	    		//! \param[in] first : Iterator at the beginning of the imavol which we want to transform.
    	    		//! \param[in] last : Iterator at the end of the imavol which we want to transform.
    	    		//! \param[in] level: Level at which we want to calculate the images resulting of filtering using the Decomposition low-pass and high-pass filters by rowns and columns before decimating
    	    		//!
    	    		template<class IteratorModel>
    	    	    void _calculate(IteratorModel first, IteratorModel last, std::size_t level)
    	    	    {
    	    	    	float64 value1, value2, value3, value4;

    	    			typename DWTModel::filter_container::const_reverse_iterator lfit = _dwtmodel.low_filter().rbegin();
    	    			typename DWTModel::filter_container::const_reverse_iterator hfit = _dwtmodel.high_filter().rbegin();

    	    			value1 = value2 = value3 = value4 = 0;

    	    			Neighborhood2D ngb2d_horiz = _dwtmodel.ngb2d_horiz();
    	    			for(IteratorModel it=first; it!=last; ++it)
    	    			{
    	    				for(typename IteratorModel::pixel_type::neighbor_iterator nit = (*it).local_begin(ngb2d_horiz); nit != (*it).local_end(ngb2d_horiz); ++nit, ++lfit, ++hfit)
    	    				{
    	    					value1 = value1 + static_cast<float64>((*nit).value(0))*(*lfit);
    	    					value2 = value2 + static_cast<float64>((*nit).value(0))*(*hfit);
    	    				}
    	    				_aux1[level](0)((*it).position()) = value1;
    	    				_aux2[level](0)((*it).position()) = value2;
    	    				value1=value2=0;
    	        			lfit = _dwtmodel.low_filter().rbegin();
    	        			hfit = _dwtmodel.high_filter().rbegin();
    	    			}



    	    			Neighborhood2D ngb2d_vert = _dwtmodel.ngb2d_vert();
    	    			for(IteratorModel it = first; it!=last; ++it)
    	    			{
    	    				for(typename IteratorModel::pixel_type::neighbor_iterator nit = (*it).local_begin(ngb2d_vert); nit != (*it).local_end(ngb2d_vert); ++nit, ++lfit, ++hfit)
    	    				{
    	    					value1 = value1 + static_cast<float64>(_aux1[level](0)((*nit).position()))*(*lfit);
    	    					value2 = value2 + static_cast<float64>(_aux1[level](0)((*nit).position()))*(*hfit);
    	    					value3 = value3 + static_cast<float64>(_aux2[level](0)((*nit).position()))*(*lfit);
    	    					value4 = value4 + static_cast<float64>(_aux2[level](0)((*nit).position()))*(*hfit);
    	    				}
    	    				_approx[level](0)((*it).position()) = value1;
    	    				_horiz[level](0)((*it).position()) = value2;
    	    				_vert[level](0)((*it).position()) = value3;
    	    				_diag[level](0)((*it).position()) = value4;
    	    				value1 = value2 = value3 = value4 = 0;
    	        			lfit = _dwtmodel.low_filter().rbegin();
    	        			hfit = _dwtmodel.high_filter().rbegin();
    	    			}
    	    	    }


    	    		//! Copy of the model of the wavelet used (HAAR, DB2 ...)
    	    		DWTModel _dwtmodel;

                    //! Auxiliar image to contain the mask of all teh borders computed
                    //! If the collaborative descriptors copied their dependencies, this would not be necessary
                    ImageGray<float64> _aux_im;

                    //! Vector with the images resulting of the low-pass filter by rows from each level of the multilevel descomposition without decimating.
                    std::vector<Border<ImageGray<float64> > > _aux1;

                    //! Vector with the images resulting of the high-pass filter by rows from each level of the multilevel descomposition without decimating.
                    std::vector<Border<ImageGray<float64> > > _aux2;

                    //! Vector with the approximate images from each level of the multilevel descomposition without decimating.
                    std::vector<Border<ImageGray<float64> > > _approx;

                    //! Vector with the vertical images from each level of the multilevel descomposition without decimating.
                    std::vector<Border<ImageGray<float64> > > _vert;

                    //! Vector with the horizontal images from each level of the multilevel descomposition without decimating.
                    std::vector<Border<ImageGray<float64> > > _horiz;

                    //! Vector with the diagonal images from each level of the multilevel descomposition without decimating.
                    std::vector<Border<ImageGray<float64> > > _diag;

    	    };
    	    
            //!
            //! \brief Class for HAAR 2D Discrete Wavelet Transform 
            //! 
            //! The declaration by this class should be:
            //! \code
            //!    HAAR haar;
            //! \endcode
            //!
            //! \author Carles Ventura <alcarles@gps.tsc.upc.edu>
            //!
            //! \date 29-5-2009     
    		class HAAR
    	    {
    	    	
    			public:
    			    //! Type to refer to the type of data in which contains the coefficients of the filters
    	    		typedef boost::array<float64,2> filter_container;
    	    		
    	    		//!
    	    		//! \brief Default constructor
    	    		//!
    	    		HAAR()
    	    		{
    	        		//! Filters with non-unitary energy so the final result must be normalized
    	    			_low_filter[0] = _low_filter[1] = 1;
    	        		
    	        		_high_filter[0] = -1;
    	        		_high_filter[1] = 1;
    	        		
    	            	_ngb2d_horiz.resize(2);
    	            	_ngb2d_horiz[0]=Neighborhood2D::CoordType( 0, 0 );
    	        	    _ngb2d_horiz[1]=Neighborhood2D::CoordType( 1, 0 ); 
    	            	_ngb2d_vert.resize(2);
    	            	_ngb2d_vert[0]=Neighborhood2D::CoordType( 0, 0 );
    	        	    _ngb2d_vert[1]=Neighborhood2D::CoordType( 0, 1 );    
    	        	    
    	        	    _borders2d[0]=1;
    	        	    _borders2d[1]=1;
    	    		}
    	    		
    	    		//! \brief Assignment operator for HAAR
    	    		//!
    	    		//! \param[in] copy : Creates a copy (low-pass and high-pass filters, neighbourhood and borders) 
    	    		//!
    	    		//! \return Reference to (this) so a = b = c; works.
    	    		//!  
    	    		HAAR& operator=(const HAAR& copy)
    	    		{
    	    			this->_low_filter = copy.low_filter();
    	    			this->_high_filter = copy.high_filter();
    	    			this->_ngb2d_horiz = copy.ngb2d_horiz();
    	    			this->_ngb2d_vert = copy.ngb2d_vert();
    	    			this->_borders2d = copy.borders2d();
    	    			
    	    			return *this;
    	    		}
    	    		
    	    		//!
    	    		//! \brief It returns a reference to the decomposition low-pass filter
    	    		//!
    	    		//! \return Reference to the decomposition low-pass filter
    	    		const filter_container& low_filter() const
    	    		{
    	    			return _low_filter;
    	    		}
    	    		
    	    		//!
    	    		//! \brief It returns a reference to the decomposition high-pass filter
    	    		//!
    	    		//! \return Reference to the decomposition high-pass filter
    	    		const filter_container& high_filter() const 
    	    		{
    	    			return _high_filter;
    	    		}
    	    		
    	    		//!
    	    		//! \brief It returns a reference to the horizontal neighbourhood that will be visited by the filters
    	    		//!
    	    		//! \return Reference to the horizontal neighbourhood
    	    		const Neighborhood2D& ngb2d_horiz() const
    	    		{
    	    			return _ngb2d_horiz;
    	    		}
    	    		
    	    		//!
    	    		//! \brief It returns a reference to the vertical neighbourhood that will be visited by the filters
    	    		//!
    	    		//! \return Reference to the vertical neighbourhood
    	    		const Neighborhood2D& ngb2d_vert() const
    	    		{
    	    			return _ngb2d_vert;
    	    		}
    	    		
    	    		//!
    	    		//! \brief It returns a reference to the borders that the image will needed to be transform 
    	    		//!
    	    		//! \return Reference to the borders
    	    		const boost::array<std::size_t, 2>& borders2d() const
    	    		{
    	    			return _borders2d;
    	    		}
    	    		
    	
    	    		
    	    	private:
    	    		
    	    		//! Array with the coefficients of the low pass filter.
    	    		filter_container _low_filter;
    	    		
    	    		//! Array with the coefficients of the high pass filter.
    	    		filter_container _high_filter;
    	    		
    	    		//! Neighborhood affected horizontally by the filter
    	    		Neighborhood2D _ngb2d_horiz;
    	    		
    	    		//! Neighborhood affected vertically by the filter
    	    		Neighborhood2D _ngb2d_vert; 
    	    		
    	    		//! Borders that have to be added to the image because of the size of the filters.
    	    		boost::array<std::size_t, 2> _borders2d;
    	    		  		
    	    };
    		
            //!
            //! \brief Class for Daubechies2 2D Discrete Wavelet Transform 
            //! 
            //! The declaration by this class should be:
            //! \code
            //!    DB2 db2;
            //! \endcode
            //!
            //! \author Carles Ventura <alcarles@gps.tsc.upc.edu>
            //!
            //! \date 29-5-2009 
    		class DB2
    	    {
    			
    	    	public:
    	    	    //! Type to refer to the type of data in which contains the coefficients of the filters
    	    		typedef boost::array<float64,4> filter_container;
    	    		
    	    		//!
    	    		//! \brief Default constructor
    	    		//!
    	    		DB2()
    	    		{
    	        		
    	    			_low_filter[0] = -0.12940952255092145;
    	    			_low_filter[1] = 0.22414386804185735;
    	    			_low_filter[2] = 0.83651630373746899;
    	    			_low_filter[3] = 0.48296291314469025;
    	    			
    	    			_high_filter[0] = -0.48296291314469025;
    	    			_high_filter[1] = 0.83651630373746899;
    	    			_high_filter[2] = -0.22414386804185735;		
    	        		_high_filter[3] = -0.12940952255092145;
    
    	            	_ngb2d_horiz.resize(4);
    	            	_ngb2d_horiz[0]=GeometricShape<int32, 2>::CoordType( 0, 0 );
    	        	    _ngb2d_horiz[1]=GeometricShape<int32, 2>::CoordType( 1, 0 ); 
    	            	_ngb2d_horiz[2]=GeometricShape<int32, 2>::CoordType( 2, 0 );
    	        	    _ngb2d_horiz[3]=GeometricShape<int32, 2>::CoordType( 3, 0 ); 
    	            	_ngb2d_vert.resize(4);
    	            	_ngb2d_vert[0]=GeometricShape<int32, 2>::CoordType( 0, 0 );
    	        	    _ngb2d_vert[1]=GeometricShape<int32, 2>::CoordType( 0, 1 );    
    	            	_ngb2d_vert[0]=GeometricShape<int32, 2>::CoordType( 0, 2 );
    	        	    _ngb2d_vert[1]=GeometricShape<int32, 2>::CoordType( 0, 3 ); 
    	        	    
    	        	    _borders2d[0]=3;
    	        	    _borders2d[1]=3;
    	    		}
    	    		
    	    		//! \brief Assignment operator for DB2
    	    		//!
    	    		//! \param[in] copy : Creates a copy (low-pass and high-pass filters, neighbourhood and borders) 
    	    		//!
    	    		//! \return Reference to (this) so a = b = c; works.
    	    		//!  
    	    		DB2& operator=(const DB2& copy)
    	    		{
    	    			this->_low_filter = copy.low_filter();
    	    			this->_high_filter = copy.high_filter();
    	    			this->_ngb2d_horiz = copy.ngb2d_horiz();
    	    			this->_ngb2d_vert = copy.ngb2d_vert();
    	    			this->_borders2d = copy.borders2d();
    	    			
    	    			return *this;
    	    		}
    	    		
    	    		//!
    	    		//! \brief It returns a reference to the decomposition low-pass filter
    	    		//!
    	    		//! \return Reference to the decomposition low-pass filter
    	    		const filter_container& low_filter() const
    	    		{
    	    			return _low_filter;
    	    		}
    	    		
    	    		//!
    	    		//! \brief It returns a reference to the decomposition high-pass filter
    	    		//!
    	    		//! \return Reference to the decomposition high-pass filter
    	    		const filter_container& high_filter() const 
    	    		{
    	    			return _high_filter;
    	    		}
    	    		
    	    		//!
    	    		//! \brief It returns a reference to the horizontal neighbourhood that will be visited by the filters
    	    		//!
    	    		//! \return Reference to the horizontal neighbourhood
    	    		const Neighborhood2D& ngb2d_horiz() const
    	    		{
    	    			return _ngb2d_horiz;
    	    		}
    	    		
    	    		//!
    	    		//! \brief It returns a reference to the vertical neighbourhood that will be visited by the filters
    	    		//!
    	    		//! \return Reference to the vertical neighbourhood
    	    		const Neighborhood2D& ngb2d_vert() const
    	    		{
    	    			return _ngb2d_vert;
    	    		}
    	    		
    	    		//!
    	    		//! \brief It returns a reference to the borders that the image will needed to be transform 
    	    		//!
    	    		//! \return Reference to the borders
    	    		const boost::array<std::size_t, 2>& borders2d() const
    	    		{
    	    			return _borders2d;
    	    		}
    	    		
    	
    	    		
    	    	private:
    	    		
    	    		//! Array with the coefficients of the low pass filter.
    	    		filter_container _low_filter;
    	    		
    	    		//! Array with the coefficients of the high pass filter.
    	    		filter_container _high_filter;
    	    		
    	    		//! Neighborhood affected horizontally by the filter
    	    		Neighborhood2D _ngb2d_horiz;
    	    		
    	    		//! Neighborhood affected vertically by the filter
    	    		Neighborhood2D _ngb2d_vert;
    	    		
    	    		//! Borders that have to be added to the image because of the size of the filters.
    	    		boost::array<std::size_t, 2> _borders2d;
    	    		  		
    	    };

    		//!
    		//! \brief Class for Generic Filter 2D Discrete Wavelet Transform
    		//!
    		//! The declaration by this class should be:
    		//! \code
    		//!    GenericFilterWavelet wave;
    		//!	   wave.set_low_pass_filter(lp);
    		//!    wave.set_high_pass_filter(hp);
    		//! \endcode
    		//!
    		//! \author Guillem Palou <guillem.palou@upc.edu>
    		//!
    		//! \date 29-5-2009
    		class GenericFilterWavelet
    		{

    		public:
    			//! Type to refer to the type of data in which contains the coefficients of the filters
    			typedef std::vector<float64> filter_container;

    			//!
    			//! \brief Default constructor
    			//!
    			GenericFilterWavelet()
    			{
    				//! Filters with non-unitary energy so the final result must be normalized
    				_low_filter.resize(2);
    				_low_filter[0] = _low_filter[1] = 1/std::sqrt(2.0);

    				_high_filter.resize(2);
    				_high_filter[0] = -1/std::sqrt(2.0);
    				_high_filter[1] = 1/std::sqrt(2.0);

    				_ngb2d_horiz.resize(2);
    				_ngb2d_horiz[0]=Neighborhood2D::CoordType( 0, 0 );
    				_ngb2d_horiz[1]=Neighborhood2D::CoordType( 1, 0 );
    				_ngb2d_vert.resize(2);
    				_ngb2d_vert[0]=Neighborhood2D::CoordType( 0, 0 );
    				_ngb2d_vert[1]=Neighborhood2D::CoordType( 0, 1 );

    				_borders2d[0]=1;
    				_borders2d[1]=1;
    			}

    		private:

    			//!
    			//! \brief It calculates the borders based on the length of the filters
    			//!
    			//!
    			void _calculate_borders() {
    				uint32 len = std::max(_low_filter.size(), _high_filter.size());
    				_borders2d[0] = len + 1;
    				_borders2d[1] = _borders2d[0];

    				_ngb2d_horiz.resize(len);
    				_ngb2d_vert.resize(len);
    				for (uint32 i = 0; i < len; i++) {
    					_ngb2d_horiz[i] = GeometricShape<int32, 2>::CoordType( i, 0 );
    					_ngb2d_vert[i] = GeometricShape<int32, 2>::CoordType( 0, i );
    				}
    			}
    		public:

    			//! \brief Assignment operator for GenericFilterWavelet
    			//!
    			//! \param[in] copy : Creates a copy (low-pass and high-pass filters, neighbourhood and borders)
    			//!
    			//! \return Reference to (this) so a = b = c; works.
    			//!
    			GenericFilterWavelet& operator=(const GenericFilterWavelet& copy)
    			{
    				this->_low_filter = copy.low_filter();
    				this->_high_filter = copy.high_filter();
    				this->_ngb2d_horiz = copy.ngb2d_horiz();
    				this->_ngb2d_vert = copy.ngb2d_vert();
    				this->_borders2d = copy.borders2d();

    				return *this;
    			}

    			//!
    			//! \brief It returns a reference to the decomposition low-pass filter
    			//!
    			//! \return Reference to the decomposition low-pass filter
    			const filter_container& low_filter() const
    			{
    				return _low_filter;
    			}

    			//!
    			//! \brief It returns a reference to the decomposition high-pass filter
    			//!
    			//! \return Reference to the decomposition high-pass filter
    			const filter_container& high_filter() const
    			{
    				return _high_filter;
    			}

    			//!
    			//! \brief It returns a reference to the horizontal neighbourhood that will be visited by the filters
    			//!
    			//! \return Reference to the horizontal neighbourhood
    			const Neighborhood2D& ngb2d_horiz() const
    			{
    				return _ngb2d_horiz;
    			}

    			//!
    			//! \brief It returns a reference to the vertical neighbourhood that will be visited by the filters
    			//!
    			//! \return Reference to the vertical neighbourhood
    			const Neighborhood2D& ngb2d_vert() const
    			{
    				return _ngb2d_vert;
    			}

    			//!
    			//! \brief It returns a reference to the borders that the image will needed to be transform
    			//!
    			//! \return Reference to the borders
    			const boost::array<std::size_t, 2>& borders2d() const
    			{
    				return _borders2d;
    			}

    			//!
    			//! \brief It sets the borders that the image will needed to be transform
    			//!
    			//!	\param[in] borders : array with the borders for each dimension
    			//!
    			//! \return Reference to the borders
    			void set_borders(boost::array<std::size_t, 2>& borders)
    			{
    				_borders2d = borders;
    			}

    			//!
    			//! \brief It sets the filter to use
    			//!
    			//! \param[in] lowpass : Vector containing the low pass impulse response
    			//!
    			//! \return Reference to the borders
    			void set_low_pass_filter(filter_container &lowpass)
    			{
    				_low_filter = lowpass;
    				_calculate_borders();
    			}

    			//!
    			//! \brief It sets the filter to use
    			//!
    			//! \param[in] highpass : Vector containing the high pass impulse response
    			//!
    			//! \return Reference to the borders
    			void set_high_pass_filter(filter_container &highpass)
    			{
    				_high_filter = highpass;
    				_calculate_borders();
    			}

    		private:

    			//! Array with the coefficients of the low pass filter.
    			filter_container _low_filter;

    			//! Array with the coefficients of the high pass filter.
    			filter_container _high_filter;

    			//! Neighborhood affected horizontally by the filter
    			Neighborhood2D _ngb2d_horiz;

    			//! Neighborhood affected vertically by the filter
    			Neighborhood2D _ngb2d_vert;

    			//! Borders that have to be added to the image because of the size of the filters.
    			boost::array<std::size_t, 2> _borders2d;

    		};


    		//!
    		//! \brief Function to create a Gaussian Wavelet
    		//!
    		//!	\param[in] scale : proportional to the support of the Gaussian, (-5*scale .. 5*scale)
    		//! \param[in] derivative : derivative of the Gaussian pulse to use (tipically 1,2 or 3). Defined only for values 1 to 5
    		//!
    		//! \return A Wavelet model with a Gaussian derivative as a filter
    		//!
    		//! \date 15-7-2010
    		//! \author Guillem Palou <guillem.palou@upc.edu>
    		//!
    		inline
    		GenericFilterWavelet create_gauss_wavelet(float64 scale, uint32 derivative)
    		{
    			GenericFilterWavelet w; // HAAR by default

    			// Gaussian wavelets
    			std::vector<float64> gauss_hi((uint32)(10*scale + 1));
    			std::vector<float64> gauss_lo((uint32)(10*scale + 1));
    			float64 center = (5*scale);

    			float64 c_hi = 0;
    			float64 c_lo = 0;

    			for (int i = 0; i < 10*scale + 1; i++) {
    				float64 x = (i-center)/scale;

    				if (derivative == 5) gauss_hi[i] = x*x*x*x*x - 10*x*x*x - 15*x;
    				if (derivative == 4) gauss_hi[i] = -(x*x*x*x - 6*x*x + 3);
    				if (derivative == 3)  gauss_hi[i] = x*x*x - 12*x; // 3rd derivative
    				if (derivative == 2)  gauss_hi[i] = (1 - x*x); // second derivative
    				if (derivative == 1)  gauss_hi[i] = x;

    				gauss_hi[i] *= std::exp(-x*x/2);
    				c_hi += (gauss_hi[i]*gauss_hi[i]);

    				gauss_lo[i] = std::exp(-x*x/2);
    				c_lo += (gauss_lo[i]*gauss_lo[i]);
    			}

    			for (int i = 0; i < 10*scale +1 ; i++) {
    				gauss_hi[i] /= c_hi;
    				gauss_lo[i] /= c_lo;
    			}

    			w.set_low_pass_filter(gauss_lo);
    			w.set_high_pass_filter(gauss_hi);

    			return w;
    		}
	    }
	}
}

#endif
