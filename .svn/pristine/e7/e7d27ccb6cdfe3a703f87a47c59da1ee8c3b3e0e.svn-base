// --------------------------------------------------------------
// Copyright (C)
// Universitat Politecnica de Catalunya (UPC) - Barcelona - Spain
// --------------------------------------------------------------

//!
//!  \file imavol.hpp
//!
//!  Interface for ImaVol class, base class of all images and volumes in ImagePlus
//!

#ifndef IMAGEPLUS_CORE_PIXEL_HPP
#define IMAGEPLUS_CORE_PIXEL_HPP

#include <imageplus/core/iterator.hpp>

namespace imageplus
{
    /*! Class that represents a pixel, i.e., a position and the color.
     * It also allows to iterate through neighbors and globally
     * 
     * \author Jordi Pont Tuset <jordi.pont@upc.edu>
     */
    template<class RegionType, class ImaVolType, typename DataType>
    class Pixel 
    {
        /*! 
         * \cond SKIP_DOC 
         */
        typedef ColorViewBase< DataType, 
                               ImaVolType::channels, 
                               boost::array< DataType*, ImaVolType::channels> >       color_view;
        typedef typename ImaVolType::const_color_view                           const_color_view;
        
        typedef typename RegionType::CoordType                                  CoordType;
        
        
    protected:  // Not private to be used in ChannelPixel
        
        ImaVolType*    _iv;
        CoordType      _pos;
    
        Pixel( ImaVolType* const iv , CoordType pos)
          : _iv(iv), _pos(pos)
        {}
        /*! \endcond */
        
    public:

        /*! Returns the current position
         * 
         * \return Current position 
         */
        CoordType position() const
        {
            return _pos;
        }
        
        /*! Returns the current color value
         * 
         * \return Current color value
         */        
        color_view value()
        {
            return (*_iv)(_pos);
        }

        /*! Returns the current color value (const)
         * 
         * \return Current color value (const)
         */
        const_color_view value() const
        {
            return (*_iv)(_pos);
        }

        /*! Returns the current color component
         * 
         * \param[in] channel : Channel to read/write
         * \return Current color component
         */
        DataType& value(std::size_t channel)
        {
            return (*_iv)(_pos)[channel];
        }

        /*! Returns the current color component (const)
         *
         * \param[in] channel : Channel to read/write 
         * \return Current color component (const)
         */
        DataType value(std::size_t channel) const
        {
            return (*_iv)(_pos)[channel];
        }

        /*! Iterator to the whole image to compute global descriptors
         */
        class global_iterator : public DataIteratorBase< ImaVolType, ImaVolType, DataType, Pixel >
        {
            /*! 
             * \cond SKIP_DOC 
             */
            typedef DataIteratorBase< ImaVolType, ImaVolType, DataType, Pixel > base_class;
            
        public:
            global_iterator( const base_class& copy ) : base_class(copy)
            {}

            global_iterator( ImaVolType* iv , typename ImaVolType::const_position_iterator it )
            : base_class(iv, it)
            {}
            /*! \endcond */
        };


        /*! Begin iterator to the whole image to compute global descriptors
         * 
         * \return Begin global iterator
         */
        global_iterator global_begin()
        {
            return global_iterator( this->_iv, this->_iv->position_begin() );                    
        }

        /*! End iterator to the whole image to compute global descriptors
         * 
         * \return End global iterator
         */
        global_iterator global_end()
        {
            return global_iterator( this->_iv, this->_iv->position_end() );                    
        }

        /*! Type of neighborhood of the pixel */
        typedef Neighborhood<Coord<int64,ImaVolType::dimensions> > neighborhood; 

        /*! Iterator to the neighboring pixels */
        class neighbor_iterator : public DataIteratorBase<neighborhood, ImaVolType, DataType, Pixel>
        {
            /*! 
             * \cond SKIP_DOC 
             */
            typedef DataIteratorBase<neighborhood, ImaVolType, DataType, Pixel> base_class;
            typedef typename base_class::position_iterator position_iterator;
        public:
            neighbor_iterator( const base_class& copy )
            : base_class(copy)
            {}

            neighbor_iterator( ImaVolType* iv , position_iterator it )
            : base_class(iv, it)
            {}
            /*! \endcond */
        };

        /*! Iterator to the neighboring pixels */
        class const_neighbor_iterator : public DataIteratorBase<neighborhood, const ImaVolType, const DataType, const Pixel>
        {
            /*!
             * \cond SKIP_DOC
             */
            typedef DataIteratorBase<neighborhood, const ImaVolType, const DataType, const Pixel> base_class;
            typedef typename base_class::position_iterator position_iterator;
        public:
            const_neighbor_iterator( const base_class& copy )
            : base_class(copy)
            {
            }

            const_neighbor_iterator( ImaVolType* iv , position_iterator it )
            : base_class(iv, it)
            {
            }
            /*! \endcond */
        };

        /*! Begin iterator to the neighboring pixels
         * 
         * \param[in] ngb : Neighborhood to iterate
         * \return Begin neighbor iterator
         */
        neighbor_iterator local_begin(/*const*/ neighborhood& ngb)
        {
            ngb.origin(position());
            return neighbor_iterator( this->_iv, ngb.begin() );
        }

        /*! End iterator to the neighboring pixels
         *
         * \param[in] ngb : Neighborhood to iterate
         * \return End neighbor iterator
         */
        neighbor_iterator local_end(/*const*/ neighborhood& ngb)
        {
            ngb.origin(position());
            return neighbor_iterator( this->_iv, ngb.end() );
        }

        /*! Begin iterator to the neighboring pixels
         *
         * \param[in] ngb : Neighborhood to iterate
         * \return Begin neighbor iterator
         */
        const_neighbor_iterator local_begin(/*const*/ neighborhood& ngb) const
        {
            ngb.origin(position());
            return const_neighbor_iterator( this->_iv, ngb.begin() );
        }

        /*! End iterator to the neighboring pixels
         * 
         * \param[in] ngb : Neighborhood to iterate
         * \return End neighbor iterator
         */
        const_neighbor_iterator local_end(/*const*/ neighborhood& ngb) const
        {
            ngb.origin(position());
            return const_neighbor_iterator( this->_iv, ngb.end() );
        }
        

        /*! 
         * \cond SKIP_DOC
         *
         *  Friends 
         */
        template< class RT, class IVT, typename DT, class PT >
        friend class DataIteratorBase;
        /*! \endcond */
    };
    
    
    
    
    /*! Class that represents a single-channel pixel, i.e., a position and the single-channel color.
     * This is necessary for channel-independent histograms
     * 
     * \author Jordi Pont Tuset <jordi.pont@upc.edu>
     */
    template<class RegionType, class ImaVolType, typename DataType>
    class ChannelPixel : public Pixel<RegionType, ImaVolType, DataType>
    {
        /*! 
         * \cond SKIP_DOC
         */
        typedef Pixel<RegionType, ImaVolType, DataType> base_class;
        
        typedef ColorViewBase< DataType,
                               1,
                               boost::array< DataType*, 1> >      sch_color_view;
        typedef typename ImaVolType::const_sch_color_view   const_sch_color_view;

        typedef typename RegionType::CoordType CoordType;
        
        ChannelPixel( ImaVolType* const iv , CoordType pos, std::size_t channel)
          : base_class(iv,pos), _channel(channel)
        {}
        
    public:
    
        sch_color_view value()
        {
            sch_color_view col;
            
            col.assign_ptr(0, &(this->_iv->_c[_channel](this->_pos)));
            
            return col;
        }
        
        const_sch_color_view value() const
        {
            const_sch_color_view col;
            
            col.assign_ptr(0, &(this->_iv->_c[_channel](this->_pos)));
            
            return col;
        }
        
        DataType value(std::size_t channel) const
        {
            return this->_iv->_c[_channel](this->_pos);
        }
        
        DataType& value(std::size_t channel)
        {
            return this->_iv->_c[_channel](this->_pos);
        }
        /*! \endcond */
        
    private:
    
        //! Current channel
        std::size_t _channel;
        
        /*! 
         * \cond SKIP_DOC
         *
         *  Friends 
         */
        template< class RT, class IVT, typename DT, class PT >
        friend class DataIteratorBase;
        
        template<typename T, std::size_t N, std::size_t D>
        friend class ImaVol;
        /*! \endcond */
    };
}

#endif
